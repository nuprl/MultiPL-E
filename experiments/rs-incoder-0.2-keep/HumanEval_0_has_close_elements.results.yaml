name: HumanEval_0_has_close_elements
language: rust
results:
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphm6bon2o.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7xa2wk9g.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd_9u_m0n.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = std::f64::MAX;\n    let mut min_number =\
    \ numbers[0];\n    for &n in numbers {\n        let distance = std::f64::MAX;\n\
    \        for &m in numbers {\n            if m == n {\n                continue;\n\
    \            }\n            let distance = n.abs() - m.abs();\n            if\
    \ distance < distance {\n                distance = n.abs() - m.abs();\n     \
    \       }\n        }\n        if distance < min_distance {\n            min_distance\
    \ = distance;\n            min_number = n;\n        }\n    }\n    min_distance\
    \ < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxo5nauys.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxo5nauys.rs:12:13\n   |\n12 |         for &m\
    \ in numbers {\n   |             ^^    ------- this expression has type `Option<f64>`\n\
    \   |             |\n   |             expected `f64`, found reference\n   |  \
    \           help: you can probably remove the explicit borrow: `m`\n   |\n   =\
    \ note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist < 0.0\
    \ {\n            min_dist = dist;\n            min_idx = -1;\n        }\n    \
    \    if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n     \
    \       min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmptzevu309.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptzevu309.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_copy = numbers.clone();\n    numbers_copy.sort();\n\
    \    let mut i = 0;\n    let mut j = 1;\n    while i < numbers_copy.len() && j\
    \ < numbers_copy.len() {\n        if numbers_copy[i] - numbers_copy[j] < threshold\
    \ {\n            i += 1;\n        } else {\n            j += 1;\n        }\n \
    \   }\n    i != numbers_copy.len()\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpc63pz49e.rs:9:18\n\
    \    |\n9   |     numbers_copy.sort();\n    |                  ^^^^ the trait\
    \ `Ord` is not implemented for `f64`\n    |\n    = help: the following other types\
    \ implement trait `Ord`:\n              i128\n              i16\n            \
    \  i32\n              i64\n              i8\n              isize\n           \
    \   u128\n              u16\n            and 4 others\nnote: required by a bound\
    \ in `slice::<impl [T]>::sort`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        }\n        if n == min_number\
    \ {\n            min_distance = std::f64::MAX;\n        }\n        if n < min_number\
    \ + min_distance {\n            min_number = n;\n            min_distance = threshold\
    \ - min_number;\n        }\n    }\n    min_distance < 0.0\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdfs_8g6l.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfgbf4p1w.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = std::f64::MAX;\n    let mut min_number =\
    \ std::f64::MAX;\n    for &n in numbers {\n        let distance = std::f64::MAX;\n\
    \        for &m in numbers {\n            if m == n {\n                continue;\n\
    \            }\n            let distance = n.abs() - m.abs();\n            if\
    \ distance < distance {\n                break;\n            }\n        }\n  \
    \      if distance < min_distance {\n            min_distance = distance;\n  \
    \          min_number = n;\n        }\n    }\n    min_distance < threshold\n}\n\
    \nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiztfk77r.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiztfk77r.rs:12:13\n   |\n12 |         for &m\
    \ in numbers {\n   |             ^^    ------- this expression has type `Option<f64>`\n\
    \   |             |\n   |             expected `f64`, found reference\n   |  \
    \           help: you can probably remove the explicit borrow: `m`\n   |\n   =\
    \ note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist < 0.0\
    \ {\n            min_dist = dist;\n            min_idx = -1;\n        }\n    \
    \    if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n     \
    \       min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpf2ke0ujs.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf2ke0ujs.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_sorted = numbers.iter().cloned().collect::<Vec<_>>();\n\
    \    numbers_sorted.sort_unstable();\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut found = false;\n    while i < numbers_sorted.len() && j < numbers_sorted.len()\
    \ {\n        if numbers_sorted[i] < numbers_sorted[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n        if i == numbers_sorted.len()\
    \ || j == numbers_sorted.len() {\n            found = true;\n            break;\n\
    \        }\n        if numbers_sorted[i] - numbers_sorted[j] > threshold {\n \
    \           i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    found\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_nxl5d5p.rs:9:20\n\
    \     |\n9    |     numbers_sorted.sort_unstable();\n     |                  \
    \  ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n     |\n     =\
    \ help: the following other types implement trait `Ord`:\n               i128\n\
    \               i16\n               i32\n               i64\n               i8\n\
    \               isize\n               u128\n               u16\n             and\
    \ 4 others\nnote: required by a bound in `core::slice::<impl [T]>::sort_unstable`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| f64::abs(x - threshold) < threshold)\n}\n\
    \nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg4zjke_j.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_copy = numbers.clone();\n    numbers_copy.sort();\n\
    \    let mut min_value = numbers_copy[0];\n    let mut max_value = numbers_copy[0];\n\
    \    let mut min_distance = threshold;\n    let mut max_distance = threshold;\n\
    \    for number in numbers_copy {\n        if number < min_value {\n         \
    \   min_value = number;\n        }\n        if number > max_value {\n        \
    \    max_value = number;\n        }\n        if number - min_value < max_distance\
    \ {\n            max_distance = number - min_value;\n        }\n        if number\
    \ - min_value > min_distance {\n            min_distance = number - min_value;\n\
    \        }\n    }\n    min_distance < max_distance\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpkdbpsixo.rs:9:18\n\
    \    |\n9   |     numbers_copy.sort();\n    |                  ^^^^ the trait\
    \ `Ord` is not implemented for `f64`\n    |\n    = help: the following other types\
    \ implement trait `Ord`:\n              i128\n              i16\n            \
    \  i32\n              i64\n              i8\n              isize\n           \
    \   u128\n              u16\n            and 4 others\nnote: required by a bound\
    \ in `slice::<impl [T]>::sort`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist < 0.0\
    \ {\n            min_dist = dist;\n            min_idx = -1;\n        }\n    \
    \    if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n     \
    \       min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp153hj30t.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp153hj30t.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7izptod0.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvk0tunox.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcvkbi25b.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ugn8z_t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &x) in numbers.iter().enumerate()\
    \ {\n            let dist = x - i;\n            if dist < min_dist {\n       \
    \         min_dist = dist;\n                min_idx = i;\n            }\n    \
    \    }\n        min_dist < threshold\n    })\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `usize` from `f64`\n  --> /tmp/tmp842iltbe.rs:12:26\n\
    \   |\n12 |             let dist = x - i;\n   |                          ^ no\
    \ implementation for `f64 - usize`\n   |\n   = help: the trait `Sub<usize>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n\
    \             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n  \
    \           <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n      \
    \       <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n        \
    \   and 48 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmp842iltbe.rs:10:27\n   |\n10 |         let mut min_idx = -1;\n \
    \  |                           ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = std::f64::MAX;\n    let mut min_number =\
    \ std::f64::MAX;\n    for number in numbers {\n        let distance = std::f64::MAX;\n\
    \        for other_number in numbers {\n            if *number == *other_number\
    \ {\n                continue;\n            }\n            let distance = std::f64::max(distance,\
    \ other_number - number);\n        }\n        if distance < min_distance {\n \
    \           min_distance = distance;\n            min_number = number;\n     \
    \   }\n    }\n    if min_distance < threshold {\n        return true;\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in module `std::f64`\n   --> /tmp/tmp0_e6n1rx.rs:16:38\n\
    \    |\n16  |             let distance = std::f64::max(distance, other_number\
    \ - number);\n    |                                      ^^^\n    |\nhelp: a constant\
    \ with a similar name exists\n    |\n16  |             let distance = std::f64::MAX(distance,\
    \ other_number - number);\n    |                                      ~~~\nhelp:\
    \ consider importing this function\n    |\n1   | use std::cmp::max;\n    |\nhelp:\
    \ if you import `max`, refer to it directly\n    |\n16  -             let distance\
    \ = std::f64::max(distance, other_number - number);\n16  +             let distance\
    \ = max(distance, other_number - number);\n    | \n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmp0_e6n1rx.rs:13:16\n   |\n13 |        \
    \     if *number == *other_number {\n   |                ^^^^^^^\n\nerror[E0614]:\
    \ type `f64` cannot be dereferenced\n  --> /tmp/tmp0_e6n1rx.rs:13:27\n   |\n13\
    \ |             if *number == *other_number {\n   |                          \
    \ ^^^^^^^^^^^^^\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr0y3w7a7.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| {\n        let mut min_distance = threshold;\n\
    \        let mut min_number = x;\n        for y in numbers.iter() {\n        \
    \    let distance = hypot(x - y, threshold);\n            if distance < min_distance\
    \ {\n                min_distance = distance;\n                min_number = y;\n\
    \            }\n        }\n        min_distance < threshold\n    })\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `hypot` in this scope\n  --> /tmp/tmpz0qxbszw.rs:12:28\n\
    \   |\n12 |             let distance = hypot(x - y, threshold);\n   |        \
    \                    ^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe4dqoo3m.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqkiynh66.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_diff = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let diff = n - min_number;\n        if diff\
    \ < min_diff {\n            min_diff = diff;\n            min_number = n;\n  \
    \      }\n    }\n    min_diff < threshold\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0gg4erem.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_diff = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let diff = n - min_diff;\n        if diff < 0 {\n \
    \           min_diff = n;\n            min_idx = -1;\n        }\n        if diff\
    \ < min_diff {\n            min_diff = diff;\n            min_idx = Some(numbers.iter().position(|&n|\
    \ n == n).unwrap());\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb46tmm_g.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n  --> /tmp/tmpb46tmm_g.rs:12:17\n   |\n\
    12 |         if diff < 0 {\n   |                 ^ no implementation for `f64\
    \ < {integer}` and `f64 > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n12 |         if diff < 0.0 {\n   |  \
    \                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb46tmm_g.rs:18:23\n\
    \   |\n9  |     let mut min_idx = -1;\n   |                       -- expected\
    \ due to this value\n...\n18 |             min_idx = Some(numbers.iter().position(|&n|\
    \ n == n).unwrap());\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = std::f64::abs(n - min_dist);\n        if\
    \ dist < min_dist {\n            min_dist = dist;\n            min_idx = i;\n\
    \        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpu6gs0p0v.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_dist);\n   |            \
    \                  ^^^ not found in `std::f64`\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmpu6gs0p0v.rs:14:23\n   |\n14 |             min_idx\
    \ = i;\n   |                       ^ help: a local variable with a similar name\
    \ exists: `n`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu6gs0p0v.rs:10:9\n\
    \   |\n10 |     for &n in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|n| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = numbers.iter().position(|n| {\n            n.abs()\
    \ < min_dist\n        });\n        if min_idx != numbers.len() - 1 {\n       \
    \     min_dist = numbers[min_idx + 1].abs();\n            min_idx = numbers.iter().position(|n|\
    \ {\n                n.abs() < min_dist\n            });\n        }\n        min_dist\
    \ < threshold\n    })\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpox112195.rs:13:23\n   |\n\
    13 |         if min_idx != numbers.len() - 1 {\n   |                       ^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n13 |         if min_idx != Some(numbers.len() - 1) {\n   |            \
    \           +++++                 +\n\nerror[E0369]: cannot add `{integer}` to\
    \ `Option<usize>`\n  --> /tmp/tmpox112195.rs:14:40\n   |\n14 |             min_dist\
    \ = numbers[min_idx + 1].abs();\n   |                                ------- ^\
    \ - {integer}\n   |                                |\n   |                   \
    \             Option<usize>\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ (i, n) in numbers.iter().enumerate() {\n        let dist = n.abs() - min_dist;\n\
    \        if dist < threshold {\n            min_dist = dist;\n            min_idx\
    \ = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpdotj_9yy.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpdotj_9yy.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        if min_dist > n {\n            min_dist = n;\n    \
    \        min_idx = -1;\n        }\n        if min_dist == n {\n            min_idx\
    \ = 0;\n        }\n        if min_dist < n {\n            min_dist = n;\n    \
    \        min_idx = 1;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj1v58d5j.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzcn6a3yq.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        if min_dist > n.abs() {\n            min_dist = n.abs();\n\
    \            min_idx = -1;\n        }\n        if min_dist > threshold {\n   \
    \         break;\n        }\n        if min_dist == n.abs() {\n            min_idx\
    \ = numbers.iter().position(|x| x == n);\n        }\n    }\n    min_idx != -1\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr_nbj0u_.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr_nbj0u_.rs:19:23\n   |\n9  |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n19 | \
    \            min_idx = numbers.iter().position(|x| x == n);\n   |            \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = std::f64::abs(n - min_dist);\n        if\
    \ dist < min_dist {\n            min_dist = dist;\n            min_idx = -1;\n\
    \        }\n        if min_idx < 0 || min_dist < threshold {\n            min_dist\
    \ = threshold;\n            min_idx = i;\n        }\n    }\n    min_idx != -1\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpd_px4nxy.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_dist);\n   |            \
    \                  ^^^ not found in `std::f64`\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmpd_px4nxy.rs:18:23\n   |\n18 |             min_idx\
    \ = i;\n   |                       ^ help: a local variable with a similar name\
    \ exists: `n`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_px4nxy.rs:10:9\n\
    \   |\n10 |     for &n in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp549zl7k.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2g0ue7o1.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjv_syz0y.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_num = numbers[0];\n\
    \    for num in numbers {\n        let dist = abs(num - min_num);\n        if\
    \ dist < min_dist {\n            min_dist = dist;\n            min_num = num;\n\
    \        }\n    }\n    min_dist < threshold\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmptmppdkh9.rs:11:20\n\
    \   |\n11 |         let dist = abs(num - min_num);\n   |                    ^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptmgiz9ms.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        } else if n - min_number\
    \ < min_distance {\n            min_number = n;\n            min_distance = n\
    \ - min_number;\n        }\n    }\n    min_distance < threshold\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl075paqp.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_sorted = numbers.iter().cloned().collect::<Vec<_>>();\n\
    \    numbers_sorted.sort_unstable();\n    let mut threshold = threshold * f64::consts::PI;\n\
    \    loop {\n        if numbers_sorted.len() == 1 {\n            return false;\n\
    \        }\n        let mut current_number = numbers_sorted.remove(0);\n     \
    \   let mut current_index = 0;\n        let mut current_distance = std::f64::MAX;\n\
    \        for index in numbers_sorted.iter().rev() {\n            let distance\
    \ = current_number - numbers[index];\n            if distance < current_distance\
    \ {\n                current_distance = distance;\n                current_index\
    \ = index;\n            }\n        }\n        if current_distance < threshold\
    \ {\n            return true;\n        }\n        numbers_sorted.insert(current_index,\
    \ current_number);\n    }\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpoth_p0_b.rs:9:20\n\
    \     |\n9    |     numbers_sorted.sort_unstable();\n     |                  \
    \  ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n     |\n     =\
    \ help: the following other types implement trait `Ord`:\n               i128\n\
    \               i16\n               i32\n               i64\n               i8\n\
    \               isize\n               u128\n               u16\n             and\
    \ 4 others\nnote: required by a bound in `core::slice::<impl [T]>::sort_unstable`\n\
    \nerror[E0223]: ambiguous associated type\n  --> /tmp/tmpoth_p0_b.rs:10:37\n \
    \  |\n10 |     let mut threshold = threshold * f64::consts::PI;\n   |        \
    \                             ^^^^^^^^^^^\n   |\nhelp: you are looking for the\
    \ module in `std`, not the primitive type\n   |\n10 |     let mut threshold =\
    \ threshold * std::f64::consts::PI;\n   |                                    \
    \ ~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n\
    \  --> /tmp/tmpoth_p0_b.rs:19:45\n   |\n19 |             let distance = current_number\
    \ - numbers[index];\n   |                                             ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoth_p0_b.rs:22:33\n   |\n16 |         let mut\
    \ current_index = 0;\n   |                                 - expected due to this\
    \ value\n...\n22 |                 current_index = index;\n   |              \
    \                   ^^^^^ expected integer, found `&f64`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0223, E0277,\
    \ E0308.\nFor more information about an error, try `rustc --explain E0223`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist < threshold\
    \ {\n            min_dist = dist;\n            min_idx = i;\n        }\n    }\n\
    \    min_idx != -1\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp99x9l1xb.rs:14:23\n\
    \   |\n14 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp99x9l1xb.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ idx in 0..numbers.len() {\n        let dist = numbers[idx] - threshold;\n  \
    \      if dist < min_dist {\n            min_dist = dist;\n            min_idx\
    \ = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmp41yq8jbt.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmp41yq8jbt.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdt8e5w3t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|n| {\n        let mut min_dist = threshold;\n\
    \        let mut min_num = numbers[0];\n        for num in numbers {\n       \
    \     let dist = abs(n - num);\n            if dist < min_dist {\n           \
    \     min_dist = dist;\n                min_num = num;\n            }\n      \
    \  }\n        min_dist < threshold\n    })\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpjgm5jl8a.rs:12:24\n\
    \   |\n12 |             let dist = abs(n - num);\n   |                       \
    \ ^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ idx in 0..numbers.len() {\n        let dist = numbers[idx] - threshold;\n  \
    \      if dist < min_dist {\n            min_dist = dist;\n            min_idx\
    \ = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpzu62hsjz.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpzu62hsjz.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ idx in 0..numbers.len() {\n        let dist = numbers[idx] - threshold;\n  \
    \      if dist < min_dist {\n            min_dist = dist;\n            min_idx\
    \ = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpvrltumqr.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpvrltumqr.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_element = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_element.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_element = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg4dg3sh3.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &x) in numbers.iter().enumerate()\
    \ {\n            let dist = x - i;\n            if dist < min_dist {\n       \
    \         min_dist = dist;\n                min_idx = i;\n            }\n    \
    \    }\n        min_idx != -1\n    })\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `usize` from `f64`\n  --> /tmp/tmpmgpawgt1.rs:12:26\n\
    \   |\n12 |             let dist = x - i;\n   |                          ^ no\
    \ implementation for `f64 - usize`\n   |\n   = help: the trait `Sub<usize>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n\
    \             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n  \
    \           <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n      \
    \       <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n        \
    \   and 48 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpmgpawgt1.rs:10:27\n   |\n10 |         let mut min_idx = -1;\n \
    \  |                           ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmpmgpawgt1.rs:18:20\n   |\n18 |         min_idx != -1\n   |     \
    \               ^^\n   |                    |\n   |                    cannot\
    \ apply unary operator `-`\n   |                    help: you may have meant the\
    \ maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot\
    \ be negated\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0600.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        } else if n - min_number\
    \ < min_distance {\n            min_number = n;\n            min_distance = n\
    \ - min_number;\n        }\n    }\n    min_distance < threshold\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfir8zhkd.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &x) in numbers.iter().enumerate()\
    \ {\n            let dist = x - i;\n            if dist < min_dist {\n       \
    \         min_dist = dist;\n                min_idx = i;\n            }\n    \
    \    }\n        min_dist < threshold\n    })\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `usize` from `f64`\n  --> /tmp/tmpcu64x45w.rs:12:26\n\
    \   |\n12 |             let dist = x - i;\n   |                          ^ no\
    \ implementation for `f64 - usize`\n   |\n   = help: the trait `Sub<usize>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n\
    \             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n  \
    \           <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n      \
    \       <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n        \
    \   and 48 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpcu64x45w.rs:10:27\n   |\n10 |         let mut min_idx = -1;\n \
    \  |                           ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdttf6mh7.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = std::f64::abs(n - min_dist);\n        if\
    \ dist < min_dist {\n            min_dist = dist;\n            min_idx = i;\n\
    \        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpzdgssls8.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_dist);\n   |            \
    \                  ^^^ not found in `std::f64`\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmpzdgssls8.rs:14:23\n   |\n14 |             min_idx\
    \ = i;\n   |                       ^ help: a local variable with a similar name\
    \ exists: `n`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzdgssls8.rs:10:9\n\
    \   |\n10 |     for &n in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = std::f64::abs(n - min_number);\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpniq2tnh7.rs:11:34\n\
    \   |\n11 |         let distance = std::f64::abs(n - min_number);\n   |      \
    \                            ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpniq2tnh7.rs:10:9\n   |\n10 |     for &n in numbers {\n\
    \   |         ^^    ------- this expression has type `Option<f64>`\n   |     \
    \    |\n   |         expected `f64`, found reference\n   |         help: you can\
    \ probably remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiwksde5v.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &x) in numbers.iter().enumerate()\
    \ {\n            let dist = x - i;\n            if dist < min_dist {\n       \
    \         min_dist = dist;\n                min_idx = i;\n            }\n    \
    \    }\n        min_dist < threshold\n    })\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `usize` from `f64`\n  --> /tmp/tmpid_cj_l0.rs:12:26\n\
    \   |\n12 |             let dist = x - i;\n   |                          ^ no\
    \ implementation for `f64 - usize`\n   |\n   = help: the trait `Sub<usize>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n\
    \             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n  \
    \           <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n      \
    \       <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n        \
    \   and 48 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpid_cj_l0.rs:10:27\n   |\n10 |         let mut min_idx = -1;\n \
    \  |                           ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc9tzkrlj.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| {\n        numbers.iter().any(|y| {\n   \
    \         abs(x - y) < threshold\n        })\n    })\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpup1e1fcx.rs:10:13\n\
    \   |\n10 |             abs(x - y) < threshold\n   |             ^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpezlxkln1.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp525c3220.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_4otftd8.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ (i, n) in numbers.iter().enumerate() {\n        let dist = n.abs() - min_dist;\n\
    \        if dist < 0.0 {\n            min_dist = dist;\n            min_idx =\
    \ i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmptb6f6r1r.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmptb6f6r1r.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_diff = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let diff = n - min_diff;\n        if diff < 0.0 {\n\
    \            min_diff = n;\n            min_idx = -1;\n        } else if diff\
    \ < min_diff {\n            min_diff = diff;\n            min_idx = Some(numbers.iter().position(|&x|\
    \ x == n));\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprnpbq7uv.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprnpbq7uv.rs:17:23\n   |\n9  |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n17 | \
    \            min_idx = Some(numbers.iter().position(|&x| x == n));\n   |     \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<Option<usize>>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|n| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, n) in numbers.iter().enumerate()\
    \ {\n            let dist = n.abs() - threshold;\n            if dist < min_dist\
    \ {\n                min_dist = dist;\n                min_idx = i;\n        \
    \    }\n        }\n        min_idx == -1\n    })\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp4xl993em.rs:10:27\n\
    \   |\n10 |         let mut min_idx = -1;\n   |                           ^^ the\
    \ trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other\
    \ types implement trait `Neg`:\n             &f32\n             &f64\n       \
    \      &i128\n             &i16\n             &i32\n             &i64\n      \
    \       &i8\n             &isize\n           and 8 others\n\nerror[E0600]: cannot\
    \ apply unary operator `-` to type `usize`\n  --> /tmp/tmp4xl993em.rs:18:20\n\
    \   |\n18 |         min_idx == -1\n   |                    ^^\n   |          \
    \          |\n   |                    cannot apply unary operator `-`\n   |  \
    \                  help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0600.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9oug70na.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkc7o295e.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppry8llul.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    for n in numbers {\n        let\
    \ dist = n.abs() - min_dist;\n        if dist < threshold {\n            return\
    \ true;\n        }\n        min_dist = dist;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp31koi9ql.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = std::f64::abs(n - min_dist);\n        if\
    \ dist < min_dist {\n            min_dist = dist;\n            min_idx = -1;\n\
    \        }\n    }\n    if min_idx < 0 {\n        false\n    } else {\n       \
    \ numbers.iter().any(|&n| {\n            std::f64::abs(n - min_dist) < threshold\n\
    \        })\n    }\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpufnaf0jy.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_dist);\n   |            \
    \                  ^^^ not found in `std::f64`\n\nerror[E0425]: cannot find function\
    \ `abs` in module `std::f64`\n  --> /tmp/tmpufnaf0jy.rs:21:23\n   |\n21 |    \
    \         std::f64::abs(n - min_dist) < threshold\n   |                      \
    \ ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpufnaf0jy.rs:10:9\n\
    \   |\n10 |     for &n in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_diff = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let diff = n - min_diff;\n        if diff < 0.0 {\n\
    \            min_diff = n;\n            min_idx = -1;\n        }\n        if diff\
    \ < min_diff {\n            min_diff = diff;\n            min_idx = i;\n     \
    \   }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpkg1f55d_.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkg1f55d_.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &x) in numbers.iter().enumerate()\
    \ {\n            let dist = x - i;\n            if dist < min_dist {\n       \
    \         min_dist = dist;\n                min_idx = i;\n            }\n    \
    \    }\n        min_dist < threshold\n    })\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `usize` from `f64`\n  --> /tmp/tmpnpaxcidx.rs:12:26\n\
    \   |\n12 |             let dist = x - i;\n   |                          ^ no\
    \ implementation for `f64 - usize`\n   |\n   = help: the trait `Sub<usize>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n\
    \             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n  \
    \           <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n      \
    \       <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n        \
    \   and 48 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpnpaxcidx.rs:10:27\n   |\n10 |         let mut min_idx = -1;\n \
    \  |                           ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_ounkgl.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3sb0rf19.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ idx in 0..numbers.len() {\n        let dist = numbers[idx] - threshold;\n  \
    \      if dist < min_dist {\n            min_dist = dist;\n            min_idx\
    \ = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpxrncm6dd.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpxrncm6dd.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_element = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_element;\n    \
    \    if distance < min_distance {\n            min_distance = distance;\n    \
    \        min_element = n;\n        }\n    }\n    min_distance < threshold\n}\n\
    \nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpayc6a2_3.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        if min_idx < 0 || min_dist > n {\n            min_dist\
    \ = n;\n            min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpfl9drrpq.rs:13:23\n\
    \   |\n13 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfl9drrpq.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_diff = threshold;\n    let mut min_diff_index = 0;\n\
    \    for (i, &num) in numbers.iter().enumerate() {\n        let diff = num - min_diff;\n\
    \        if diff < 0 {\n            min_diff = diff;\n            min_diff_index\
    \ = i;\n        }\n    }\n    min_diff_index != numbers.len() && min_diff < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph8ocl391.rs:12:19\n   |\n\
    12 |         if diff < 0 {\n   |                   ^\n   |                   |\n\
    \   |                   expected `f64`, found integer\n   |                  \
    \ help: use a float literal: `0.0`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_diff = threshold;\n    let mut min_element = numbers[0];\n\
    \    for &n in numbers {\n        let diff = n - min_element;\n        if diff\
    \ < min_diff {\n            min_diff = diff;\n            min_element = n;\n \
    \       }\n    }\n    min_diff < threshold\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuubksqgy.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| {\n        numbers.iter().any(|y| {\n   \
    \         abs(x - y) < threshold\n        })\n    })\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpnjln3mdl.rs:10:13\n\
    \   |\n10 |             abs(x - y) < threshold\n   |             ^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfldpie7y.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n        }\n    }\n    for &n in numbers {\n        let distance = n -\
    \ min_number;\n        if distance < min_distance {\n            min_distance\
    \ = distance;\n            min_number = n;\n        }\n    }\n    min_number !=\
    \ numbers[0]\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpopce61vy.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpopce61vy.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist < 0.0\
    \ {\n            min_dist = dist;\n            min_idx = -1;\n        }\n    \
    \    if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n     \
    \       min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp21jqsths.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp21jqsths.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr4hpmgw_.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_iter = numbers.iter();\n    let mut min_distance\
    \ = threshold;\n    let mut min_number = numbers_iter.next();\n    while let Some(number)\
    \ = numbers_iter.next() {\n        let distance = number.abs_sub(&min_number).unwrap();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = number;\n        }\n    }\n    min_number != numbers_iter.next()\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "warning: use of deprecated associated function `std::f64::<impl f64>::abs_sub`:\
    \ you probably meant `(self - other).abs()`: this operation is `(self - other).max(0.0)`\
    \ except that `abs_sub` also propagates NaNs (also known as `fdim` in C). If you\
    \ truly need the positive difference, consider using that expression or the C\
    \ function `fdim`, depending on how you wish to handle NaN (please consider filing\
    \ an issue describing your use-case too).\n  --> /tmp/tmpvu9ozl5e.rs:12:31\n \
    \  |\n12 |         let distance = number.abs_sub(&min_number).unwrap();\n   |\
    \                               ^^^^^^^\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvu9ozl5e.rs:12:39\n\
    \   |\n12 |         let distance = number.abs_sub(&min_number).unwrap();\n   |\
    \                                       ^^^^^^^^^^^ expected `f64`, found `&Option<&f64>`\n\
    \   |\n   = note:   expected type `f64`\n           found reference `&Option<&f64>`\n\
    \nerror[E0599]: no method named `unwrap` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpvu9ozl5e.rs:12:52\n   |\n12 |         let distance = number.abs_sub(&min_number).unwrap();\n\
    \   |                                                    ^^^^^^ method not found\
    \ in `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvu9ozl5e.rs:15:26\n\
    \   |\n10 |     let mut min_number = numbers_iter.next();\n   |              \
    \            ------------------- expected due to this value\n...\n15 |       \
    \      min_number = number;\n   |                          ^^^^^^ expected enum\
    \ `Option`, found `&f64`\n   |\n   = note:   expected enum `Option<&f64>`\n  \
    \         found reference `&f64`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n15 |             min_number = Some(number);\n   |                     \
    \     +++++      +\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_iter = numbers.iter();\n    let mut min_distance\
    \ = threshold;\n    let mut min_number = numbers_iter.next();\n    while let Some(number)\
    \ = numbers_iter.next() {\n        let distance = number.abs_sub(&min_number).abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = number;\n        }\n    }\n    min_number != numbers_iter.next()\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "warning: use of deprecated associated function `std::f64::<impl f64>::abs_sub`:\
    \ you probably meant `(self - other).abs()`: this operation is `(self - other).max(0.0)`\
    \ except that `abs_sub` also propagates NaNs (also known as `fdim` in C). If you\
    \ truly need the positive difference, consider using that expression or the C\
    \ function `fdim`, depending on how you wish to handle NaN (please consider filing\
    \ an issue describing your use-case too).\n  --> /tmp/tmpq9c6gwkl.rs:12:31\n \
    \  |\n12 |         let distance = number.abs_sub(&min_number).abs();\n   |   \
    \                            ^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on\
    \ by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq9c6gwkl.rs:12:39\n\
    \   |\n12 |         let distance = number.abs_sub(&min_number).abs();\n   |  \
    \                                     ^^^^^^^^^^^ expected `f64`, found `&Option<&f64>`\n\
    \   |\n   = note:   expected type `f64`\n           found reference `&Option<&f64>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpq9c6gwkl.rs:15:26\n   |\n10 |\
    \     let mut min_number = numbers_iter.next();\n   |                        \
    \  ------------------- expected due to this value\n...\n15 |             min_number\
    \ = number;\n   |                          ^^^^^^ expected enum `Option`, found\
    \ `&f64`\n   |\n   = note:   expected enum `Option<&f64>`\n           found reference\
    \ `&f64`\nhelp: try wrapping the expression in `Some`\n   |\n15 |            \
    \ min_number = Some(number);\n   |                          +++++      +\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbk_co9iw.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_iter = numbers.iter();\n    let mut prev_number:\
    \ f64 = numbers_iter.next().unwrap();\n    let mut next_number: f64 = numbers_iter.next().unwrap();\n\
    \    let mut close = false;\n    while numbers_iter.any() {\n        let number\
    \ = numbers_iter.next().unwrap();\n        if number - prev_number < threshold\
    \ && number - next_number < threshold {\n            close = true;\n         \
    \   break;\n        }\n        prev_number = number;\n        next_number = number;\n\
    \    }\n    close\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpu56y6tvl.rs:9:32\n  |\n9 |\
    \     let mut prev_number: f64 = numbers_iter.next().unwrap();\n  |          \
    \                ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n\
    \  |                          |\n  |                          expected due to\
    \ this\n  |\nhelp: consider dereferencing the borrow\n  |\n9 |     let mut prev_number:\
    \ f64 = *numbers_iter.next().unwrap();\n  |                                +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpu56y6tvl.rs:10:32\n   |\n10 |\
    \     let mut next_number: f64 = numbers_iter.next().unwrap();\n   |         \
    \                 ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n\
    \   |                          |\n   |                          expected due to\
    \ this\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |     let mut\
    \ next_number: f64 = *numbers_iter.next().unwrap();\n   |                    \
    \            +\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n    --> /tmp/tmpu56y6tvl.rs:12:24\n     |\n12   |     while numbers_iter.any()\
    \ {\n     |                        ^^^- supplied 0 arguments\n     |         \
    \               |\n     |                        expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpu56y6tvl.rs:18:23\n   |\n9  |     let mut prev_number: f64 = numbers_iter.next().unwrap();\n\
    \   |                          --- expected due to this type\n...\n18 |      \
    \   prev_number = number;\n   |                       ^^^^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |         prev_number\
    \ = *number;\n   |                       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu56y6tvl.rs:19:23\n   |\n10 |     let mut next_number: f64 = numbers_iter.next().unwrap();\n\
    \   |                          --- expected due to this type\n...\n19 |      \
    \   next_number = number;\n   |                       ^^^^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |         next_number\
    \ = *"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbtw3jvtg.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = std::f64::MAX;\n    let mut min_number =\
    \ numbers[0];\n    for &n in numbers {\n        let distance = std::f64::MAX;\n\
    \        for &m in numbers {\n            if m == n {\n                continue;\n\
    \            }\n            let distance = n.abs() - m.abs();\n            if\
    \ distance < distance {\n                distance = n.abs() - m.abs();\n     \
    \       }\n        }\n        if distance < min_distance {\n            min_distance\
    \ = distance;\n            min_number = n;\n        }\n    }\n    min_distance\
    \ < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpebh07uj3.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpebh07uj3.rs:12:13\n   |\n12 |         for &m\
    \ in numbers {\n   |             ^^    ------- this expression has type `Option<f64>`\n\
    \   |             |\n   |             expected `f64`, found reference\n   |  \
    \           help: you can probably remove the explicit borrow: `m`\n   |\n   =\
    \ note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9pbzfqm8.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        if n == min_dist {\n            continue;\n       \
    \ }\n        let dist = std::f64::abs(n - min_dist);\n        if dist < min_dist\
    \ {\n            min_dist = dist;\n            min_idx = -1;\n        }\n    \
    \    if dist < threshold {\n            min_dist = dist;\n            min_idx\
    \ = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpci_64g_1.rs:14:30\n\
    \   |\n14 |         let dist = std::f64::abs(n - min_dist);\n   |            \
    \                  ^^^ not found in `std::f64`\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmpci_64g_1.rs:21:23\n   |\n21 |             min_idx\
    \ = i;\n   |                       ^ help: a local variable with a similar name\
    \ exists: `n`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpci_64g_1.rs:10:9\n\
    \   |\n10 |     for &n in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp28nnxdx2.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|n| {\n        fn is_close(n: f64, threshold:\
    \ f64) -> bool {\n            n < threshold && n > -threshold\n        }\n   \
    \     numbers.iter().any(is_close(n, threshold))\n    })\n}\n\nfn main() {\n \
    \   let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzxa9jagn.rs:12:37\n   |\n\
    12 |         numbers.iter().any(is_close(n, threshold))\n   |                \
    \                     ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n12 |         numbers.iter().any(is_close(*n, threshold))\n\
    \   |                                     +\n\nerror[E0277]: expected a `FnMut<(&f64,)>`\
    \ closure, found `bool`\n    --> /tmp/tmpzxa9jagn.rs:12:28\n     |\n12   |   \
    \      numbers.iter().any(is_close(n, threshold))\n     |                    \
    \    --- ^^^^^^^^^^^^^^^^^^^^^^ expected an `FnMut<(&f64,)>` closure, found `bool`\n\
    \     |                        |\n     |                        required by a\
    \ bound introduced by this call\n     |\n     = help: the trait `FnMut<(&f64,)>`\
    \ is not implemented for `bool`\nnote: required by a bound in `any`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqldyaz1h.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiu69ngc5.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| f64::abs(x - threshold) < threshold)\n}\n\
    \nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1ek6y57k.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6vm9cxyq.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let dist = n.abs() - min_number.abs();\n   \
    \     if dist < min_dist {\n            min_dist = dist;\n            min_number\
    \ = n;\n        }\n    }\n    min_dist < threshold\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5x42qzk_.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeuolalhl.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_diff = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if *n - min_number < min_diff {\n          \
    \  min_diff = *n - min_number;\n            min_number = n;\n        }\n    }\n\
    \    min_diff < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppuvm46ip.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiy9qa1z9.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ (i, n) in numbers.iter().enumerate() {\n        let dist = n.abs() - min_dist;\n\
    \        if dist < 0.0 {\n            min_dist = dist;\n            min_idx =\
    \ i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpcn3ie__1.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpcn3ie__1.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = std::f64::MAX;\n    let mut min_number =\
    \ numbers[0];\n    for &n in numbers {\n        let distance = std::f64::MAX;\n\
    \        for &m in numbers {\n            if m == n {\n                continue;\n\
    \            }\n            let distance = n.abs() - m.abs();\n            if\
    \ distance < distance {\n                distance = n.abs() - m.abs();\n     \
    \       }\n        }\n        if distance < min_distance {\n            min_distance\
    \ = distance;\n            min_number = n;\n        }\n    }\n    min_distance\
    \ < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaqkvqq95.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaqkvqq95.rs:12:13\n   |\n12 |         for &m\
    \ in numbers {\n   |             ^^    ------- this expression has type `Option<f64>`\n\
    \   |             |\n   |             expected `f64`, found reference\n   |  \
    \           help: you can probably remove the explicit borrow: `m`\n   |\n   =\
    \ note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_iter = numbers.iter();\n    let mut min_diff = threshold;\n\
    \    let mut min_number = numbers_iter.next();\n    let mut max_number = numbers_iter.next();\n\
    \    while let Some(number) = min_number {\n        if number > max_number {\n\
    \            min_diff = threshold - min_diff;\n            min_number = numbers_iter.next();\n\
    \            max_number = numbers_iter.next();\n        } else {\n           \
    \ if number - min_diff < threshold {\n                return false;\n        \
    \    }\n            min_diff = threshold - min_diff;\n            min_number =\
    \ numbers_iter.next();\n            max_number = numbers_iter.next();\n      \
    \  }\n    }\n    true\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppx1ha3h6.rs:13:21\n   |\n\
    13 |         if number > max_number {\n   |                     ^^^^^^^^^^ expected\
    \ `&f64`, found enum `Option`\n   |\n   = note: expected reference `&f64`\n  \
    \                 found enum `Option<&f64>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_diff = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let diff = n - min_diff;\n        if diff < 0 {\n \
    \           min_diff = n;\n            min_idx = -1;\n        } else if diff ==\
    \ 0 {\n            min_idx = numbers.iter().position(|&n| n == n);\n        }\n\
    \    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppld451eb.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n  --> /tmp/tmppld451eb.rs:12:17\n   |\n\
    12 |         if diff < 0 {\n   |                 ^ no implementation for `f64\
    \ < {integer}` and `f64 > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n12 |         if diff < 0.0 {\n   |  \
    \                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppld451eb.rs:15:27\n\
    \   |\n15 |         } else if diff == 0 {\n   |                           ^\n\
    \   |                           |\n   |                           expected `f64`,\
    \ found integer\n   |                           help: use a float literal: `0.0`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppld451eb.rs:16:23\n   |\n9  |\
    \     let mut min_idx = -1;\n   |                       -- expected due to this\
    \ value\n...\n16 |             min_idx = numbers.iter().position(|&n| n == n);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<usize>`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmkkhu0vo.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| {\n        let mut min_diff = threshold;\n\
    \        let mut min_idx = -1;\n        for &mut x in numbers {\n            if\
    \ *x - x < min_diff {\n                min_diff = *x - x;\n                min_idx\
    \ = x;\n            }\n        }\n        min_idx != -1\n    })\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_o514i_e.rs:11:13\n   |\n\
    11 |         for &mut x in numbers {\n   |             ^^^^^^    ------- this\
    \ expression has type `Option<f64>`\n   |             |\n   |             expected\
    \ `f64`, found `&mut _`\n   |             help: you can probably remove the explicit\
    \ borrow: `x`\n   |\n   = note:           expected type `f64`\n           found\
    \ mutable reference `&mut _`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist < 0.0\
    \ {\n            min_dist = dist;\n            min_idx = -1;\n        }\n    \
    \    if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n     \
    \       min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpzex6moop.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzex6moop.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        if min_dist > n.abs() {\n            min_dist = n.abs();\n\
    \            min_idx = -1;\n        }\n        if min_dist > threshold {\n   \
    \         break;\n        }\n        min_dist = n.abs() - min_dist;\n        min_idx\
    \ = (min_idx + 1) % numbers.len();\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpodxnqtjo.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpodxnqtjo.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0277]: the trait bound `usize: Neg`\
    \ is not satisfied\n  --> /tmp/tmpodxnqtjo.rs:13:23\n   |\n13 |             min_idx\
    \ = -1;\n   |                       ^^ the trait `Neg` is not implemented for\
    \ `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type\
    \ `usize`\n  --> /tmp/tmpodxnqtjo.rs:21:16\n   |\n21 |     min_idx != -1\n   |\
    \                ^^\n   |                |\n   |                cannot apply unary\
    \ operator `-`\n   |                help: you may have meant the maximum value\
    \ of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0600.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        } else {\n            let\
    \ distance = n.abs() - min_number.abs();\n            if distance < min_distance\
    \ {\n                min_number = n;\n                min_distance = distance;\n\
    \            }\n        }\n    }\n    min_distance < threshold\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_o66n67d.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_diff = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let diff = n - min_number;\n        if diff\
    \ < min_diff {\n            min_diff = diff;\n            min_number = n;\n  \
    \      }\n    }\n    min_diff < threshold\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9rnxynra.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let dist = std::f64::abs(n - min_number);\n\
    \        if dist < min_dist {\n            min_dist = dist;\n            min_number\
    \ = n;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpttlunkhv.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_number);\n   |          \
    \                    ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpttlunkhv.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_iter = numbers.iter();\n    let mut min_distance\
    \ = threshold;\n    let mut min_number = numbers_iter.next();\n    while let Some(number)\
    \ = numbers_iter.next() {\n        let distance = number.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = number;\n        }\n    }\n    min_number != numbers_iter.next()\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `abs` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp5crodyjc.rs:12:50\n   |\n12 |         let distance = number.abs()\
    \ - min_number.abs();\n   |                                                  ^^^\
    \ method not found in `Option<&f64>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5crodyjc.rs:15:26\n   |\n10 |     let mut min_number = numbers_iter.next();\n\
    \   |                          ------------------- expected due to this value\n\
    ...\n15 |             min_number = number;\n   |                          ^^^^^^\
    \ expected enum `Option`, found `&f64`\n   |\n   = note:   expected enum `Option<&f64>`\n\
    \           found reference `&f64`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n15 |             min_number = Some(number);\n   |                     \
    \     +++++      +\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    for &n in numbers {\n       \
    \ let dist = n.abs() - min_dist;\n        if dist < threshold {\n            return\
    \ true;\n        }\n        min_dist = dist;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0v24mlpf.rs:9:9\n  |\n9 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_element = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_element.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_element = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpviuhexu9.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let dist = n.abs() - min_number.abs();\n   \
    \     if dist < min_dist {\n            min_dist = dist;\n            min_number\
    \ = n;\n        }\n    }\n    min_dist < threshold\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxstfenbg.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        }\n        if n < min_number\
    \ + min_distance {\n            min_number = n;\n            min_distance = threshold\
    \ - min_number;\n        }\n    }\n    min_number < threshold\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpui3ifdq8.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        }\n        if n - min_number\
    \ < min_distance {\n            min_number = n;\n            min_distance = n\
    \ - min_number;\n        }\n    }\n    min_distance < threshold\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp8zant8n.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoitq101t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_set = HashSet::new();\n    for n in numbers {\n\
    \        numbers_set.insert(n);\n    }\n    for n in numbers {\n        if numbers_set.contains(n\
    \ - threshold) {\n            return true;\n        }\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmp6iqtkcc0.rs:8:27\n  |\n8 |     let mut numbers_set = HashSet::new();\n\
    \  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|n| {\n        let mut min_dist = threshold;\n\
    \        let mut min_num = std::f64::MAX;\n        for num in numbers {\n    \
    \        if *num < *n {\n                continue;\n            }\n          \
    \  let dist = *n - num;\n            if dist < min_dist {\n                min_dist\
    \ = dist;\n                min_num = num;\n            }\n        }\n        min_dist\
    \ < threshold\n    })\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpf9ys57lv.rs:12:16\n\
    \   |\n12 |             if *num < *n {\n   |                ^^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = std::f64::MAX;\n    let mut min_number =\
    \ numbers[0];\n    for &n in numbers {\n        let distance = std::f64::MAX;\n\
    \        for &m in numbers {\n            if m == n {\n                continue;\n\
    \            }\n            let distance = std::f64::MAX;\n            if m <\
    \ n {\n                distance = std::f64::MAX;\n            }\n            distance\
    \ = std::f64::MAX if distance > m {\n                distance\n            };\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                min_number = m;\n            }\n        }\n    }\n    min_distance\
    \ < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmpo2t5ynwp.rs:20:38\n   |\n20 |            \
    \ distance = std::f64::MAX if distance > m {\n   |                           \
    \           ^^ expected one of 8 possible tokens\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo2t5ynwp.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo2t5ynwp.rs:12:13\n\
    \   |\n12 |         for &m in numbers {\n   |             ^^    ------- this expression\
    \ has type `Option<f64>`\n   |             |\n   |             expected `f64`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `m`\n   |\n   = note:   expected type `f64`\n           found reference\
    \ `&_`\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ (i, n) in numbers.iter().enumerate() {\n        let dist = n.abs() - min_dist;\n\
    \        if dist < 0.0 {\n            min_dist = dist;\n            min_idx =\
    \ i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmph1dwwy7m.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmph1dwwy7m.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_diff = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let diff = n - min_diff;\n        if diff < 0.0 {\n\
    \            min_diff = n;\n            min_idx = -1;\n        }\n        if diff\
    \ < min_diff {\n            min_diff = diff;\n            min_idx = i;\n     \
    \   }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpx1e__xq1.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpx1e__xq1.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ (i, n) in numbers.iter().enumerate() {\n        let dist = n.abs() - min_dist;\n\
    \        if dist < threshold {\n            min_dist = dist;\n            min_idx\
    \ = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmp_bgs9h67.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmp_bgs9h67.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_diff = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let diff = n - min_number;\n        if diff\
    \ < min_diff {\n            min_diff = diff;\n            min_number = n;\n  \
    \      }\n    }\n    min_diff < threshold\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2wwu74an.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist < 0.0\
    \ {\n            min_dist = dist;\n            min_idx = -1;\n        }\n    \
    \    if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n     \
    \       min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpf901oo4n.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf901oo4n.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = std::f64::MAX;\n    let mut min_number =\
    \ numbers[0];\n    for &n in numbers {\n        let distance = std::f64::MAX;\n\
    \        for &m in numbers {\n            if m == n {\n                continue;\n\
    \            }\n            let distance = m - n;\n            if distance < min_distance\
    \ {\n                min_distance = distance;\n                min_number = m;\n\
    \            }\n        }\n    }\n    min_distance < threshold\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl1sc1ow6.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl1sc1ow6.rs:12:13\n   |\n12 |         for &m\
    \ in numbers {\n   |             ^^    ------- this expression has type `Option<f64>`\n\
    \   |             |\n   |             expected `f64`, found reference\n   |  \
    \           help: you can probably remove the explicit borrow: `m`\n   |\n   =\
    \ note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9yj1tozi.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0xbrm0g6.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx8n0_zc4.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let dist = std::f64::abs(n - min_number);\n\
    \        if dist < min_dist {\n            min_dist = dist;\n            min_number\
    \ = n;\n        }\n    }\n    min_dist < threshold\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmp1iamp1z0.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_number);\n   |          \
    \                    ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1iamp1z0.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        if min_dist > n {\n            min_dist = n;\n    \
    \        min_idx = -1;\n        }\n        if min_dist == n {\n            min_idx++;\n\
    \        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp74qe3o9t.rs:16:20\n\
    \   |\n16 |             min_idx++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n16 |             { let tmp =\
    \ min_idx; min_idx += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    16 -             min_idx++;\n16 +             min_idx += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp74qe3o9t.rs:10:9\n   |\n10 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        if min_dist > n.abs() {\n            min_dist = n.abs();\n\
    \            min_idx = -1;\n        }\n        if min_dist > threshold {\n   \
    \         break;\n        }\n        min_dist = n.abs() - min_dist;\n        min_idx\
    \ = match min_idx {\n            -1 => n,\n            i => if n < numbers[min_idx]\
    \ {\n                i\n            } else {\n                min_idx\n      \
    \      }\n        };\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpesh9tjud.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpesh9tjud.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0277]: the trait bound `usize: Neg`\
    \ is not satisfied\n  --> /tmp/tmpesh9tjud.rs:13:23\n   |\n13 |             min_idx\
    \ = -1;\n   |                       ^^ the trait `Neg` is not implemented for\
    \ `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmpesh9tjud.rs:20:13\n   |\n20 |             -1 => n,\n\
    \   |             ^^ the trait `Neg` is not implemented for `usize`\n   |\n  \
    \ = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpesh9tjud.rs:28:16\n\
    \   |\n28 |     min_idx != -1\n   |                ^^\n   |                |\n\
    \   |                cannot apply unary operator `-`\n   |                help:\
    \ you may have meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note:\
    \ unsigned values cannot be negated\n\nerror: aborting due to 5 previous err"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = std::f64::abs(n - min_dist);\n        if\
    \ min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n           \
    \ min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmp47qg1day.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_dist);\n   |            \
    \                  ^^^ not found in `std::f64`\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmp47qg1day.rs:14:23\n   |\n14 |             min_idx\
    \ = i;\n   |                       ^ help: a local variable with a similar name\
    \ exists: `n`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp47qg1day.rs:10:9\n\
    \   |\n10 |     for &n in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| f64::abs(x - threshold) < threshold)\n}\n\
    \nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6lzwp2y0.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| {\n        numbers.iter().any(|y| {\n   \
    \         abs(x - y) < threshold\n        })\n    })\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpywiv_qfy.rs:10:13\n\
    \   |\n10 |             abs(x - y) < threshold\n   |             ^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu63ylx2n.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ (i, &num) in numbers.iter().enumerate() {\n        let dist = std::f64::abs(num\
    \ - min_dist);\n        if dist < threshold {\n            min_dist = num;\n \
    \           min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpe607tz69.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(num - min_dist);\n   |          \
    \                    ^^^ not found in `std::f64`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n --> /tmp/tmpe607tz69.rs:9:23\n  |\n9 |     let\
    \ mut min_idx = -1;\n  |                       ^^ the trait `Neg` is not implemented\
    \ for `usize`\n  |\n  = help: the following other types implement trait `Neg`:\n\
    \            &f32\n            &f64\n            &i128\n            &i16\n   \
    \         &i32\n            &i64\n            &i8\n            &isize\n      \
    \    and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmpe607tz69.rs:17:16\n   |\n17 |     min_idx != -1\n   |         \
    \       ^^\n   |                |\n   |                cannot apply unary operator\
    \ `-`\n   |                help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0425,\
    \ E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp3siifmf.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n        }\n    }\n    for &n in numbers {\n        let distance = n.abs()\
    \ - min_number.abs();\n        if distance < min_distance {\n            min_distance\
    \ = distance;\n            min_number = n;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgbk5c61m.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgbk5c61m.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpayzhmgcg.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_element = numbers[0];\n\
    \    for &n in numbers {\n        if *n < min_distance {\n            min_distance\
    \ = *n;\n            min_element = n;\n        }\n    }\n    for &n in numbers\
    \ {\n        if *n >= min_distance {\n            return false;\n        }\n \
    \   }\n    true\n}\n\nfn main() {\n    let candidate = has_close_elements;\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpldm0lsbn.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpldm0lsbn.rs:16:9\n   |\n16 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = std::f64::abs(n - min_dist);\n        if\
    \ dist < min_dist {\n            min_dist = dist;\n            min_idx = -1;\n\
    \        }\n    }\n    if min_idx >= 0 {\n        true\n    } else {\n       \
    \ false\n    }\n}\n\nfn main() {\n    let candidate = has_close_elements;\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpalravpz9.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_dist);\n   |            \
    \                  ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpalravpz9.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    for &n in numbers {\n       \
    \ let dist = n.abs() - min_dist;\n        if dist < threshold {\n            return\
    \ true;\n        }\n        min_dist = dist;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_e21ucmi.rs:9:9\n  |\n9 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_element = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_element;\n    \
    \    if distance < min_distance {\n            min_distance = distance;\n    \
    \        min_element = n;\n        }\n    }\n    min_distance < threshold\n}\n\
    \nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphnniz3lj.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt3s7kj9z.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgwqgqukw.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpns2_hnti.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| f64::abs(x - threshold) < threshold)\n}\n\
    \nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3cuh9j26.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbefhi5np.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_iter = numbers.iter();\n    let mut min_distance\
    \ = threshold;\n    let mut min_number = numbers_iter.next();\n    let mut max_number\
    \ = numbers_iter.next();\n    while let Some(number) = min_number {\n        if\
    \ number > max_number {\n            min_number = max_number;\n            max_number\
    \ = number;\n        } else {\n            let distance = number.abs() - min_number.abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                min_number = number;\n            }\n        }\n    }\n    min_number\
    \ == max_number\n}\n\nfn main() {\n    let candidate = has_close_elements;\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbfb9vyzs.rs:13:21\n   |\n\
    13 |         if number > max_number {\n   |                     ^^^^^^^^^^ expected\
    \ `&f64`, found enum `Option`\n   |\n   = note: expected reference `&f64`\n  \
    \                 found enum `Option<&f64>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbfb9vyzs.rs:15:26\n   |\n11 |     let mut max_number = numbers_iter.next();\n\
    \   |                          ------------------- expected due to this value\n\
    ...\n15 |             max_number = number;\n   |                          ^^^^^^\
    \ expected enum `Option`, found `&f64`\n   |\n   = note:   expected enum `Option<&f64>`\n\
    \           found reference `&f64`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n15 |             max_number = Some(number);\n   |                     \
    \     +++++      +\n\nerror[E0599]: no method named `abs` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpbfb9vyzs.rs:17:54\n   |\n17 |          \
    \   let distance = number.abs() - min_number.abs();\n   |                    \
    \                                  ^^^ method not found in `Option<&f64>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpbfb9vyzs.rs:20:30\n   |\n10 |  \
    \   let mut min_number = numbers_iter.next();\n   |                          -------------------\
    \ expected due to this value\n...\n20 |                 min_number = number;\n\
    \   |                              ^^^^^^ expected enum `Option`, found `&f64`\n\
    \   |\n   = note:   expected enum `Option<&f64>`\n           found reference `&f64`\n\
    help: try wrapping the expression in `Some`\n   |\n20 |                 min_number\
    \ = Some(number);\n   |                              +++++      +\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6c6gn5f6.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnhsxyb8s.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_iter = numbers.iter().cloned();\n    let mut threshold\
    \ = threshold * threshold;\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut min_number = numbers_iter.next().unwrap();\n    while let Some(number) =\
    \ numbers_iter.next() {\n        let distance = number.abs_sub(&min_number).unwrap();\n\
    \        if distance < threshold {\n            min_distance = distance;\n   \
    \         min_number = number;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "warning: use of deprecated associated function `std::f64::<impl f64>::abs_sub`:\
    \ you probably meant `(self - other).abs()`: this operation is `(self - other).max(0.0)`\
    \ except that `abs_sub` also propagates NaNs (also known as `fdim` in C). If you\
    \ truly need the positive difference, consider using that expression or the C\
    \ function `fdim`, depending on how you wish to handle NaN (please consider filing\
    \ an issue describing your use-case too).\n  --> /tmp/tmpc2y4c62f.rs:13:31\n \
    \  |\n13 |         let distance = number.abs_sub(&min_number).unwrap();\n   |\
    \                               ^^^^^^^\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc2y4c62f.rs:13:39\n\
    \   |\n13 |         let distance = number.abs_sub(&min_number).unwrap();\n   |\
    \                                       ^^^^^^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider removing the borrow\n   |\n13 -         let distance = number.abs_sub(&min_number).unwrap();\n\
    13 +         let distance = number.abs_sub(min_number).unwrap();\n   | \n\nerror[E0599]:\
    \ no method named `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmpc2y4c62f.rs:13:52\n\
    \   |\n13 |         let distance = number.abs_sub(&min_number).unwrap();\n   |\
    \                                                    ^^^^^^ method not found in\
    \ `f64`\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_copy = numbers.clone();\n    numbers_copy.sort();\n\
    \    let mut min_distance = threshold;\n    for &n in numbers_copy {\n       \
    \ let mut min_distance = threshold;\n        for &m in numbers_copy {\n      \
    \      if m == n {\n                continue;\n            }\n            let\
    \ distance = std::f64::abs(n - m);\n            if distance < min_distance {\n\
    \                min_distance = distance;\n            }\n        }\n        if\
    \ min_distance < threshold {\n            return true;\n        }\n    }\n   \
    \ false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpwglzpbdu.rs:17:38\n\
    \   |\n17 |             let distance = std::f64::abs(n - m);\n   |           \
    \                           ^^^ not found in `std::f64`\n\nerror[E0277]: the trait\
    \ bound `f64: Ord` is not satisfied\n   --> /tmp/tmpwglzpbdu.rs:9:18\n    |\n\
    9   |     numbers_copy.sort();\n    |                  ^^^^ the trait `Ord` is\
    \ not implemented for `f64`\n    |\n    = help: the following other types implement\
    \ trait `Ord`:\n              i128\n              i16\n              i32\n   \
    \           i64\n              i8\n              isize\n              u128\n \
    \             u16\n            and 4 others\nnote: required by a bound in `slice::<impl\
    \ [T]>::sort`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwglzpbdu.rs:11:9\n\
    \   |\n11 |     for &n in numbers_copy {\n   |         ^^    ------------ this\
    \ expression has type `Option<f64>`\n   |         |\n   |         expected `f64`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `n`\n   |\n   = note:   expected type `f64`\n           found reference `&_`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwglzpbdu.rs:13:13\n   |\n13 |\
    \         for &m in numbers_copy {\n   |             ^^    ------------ this expression\
    \ has type `Option<f64>`\n   |             |\n   |             expected `f64`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `m`\n   |\n   = note:   expected type `f64`\n           found reference\
    \ `&_`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_diff = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        if min_diff > n {\n            min_diff = n;\n    \
    \        min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpgb7lzt8e.rs:13:23\n\
    \   |\n13 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgb7lzt8e.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_iter = numbers.iter().cloned();\n    let mut threshold\
    \ = threshold * std::f64::consts::PI;\n    let mut close = false;\n    let mut\
    \ prev_x = std::f64::consts::PI;\n    let mut prev_y = std::f64::consts::PI;\n\
    \    let mut prev_z = std::f64::consts::PI;\n    let mut prev_r = std::f64::consts::PI;\n\
    \    let mut prev_d = std::f64::consts::PI;\n    let mut prev_a = std::f64::consts::PI;\n\
    \    let mut prev_b = std::f64::consts::PI;\n    let mut prev_c = std::f64::consts::PI;\n\
    \    let mut prev_w = std::f64::consts::PI;\n    let mut prev_v = std::f64::consts::PI;\n\
    \    let mut prev_w = std::f64::consts::PI;\n    let mut prev_v = std::f64::consts::PI;\n\
    \    let mut prev_w = std::f64::consts::PI;\n    let mut prev_v = std::f64::consts::PI;\n\
    \    let mut prev_w = std::f64::consts::PI;\n    let mut prev_v = std::f64::consts::PI;\n\
    \    let mut prev_w = std::f64::consts::PI;\n    let mut prev_v = std::f64::consts::PI;\n\
    \    let mut prev_w = std::f64::consts::PI;\n    let mut prev_v = std::f64::consts::PI;\n\
    \    let mut prev_w = std::f64::consts::PI;\n    let mut prev_v = std::f64::consts::PI;\n\
    \    let mut prev_w = std::f64::consts::PI;\n    let mut prev_v = std::f64::consts::PI;\n\
    \    let mut prev_w = std::f64::consts::PI;\n    let mut prev_v = std::f64::consts::PI;\n\
    \    let mut prev_w = std::f64::consts::PI;\n    let mut prev_v = std::f64::consts::PI;\n\
    \    let mut prev_w = std::f64::consts::PI;\n    let mut prev_v = std::f64::consts::PI;\n\
    \    let mut prev_w = std::f64::consts::PI;\n    let mut prev_v = std::f64::consts::PI;\n\
    \    let mut prev_w = std::f64::consts::PI;\n    let mut prev_v = std::f64::consts::PI;\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdhnhlzdz.rs:45:11\n   |\n\
    45 |     let mu\n   |           ^ help: add `;` here\n46 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdhnhlzdz.rs:7:61\n  |\n\
    7 | fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n  |  \
    \  ------------------                                       ^^^^ expected `bool`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpylj3khvr.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ idx in 0..numbers.len() {\n        let dist = numbers[idx] - threshold;\n  \
    \      if dist < min_dist {\n            min_dist = dist;\n            min_idx\
    \ = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpl5wbzm01.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpl5wbzm01.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = std::f64::abs(n - min_dist);\n        if\
    \ dist < min_dist {\n            min_dist = dist;\n            min_idx = -1;\n\
    \        }\n        if min_idx < 0 || min_dist < threshold {\n            min_idx\
    \ = Some(numbers.iter().position(|&n| n == n).unwrap());\n        }\n    }\n \
    \   min_idx != -1\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmptwk7knyx.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_dist);\n   |            \
    \                  ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptwk7knyx.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptwk7knyx.rs:17:23\n\
    \   |\n9  |     let mut min_idx = -1;\n   |                       -- expected\
    \ due to this value\n...\n17 |             min_idx = Some(numbers.iter().position(|&n|\
    \ n == n).unwrap());\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbezielp6.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy6nrea2_.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| {\n        let mut min_distance = threshold;\n\
    \        let mut min_number = numbers[0];\n        for &n in numbers {\n     \
    \       let distance = x.abs() - n.abs();\n            if distance < min_distance\
    \ {\n                min_distance = distance;\n                min_number = n;\n\
    \            }\n        }\n        min_distance < threshold\n    })\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2kwlj2vy.rs:11:13\n   |\n\
    11 |         for &n in numbers {\n   |             ^^    ------- this expression\
    \ has type `Option<f64>`\n   |             |\n   |             expected `f64`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `n`\n   |\n   = note:   expected type `f64`\n           found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9kntqsj9.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplplx11y9.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ idx in 0..numbers.len() {\n        let dist = numbers[idx] - threshold;\n  \
    \      if dist < min_dist {\n            min_dist = dist;\n            min_idx\
    \ = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmp4qg3ok39.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmp4qg3ok39.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp57v47ipu.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist < 0.0\
    \ {\n            min_dist = dist;\n            min_idx = -1;\n        }\n    \
    \    if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n     \
    \       min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmph3ekzhyh.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmph3ekzhyh.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7l2nv65g.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_set = HashSet::new();\n    for n in numbers {\n\
    \        numbers_set.insert(n);\n    }\n    for n in numbers_set {\n        if\
    \ *n >= threshold {\n            return true;\n        }\n    }\n    false\n}\n\
    \nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpmpkf58wg.rs:8:27\n  |\n8 |     let mut numbers_set = HashSet::new();\n\
    \  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist < 0.0\
    \ {\n            min_dist = dist;\n            min_idx = -1;\n        }\n    \
    \    if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n     \
    \       min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpsebtg552.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsebtg552.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = std::f64::abs(n - min_dist);\n        if\
    \ dist < min_dist {\n            min_dist = dist;\n            min_idx = i;\n\
    \        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmprv3289hf.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_dist);\n   |            \
    \                  ^^^ not found in `std::f64`\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmprv3289hf.rs:14:23\n   |\n14 |             min_idx\
    \ = i;\n   |                       ^ help: a local variable with a similar name\
    \ exists: `n`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprv3289hf.rs:10:9\n\
    \   |\n10 |     for &n in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist < 0.0\
    \ {\n            min_dist = dist;\n            min_idx = -1;\n        }\n    \
    \    if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n     \
    \       min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp25myj1np.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp25myj1np.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    for &n in numbers {\n       \
    \ let dist = n.abs() - min_dist;\n        if dist < threshold {\n            return\
    \ true;\n        }\n        min_dist = dist;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbm3281eh.rs:9:9\n  |\n9 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        if min_idx < 0 || n - numbers[min_idx] < min_dist {\n\
    \            min_dist = n - numbers[min_idx];\n            min_idx = i;\n    \
    \    }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpvctxnjhf.rs:13:23\n\
    \   |\n13 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvctxnjhf.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror[E0277]: the trait bound `usize: Neg` is\
    \ not satisfied\n --> /tmp/tmpvctxnjhf.rs:9:23\n  |\n9 |     let mut min_idx =\
    \ -1;\n  |                       ^^ the trait `Neg` is not implemented for `usize`\n\
    \  |\n  = help: the following other types implement trait `Neg`:\n           \
    \ &f32\n            &f64\n            &i128\n            &i16\n            &i32\n\
    \            &i64\n            &i8\n            &isize\n          and 8 others\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpvctxnjhf.rs:16:16\n\
    \   |\n16 |     min_idx != -1\n   |                ^^\n   |                |\n\
    \   |                cannot apply unary operator `-`\n   |                help:\
    \ you may have meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note:\
    \ unsigned values cannot be negated\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0425, E0600.\nFor more\
    \ information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &x) in numbers.iter().enumerate()\
    \ {\n            let dist = x - i;\n            if dist < min_dist {\n       \
    \         min_dist = dist;\n                min_idx = i;\n            }\n    \
    \    }\n        min_dist < threshold\n    })\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `usize` from `f64`\n  --> /tmp/tmprlr_36ai.rs:12:26\n\
    \   |\n12 |             let dist = x - i;\n   |                          ^ no\
    \ implementation for `f64 - usize`\n   |\n   = help: the trait `Sub<usize>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n\
    \             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n  \
    \           <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n      \
    \       <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n        \
    \   and 48 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmprlr_36ai.rs:10:27\n   |\n10 |         let mut min_idx = -1;\n \
    \  |                           ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpldko2esm.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ idx in 0..numbers.len() {\n        let dist = numbers[idx] - threshold;\n  \
    \      if dist < min_dist {\n            min_dist = dist;\n            min_idx\
    \ = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpzvt08pkt.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpzvt08pkt.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbni9v7ql.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_diff = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let diff = n - min_number;\n        if diff\
    \ < min_diff {\n            min_diff = diff;\n            min_number = n;\n  \
    \      }\n    }\n    min_diff < threshold\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr3tagynv.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, x) in numbers.iter().enumerate()\
    \ {\n            let dist = x - i;\n            if dist < min_dist {\n       \
    \         min_dist = dist;\n                min_idx = i;\n            }\n    \
    \    }\n        min_dist < threshold\n    })\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `usize` from `&f64`\n  --> /tmp/tmpqd_an3yb.rs:12:26\n\
    \   |\n12 |             let dist = x - i;\n   |                          ^ no\
    \ implementation for `&f64 - usize`\n   |\n   = help: the trait `Sub<usize>` is\
    \ not implemented for `&f64`\n   = help: the following other types implement trait\
    \ `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n\
    \             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n  \
    \           <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n      \
    \       <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n        \
    \   and 48 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpqd_an3yb.rs:10:27\n   |\n10 |         let mut min_idx = -1;\n \
    \  |                           ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = std::f64::abs(n - min_number);\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmp9h_sw6j2.rs:11:34\n\
    \   |\n11 |         let distance = std::f64::abs(n - min_number);\n   |      \
    \                            ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9h_sw6j2.rs:10:9\n   |\n10 |     for &n in numbers {\n\
    \   |         ^^    ------- this expression has type `Option<f64>`\n   |     \
    \    |\n   |         expected `f64`, found reference\n   |         help: you can\
    \ probably remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_iter = numbers.iter().cloned();\n    let mut min_distance\
    \ = threshold;\n    let mut min_number = numbers_iter.next().unwrap();\n    for\
    \ number in numbers_iter {\n        let distance = number.abs_sub(&min_number).unwrap();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = number;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "warning: use of deprecated associated function `std::f64::<impl f64>::abs_sub`:\
    \ you probably meant `(self - other).abs()`: this operation is `(self - other).max(0.0)`\
    \ except that `abs_sub` also propagates NaNs (also known as `fdim` in C). If you\
    \ truly need the positive difference, consider using that expression or the C\
    \ function `fdim`, depending on how you wish to handle NaN (please consider filing\
    \ an issue describing your use-case too).\n  --> /tmp/tmpap3cfsyd.rs:12:31\n \
    \  |\n12 |         let distance = number.abs_sub(&min_number).unwrap();\n   |\
    \                               ^^^^^^^\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpap3cfsyd.rs:12:39\n\
    \   |\n12 |         let distance = number.abs_sub(&min_number).unwrap();\n   |\
    \                                       ^^^^^^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider removing the borrow\n   |\n12 -         let distance = number.abs_sub(&min_number).unwrap();\n\
    12 +         let distance = number.abs_sub(min_number).unwrap();\n   | \n\nerror[E0599]:\
    \ no method named `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmpap3cfsyd.rs:12:52\n\
    \   |\n12 |         let distance = number.abs_sub(&min_number).unwrap();\n   |\
    \                                                    ^^^^^^ method not found in\
    \ `f64`\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe13mkj59.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist < threshold\
    \ {\n            min_dist = dist;\n            min_idx = Some(numbers.iter().position(|&n|\
    \ n == n).unwrap());\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyhz3st7n.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyhz3st7n.rs:14:23\n   |\n9  |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n14 | \
    \            min_idx = Some(numbers.iter().position(|&n| n == n).unwrap());\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_diff = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let diff = n - min_number;\n        if diff\
    \ < min_diff {\n            min_diff = diff;\n            min_number = n;\n  \
    \      }\n    }\n    min_diff < threshold\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp23jq1fx_.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_set = HashSet::new();\n    for n in numbers {\n\
    \        numbers_set.insert(n);\n    }\n    for n in numbers_set {\n        if\
    \ *n < threshold {\n            return false;\n        }\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpqq0xnum3.rs:8:27\n  |\n8 |     let mut numbers_set = HashSet::new();\n\
    \  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = std::f64::abs(n - min_number);\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpeau6v_6e.rs:11:34\n\
    \   |\n11 |         let distance = std::f64::abs(n - min_number);\n   |      \
    \                            ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeau6v_6e.rs:10:9\n   |\n10 |     for &n in numbers {\n\
    \   |         ^^    ------- this expression has type `Option<f64>`\n   |     \
    \    |\n   |         expected `f64`, found reference\n   |         help: you can\
    \ probably remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = std::f64::abs(n - min_dist);\n        if\
    \ min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n           \
    \ min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpgf8jodju.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_dist);\n   |            \
    \                  ^^^ not found in `std::f64`\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmpgf8jodju.rs:14:23\n   |\n14 |             min_idx\
    \ = i;\n   |                       ^ help: a local variable with a similar name\
    \ exists: `n`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgf8jodju.rs:10:9\n\
    \   |\n10 |     for &n in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| x < threshold || x > -threshold)\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2ynm09cu.rs:8:32\n  |\n8 |\
    \     numbers.iter().any(|x| x < threshold || x > -threshold)\n  |           \
    \                     ^^^^^^^^^\n  |                                |\n  |   \
    \                             expected `&f64`, found `f64`\n  |              \
    \                  help: consider borrowing here: `&threshold`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp2ynm09cu.rs:8:49\n  |\n8 |     numbers.iter().any(|x|\
    \ x < threshold || x > -threshold)\n  |                                      \
    \           ^^^^^^^^^^\n  |                                                 |\n\
    \  |                                                 expected `&f64`, found `f64`\n\
    \  |                                                 help: consider borrowing\
    \ here: `&-threshold`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n    for\
    \ &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist < 0.0\
    \ {\n            min_dist = dist;\n            min_idx = -1;\n        }\n    \
    \    if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n     \
    \       min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpbuvuxa90.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbuvuxa90.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &x) in numbers.iter().enumerate()\
    \ {\n            let dist = x - i;\n            if dist < min_dist {\n       \
    \         min_dist = dist;\n                min_idx = i;\n            }\n    \
    \    }\n        min_dist < threshold\n    })\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `usize` from `f64`\n  --> /tmp/tmplxrwp1ri.rs:12:26\n\
    \   |\n12 |             let dist = x - i;\n   |                          ^ no\
    \ implementation for `f64 - usize`\n   |\n   = help: the trait `Sub<usize>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n\
    \             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n  \
    \           <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n      \
    \       <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n        \
    \   and 48 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmplxrwp1ri.rs:10:27\n   |\n10 |         let mut min_idx = -1;\n \
    \  |                           ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_dist = 0;\n        }\n        if min_dist > threshold\
    \ {\n            return false;\n        }\n        min_dist += n;\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpklv7ahbb.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpklv7ahbb.rs:13:24\n   |\n8  |     let mut min_dist\
    \ = threshold;\n   |                        --------- expected due to this value\n\
    ...\n13 |             min_dist = 0;\n   |                        ^\n   |     \
    \                   |\n   |                        expected `f64`, found integer\n\
    \   |                        help: use a float literal: `0.0`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().any(|n| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, n2) in numbers.iter().enumerate()\
    \ {\n            let dist = abs(n - n2);\n            if dist < min_dist {\n \
    \               min_dist = dist;\n                min_idx = i;\n            }\n\
    \        }\n        min_idx != -1\n    })\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpf34bb18o.rs:12:24\n\
    \   |\n12 |             let dist = abs(n - n2);\n   |                        ^^^\
    \ not found in this scope\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmpf34bb18o.rs:10:27\n   |\n10 |         let mut min_idx\
    \ = -1;\n   |                           ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type\
    \ `usize`\n  --> /tmp/tmpf34bb18o.rs:18:20\n   |\n18 |         min_idx != -1\n\
    \   |                    ^^\n   |                    |\n   |                 \
    \   cannot apply unary operator `-`\n   |                    help: you may have\
    \ meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned\
    \ values cannot be negated\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0425, E0600.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnd4q6iwe.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_set = HashSet::new();\n    for n in numbers {\n\
    \        numbers_set.insert(n);\n    }\n    for n in numbers_set.iter() {\n  \
    \      if *n >= threshold {\n            return false;\n        }\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpo5b9szkp.rs:8:27\n  |\n8 |     let mut numbers_set = HashSet::new();\n\
    \  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp02f4b5j6.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_iter = numbers.iter();\n    let mut threshold =\
    \ threshold * threshold;\n    let mut close = false;\n    let mut current_element:\
    \ f64 = numbers_iter.next().unwrap();\n    let mut current_element_distance: f64\
    \ = current_element as f64;\n    let mut current_element_index: usize = 0;\n \
    \   while !numbers_iter.next().is_none() {\n        let next_element = numbers_iter.next().unwrap();\n\
    \        let next_element_distance = next_element as f64;\n        let next_element_index\
    \ = numbers_iter.index();\n        if current_element_distance < next_element_distance\
    \ {\n            current_element = next_element;\n            current_element_distance\
    \ = next_element_distance;\n            current_element_index = next_element_index;\n\
    \        } else {\n            if current_element_distance - threshold < next_element_distance\
    \ - threshold {\n                close = true;\n            }\n            current_element\
    \ = next_element;\n            current_element_distance = next_element_distance;\n\
    \            current_element_index = next_element_index;\n        }\n    }\n \
    \   close\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc5jj3801.rs:11:36\n   |\n\
    11 |     let mut current_element: f64 = numbers_iter.next().unwrap();\n   |  \
    \                            ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`,\
    \ found `&f64`\n   |                              |\n   |                    \
    \          expected due to this\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n11 |     let mut current_element: f64 = *numbers_iter.next().unwrap();\n\
    \   |                                    +\n\nerror[E0599]: no method named `index`\
    \ found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpc5jj3801.rs:17:47\n\
    \   |\n17 |         let next_element_index = numbers_iter.index();\n   |     \
    \                                          ^^^^^ method not found in `std::slice::Iter<'_,\
    \ f64>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc5jj3801.rs:19:31\n \
    \  |\n11 |     let mut current_element: f64 = numbers_iter.next().unwrap();\n\
    \   |                              --- expected due to this type\n...\n19 |  \
    \           current_element = next_element;\n   |                            \
    \   ^^^^^^^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n19 |             current_element = *next_element;\n   |  \
    \                             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc5jj3801.rs:26:31\n\
    \   |\n11 |     let mut current_element: f64 = numbers_iter.next().unwrap();\n\
    \   |                              --- expected due to this type\n...\n26 |  \
    \           current_element = next_element;\n   |                            \
    \   ^^^^^^^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n26 |             current_element = *next_element;\n   |  \
    \                             +\n\nerror[E0606]: casting `&f64` as `f64` is invalid\n\
    \  --> /tmp/tmpc5jj3801.rs:16:37\n   |\n16 |         let next_element_distance\
    \ = next_element as f64;\n   |                                     ------------^^^^^^^\n\
    \   |                                     |\n   |                            \
    \         cannot cast `&f64` as `f64"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj5tyt1fl.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7i3xt6lm.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
