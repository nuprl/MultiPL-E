name: HumanEval_70_strange_sort_list
language: rust
results:
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < \n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp3rbuvz1a.rs:117:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    102 |     for el in lst {\n    |                   - this delimiter might not\
    \ be properly closed...\n103 |         if el < \n104 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n117 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmp3rbuvz1a.rs:104:1\n    |\n104 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmp3rbuvz1a.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpaatazh4z.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            sorted_list.push(value);\n        }\n\
    \        if value > max_value {\n            sorted_list.push(value);\n      \
    \  }\n    }\n    for value in lst {\n        if value < max_value {\n        \
    \    sorted_list.push(value);\n        }\n    }\n    for value in lst {\n    \
    \    if value < min_value {\n            sorted_list.push(value);\n        }\n\
    \    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp_kqsxopl.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n12  |     for value in &lst\
    \ {\n    |                  +\n\nerror[E0382]: use of moved value: `lst`\n  -->\
    \ /tmp/tmp_kqsxopl.rs:28:18\n   |\n8  | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                      --- move occurs because `lst` has\
    \ type `Vec<isize>`, which does not implement the `Copy` trait\n...\n20 |    \
    \ for value in lst {\n   |                  --- `lst` moved due to this implicit\
    \ call to `.into_iter()`\n...\n28 |     for value in lst {\n   |             \
    \     ^^^ value used here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n20\
    \ |     for value in &lst {\n   |                  +\n\nerror[E0382]: use of moved\
    \ value: `lst`\n  --> /tmp/tmp_kqsxopl.rs:33:18\n   |\n8  | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- move occurs because\
    \ `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n\
    28 |     for value in lst {\n   |                  --- `lst` moved due to this\
    \ implicit call to `.into_iter()`\n...\n33 |     for value in lst {\n   |    \
    \              ^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \   |\n28 |     for value in &lst {\n   |                  +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmphu4i4w06.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            result.push(value);\n        }\n  \
    \      if value > max_value {\n            result.push(value);\n        }\n  \
    \  }\n    for value in lst {\n        if value < max_value {\n            result.push(value);\n\
    \        }\n        if value > min_value {\n            result.push(value);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpeqtwuzq_.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n12  |     for value in &lst\
    \ {\n    |                  +\n\nerror[E0382]: use of moved value: `lst`\n  -->\
    \ /tmp/tmpeqtwuzq_.rs:28:18\n   |\n8  | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                      --- move occurs because `lst` has\
    \ type `Vec<isize>`, which does not implement the `Copy` trait\n...\n20 |    \
    \ for value in lst {\n   |                  --- `lst` moved due to this implicit\
    \ call to `.into_iter()`\n...\n28 |     for value in lst {\n   |             \
    \     ^^^ value used here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n20\
    \ |     for value in &lst {\n   |                  +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|&x|\
    \ x == min).unwrap();\n    let mut max_idx = lst.iter().position(|&x| x == max).unwrap();\n\
    \    while min_idx != max_idx {\n        let tmp = min;\n        min = max;\n\
    \        max = tmp;\n        min_idx = lst.iter().position(|&x| x == min).unwrap();\n\
    \        max_idx = lst.iter().position(|&x| x == max).unwrap();\n    }\n    lst.swap(min_idx,\
    \ max_idx);\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnb3yhd4o.rs:12:53\n   |\n\
    12 |     let mut min_idx = lst.iter().position(|&x| x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |     let\
    \ mut min_idx = lst.iter().position(|&x| x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnb3yhd4o.rs:13:53\n   |\n13 |     let mut max_idx = lst.iter().position(|&x|\
    \ x == max).unwrap();\n   |                                                  \
    \   ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n13 |     let mut max_idx = lst.iter().position(|&x| x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnb3yhd4o.rs:18:49\n   |\n18 |         min_idx = lst.iter().position(|&x|\
    \ x == min).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n18 |         min_idx = lst.iter().position(|&x| x == *min).unwrap();\n\
    \   |                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnb3yhd4o.rs:19:49\n   |\n19 |         max_idx = lst.iter().position(|&x|\
    \ x == max).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n19 |         max_idx = lst.iter().position(|&x| x == *max).unwrap();\n\
    \   |                                                 +\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmppr7_g5ch.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|&x|\
    \ x == min).unwrap();\n    let mut max_idx = lst.iter().position(|&x| x == max).unwrap();\n\
    \    let mut mid_idx = min_idx;\n    while min_idx < max_idx {\n        result.push(lst[mid_idx]);\n\
    \        mid_idx += 1;\n        if mid_idx > max_idx {\n            mid_idx =\
    \ min_idx;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbwloqjf7.rs:12:53\n   |\n\
    12 |     let mut min_idx = lst.iter().position(|&x| x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |     let\
    \ mut min_idx = lst.iter().position(|&x| x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbwloqjf7.rs:13:53\n   |\n13 |     let mut max_idx = lst.iter().position(|&x|\
    \ x == max).unwrap();\n   |                                                  \
    \   ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n13 |     let mut max_idx = lst.iter().position(|&x| x == *max).unwrap();\n\
    \   |                                                     +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp5z0xg3a2.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for v in lst.iter() {\n        if v < min_value\
    \ {\n            min_value = v;\n        }\n        if v > max_value {\n     \
    \       max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpruft18og.rs:121:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    102 |     for v in lst.iter() {\n    |                         - unclosed delimiter\n\
    ...\n106 |         if v > max_value {\n    |                          - this delimiter\
    \ might not be properly closed...\n107 |             max_\n108 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n121 | }\n    |   ^\n\n\
    error[E0425]: cannot find value `max_` in this scope\n   --> /tmp/tmpruft18og.rs:107:13\n\
    \    |\n107 |             max_\n    |             ^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpruft18og.rs:13:16\n   |\n13 |\
    \         if v < min_value {\n   |                ^^^^^^^^^\n   |            \
    \    |\n   |                expected `&isize`, found `isize`\n   |           \
    \     help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpruft18og.rs:14:25\n   |\n10 |     let mut min_value = lst[0];\n\
    \   |                         ------ expected due to this value\n...\n14 |   \
    \          min_value = v;\n   |                         ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |        \
    \     min_value = *v;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpruft18og.rs:16:16\n   |\n16 |         if v > max_value\
    \ {\n   |                ^^^^^^^^^\n   |                |\n   |              \
    \  expected `&isize`, found `isize`\n   |                help: consider borrowing\
    \ here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpruft18og.rs:17:25\n\
    \   |\n11 |     let mut max_value = lst[0];\n   |                         ------\
    \ expected due to this value\n...\n17 |             max_value = v;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n17 |             max_value = *v;\n   |     \
    \                    +\n\nerror[E0308]: mismatched types\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp5099j5x_.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| *x == max).unwrap();\n\
    \    let mut min_idx = min_idx - 1;\n    let mut max_idx = max_idx + 1;\n    while\
    \ min_idx < max_idx {\n        let tmp = min;\n        min = lst.iter().nth(min_idx).unwrap();\n\
    \        lst.swap(min_idx, max_idx);\n        max = lst.iter().nth(max_idx).unwrap();\n\
    \        lst.swap(max_idx, min_idx);\n        min_idx = min_idx + 1;\n       \
    \ max_idx = max_idx - 1;\n    }\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyn4ud6et.rs:12:53\n   |\n\
    12 |     let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |     let\
    \ mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyn4ud6et.rs:13:53\n   |\n13 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n13 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    let mut min = lst[0];\n    let\
    \ mut max = lst[0];\n    for el in lst {\n        if el < min {\n            min\
    \ = el;\n        }\n        if el > max {\n            max = el;\n        }\n\
    \    }\n    for i in 0..(lst.len() - 1) {\n        let mut j = i;\n        while\
    \ j > 0 && lst[j - 1] > max {\n            j -= 1;\n        }\n        res.push(lst[j]);\n\
    \    }\n    res.push(min);\n    res.push(max);\n    res\n}\n\nfn main() {\n  \
    \  let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmp3srw4mpg.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for el in lst {\n    | \
    \              --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for i in 0..(lst.len() - 1) {\n    |                  ^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of\
    \ the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |\
    \     for el in &lst {\n    |               +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value = sorted_list[0];\n\
    \    let mut max_value = sorted_list[0];\n    for value in sorted_list.iter()\
    \ {\n        if value < min_value {\n            min_value = value;\n        }\n\
    \        if value > max_value {\n            max_value = value;\n        }\n \
    \   }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n   --> /tmp/tmpwwa1znx8.rs:111:17\n   \
    \ |\n111 |     let mut max_\n    |                 ^ help: add `;` here\n112 |\
    \ }\n    | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwwa1znx8.rs:13:20\n\
    \   |\n13 |         if value < min_value {\n   |                    ^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwwa1znx8.rs:14:25\n   |\n10 |     let mut min_value\
    \ = sorted_list[0];\n   |                         -------------- expected due\
    \ to this value\n...\n14 |             min_value = value;\n   |              \
    \           ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n14 |             min_value = *value;\n   |               \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwwa1znx8.rs:16:20\n\
    \   |\n16 |         if value > max_value {\n   |                    ^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&max_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwwa1znx8.rs:17:25\n   |\n11 |     let mut max_value\
    \ = sorted_list[0];\n   |                         -------------- expected due\
    \ to this value\n...\n17 |             max_value = value;\n   |              \
    \           ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |             max_value = *value;\n   |               \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwwa1znx8.rs:23:20\n\
    \   |\n23 |         if value < min_value {\n   |                    ^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwwa1znx8.rs:24:25\n   |\n20 |     let mut min_value\
    \ = min_value;\n   |                         --------- expected due to this value\n\
    ...\n24 |   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp09_7je5c.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            sorted_list.push(value);\n        }\n\
    \        if value > max_value {\n            sorted_list.push(value);\n      \
    \  }\n    }\n    for value in lst {\n        if value < max_value {\n        \
    \    sorted_list.push(value);\n        }\n    }\n    for value in lst {\n    \
    \    if value > min_value {\n            sorted_list.push(value);\n        }\n\
    \    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp9p5hpicj.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n12  |     for value in &lst\
    \ {\n    |                  +\n\nerror[E0382]: use of moved value: `lst`\n  -->\
    \ /tmp/tmp9p5hpicj.rs:28:18\n   |\n8  | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                      --- move occurs because `lst` has\
    \ type `Vec<isize>`, which does not implement the `Copy` trait\n...\n20 |    \
    \ for value in lst {\n   |                  --- `lst` moved due to this implicit\
    \ call to `.into_iter()`\n...\n28 |     for value in lst {\n   |             \
    \     ^^^ value used here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n20\
    \ |     for value in &lst {\n   |                  +\n\nerror[E0382]: use of moved\
    \ value: `lst`\n  --> /tmp/tmp9p5hpicj.rs:33:18\n   |\n8  | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- move occurs because\
    \ `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n\
    28 |     for value in lst {\n   |                  --- `lst` moved due to this\
    \ implicit call to `.into_iter()`\n...\n33 |     for value in lst {\n   |    \
    \              ^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \   |\n28 |     for value in &lst {\n   |                  +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = Vec::new();\n    let mut min_value =\
    \ lst[0];\n    let mut max_value = lst[0];\n    for value in lst {\n        if\
    \ value < min_value {\n            min_value = value;\n        }\n        if value\
    \ > max_value {\n            max_value = value;\n        }\n    }\n    for value\
    \ in lst {\n        if value < min_value {\n            sorted_list.push(value);\n\
    \        } else {\n            if value > max_value {\n                sorted_list.push(value);\n\
    \            } else {\n                sorted_list.push(min_value);\n        \
    \        sorted_list.push(max_value);\n            }\n        }\n    }\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpcsuqg62y.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n12  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpt7gmhv24.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for x in lst.iter() {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    for x in lst.iter() {\n        if\
    \ x == min_value {\n            result.push(x);\n        }\n        if x == max_value\
    \ {\n            result.push(x);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxammakvb.rs:13:16\n   |\n\
    13 |         if x < min_value {\n   |                ^^^^^^^^^\n   |         \
    \       |\n   |                expected `&isize`, found `isize`\n   |        \
    \        help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxammakvb.rs:14:25\n   |\n10 |     let mut min_value = lst[0];\n\
    \   |                         ------ expected due to this value\n...\n14 |   \
    \          min_value = x;\n   |                         ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |        \
    \     min_value = *x;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxammakvb.rs:16:16\n   |\n16 |         if x > max_value\
    \ {\n   |                ^^^^^^^^^\n   |                |\n   |              \
    \  expected `&isize`, found `isize`\n   |                help: consider borrowing\
    \ here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxammakvb.rs:17:25\n\
    \   |\n11 |     let mut max_value = lst[0];\n   |                         ------\
    \ expected due to this value\n...\n17 |             max_value = x;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n17 |             max_value = *x;\n   |     \
    \                    +\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmpxammakvb.rs:21:14\n   |\n21 |         if x == min_value {\n   |\
    \              ^^ no implementation for `&isize == isize`\n   |\n   = help: the\
    \ trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmpxammakvb.rs:24:14\n   |\n\
    24 |         if x == max_value {\n   |              ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp4i9fa97t.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value == min_value {\n            result.push(value);\n        }\n \
    \       if value == max_value {\n            result.push(value);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpuw0kd0hz.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n12  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpwolm3uqk.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for ele in lst.iter() {\n        if ele\
    \ < min_value {\n            min_value = ele;\n        }\n        if ele > max_value\
    \ {\n            max_value = ele;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for ele in lst.iter() {\n        if ele\
    \ < min_value {\n            min_value = ele;\n        }\n        if ele > max_value\
    \ {\n            max_value = ele;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for ele in lst.iter() {\n        if ele\
    \ < min_value {\n            min_value = ele;\n        }\n        if ele > max_value\
    \ {\n            max_value = ele;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for ele in lst.iter() {\n        if ele\
    \ < min_value {\n            min_value = ele;\n        }\n        if ele > max_value\
    \ {\n            max_value = ele;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for ele in lst.iter() {\n        if ele\
    \ < min_value {\n            min_value = ele;\n        }\n        if ele > max_value\
    \ {\n            max_value = ele;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for ele in lst.iter() {\n        if ele\
    \ < min_value {\n            min_value = ele;\n        }\n        if ele > max_value\
    \ {\n            max_value = ele;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for ele in lst.iter() {\n        if ele\
    \ < min_value {\n            min_value = ele;\n        }\n        if ele > max_value\
    \ {\n            max_value = ele;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for ele in lst.iter() {\n        if ele\
    \ < min_value {\n            min_value = ele;\n        }\n        if ele > max_value\
    \ {\n            max_value = ele;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for ele in lst.iter() {\n        if ele\
    \ < min_value {\n            min_value = ele;\n        }\n        if ele > max_value\
    \ {\n            max_value = ele;\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps6ln9v0h.rs:13:18\n   |\n\
    13 |         if ele < min_value {\n   |                  ^^^^^^^^^\n   |     \
    \             |\n   |                  expected `&isize`, found `isize`\n   |\
    \                  help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps6ln9v0h.rs:14:25\n   |\n10 |     let mut min_value\
    \ = lst[0];\n   |                         ------ expected due to this value\n\
    ...\n14 |             min_value = ele;\n   |                         ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |             min_value = *ele;\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps6ln9v0h.rs:16:18\n   |\n16 |         if ele\
    \ > max_value {\n   |                  ^^^^^^^^^\n   |                  |\n  \
    \ |                  expected `&isize`, found `isize`\n   |                  help:\
    \ consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmps6ln9v0h.rs:17:25\n   |\n11 |     let mut max_value = lst[0];\n   |\
    \                         ------ expected due to this value\n...\n17 |       \
    \      max_value = ele;\n   |                         ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |        \
    \     max_value = *ele;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps6ln9v0h.rs:23:18\n   |\n23 |         if ele < min_value\
    \ {\n   |                  ^^^^^^^^^\n   |                  |\n   |          \
    \        expected `&isize`, found `isize`\n   |                  help: consider\
    \ borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps6ln9v0h.rs:24:25\n\
    \   |\n20 |     let mut min_value = min_value;\n   |                         ---------\
    \ expected due to this value\n...\n24 |             min_value = ele;\n   |   \
    \                      ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n24 |             min_value = *ele;\n   |   \
    \                      +\n\nerror[E0308]: mismatched types\n  --"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpoeg83mp6.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpedsiu5vt.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value = sorted_list[0];\n\
    \    let mut max_value = sorted_list[0];\n    for value in sorted_list.iter()\
    \ {\n        if value < min_value {\n            min_value = value;\n        }\n\
    \        if value > max_value {\n            max_value = value;\n        }\n \
    \   }\n    sorted_list.sort();\n    let mut new_list = Vec::new();\n    for value\
    \ in sorted_list {\n        if value == min_value {\n            new_list.push(value);\n\
    \        } else {\n            new_list.push(value);\n            new_list.push(max_value);\n\
    \        }\n    }\n    new_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdy8y5m1c.rs:13:20\n   |\n\
    13 |         if value < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdy8y5m1c.rs:14:25\n   |\n10 |     let mut min_value\
    \ = sorted_list[0];\n   |                         -------------- expected due\
    \ to this value\n...\n14 |             min_value = value;\n   |              \
    \           ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n14 |             min_value = *value;\n   |               \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdy8y5m1c.rs:16:20\n\
    \   |\n16 |         if value > max_value {\n   |                    ^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&max_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdy8y5m1c.rs:17:25\n   |\n11 |     let mut max_value\
    \ = sorted_list[0];\n   |                         -------------- expected due\
    \ to this value\n...\n17 |             max_value = value;\n   |              \
    \           ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |             max_value = *value;\n   |               \
    \          +\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpy_u4c7tl.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n113 |         if value < \n114 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n127 | }\n    |   ^\n\n\
    error: expected expression, found `}`\n   --> /tmp/tmpy_u4c7tl.rs:114:1\n    |\n\
    114 | }\n    | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmpy_u4c7tl.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut min = lst[0];\n    let\
    \ mut max = lst[0];\n    for el in lst {\n        if el < min {\n            min\
    \ = el;\n        }\n        if el > max {\n            max = el;\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(el);\n\
    \        }\n        if el == max {\n            result.push(el);\n        }\n\
    \    }\n\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n   --> /tmp/tmpntc79dtj.rs:116:5\n    |\n\
    8   |   fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |         \
    \                                   ---------- expected `Vec<isize>` because of\
    \ return type\n...\n116 | /     for el in lst {\n117 | |         if el == min\
    \ {\n118 | |             result.push(el);\n119 | |         }\n...   |\n122 | |\
    \         }\n123 | |     }\n    | |_____^ expected struct `Vec`, found `()`\n\
    \    |\n    = note: expected struct `Vec<isize>`\n            found unit type\
    \ `()`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for v in lst.iter() {\n        if v < min_value\
    \ {\n            min_value = v;\n        }\n        if v > max_value {\n     \
    \       max_value = v;\n        }\n    }\n    let mut min_idx = 1;\n    let mut\
    \ max_idx = 1;\n    while min_idx < lst.len() {\n        let v = lst[min_idx];\n\
    \        let mut j = min_idx;\n        while j < lst.len() {\n            if v\
    \ < lst[j] {\n                break;\n            }\n            j += 1\n    \
    \    }\n        result.push(v);\n        min_idx = j;\n    }\n    while max_idx\
    \ < lst.len() {\n        let v = lst[max_idx];\n        let mut j = max_idx;\n\
    \        while j > min_idx {\n            if v > lst[j] {\n                break;\n\
    \            }\n            j -= 1\n        }\n        result.push(v);\n     \
    \   max_idx = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw47ozdgd.rs:13:16\n   |\n\
    13 |         if v < min_value {\n   |                ^^^^^^^^^\n   |         \
    \       |\n   |                expected `&isize`, found `isize`\n   |        \
    \        help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw47ozdgd.rs:14:25\n   |\n10 |     let mut min_value = lst[0];\n\
    \   |                         ------ expected due to this value\n...\n14 |   \
    \          min_value = v;\n   |                         ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |        \
    \     min_value = *v;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw47ozdgd.rs:16:16\n   |\n16 |         if v > max_value\
    \ {\n   |                ^^^^^^^^^\n   |                |\n   |              \
    \  expected `&isize`, found `isize`\n   |                help: consider borrowing\
    \ here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw47ozdgd.rs:17:25\n\
    \   |\n11 |     let mut max_value = lst[0];\n   |                         ------\
    \ expected due to this value\n...\n17 |             max_value = v;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n17 |             max_value = *v;\n   |     \
    \                    +\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp_vj08rn8.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            result.push(value);\n        }\n  \
    \      if value > max_value {\n            result.push(value);\n        }\n  \
    \  }\n    for value in lst {\n        if value < max_value {\n            result.push(value);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpyorzrm0t.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n12  |     for value in &lst\
    \ {\n    |                  +\n\nerror[E0382]: use of moved value: `lst`\n  -->\
    \ /tmp/tmpyorzrm0t.rs:28:18\n   |\n8  | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                      --- move occurs because `lst` has\
    \ type `Vec<isize>`, which does not implement the `Copy` trait\n...\n20 |    \
    \ for value in lst {\n   |                  --- `lst` moved due to this implicit\
    \ call to `.into_iter()`\n...\n28 |     for value in lst {\n   |             \
    \     ^^^ value used here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n20\
    \ |     for value in &lst {\n   |                  +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| *x == max).unwrap();\n\
    \    while min_idx < max_idx {\n        let tmp = min;\n        min = max;\n \
    \       max = tmp;\n        min_idx = lst.iter().position(|x| *x == min).unwrap();\n\
    \        max_idx = lst.iter().position(|x| *x == max).unwrap();\n    }\n    lst.swap(min_idx,\
    \ max_idx);\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpso7hwppx.rs:12:53\n   |\n\
    12 |     let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |     let\
    \ mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpso7hwppx.rs:13:53\n   |\n13 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n13 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpso7hwppx.rs:18:49\n   |\n18 |         min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n18 |         min_idx = lst.iter().position(|x| *x == *min).unwrap();\n\
    \   |                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpso7hwppx.rs:19:49\n   |\n19 |         max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n19 |         max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                 +\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpj1ftukqs.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| *x == max).unwrap();\n\
    \    let mut mid = min + (max - min) / 2;\n    while min_idx != max_idx {\n  \
    \      result.push(mid);\n        mid = min + (max - min) / 2;\n        min_idx\
    \ = lst.iter().position(|x| *x == min).unwrap();\n        max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n    }\n    result.push(mid);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyssm9zym.rs:12:53\n   |\n\
    12 |     let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |     let\
    \ mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyssm9zym.rs:13:53\n   |\n13 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n13 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyssm9zym.rs:18:49\n   |\n18 |         min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n18 |         min_idx = lst.iter().position(|x| *x == *min).unwrap();\n\
    \   |                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyssm9zym.rs:19:49\n   |\n19 |         max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n19 |         max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                 +\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp0hvspvfx.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpryuuuiyc.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp0h9wlnfn.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    for x in lst {\n        if x ==\
    \ min_value {\n            result.push(max_value);\n            result.push(x);\n\
    \            result.push(min_value);\n        } else {\n            result.push(x);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpfvop3_ja.rs:20:14\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for x in lst {\n    |  \
    \            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for x in lst {\n    |              ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n12  |     for x in &lst {\n    |  \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpaq7_3soc.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = Vec::new();\n    let mut min_value =\
    \ lst[0];\n    let mut max_value = lst[0];\n    for x in lst {\n        if x <\
    \ min_value {\n            min_value = x;\n        }\n        if x > max_value\
    \ {\n            max_value = x;\n        }\n    }\n    let mut min_idx = 1;\n\
    \    let mut max_idx = 1;\n    for x in lst {\n        if x == min_value {\n \
    \           sorted_list.push(min_value);\n            min_idx++;\n        }\n\
    \        if x == max_value {\n            sorted_list.push(max_value);\n     \
    \       max_idx++;\n        }\n        sorted_list.push(x);\n    }\n    sorted_list.extend(vec![min_value;\
    \ min_idx]);\n    sorted_list.extend(vec![max_value; max_idx]);\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp037z6cvj.rs:25:20\n\
    \   |\n25 |             min_idx++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n25 |             { let tmp =\
    \ min_idx; min_idx += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    25 -             min_idx++;\n25 +             min_idx += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmp037z6cvj.rs:29:20\n   |\n29\
    \ |             max_idx++;\n   |                    ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n29 |             { let tmp = max_idx; max_idx\
    \ += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n29\
    \ -             max_idx++;\n29 +             max_idx += 1;\n   | \n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < \n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpi8_besik.rs:117:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    102 |     for el in lst {\n    |                   - this delimiter might not\
    \ be properly closed...\n103 |         if el < \n104 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n117 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpi8_besik.rs:104:1\n    |\n104 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmpi8_besik.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            result.push(value);\n        }\n  \
    \      if value > max_value {\n            result.push(value);\n        }\n  \
    \  }\n    for value in lst {\n        if value < max_value {\n            result.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value > min_value {\n  \
    \          result.push(value);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp22vjvks1.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n12  |     for value in &lst\
    \ {\n    |                  +\n\nerror[E0382]: use of moved value: `lst`\n  -->\
    \ /tmp/tmp22vjvks1.rs:28:18\n   |\n8  | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                      --- move occurs because `lst` has\
    \ type `Vec<isize>`, which does not implement the `Copy` trait\n...\n20 |    \
    \ for value in lst {\n   |                  --- `lst` moved due to this implicit\
    \ call to `.into_iter()`\n...\n28 |     for value in lst {\n   |             \
    \     ^^^ value used here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n20\
    \ |     for value in &lst {\n   |                  +\n\nerror[E0382]: use of moved\
    \ value: `lst`\n  --> /tmp/tmp22vjvks1.rs:33:18\n   |\n8  | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- move occurs because\
    \ `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n\
    28 |     for value in lst {\n   |                  --- `lst` moved due to this\
    \ implicit call to `.into_iter()`\n...\n33 |     for value in lst {\n   |    \
    \              ^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \   |\n28 |     for value in &lst {\n   |                  +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp9898wj73.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpqf68ebvl.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpaexhrz2k.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut min = lst[0];\n    let\
    \ mut max = lst[0];\n    for x in lst {\n        if x < min {\n            min\
    \ = x;\n        }\n        if x > max {\n            max = x;\n        }\n   \
    \ }\n    for x in lst {\n        if x == min {\n            result.push(min);\n\
    \        }\n        if x == max {\n            result.push(max);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp1g_7r7ss.rs:20:14\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for x in lst {\n    |  \
    \            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for x in lst {\n    |              ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n12  |     for x in &lst {\n    |  \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpe787fqah.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp1se8bjnm.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmplewxpvrw.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    for el in lst {\n        if el\
    \ < min_value {\n            res.push(min_value);\n            min_value = el;\n\
    \        }\n        if el > max_value {\n            res.push(max_value);\n  \
    \          max_value = el;\n        }\n    }\n    res.push(min_value);\n    res.push(max_value);\n\
    \    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp13d9dhn9.rs:20:15\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for el in lst {\n    | \
    \              --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for el in lst {\n    |               ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n12  |     for el in &lst {\n    | \
    \              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp4_jniyf3.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpq7vom_uf.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6s8p0knp.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n113 |         if \n114 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmp6s8p0knp.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmp6s8p0knp.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpmahri0v3.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            result.push(value);\n        } else\
    \ {\n            result.push(min_value);\n            result.push(value);\n  \
    \          result.push(max_value);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpsh8ietp8.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n12  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmphtgn3tuw.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmppwdmlptx.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    for value\
    \ in lst {\n        if value < min_value {\n            min_value = value;\n \
    \       }\n        if value > max_value {\n            max_value = value;\n  \
    \      }\n    }\n    for value in lst {\n        if value < min_value {\n    \
    \        min_value = value;\n        }\n        if value > max_value {\n     \
    \       max_value = value;\n        }\n    }\n    for value in lst {\n       \
    \ if value < min_value {\n            min_value = value;\n        }\n        if\
    \ value > max_value {\n            max_value = value;\n        }\n    }\n    for\
    \ value in lst {\n        if value < min_value {\n            min_value = value;\n\
    \        }\n        if value > max_value {\n            max_value = value;\n \
    \       }\n    }\n    for value in lst {\n        if value < min_value {\n   \
    \         min_value = value;\n        }\n        if value > max_value {\n    \
    \        max_value = value;\n        }\n    }\n    for value in lst {\n      \
    \  if value < min_value {\n            min_value = value;\n        }\n       \
    \ if value > max_value {\n            max_value = value;\n        }\n    }\n \
    \   for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            min_value = value;\n        }\n   \
    \     if value > max_value {\n            max_value = value;\n        }\n    }\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            min_value = value;\n        }\n   \
    \     if value > max_value {\n            max_value = value;\n        }\n    }\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpeyvu18k2.rs:144:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    126 |     for value in lst {\n    |                      - unclosed delimiter\n\
    ...\n130 |         if value > max_value {\n    |                             \
    \ - this delimiter might not be properly closed...\n131 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n144 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmpeyvu18k2.rs:126:5\n    |\n8   |   fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    |                                         \
    \   ---------- expected `Vec<isize>` because of return type\n...\n126 | /    \
    \ for value in lst {\n127 | |         if value < min_value {\n128 | |        \
    \     min_value = value;\n129 | |         }\n...   |\n143 | |     assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n144 | | }\n    | |__^ expected struct `Vec`, found `()`\n  \
    \  |\n    = note: expected struct `Vec<isize>`\n            found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpc3bqfmjz.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp31ybhxsj.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.clone();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| *x == max).unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    while min_idx != max_idx {\n        let tmp = min;\n        min = max;\n\
    \        max = tmp;\n        min_idx = lst.iter().position(|x| *x == min).unwrap();\n\
    \        max_idx = lst.iter().position(|x| *x == max).unwrap();\n        min_idx\
    \ = min_idx.unwrap();\n        max_idx = max_idx.unwrap();\n    }\n    lst.sort_unstable();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ljbdnfi.rs:12:53\n   |\n\
    12 |     let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |     let\
    \ mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7ljbdnfi.rs:13:53\n   |\n13 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n13 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0599]: no\
    \ method named `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmp7ljbdnfi.rs:14:31\n\
    \   |\n14 |     let mut min_idx = min_idx.unwrap();\n   |                    \
    \           ^^^^^^ method not found in `usize`\n\nerror[E0599]: no method named\
    \ `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmp7ljbdnfi.rs:15:31\n\
    \   |\n15 |     let mut max_idx = max_idx.unwrap();\n   |                    \
    \           ^^^^^^ method not found in `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7ljbdnfi.rs:20:49\n   |\n20 |         min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n20 |         min_idx = lst.iter().position(|x| *x == *min).unwrap();\n\
    \   |                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7ljbdnfi.rs:21:49\n   |\n21 |         max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |         max_idx = lst.iter().position(|x| *x == *max).unwrap"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    let mut min = lst[0];\n    let\
    \ mut max = lst[0];\n    for x in lst {\n        if x < min {\n            min\
    \ = x;\n        }\n        if x > max {\n            max = x;\n        }\n   \
    \ }\n    for i in 0..(lst.len() - 1) {\n        if lst[i] < min {\n          \
    \  res[i] = min;\n            min = lst[i];\n        }\n        if lst[i] > max\
    \ {\n            res[i] = max;\n            max = lst[i];\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmp3fw0gtu4.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for x in lst {\n    |  \
    \            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for i in 0..(lst.len() - 1) {\n    |                  ^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of\
    \ the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |\
    \     for x in &lst {\n    |              +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst[0];\n\
    \    let mut max = lst[0];\n    for x in lst {\n        if x < min {\n       \
    \     min = x;\n        }\n        if x > max {\n            max = x;\n      \
    \  }\n    }\n    for x in lst {\n        if x == min {\n            result.push(x);\n\
    \        }\n        if x == max {\n            result.push(x);\n        }\n  \
    \  }\n    for x in lst {\n        if x == min {\n            result.push(x);\n\
    \        }\n        if x == max {\n            result.push(x);\n        }\n  \
    \  }\n    for x in lst {\n        if x == min {\n            result.push(x);\n\
    \        }\n        if x == max {\n            result.push(x);\n        }\n  \
    \  }\n    for x in lst {\n        if x == min {\n            result.push(x);\n\
    \        }\n        if x == max {\n            result.push(x);\n        }\n  \
    \  }\n    for x in lst {\n        if x == min {\n            result.push(x);\n\
    \        }\n        if x == max {\n            result.push(x);\n        }\n  \
    \  }\n    for x in lst {\n        if x == min {\n            result.push(x);\n\
    \        }\n        if x == max {\n            result.push(x);\n        }\n  \
    \  }\n    for x in lst {\n        if x == min {\n            result.push(x);\n\
    \        }\n        if x == max {\n            result.push(x);\n        }\n  \
    \  }\n    for x in lst {\n        if x == min {\n            result.push(x);\n\
    \        }\n        if x == max {\n            result.push(x);\n        }\n  \
    \  }\n    for x in lst {\n        if x == min {\n            result.push(x);\n\
    \        }\n        if x == max {\n            result.push(x);\n        }\n  \
    \  }\n    for x in lst {\n        if x == min {\n            result.push(x);\n\
    \        }\n        if x == max {\n            result.push(x);\n        }\n  \
    \  }\n    for x in lst {\n        if x == min {\n            result.push(x);\n\
    \        }\n        if x == max {\n            result.push(x);\n        }\n  \
    \  }\n    for x in lst {\n        if x == min {\n            result.push(x);\n\
    \        }\n        if x == max {\n            result.push(x);\n        }\n  \
    \  }\n    for x in lst {\n        if x == min {\n            result.push(x);\n\
    \        }\n        if x == max {\n            result.push(x);\n        }\n  \
    \  }\n    for x in lst {\n        if x == min {\n            result.push(x);\n\
    \        }\n        if x == max {\n            result.push(x);\n        }\n  \
    \  }\n    for x in lst {\n        if x == min {\n            result.push(x);\n\
    \        }\n        if x == max {\n            result.push(x);\n        }\n  \
    \  }\n    for x in lst {\n        if x == min \n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp4geyjmne.rs:155:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    140 |     for x in lst {\n    |                  - this delimiter might not be\
    \ properly closed...\n141 |         if x == min \n142 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n155 | }\n    |   ^\n\nerror: expected\
    \ `{`, found `}`\n   --> /tmp/tmp4geyjmne.rs:142:1\n    |\n141 |         if x\
    \ == min \n    |         -- this `if` expression has a condition, but no block\n\
    142 | }\n    | ^ expected `{`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4geyjmne.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpo4q64weh.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp9ipt8dxe.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpsbym6cdj.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value == min_value {\n            result.push(value);\n        }\n \
    \       if value == max_value {\n            result.push(value);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpkw1lmii9.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n12  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = std::i32::MAX;\n\
    \    let mut max_value = std::i32::MIN;\n    let mut min_pos = 0;\n    let mut\
    \ max_pos = 0;\n    let mut i = 0;\n    while i < lst.len() {\n        if min_value\
    \ < lst[i] {\n            min_value = lst[i];\n            min_pos = i;\n    \
    \    }\n        if max_value > lst[i] {\n            max_value = lst[i];\n   \
    \         max_pos = i;\n        }\n        i += 1;\n    }\n    let mut j = min_pos;\n\
    \    while j != max_pos {\n        result.push(lst[j]);\n        j += 1;\n   \
    \ }\n    result.push(min_value);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjf435uzz.rs:16:24\n   |\n\
    16 |         if min_value < lst[i] {\n   |                        ^^^^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         if min_value <\
    \ lst[i].try_into().unwrap() {\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjf435uzz.rs:17:25\n   |\n10 |\
    \     let mut min_value = std::i32::MAX;\n   |                         -------------\
    \ expected due to this value\n...\n17 |             min_value = lst[i];\n   |\
    \                         ^^^^^^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjf435uzz.rs:20:24\n   |\n20 |         if max_value\
    \ > lst[i] {\n   |                        ^^^^^^ expected `i32`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n20 |         if max_value > lst[i].try_into().unwrap()\
    \ {\n   |                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjf435uzz.rs:21:25\n   |\n11 |     let mut max_value = std::i32::MIN;\n\
    \   |                         ------------- expected due to this value\n...\n\
    21 |             max_value = lst[i];\n   |                         ^^^^^^ expected\
    \ `i32`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjf435uzz.rs:31:17\n\
    \   |\n31 |     result.push(min_value);\n   |                 ^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n31 |     result.push(min_value.try_into().unwrap());\n\
    \   |                          ++++++++++++++++++++\n\nerror: aborting due to\
    \ 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0kquoynv.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n113 |         if \n114 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmp0kquoynv.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmp0kquoynv.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpvn0ydhdk.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpr1tdslgv.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp6ozy6wtz.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp9pzhqm3y.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp44fa0xbc.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n113 |         if \n114 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmp44fa0xbc.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmp44fa0xbc.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value = sorted_list[0];\n\
    \    let mut max_value = sorted_list[0];\n    for value in sorted_list.iter()\
    \ {\n        if value < min_value {\n            min_value = value;\n        }\n\
    \        if value > max_value {\n            max_value = value;\n        }\n \
    \   }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in sorted_list.iter() {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in sorted_list.iter() {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n   --> /tmp/tmp2ihycvxo.rs:111:17\n   \
    \ |\n111 |     let mut max_\n    |                 ^ help: add `;` here\n112 |\
    \ }\n    | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ihycvxo.rs:13:20\n\
    \   |\n13 |         if value < min_value {\n   |                    ^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2ihycvxo.rs:14:25\n   |\n10 |     let mut min_value\
    \ = sorted_list[0];\n   |                         -------------- expected due\
    \ to this value\n...\n14 |             min_value = value;\n   |              \
    \           ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n14 |             min_value = *value;\n   |               \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ihycvxo.rs:16:20\n\
    \   |\n16 |         if value > max_value {\n   |                    ^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&max_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2ihycvxo.rs:17:25\n   |\n11 |     let mut max_value\
    \ = sorted_list[0];\n   |                         -------------- expected due\
    \ to this value\n...\n17 |             max_value = value;\n   |              \
    \           ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |             max_value = *value;\n   |               \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ihycvxo.rs:23:20\n\
    \   |\n23 |         if value < min_value {\n   |                    ^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2ihycvxo.rs:24:25\n   |\n20 |     let mut min_value\
    \ = min_value;\n   |                         --------- expected due to this value\n\
    ...\n24 |   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for v in lst.iter() {\n        if v < min_value\
    \ {\n            min_value = v;\n        }\n        if v > max_value {\n     \
    \       max_value = v;\n        }\n    }\n    let mut i = 1;\n    while i < lst.len()\
    \ {\n        let mut j = i;\n        while j < lst.len() && lst[j] < min_value\
    \ {\n            j += 1\n        }\n        let mut k = i;\n        while k <\
    \ lst.len() && lst[k] > max_value {\n            k += 1\n        }\n        result.push(*(lst[k..j].iter().cloned().collect()));\n\
    \        i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg104o0o3.rs:13:16\n   |\n\
    13 |         if v < min_value {\n   |                ^^^^^^^^^\n   |         \
    \       |\n   |                expected `&isize`, found `isize`\n   |        \
    \        help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg104o0o3.rs:14:25\n   |\n10 |     let mut min_value = lst[0];\n\
    \   |                         ------ expected due to this value\n...\n14 |   \
    \          min_value = v;\n   |                         ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |        \
    \     min_value = *v;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg104o0o3.rs:16:16\n   |\n16 |         if v > max_value\
    \ {\n   |                ^^^^^^^^^\n   |                |\n   |              \
    \  expected `&isize`, found `isize`\n   |                help: consider borrowing\
    \ here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg104o0o3.rs:17:25\n\
    \   |\n11 |     let mut max_value = lst[0];\n   |                         ------\
    \ expected due to this value\n...\n17 |             max_value = v;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n17 |             max_value = *v;\n   |     \
    \                    +\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| x == max).unwrap();\n\
    \    while min_idx < max_idx {\n        let tmp = min;\n        min = max.clone();\n\
    \        max = tmp;\n        min_idx = lst.iter().position(|x| x == min).unwrap();\n\
    \        max_idx = lst.iter().position(|x| x == max).unwrap();\n    }\n    lst.swap(min_idx,\
    \ max_idx);\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmhckxtwo.rs:16:15\n   |\n\
    10 |     let mut min = lst.iter().min().unwrap();\n   |                   -------------------------\
    \ expected due to this value\n...\n16 |         min = max.clone();\n   |     \
    \          ^^^^^^^^^^^\n   |               |\n   |               expected `&isize`,\
    \ found `isize`\n   |               help: consider borrowing here: `&max`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpw4saasoh.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpshuwy_3l.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5veg2v_5.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n113 |         if \n114 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmp5veg2v_5.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmp5veg2v_5.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp2j63u93k.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n113 |         if \n114 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmp2j63u93k.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmp2j63u93k.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpmcb81wtz.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n113 |         if \n114 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpmcb81wtz.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmpmcb81wtz.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| *x == max).unwrap();\n\
    \    while min_idx != max_idx {\n        result.push(lst.swap_remove(min_idx).unwrap());\n\
    \        min_idx = lst.iter().position(|x| *x == min).unwrap();\n        max_idx\
    \ = lst.iter().position(|x| *x == max).unwrap();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpllybvf9e.rs:12:53\n   |\n\
    12 |     let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |     let\
    \ mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpllybvf9e.rs:13:53\n   |\n13 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n13 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0599]: no\
    \ method named `unwrap` found for type `isize` in the current scope\n  --> /tmp/tmpllybvf9e.rs:15:46\n\
    \   |\n15 |         result.push(lst.swap_remove(min_idx).unwrap());\n   |    \
    \                                          ^^^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpllybvf9e.rs:16:49\n   |\n16 |\
    \         min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |       \
    \                                          ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n16 |         min_idx = lst.iter().position(|x|\
    \ *x == *min).unwrap();\n   |                                                \
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpllybvf9e.rs:17:49\n   |\n\
    17 |         max_idx = lst.iter().position(|x| *x == max).unwrap();\n   |    \
    \                                             ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |         max_idx = lst.iter().position(|x|\
    \ *x == *max).unwrap();\n   |                                                \
    \ +\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc -"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst[0];\n\
    \    let mut max = lst[0];\n    for x in lst {\n        if x < min {\n       \
    \     min = x;\n        }\n        if x > max {\n            max = x;\n      \
    \  }\n    }\n    let mut i = 1;\n    while i < lst.len() {\n        if lst[i]\
    \ < min {\n            result.push(min);\n            i += 1;\n        } else\
    \ {\n            result.push(max);\n            i += 1;\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmps0_rdvum.rs:21:15\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for x in lst {\n    |  \
    \            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    21  |     while i < lst.len() {\n    |               ^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n12  |     for x in &lst\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.clone();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for v in lst.iter() {\n        if v < min_value\
    \ {\n            min_value = v;\n        }\n        if v > max_value {\n     \
    \       max_value = v;\n        }\n    }\n    let mut new_lst = vec![];\n    for\
    \ v in lst.iter() {\n        if v < min_value {\n            new_lst.push(v);\n\
    \        }\n        if v > max_value {\n            new_lst.push(v);\n       \
    \ }\n    }\n    new_lst.sort();\n    new_lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq67zxf33.rs:13:16\n   |\n\
    13 |         if v < min_value {\n   |                ^^^^^^^^^\n   |         \
    \       |\n   |                expected `&isize`, found `isize`\n   |        \
    \        help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq67zxf33.rs:14:25\n   |\n10 |     let mut min_value = lst[0];\n\
    \   |                         ------ expected due to this value\n...\n14 |   \
    \          min_value = v;\n   |                         ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |        \
    \     min_value = *v;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq67zxf33.rs:16:16\n   |\n16 |         if v > max_value\
    \ {\n   |                ^^^^^^^^^\n   |                |\n   |              \
    \  expected `&isize`, found `isize`\n   |                help: consider borrowing\
    \ here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq67zxf33.rs:17:25\n\
    \   |\n11 |     let mut max_value = lst[0];\n   |                         ------\
    \ expected due to this value\n...\n17 |             max_value = v;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n17 |             max_value = *v;\n   |     \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq67zxf33.rs:22:16\n\
    \   |\n22 |         if v < min_value {\n   |                ^^^^^^^^^\n   |  \
    \              |\n   |                expected `&isize`, found `isize`\n   | \
    \               help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq67zxf33.rs:25:16\n   |\n25 |         if v > max_value\
    \ {\n   |                ^^^^^^^^^\n   |                |\n   |              \
    \  expected `&isize`, found `isize`\n   |                help: consider borrowing\
    \ here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq67zxf33.rs:30:5\n\
    \   |\n8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpnxfs30v2.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n113 |         if \n114 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpnxfs30v2.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmpnxfs30v2.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp0q074h33.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for v in lst {\n        if v < min_value\
    \ {\n            min_value = v;\n        }\n        if v > max_value {\n     \
    \       max_value = v;\n        }\n    }\n    for v in lst {\n        if v ==\
    \ min_value {\n            res.push(v);\n        } else {\n            res.push(v);\n\
    \            res.push(max_value);\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp1n2epypy.rs:20:14\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for v in lst {\n    |  \
    \            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for v in lst {\n    |              ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n12  |     for v in &lst {\n    |  \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpbacqwcsg.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut min = lst[0];\n    let\
    \ mut max = lst[0];\n    for el in lst {\n        if el < min {\n            min\
    \ = el;\n        }\n        if el > max {\n            max = el;\n        }\n\
    \    }\n    let mut min_idx = 1;\n    let mut max_idx = 1;\n    let mut min_el\
    \ = min;\n    let mut max_el = max;\n    while min_idx < lst.len() {\n       \
    \ if lst[min_idx] < min_el {\n            result.push(min_el);\n            min_idx\
    \ += 1;\n            min_el = min;\n        }\n        if lst[max_idx] > max_el\
    \ {\n            result.push(max_el);\n            max_idx += 1;\n           \
    \ max_el = max;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmp57gozoth.rs:24:21\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for el in lst {\n    | \
    \              --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    24  |     while min_idx < lst.len() {\n    |                     ^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of\
    \ the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |\
    \     for el in &lst {\n    |               +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = std::i32::MAX;\n\
    \    let mut max_value = std::i32::MIN;\n    for el in lst {\n        if el <\
    \ min_value {\n            min_value = el;\n        }\n        if el > max_value\
    \ {\n            max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in l\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpn9nsox3c.rs:103:1\n    |\n\
    103 | }\n    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn9nsox3c.rs:13:17\n\
    \   |\n13 |         if el < min_value {\n   |                 ^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n13 |         if el < min_value.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn9nsox3c.rs:14:25\n   |\n10 |     let mut min_value = std::i32::MAX;\n\
    \   |                         ------------- expected due to this value\n...\n\
    14 |             min_value = el;\n   |                         ^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn9nsox3c.rs:16:17\n\
    \   |\n16 |         if el > max_value {\n   |                 ^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         if el > max_value.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn9nsox3c.rs:17:25\n   |\n11 |     let mut max_value = std::i32::MIN;\n\
    \   |                         ------------- expected due to this value\n...\n\
    17 |             max_value = el;\n   |                         ^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn9nsox3c.rs:23:17\n\
    \   |\n23 |         if el < min_value {\n   |                 ^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |         if el < min_value.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn9nsox3c.rs:24:25\n   |\n20 |     let mut min_value = min_value;\n\
    \   |                         --------- expected due to this value\n...\n24 |\
    \             min_value = el;\n   |                         ^^ expected `i32`,\
    \ found `isize`\n\nerror[E03"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for el in lst.iter() {\n        if el <\
    \ min_value {\n            min_value = el;\n        }\n        if el > max_value\
    \ {\n            max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst.iter() {\n        if el\
    \ < min_value {\n            min_value = el;\n        }\n        if el > max_value\
    \ {\n            max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst.iter() {\n        if el\
    \ < min_value {\n            min_value = el;\n        }\n        if el > max_value\
    \ {\n            max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst.iter() {\n        if el\
    \ < min_value {\n            min_value = el;\n        }\n        if el > max_value\
    \ {\n            max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst.iter() {\n        if el\
    \ < min_value {\n            min_value = el;\n        }\n        if el > max_value\
    \ {\n            max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst.iter() {\n        if el\
    \ < min_value {\n            min_value = el;\n        }\n        if el > max_value\
    \ {\n            max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst.iter() {\n        if el\
    \ < min_value {\n            min_value = el;\n        }\n        if el > max_value\
    \ {\n            max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst.iter() {\n        if el\
    \ < min_value {\n            min_value = el;\n        }\n        if el > max_value\
    \ {\n            max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst.iter() {\n        if el\
    \ < min_value {\n            min_value = el;\n        }\n        if el > max_value\
    \ {\n            max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for \n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n   --> /tmp/tmpyurbs8em.rs:103:1\n\
    \    |\n103 | }\n    | ^ expected pattern\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyurbs8em.rs:13:17\n   |\n13 |         if el < min_value {\n   |\
    \                 ^^^^^^^^^\n   |                 |\n   |                 expected\
    \ `&isize`, found `isize`\n   |                 help: consider borrowing here:\
    \ `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyurbs8em.rs:14:25\n\
    \   |\n10 |     let mut min_value = lst[0];\n   |                         ------\
    \ expected due to this value\n...\n14 |             min_value = el;\n   |    \
    \                     ^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n14 |             min_value = *el;\n   |    \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyurbs8em.rs:16:17\n\
    \   |\n16 |         if el > max_value {\n   |                 ^^^^^^^^^\n   |\
    \                 |\n   |                 expected `&isize`, found `isize`\n \
    \  |                 help: consider borrowing here: `&max_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyurbs8em.rs:17:25\n   |\n11 |     let mut max_value\
    \ = lst[0];\n   |                         ------ expected due to this value\n\
    ...\n17 |             max_value = el;\n   |                         ^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |             max_value = *el;\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyurbs8em.rs:23:17\n   |\n23 |         if el\
    \ < min_value {\n   |                 ^^^^^^^^^\n   |                 |\n   |\
    \                 expected `&isize`, found `isize`\n   |                 help:\
    \ consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyurbs8em.rs:24:25\n   |\n20 |     let mut min_value = min_value;\n \
    \  |                         --------- expected due to this value\n...\n24 | \
    \            min_value = el;\n   |                         ^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |  \
    \           "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpac24um5v.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpwxh_rien.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpkd4e_h8t.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    let mut min_val = lst[0];\n   \
    \ let mut max_val = lst[0];\n    for v in lst {\n        if v < min_val {\n  \
    \          min_val = v;\n        }\n        if v > max_val {\n            max_val\
    \ = v;\n        }\n    }\n    for v in lst {\n        if v == min_val {\n    \
    \        res.push(v);\n        } else {\n            if v == max_val {\n     \
    \           res.push(v);\n            } else {\n                res.push(min_val);\n\
    \                res.push(v);\n                res.push(max_val);\n          \
    \  }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpc1snyk6_.rs:20:14\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for v in lst {\n    |  \
    \            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for v in lst {\n    |              ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n12  |     for v in &lst {\n    |  \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp8fmkw6h7.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmptxusbjm2.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for x in lst.iter() {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    for x in lst.iter() {\n        if\
    \ x == min_value {\n            res.push(x);\n        }\n        if x == max_value\
    \ {\n            res.push(x - 1);\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp59t622o1.rs:13:16\n   |\n\
    13 |         if x < min_value {\n   |                ^^^^^^^^^\n   |         \
    \       |\n   |                expected `&isize`, found `isize`\n   |        \
    \        help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp59t622o1.rs:14:25\n   |\n10 |     let mut min_value = lst[0];\n\
    \   |                         ------ expected due to this value\n...\n14 |   \
    \          min_value = x;\n   |                         ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |        \
    \     min_value = *x;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp59t622o1.rs:16:16\n   |\n16 |         if x > max_value\
    \ {\n   |                ^^^^^^^^^\n   |                |\n   |              \
    \  expected `&isize`, found `isize`\n   |                help: consider borrowing\
    \ here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp59t622o1.rs:17:25\n\
    \   |\n11 |     let mut max_value = lst[0];\n   |                         ------\
    \ expected due to this value\n...\n17 |             max_value = x;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n17 |             max_value = *x;\n   |     \
    \                    +\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmp59t622o1.rs:21:14\n   |\n21 |         if x == min_value {\n   |\
    \              ^^ no implementation for `&isize == isize`\n   |\n   = help: the\
    \ trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmp59t622o1.rs:24:14\n   |\n\
    24 |         if x == max_value {\n   |              ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = Vec::new();\n    let mut min_value =\
    \ lst[0];\n    let mut max_value = lst[0];\n    for el in lst {\n        if el\
    \ < min_value {\n            min_value = el;\n        }\n        if el > max_value\
    \ {\n            max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp23z0b6l4.rs:117:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    102 |     for el in lst {\n    |                   - this delimiter might not\
    \ be properly closed...\n103 |         if el\n104 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n117 | }\n    |   ^\n\nerror: expected\
    \ `{`, found `}`\n   --> /tmp/tmp23z0b6l4.rs:104:1\n    |\n103 |         if el\n\
    \    |         -- this `if` expression has a condition, but no block\n104 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp23z0b6l4.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| x == max).unwrap();\n\
    \    let mut i = min_idx;\n    while i != max_idx {\n        result.push(lst[i]);\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpzhm3tpi4.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpefhw9jmc.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpu15gy9js.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    let mut min_val = lst[0];\n   \
    \ let mut max_val = lst[0];\n    for el in lst {\n        if el < min_val {\n\
    \            min_val = el;\n        }\n        if el > max_val {\n           \
    \ max_val = el;\n        }\n    }\n    let mut min_idx = 1;\n    let mut max_idx\
    \ = 1;\n    while min_idx < lst.len() {\n        if lst[min_idx] > max_val {\n\
    \            res[min_idx] = max_val;\n            max_idx++;\n        } else {\n\
    \            res[min_idx] = min_val;\n            min_idx++;\n        }\n    }\n\
    \    while max_idx < lst.len() {\n        if lst[max_idx] < min_val {\n      \
    \      res[max_idx] = min_val;\n            min_idx++;\n        } else {\n   \
    \         res[max_idx] = max_val;\n            max_idx++;\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpf8bhsyrh.rs:25:20\n\
    \   |\n25 |             max_idx++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n25 |             { let tmp =\
    \ max_idx; max_idx += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    25 -             max_idx++;\n25 +             max_idx += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmpf8bhsyrh.rs:28:20\n   |\n28\
    \ |             min_idx++;\n   |                    ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n28 |             { let tmp = min_idx; min_idx\
    \ += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n28\
    \ -             min_idx++;\n28 +             min_idx += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmpf8bhsyrh.rs:34:20\n   |\n34\
    \ |             min_idx++;\n   |                    ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n34 |             { let tmp = min_idx; min_idx\
    \ += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n34\
    \ -             min_idx++;\n34 +             min_idx += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmpf8bhsyrh.rs:37:20\n   |\n37\
    \ |             max_idx++;\n   |                    ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n37 |             { let tmp = max_idx; max_idx\
    \ += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n37\
    \ -             max_idx++;\n37 +             max_idx += 1;\n   | \n\nerror: aborting\
    \ due to 4 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp8xhxvrg9.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for v in lst.iter() {\n        if v < min_value\
    \ {\n            min_value = v;\n        }\n        if v > max_value {\n     \
    \       max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_value = v;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for v in lst.iter() {\n        if v <\
    \ min_value {\n            min_value = v;\n        }\n        if v > max_value\
    \ {\n            max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpj63shwhj.rs:121:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    102 |     for v in lst.iter() {\n    |                         - unclosed delimiter\n\
    ...\n106 |         if v > max_value {\n    |                          - this delimiter\
    \ might not be properly closed...\n107 |             max_\n108 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n121 | }\n    |   ^\n\n\
    error[E0425]: cannot find value `max_` in this scope\n   --> /tmp/tmpj63shwhj.rs:107:13\n\
    \    |\n107 |             max_\n    |             ^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpj63shwhj.rs:13:16\n   |\n13 |\
    \         if v < min_value {\n   |                ^^^^^^^^^\n   |            \
    \    |\n   |                expected `&isize`, found `isize`\n   |           \
    \     help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj63shwhj.rs:14:25\n   |\n10 |     let mut min_value = lst[0];\n\
    \   |                         ------ expected due to this value\n...\n14 |   \
    \          min_value = v;\n   |                         ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |        \
    \     min_value = *v;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj63shwhj.rs:16:16\n   |\n16 |         if v > max_value\
    \ {\n   |                ^^^^^^^^^\n   |                |\n   |              \
    \  expected `&isize`, found `isize`\n   |                help: consider borrowing\
    \ here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj63shwhj.rs:17:25\n\
    \   |\n11 |     let mut max_value = lst[0];\n   |                         ------\
    \ expected due to this value\n...\n17 |             max_value = v;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n17 |             max_value = *v;\n   |     \
    \                    +\n\nerror[E0308]: mismatched types\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpsocgzzgi.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for x in lst.iter() {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_idx = 1;\n    let mut\
    \ max_idx = 1;\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for x in lst.iter() {\n        if x < min_value {\n            min_value\
    \ = x;\n            min_idx = x;\n        }\n        if x > max_value {\n    \
    \        max_value = x;\n            max_idx = x;\n        }\n    }\n    while\
    \ min_idx < max_idx {\n        let tmp = min_value;\n        min_value = max_value;\n\
    \        max_value = tmp;\n        min_idx += 1;\n        max_idx += 1;\n    }\n\
    \    result.push(min_value);\n    for x in lst.iter().rev() {\n        if x <\
    \ min_value {\n            result.push(x);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp151n4pyj.rs:13:16\n   |\n\
    13 |         if x < min_value {\n   |                ^^^^^^^^^\n   |         \
    \       |\n   |                expected `&isize`, found `isize`\n   |        \
    \        help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp151n4pyj.rs:14:25\n   |\n10 |     let mut min_value = lst[0];\n\
    \   |                         ------ expected due to this value\n...\n14 |   \
    \          min_value = x;\n   |                         ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |        \
    \     min_value = *x;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp151n4pyj.rs:16:16\n   |\n16 |         if x > max_value\
    \ {\n   |                ^^^^^^^^^\n   |                |\n   |              \
    \  expected `&isize`, found `isize`\n   |                help: consider borrowing\
    \ here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp151n4pyj.rs:17:25\n\
    \   |\n11 |     let mut max_value = lst[0];\n   |                         ------\
    \ expected due to this value\n...\n17 |             max_value = x;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n17 |             max_value = *x;\n   |     \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp151n4pyj.rs:25:16\n\
    \   |\n25 |         if x < min_value {\n   |                ^^^^^^^^^\n   |  \
    \              |\n   |                expected `&isize`, found `isize`\n   | \
    \               help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp151n4pyj.rs:26:25\n   |\n22 |     let mut min_value = min_value;\n\
    \   |                         --------- expected due to this value\n...\n26 |\
    \             min_value = x;\n   |                         ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n26 |  \
    \           min_value = *x;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp151n4pyj.rs:27:23\n   |\n20 |     let mu"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| *x == max).unwrap();\n\
    \    let mut min_idx2 = lst.iter().position(|x| *x == min).unwrap();\n    let\
    \ mut max_idx2 = lst.iter().position(|x| *x == max).unwrap();\n    let mut min_idx3\
    \ = lst.iter().position(|x| *x == min).unwrap();\n    let mut max_idx3 = lst.iter().position(|x|\
    \ *x == max).unwrap();\n    let mut min_idx4 = lst.iter().position(|x| *x == min).unwrap();\n\
    \    let mut max_idx4 = lst.iter().position(|x| *x == max).unwrap();\n    let\
    \ mut min_idx5 = lst.iter().position(|x| *x == min).unwrap();\n    let mut max_idx5\
    \ = lst.iter().position(|x| *x == max).unwrap();\n    let mut min_idx6 = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx6 = lst.iter().position(|x| *x == max).unwrap();\n\
    \    let mut min_idx7 = lst.iter().position(|x| *x == min).unwrap();\n    let\
    \ mut max_idx7 = lst.iter().position(|x| *x == max).unwrap();\n    let mut min_idx8\
    \ = lst.iter().position(|x| *x == min).unwrap();\n    let mut max_idx8 = lst.iter().position(|x|\
    \ *x == max).unwrap();\n    let mut min_idx9 = lst.iter().position(|x| *x == min).unwrap();\n\
    \    let mut max_idx9 = lst.iter().position(|x| *x == max).unwrap();\n    let\
    \ mut min_idx10 = lst.iter().position(|x| *x == min).unwrap();\n    let mut max_idx10\
    \ = lst.iter().position(|x| *x == max).unwrap();\n    let mut min_idx11 = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx11 = lst.iter().position(|x| *x ==\
    \ max).unwrap();\n    let mut min_idx12 = lst.iter().position(|x| *x == min\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpegioqtft.rs:35:1\n   |\n35 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpegioqtft.rs:34:44\n   |\n8  | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                                     -\
    \ closing delimiter possibly meant for this\n...\n34 |     let mut min_idx12 =\
    \ lst.iter().position(|x| *x == min\n   |                                    \
    \        ^ unclosed delimiter\n35 | }\n   | ^ mismatched closing delimiter\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpegioqtft.rs:12:53\n   |\n12 |  \
    \   let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |     \
    \                                                ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n12 |     let mut min_idx\
    \ = lst.iter().position(|x| *x == *min).unwrap();\n   |                      \
    \                               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpegioqtft.rs:13:53\n\
    \   |\n13 |     let mut max_idx = lst.iter().position(|x| *x == max).unwrap();\n\
    \   |                                                     ^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |  \
    \   let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n   |    \
    \                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpegioqtft.rs:14:54\n   |\n14 |     let mut min_idx2 = lst.iter().position(|x|\
    \ *x == min).unwrap();\n   |                                                 \
    \     ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n14 |     let mut min_idx2 = lst.iter().position(|x| *x ==\
    \ *min).unwrap();\n   |                                                      +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpegioqtft.rs:15:54\n   |\n15 |\
    \     let mut max_idx2 = lst.iter().position(|x| *x == max).unwrap();\n   |  \
    \                                                   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp4tszgln7.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpdjrd9xb4.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| x == max).unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp0arva559.rs:54:1\n   |\n54\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp0arva559.rs:53:31\n\
    \   |\n53 |     let mut max_idx = max_idx.\n   |                             \
    \  ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmp0arva559.rs:14:31\n\
    \   |\n14 |     let mut min_idx = min_idx.unwrap();\n   |                    \
    \           ^^^^^^ method not found in `usize`\n\nerror[E0599]: no method named\
    \ `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmp0arva559.rs:15:31\n\
    \   |\n15 |     let mut max_idx = max_idx.unwrap();\n   |                    \
    \           ^^^^^^ method not found in `usize`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp0arva559.rs:8:42\n  |\n8 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n  |    -----------------                     ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = std::i32::MAX;\n\
    \    let mut max_value = std::i32::MIN;\n    let mut min_idx = -1;\n    let mut\
    \ max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let\
    \ mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n  \
    \  let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n\
    \    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n\
    \    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n\
    \    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n\
    \    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n\
    \    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n\
    \    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n\
    \    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n\
    \    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n\
    \    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n\
    \    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n\
    \    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n\
    \    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n\
    \    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n\
    \    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n\
    \    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n\
    \    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n\
    \    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n\
    \    let mut max_idx = -1;\n    let mut min_idx = -1;\n    let mut max_idx = -1;\n\
    \    let mut min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_idx = -1;\n\
    \    let mut max_idx = -1;\n    let mut min_idx = \n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp_yrp8ow3.rs:81:1\n\
    \   |\n81 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmppbju_180.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| *x == max).unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.unwrap();\n\
    \    let mut min_idx = min_idx.unwrap();\n    let mut max_idx = max_idx.\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpgabha5xu.rs:54:1\n   |\n54\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpgabha5xu.rs:53:31\n\
    \   |\n53 |     let mut max_idx = max_idx.\n   |                             \
    \  ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgabha5xu.rs:12:53\n   |\n12 |     let mut min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n12 |     let mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n\
    \   |                                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgabha5xu.rs:13:53\n   |\n13 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n13 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0599]: no\
    \ method named `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmpgabha5xu.rs:14:31\n\
    \   |\n14 |     let mut min_idx = min_idx.unwrap();\n   |                    \
    \           ^^^^^^ method not found in `usize`\n\nerror[E0599]: no method named\
    \ `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmpgabha5xu.rs:15:31\n\
    \   |\n15 |     let mut max_idx = max_idx.unwrap();\n   |                    \
    \           ^^^^^^ method not found in `usize`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpgabha5xu.rs:8:42\n  |\n8 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n  |    -----------------                     ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 7 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599."
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    let mut min = lst[0];\n    let\
    \ mut max = lst[0];\n    for el in lst {\n        if el < min {\n            min\
    \ = el;\n        }\n        if el > max {\n            max = el;\n        }\n\
    \    }\n    for el in lst {\n        if el < min {\n            res.push(min);\n\
    \            min = el;\n        } else if el > max {\n            res.push(max);\n\
    \            max = el;\n        } else {\n            res.push(el);\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpwfont_6u.rs:20:15\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for el in lst {\n    | \
    \              --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for el in lst {\n    |               ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n12  |     for el in &lst {\n    | \
    \              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpu_4p3h4m.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst[0];\n\
    \    let mut max = lst[0];\n    for el in lst {\n        if el < min {\n     \
    \       min = el;\n        }\n        if el > max {\n            max = el;\n \
    \       }\n    }\n    for el in lst {\n        if el < min {\n            result.push(min);\n\
    \            min = el;\n        }\n        if el > max {\n            result.push(max);\n\
    \            max = el;\n        }\n    }\n    result.push(min);\n    result.push(max);\n\
    \    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp623wwr7h.rs:20:15\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for el in lst {\n    | \
    \              --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for el in lst {\n    |               ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n12  |     for el in &lst {\n    | \
    \              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if \n}\n\nfn\
    \ main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmphab6vmgh.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for x in lst {\n    |                  - this delimiter might not be\
    \ properly closed...\n113 |         if \n114 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmphab6vmgh.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmphab6vmgh.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6wnfv8fk.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n113 |         if \n114 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmp6wnfv8fk.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmp6wnfv8fk.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpdkrpj4xn.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut mid = lst.iter().skip(1).take(2).min().unwrap();\n\
    \    while min < max {\n        result.push(mid);\n        mid = lst.iter().skip(1).take(2).min().unwrap();\n\
    \        min = mid;\n        max = mid;\n    }\n    result.push(mid);\n    result\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvi6w4_ll.rs:20:5\n   |\n\
    8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n20 |     result\n   |     ^^^^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpofbclqac.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpl2tts_s9.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpl5w3ovdv.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| *x == max).unwrap();\n\
    \    let mut mid = min_idx;\n    while mid < max_idx {\n        res.push(lst.swap_remove(mid));\n\
    \        mid += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp87zu7z3.rs:12:53\n   |\n\
    12 |     let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |     let\
    \ mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp87zu7z3.rs:13:53\n   |\n13 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n13 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpwtwznpdg.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for v in lst.iter() {\n        if v < min_value\
    \ {\n            min_value = v;\n        }\n        if v > max_value {\n     \
    \       max_value = v;\n        }\n    }\n    for v in lst.iter() {\n        if\
    \ v == min_value {\n            result.push(v);\n        }\n        if v == max_value\
    \ {\n            result.push(v);\n        }\n    }\n    for v in lst.iter() {\n\
    \        if v == max_value {\n            result.push(v);\n        }\n    }\n\
    \    for v in lst.iter() {\n        if v == min_value {\n            result.push(v);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr0mp_hor.rs:13:16\n   |\n\
    13 |         if v < min_value {\n   |                ^^^^^^^^^\n   |         \
    \       |\n   |                expected `&isize`, found `isize`\n   |        \
    \        help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr0mp_hor.rs:14:25\n   |\n10 |     let mut min_value = lst[0];\n\
    \   |                         ------ expected due to this value\n...\n14 |   \
    \          min_value = v;\n   |                         ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |        \
    \     min_value = *v;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr0mp_hor.rs:16:16\n   |\n16 |         if v > max_value\
    \ {\n   |                ^^^^^^^^^\n   |                |\n   |              \
    \  expected `&isize`, found `isize`\n   |                help: consider borrowing\
    \ here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr0mp_hor.rs:17:25\n\
    \   |\n11 |     let mut max_value = lst[0];\n   |                         ------\
    \ expected due to this value\n...\n17 |             max_value = v;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n17 |             max_value = *v;\n   |     \
    \                    +\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmpr0mp_hor.rs:21:14\n   |\n21 |         if v == min_value {\n   |\
    \              ^^ no implementation for `&isize == isize`\n   |\n   = help: the\
    \ trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmpr0mp_hor.rs:24:14\n   |\n\
    24 |         if v == max_value {\n   |              ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value == min_value {\n            sorted_list.push(value);\n       \
    \ }\n        if value == max_value {\n            sorted_list.push(value);\n \
    \       }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpjz_dy5jj.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n12  |     for value in &lst\
    \ {\n    |                  +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmppc08lysj.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpfmr_yawx.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            sorted_list.push(value);\n        }\n\
    \        if value > max_value {\n            sorted_list.push(value);\n      \
    \  }\n    }\n    for value in lst {\n        if value < min_value {\n        \
    \    sorted_list.push(value);\n        }\n        if value > max_value {\n   \
    \         sorted_list.push(value);\n        }\n    }\n    for value in lst {\n\
    \        if value < min_value {\n            sorted_list.push(value);\n      \
    \  }\n        if value > max_value {\n            sorted_list.push(value);\n \
    \       }\n    }\n    for value in lst {\n        if value < min_value {\n   \
    \         sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_value {\n            sorted_list.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value < min_value {\n  \
    \          sorted_list.push(value);\n        }\n        if value > max_value {\n\
    \            sorted_list.push(value);\n        }\n    }\n    for value in lst\
    \ {\n        if value < min_value {\n            sorted_list.push(value);\n  \
    \      }\n        if value > max_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpi12nx0a8.rs:134:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    116 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n121 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n134 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpi12nx0a8.rs:121:1\n    |\n120 |         if value > max_\n\
    \    |         -- this `if` expression has a condition, but no block\n121 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpi12nx0a8.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpehllb234.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpfqi4oks5.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp_kj70z6s.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| *x == max).unwrap();\n\
    \    let mut min_idx2 = lst.iter().position(|x| *x == min).unwrap();\n    let\
    \ mut max_idx2 = lst.iter().position(|x| *x == max).unwrap();\n    let mut min_idx3\
    \ = lst.iter().position(|x| *x == min).unwrap();\n    let mut max_idx3 = lst.iter().position(|x|\
    \ *x == max).unwrap();\n    let mut min_idx4 = lst.iter().position(|x| *x == min).unwrap();\n\
    \    let mut max_idx4 = lst.iter().position(|x| *x == max).unwrap();\n    let\
    \ mut min_idx5 = lst.iter().position(|x| *x == min).unwrap();\n    let mut max_idx5\
    \ = lst.iter().position(|x| *x == max).unwrap();\n    let mut min_idx6 = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx6 = lst.iter().position(|x| *x == max).unwrap();\n\
    \    let mut min_idx7 = lst.iter().position(|x| *x == min).unwrap();\n    let\
    \ mut max_idx7 = lst.iter().position(|x| *x == max).unwrap();\n    let mut min_idx8\
    \ = lst.iter().position(|x| *x == min).unwrap();\n    let mut max_idx8 = lst.iter().position(|x|\
    \ *x == max).unwrap();\n    let mut min_idx9 = lst.iter().position(|x| *x == min).unwrap();\n\
    \    let mut max_idx9 = lst.iter().position(|x| *x == max).unwrap();\n    let\
    \ mut min_idx10 = lst.iter().position(|x| *x == min).unwrap();\n    let mut max_idx10\
    \ = lst.iter().position(|x| *x == max).unwrap();\n    let mut min_idx11 = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx11 = lst.iter().position(|x| *x ==\
    \ max).unwrap();\n    let mut min_idx12 = lst.iter().position(|x| *x == min\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp_j2fstur.rs:35:1\n   |\n35 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp_j2fstur.rs:34:44\n   |\n8  | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                                     -\
    \ closing delimiter possibly meant for this\n...\n34 |     let mut min_idx12 =\
    \ lst.iter().position(|x| *x == min\n   |                                    \
    \        ^ unclosed delimiter\n35 | }\n   | ^ mismatched closing delimiter\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_j2fstur.rs:12:53\n   |\n12 |  \
    \   let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |     \
    \                                                ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n12 |     let mut min_idx\
    \ = lst.iter().position(|x| *x == *min).unwrap();\n   |                      \
    \                               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_j2fstur.rs:13:53\n\
    \   |\n13 |     let mut max_idx = lst.iter().position(|x| *x == max).unwrap();\n\
    \   |                                                     ^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |  \
    \   let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n   |    \
    \                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_j2fstur.rs:14:54\n   |\n14 |     let mut min_idx2 = lst.iter().position(|x|\
    \ *x == min).unwrap();\n   |                                                 \
    \     ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n14 |     let mut min_idx2 = lst.iter().position(|x| *x ==\
    \ *min).unwrap();\n   |                                                      +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_j2fstur.rs:15:54\n   |\n15 |\
    \     let mut max_idx2 = lst.iter().position(|x| *x == max).unwrap();\n   |  \
    \                                                   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| x == max).unwrap();\n\
    \    let mut min_idx2 = lst.iter().position(|x| x == min).unwrap();\n    let mut\
    \ max_idx2 = lst.iter().position(|x| x == max).unwrap();\n\n    while min_idx\
    \ != max_idx {\n        result.push(min);\n        min = lst.iter().nth(min_idx).unwrap();\n\
    \        min_idx = lst.iter().position(|x| x == min).unwrap();\n    }\n\n    while\
    \ min_idx2 != max_idx2 {\n        result.push(max);\n        max = lst.iter().nth(max_idx2).unwrap();\n\
    \        max_idx2 = lst.iter().position(|x| x == max).unwrap();\n    }\n\n   \
    \ result.push(min);\n    result.push(max);\n    result\n}\n\nfn main() {\n   \
    \ let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5wfynrhr.rs:31:5\n   |\n\
    8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n31 |     result\n   |     ^^^^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            sorted_list.push(value);\n        }\n\
    \        if value > max_value {\n            sorted_list.push(value);\n      \
    \  }\n    }\n    for value in lst {\n        if value < max_value {\n        \
    \    sorted_list.push(value);\n        }\n    }\n    for value in lst {\n    \
    \    if value > min_value {\n            sorted_list.push(value);\n        }\n\
    \    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpj_evtvq2.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n12  |     for value in &lst\
    \ {\n    |                  +\n\nerror[E0382]: use of moved value: `lst`\n  -->\
    \ /tmp/tmpj_evtvq2.rs:28:18\n   |\n8  | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                      --- move occurs because `lst` has\
    \ type `Vec<isize>`, which does not implement the `Copy` trait\n...\n20 |    \
    \ for value in lst {\n   |                  --- `lst` moved due to this implicit\
    \ call to `.into_iter()`\n...\n28 |     for value in lst {\n   |             \
    \     ^^^ value used here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n20\
    \ |     for value in &lst {\n   |                  +\n\nerror[E0382]: use of moved\
    \ value: `lst`\n  --> /tmp/tmpj_evtvq2.rs:33:18\n   |\n8  | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- move occurs because\
    \ `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n\
    28 |     for value in lst {\n   |                  --- `lst` moved due to this\
    \ implicit call to `.into_iter()`\n...\n33 |     for value in lst {\n   |    \
    \              ^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \   |\n28 |     for value in &lst {\n   |                  +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpuvlqubm5.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpsftbpyut.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.clone();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| x == max).unwrap();\n\
    \    while min_idx < max_idx {\n        lst[min_idx] = lst[max_idx];\n       \
    \ min_idx += 1;\n        max_idx -= 1;\n    }\n    lst\n}\n\nfn main() {\n   \
    \ let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpf_xl60a7.rs:24:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    for x in lst {\n        if\
    \ x < min {\n            min = x;\n        }\n        if x > max {\n         \
    \   max = x;\n        }\n    }\n    for x in lst {\n        if x == min {\n  \
    \          res.push(min);\n        }\n        if x == max {\n            res.push(max);\n\
    \        }\n        res.push(x);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkew54s2b.rs:13:16\n   |\n\
    13 |         if x < min {\n   |                ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n13 |         if x < *min\
    \ {\n   |                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkew54s2b.rs:14:19\n\
    \   |\n10 |     let mut min = lst.iter().min().unwrap();\n   |               \
    \    ------------------------- expected due to this value\n...\n14 |         \
    \    min = x;\n   |                   ^\n   |                   |\n   |      \
    \             expected `&isize`, found `isize`\n   |                   help: consider\
    \ borrowing here: `&x`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkew54s2b.rs:16:16\n\
    \   |\n16 |         if x > max {\n   |                ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |        \
    \ if x > *max {\n   |                +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkew54s2b.rs:17:19\n   |\n11 |     let mut max = lst.iter().max().unwrap();\n\
    \   |                   ------------------------- expected due to this value\n\
    ...\n17 |             max = x;\n   |                   ^\n   |               \
    \    |\n   |                   expected `&isize`, found `isize`\n   |        \
    \           help: consider borrowing here: `&x`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkew54s2b.rs:21:17\n   |\n21 |         if x == min {\n   |     \
    \            ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n21 |         if x == *min {\n   |                 +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkew54s2b.rs:24:17\n   |\n24 |         if x ==\
    \ max {\n   |                 ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n24 |         if x == *max {\n   | \
    \                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkew54s2b.rs:27:18\n\
    \   |\n27 |         res.push(x);\n   |                  ^\n   |              \
    \    |\n   |                  expected `&isize`, found `isize`\n   |         \
    \         help: consider borrowing here: `&x`\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8drxkh90.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n113 |         if \n114 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmp8drxkh90.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmp8drxkh90.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpwsg13tug.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp3hny_aop.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpxfc59g1x.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            result.push(value);\n        }\n  \
    \      if value > max_value {\n            result.push(value);\n        }\n  \
    \  }\n    for value in lst {\n        if value < max_value {\n            result.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value > min_value {\n  \
    \          result.push(value);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpp4t8uozy.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n12  |     for value in &lst\
    \ {\n    |                  +\n\nerror[E0382]: use of moved value: `lst`\n  -->\
    \ /tmp/tmpp4t8uozy.rs:28:18\n   |\n8  | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                      --- move occurs because `lst` has\
    \ type `Vec<isize>`, which does not implement the `Copy` trait\n...\n20 |    \
    \ for value in lst {\n   |                  --- `lst` moved due to this implicit\
    \ call to `.into_iter()`\n...\n28 |     for value in lst {\n   |             \
    \     ^^^ value used here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n20\
    \ |     for value in &lst {\n   |                  +\n\nerror[E0382]: use of moved\
    \ value: `lst`\n  --> /tmp/tmpp4t8uozy.rs:33:18\n   |\n8  | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- move occurs because\
    \ `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n\
    28 |     for value in lst {\n   |                  --- `lst` moved due to this\
    \ implicit call to `.into_iter()`\n...\n33 |     for value in lst {\n   |    \
    \              ^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \   |\n28 |     for value in &lst {\n   |                  +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpdp922ap9.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpe0shc159.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for el in lst {\n        if el < min_val\
    \ {\n            min_val = el;\n        }\n        if el > max_val {\n       \
    \     max_val = el;\n        }\n    }\n    let mut min_idx = lst.iter().position(|x|\
    \ *x == min_val).unwrap();\n    let mut max_idx = lst.iter().position(|x| *x ==\
    \ max_val).unwrap();\n    while min_idx < max_idx {\n        let mut el = lst[min_idx];\n\
    \        lst[min_idx] = lst[max_idx];\n        lst[max_idx] = el;\n        min_idx\
    \ += 1;\n        max_idx -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk1_mu0ga.rs:13:17\n   |\n\
    13 |         if el < min_val {\n   |                 ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n13 |         if el < min_val.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk1_mu0ga.rs:14:23\n   |\n10 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n14\
    \ |             min_val = el;\n   |                       ^^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk1_mu0ga.rs:16:17\n\
    \   |\n16 |         if el > max_val {\n   |                 ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if el > max_val.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk1_mu0ga.rs:17:23\n   |\n11 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             max_val = el;\n   |                       ^^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk1_mu0ga.rs:20:53\n\
    \   |\n20 |     let mut min_idx = lst.iter().position(|x| *x == min_val).unwrap();\n\
    \   |                                                     ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |     let mut min_idx = lst.iter().position(|x|\
    \ *x == min_val.try_into().unwrap()).unwrap();\n   |                         \
    \                                   ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk1_mu0ga.rs:21:53\n   |\n21 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max_val).unwrap();\n   |                                             \
    \        ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can con"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value = sorted_list[0];\n\
    \    let mut max_value = sorted_list[0];\n    for value in sorted_list.iter()\
    \ {\n        if value < min_value {\n            min_value = value;\n        }\n\
    \        if value > max_value {\n            max_value = value;\n        }\n \
    \   }\n    let mut new_list = vec![];\n    for value in sorted_list.iter() {\n\
    \        if value < min_value {\n            new_list.push(value);\n        }\n\
    \        if value > max_value {\n            new_list.push(value);\n        }\n\
    \    }\n    for value in sorted_list.iter() {\n        if value < max_value {\n\
    \            new_list.push(value);\n        }\n    }\n    for value in sorted_list.iter()\
    \ {\n        if value > min_value {\n            new_list.push(value);\n     \
    \   }\n    }\n    new_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo293ewjb.rs:13:20\n   |\n\
    13 |         if value < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo293ewjb.rs:14:25\n   |\n10 |     let mut min_value\
    \ = sorted_list[0];\n   |                         -------------- expected due\
    \ to this value\n...\n14 |             min_value = value;\n   |              \
    \           ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n14 |             min_value = *value;\n   |               \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo293ewjb.rs:16:20\n\
    \   |\n16 |         if value > max_value {\n   |                    ^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&max_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo293ewjb.rs:17:25\n   |\n11 |     let mut max_value\
    \ = sorted_list[0];\n   |                         -------------- expected due\
    \ to this value\n...\n17 |             max_value = value;\n   |              \
    \           ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |             max_value = *value;\n   |               \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo293ewjb.rs:22:20\n\
    \   |\n22 |         if value < min_value {\n   |                    ^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo293ewjb.rs:25:20\n   |\n25 |         if value\
    \ > max_value {\n   |                    ^^^^^^^^^\n   |                    |\n\
    \   |                    expected `&isize`, found `isize`\n   |              \
    \      help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo293ewjb.rs:30:20\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if \n}\n\nfn\
    \ main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpy5lwlqyg.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for x in lst {\n    |                  - this delimiter might not be\
    \ properly closed...\n113 |         if \n114 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpy5lwlqyg.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmpy5lwlqyg.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut mid = lst.iter().skip(1).take(2).min().unwrap();\n\
    \    while min <= max {\n        if min < mid {\n            result.push(min);\n\
    \            min += 1;\n        } else {\n            result.push(mid);\n    \
    \        mid -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&isize`\n  --> /tmp/tmpe857fwwt.rs:16:13\n   |\n16 |             min += 1;\n\
    \   |             ---^^^^^\n   |             |\n   |             cannot use `+=`\
    \ on type `&isize`\n   |\nhelp: `+=` can be used on `isize`, you can dereference\
    \ `min`\n   |\n16 |             *min += 1;\n   |             +\n\nerror[E0368]:\
    \ binary assignment operation `-=` cannot be applied to type `&isize`\n  --> /tmp/tmpe857fwwt.rs:19:13\n\
    \   |\n19 |             mid -= 1;\n   |             ---^^^^^\n   |           \
    \  |\n   |             cannot use `-=` on type `&isize`\n   |\nhelp: `-=` can\
    \ be used on `isize`, you can dereference `mid`\n   |\n19 |             *mid -=\
    \ 1;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe857fwwt.rs:22:5\n\
    \   |\n8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n22 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0368.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    for x in lst {\n        if x ==\
    \ min_value {\n            result.push(max_value);\n            result.push(x);\n\
    \        } else {\n            result.push(x);\n            result.push(max_value);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmplf5d1h5u.rs:20:14\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for x in lst {\n    |  \
    \            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for x in lst {\n    |              ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n12  |     for x in &lst {\n    |  \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    let mut min_value = lst[0];\n \
    \   let mut max_value = lst[0];\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    for el in lst {\n        if el\
    \ == min_value {\n            res.push(el);\n        } else {\n            if\
    \ el == max_value {\n                res.push(el);\n            } else {\n   \
    \             res.push(min_value);\n                res.push(max_value);\n   \
    \             res.push(el);\n            }\n        }\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpyjo4wqz0.rs:20:15\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for el in lst {\n    | \
    \              --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for el in lst {\n    |               ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n12  |     for el in &lst {\n    | \
    \              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut mid = min;\n    let\
    \ mut i = 0;\n    while i < lst.len() {\n        if lst[i] < min {\n         \
    \   result.push(min);\n            min = mid;\n            i += 1;\n        }\
    \ else if lst[i] > max {\n            result.push(max);\n            max = mid;\n\
    \            i += 1;\n        } else {\n            result.push(lst[i]);\n   \
    \         mid += 1;\n            i += 1;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcsb97e_9.rs:15:21\n   |\n\
    15 |         if lst[i] < min {\n   |                     ^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |  \
    \       if lst[i] < *min {\n   |                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcsb97e_9.rs:19:28\n   |\n19 |         } else if lst[i]\
    \ > max {\n   |                            ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |         } else if lst[i]\
    \ > *max {\n   |                            +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcsb97e_9.rs:24:25\n   |\n24 |             result.push(lst[i]);\n\
    \   |                         ^^^^^^\n   |                         |\n   |   \
    \                      expected `&isize`, found `isize`\n   |                \
    \         help: consider borrowing here: `&lst[i]`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&isize`\n  --> /tmp/tmpcsb97e_9.rs:25:13\n\
    \   |\n25 |             mid += 1;\n   |             ---^^^^^\n   |           \
    \  |\n   |             cannot use `+=` on type `&isize`\n   |\nhelp: `+=` can\
    \ be used on `isize`, you can dereference `mid`\n   |\n25 |             *mid +=\
    \ 1;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcsb97e_9.rs:29:5\n\
    \   |\n8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n29 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0368.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpktvnqwcl.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst {\n        if \n}\n\nfn\
    \ main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp_ivlf98k.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for x in lst {\n    |                  - this delimiter might not be\
    \ properly closed...\n113 |         if \n114 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmp_ivlf98k.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmp_ivlf98k.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    for i in 0..(lst.len() - 1) {\n\
    \        if lst[i] < min_value {\n            sorted_list.push(min_value);\n \
    \           min_value = lst[i];\n        }\n        if lst[i] > max_value {\n\
    \            sorted_list.push(max_value);\n            max_value = lst[i];\n \
    \       }\n    }\n    sorted_list.push(min_value);\n    sorted_list.push(max_value);\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmpyk8fjdjk.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for el in lst {\n    | \
    \              --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for i in 0..(lst.len() - 1) {\n    |                  ^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of\
    \ the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |\
    \     for el in &lst {\n    |               +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp93r0nor2.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp8fny4lex.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp9d3kgyz7.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpz99bt48p.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n113 |         if \n114 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpz99bt48p.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmpz99bt48p.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut min = lst[0];\n    let\
    \ mut max = lst[0];\n    for x in lst {\n        if x < min {\n            min\
    \ = x;\n        }\n        if x > max {\n            max = x;\n        }\n   \
    \ }\n    for x in lst {\n        if x == min {\n            result.push(min);\n\
    \        }\n        if x == max {\n            result.push(max);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp6lsa5082.rs:20:14\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for x in lst {\n    |  \
    \            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for x in lst {\n    |              ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n12  |     for x in &lst {\n    |  \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    for value\
    \ in lst {\n        if value < min_value {\n            min_value = value;\n \
    \       }\n        if value > max_value {\n            max_value = value;\n  \
    \      }\n    }\n    for value in lst {\n        if value < min_value {\n    \
    \        min_value = value;\n        }\n        if value > max_value {\n     \
    \       max_value = value;\n        }\n    }\n    for value in lst {\n       \
    \ if value < min_value {\n            min_value = value;\n        }\n        if\
    \ value > max_value {\n            max_value = value;\n        }\n    }\n    for\
    \ value in lst {\n        if value < min_value {\n            min_value = value;\n\
    \        }\n        if value > max_value {\n            max_value = value;\n \
    \       }\n    }\n    for value in lst {\n        if value < min_value {\n   \
    \         min_value = value;\n        }\n        if value > max_value {\n    \
    \        max_value = value;\n        }\n    }\n    for value in lst {\n      \
    \  if value < min_value {\n            min_value = value;\n        }\n       \
    \ if value > max_value {\n            max_value = value;\n        }\n    }\n \
    \   for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            min_value = value;\n        }\n   \
    \     if value > max_value {\n            max_value = value;\n        }\n    }\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            min_value = value;\n        }\n   \
    \     if value > max_value {\n            max_value = value;\n        }\n    }\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpig67iryb.rs:144:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    126 |     for value in lst {\n    |                      - unclosed delimiter\n\
    ...\n130 |         if value > max_value {\n    |                             \
    \ - this delimiter might not be properly closed...\n131 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n144 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmpig67iryb.rs:126:5\n    |\n8   |   fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    |                                         \
    \   ---------- expected `Vec<isize>` because of return type\n...\n126 | /    \
    \ for value in lst {\n127 | |         if value < min_value {\n128 | |        \
    \     min_value = value;\n129 | |         }\n...   |\n143 | |     assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n144 | | }\n    | |__^ expected struct `Vec`, found `()`\n  \
    \  |\n    = note: expected struct `Vec<isize>`\n            found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    for el in lst {\n        if el\
    \ < min_value {\n            result.push(min_value);\n            min_value =\
    \ el;\n        }\n        if el > max_value {\n            result.push(max_value);\n\
    \            max_value = el;\n        }\n    }\n    result.push(min_value);\n\
    \    result.push(max_value);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp263yjk6q.rs:20:15\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for el in lst {\n    | \
    \              --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for el in lst {\n    |               ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n12  |     for el in &lst {\n    | \
    \              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdw1zs11p.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n113 |         if \n114 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpdw1zs11p.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdw1zs11p.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpki77dibb.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            result.push(value);\n        }\n  \
    \      if value > max_value {\n            result.push(value);\n        }\n  \
    \  }\n    for value in lst {\n        if value < max_value {\n            result.push(value);\n\
    \        }\n        if value > min_value {\n            result.push(value);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpg_oe1arq.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n12  |     for value in &lst\
    \ {\n    |                  +\n\nerror[E0382]: use of moved value: `lst`\n  -->\
    \ /tmp/tmpg_oe1arq.rs:28:18\n   |\n8  | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                      --- move occurs because `lst` has\
    \ type `Vec<isize>`, which does not implement the `Copy` trait\n...\n20 |    \
    \ for value in lst {\n   |                  --- `lst` moved due to this implicit\
    \ call to `.into_iter()`\n...\n28 |     for value in lst {\n   |             \
    \     ^^^ value used here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n20\
    \ |     for value in &lst {\n   |                  +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            result.push(value);\n        }\n  \
    \      if value > max_value {\n            result.push(value);\n        }\n  \
    \  }\n    for value in lst {\n        if value < max_value {\n            result.push(value);\n\
    \        }\n        if value > min_value {\n            result.push(value);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpqk_ep4vm.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n12  |     for value in &lst\
    \ {\n    |                  +\n\nerror[E0382]: use of moved value: `lst`\n  -->\
    \ /tmp/tmpqk_ep4vm.rs:28:18\n   |\n8  | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                      --- move occurs because `lst` has\
    \ type `Vec<isize>`, which does not implement the `Copy` trait\n...\n20 |    \
    \ for value in lst {\n   |                  --- `lst` moved due to this implicit\
    \ call to `.into_iter()`\n...\n28 |     for value in lst {\n   |             \
    \     ^^^ value used here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n20\
    \ |     for value in &lst {\n   |                  +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for x in lst.iter() {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst.iter() {\n        if x <\
    \ min_value {\n            min_value = x;\n        }\n        if x > max_value\
    \ {\n            max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst.iter() {\n        if x <\
    \ min_value {\n            min_value = x;\n        }\n        if x > max_value\
    \ {\n            max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst.iter() {\n        if x <\
    \ min_value {\n            min_value = x;\n        }\n        if x > max_value\
    \ {\n            max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst.iter() {\n        if x <\
    \ min_value {\n            min_value = x;\n        }\n        if x > max_value\
    \ {\n            max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst.iter() {\n        if x <\
    \ min_value {\n            min_value = x;\n        }\n        if x > max_value\
    \ {\n            max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst.iter() {\n        if x <\
    \ min_value {\n            min_value = x;\n        }\n        if x > max_value\
    \ {\n            max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst.iter() {\n        if x <\
    \ min_value {\n            min_value = x;\n        }\n        if x > max_value\
    \ {\n            max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst.iter() {\n        if x <\
    \ min_value {\n            min_value = x;\n        }\n        if x > max_value\
    \ {\n            max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for x in lst.iter() {\n        if x <\
    \ min_value {\n            min_value = x;\n        }\n        if x > max_value\
    \ {\n            max_value = x;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmp0zkx5sel.rs:112:1\n\
    \    |\n112 | }\n    | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0zkx5sel.rs:13:16\n   |\n13 |         if x < min_value {\n   |\
    \                ^^^^^^^^^\n   |                |\n   |                expected\
    \ `&isize`, found `isize`\n   |                help: consider borrowing here:\
    \ `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0zkx5sel.rs:14:25\n\
    \   |\n10 |     let mut min_value = lst[0];\n   |                         ------\
    \ expected due to this value\n...\n14 |             min_value = x;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n14 |             min_value = *x;\n   |     \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0zkx5sel.rs:16:16\n\
    \   |\n16 |         if x > max_value {\n   |                ^^^^^^^^^\n   |  \
    \              |\n   |                expected `&isize`, found `isize`\n   | \
    \               help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0zkx5sel.rs:17:25\n   |\n11 |     let mut max_value = lst[0];\n\
    \   |                         ------ expected due to this value\n...\n17 |   \
    \          max_value = x;\n   |                         ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |        \
    \     max_value = *x;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0zkx5sel.rs:23:16\n   |\n23 |         if x < min_value\
    \ {\n   |                ^^^^^^^^^\n   |                |\n   |              \
    \  expected `&isize`, found `isize`\n   |                help: consider borrowing\
    \ here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0zkx5sel.rs:24:25\n\
    \   |\n20 |     let mut min_value = min_value;\n   |                         ---------\
    \ expected due to this value\n...\n24 |             min_value = x;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n24 |             min_value = *x;\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut mid = lst.iter().skip(1).sum();\n\
    \    while mid != 0 {\n        if mid < min {\n            mid = mid.saturating_add((min\
    \ - mid).abs());\n            min = mid;\n        }\n        if mid > max {\n\
    \            mid = mid.saturating_add((max - mid).abs());\n            max = mid;\n\
    \        }\n        res.push(mid);\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpk69ete_m.rs:15:19\n\
    \   |\n12 |     let mut mid = lst.iter().skip(1).sum();\n   |         -------\
    \ consider giving `mid` a type\n...\n15 |             mid = mid.saturating_add((min\
    \ - mid).abs());\n   |                   ^^^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| *x == max).unwrap();\n\
    \    while min_idx < max_idx {\n        let tmp = min;\n        min = max;\n \
    \       max = tmp;\n        min_idx = lst.iter().position(|x| *x == min).unwrap();\n\
    \        max_idx = lst.iter().position(|x| *x == max).unwrap();\n    }\n    lst.swap(min_idx,\
    \ max_idx);\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd1srzl6b.rs:12:53\n   |\n\
    12 |     let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |     let\
    \ mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpd1srzl6b.rs:13:53\n   |\n13 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n13 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd1srzl6b.rs:18:49\n   |\n18 |         min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n18 |         min_idx = lst.iter().position(|x| *x == *min).unwrap();\n\
    \   |                                                 +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd1srzl6b.rs:19:49\n   |\n19 |         max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n19 |         max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                 +\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for i in 1..lst.len() {\n        if lst[i]\
    \ < min_value {\n            min_value = lst[i];\n        }\n        if lst[i]\
    \ > max_value {\n            max_value = lst[i];\n        }\n    }\n    let mut\
    \ new_lst = Vec::new();\n    for i in 0..lst.len() {\n        if lst[i] < min_value\
    \ {\n            new_lst.push(min_value);\n        }\n        if lst[i] > max_value\
    \ {\n            new_lst.push(max_value);\n        }\n        if lst[i] > min_value\
    \ {\n            new_lst.push(lst[i]);\n        }\n    }\n    new_lst\n}\n\nfn\
    \ main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpg05xed_s.rs:37:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut min_val = lst[0];\n\
    \    let mut max_val = lst[0];\n    for el in lst {\n        if el < min_val {\n\
    \            min_val = el;\n        }\n        if el > max_val {\n           \
    \ max_val = el;\n        }\n    }\n    for el in lst {\n        if el == min_val\
    \ {\n            res.push(min_val);\n        }\n        if el == max_val {\n \
    \           res.push(max_val);\n        }\n        if el < min_val {\n       \
    \     res.push(el);\n        }\n        if el > max_val {\n            res.push(el);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpgu_l9e7x.rs:20:15\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for el in lst {\n    | \
    \              --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for el in lst {\n    |               ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n12  |     for el in &lst {\n    | \
    \              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = vec![];\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0ivc8mdf.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n113 |         if \n114 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmp0ivc8mdf.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmp0ivc8mdf.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmprrl8wto_.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n113 |         if \n114 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmprrl8wto_.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmprrl8wto_.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    let mut min_val = lst[0];\n   \
    \ let mut max_val = lst[0];\n    for x in lst {\n        if x < min_val {\n  \
    \          min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    for i in 0..(lst.len() - 1) {\n        if lst[i]\
    \ < min_val {\n            res[i] = min_val;\n            min_val = lst[i];\n\
    \        } else if lst[i] > max_val {\n            res[i] = max_val;\n       \
    \     max_val = lst[i];\n        } else {\n            res[i] = lst[i];\n    \
    \    }\n    }\n    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmpe2272lh6.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for x in lst {\n    |  \
    \            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for i in 0..(lst.len() - 1) {\n    |                  ^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of\
    \ the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |\
    \     for x in &lst {\n    |              +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut mid = lst.iter().skip(1).take(2).min().unwrap();\n\
    \    while let Some(item) = lst.iter().find(|&x| x > mid) {\n        res.push(item);\n\
    \        mid = mid.saturating_add(item);\n    }\n    res.push(min);\n    res.push(max);\n\
    \    res.push(mid);\n    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbd5goo0g.rs:15:34\n   |\n\
    15 |         mid = mid.saturating_add(item);\n   |                           \
    \       ^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n15 |         mid = mid.saturating_add(*item);\n   |      \
    \                            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbd5goo0g.rs:15:15\n\
    \   |\n12 |     let mut mid = lst.iter().skip(1).take(2).min().unwrap();\n   |\
    \                   ----------------------------------------- expected due to\
    \ this value\n...\n15 |         mid = mid.saturating_add(item);\n   |        \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^\n   |               |\n   |               expected\
    \ `&isize`, found `isize`\n   |               help: consider borrowing here: `&mid.saturating_add(item)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbd5goo0g.rs:20:5\n   |\n8  | fn\
    \ strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |                   \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n20 |     res\n   |     ^^^ expected `isize`, found `&isize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if value < min_value {\n            min_value = value;\n        }\n  \
    \      if value > max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    for value in lst {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    for value in lst {\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for value in lst {\n        if value\
    \ < min_value {\n            min_value = value;\n        }\n        if value >\
    \ max_value {\n            max_value = value;\n        }\n    }\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    for value in lst {\n \
    \       if \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpaoc4ogev.rs:127:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    112 |     for value in lst {\n    |                      - this delimiter might\
    \ not be properly closed...\n113 |         if \n114 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n127 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpaoc4ogev.rs:114:1\n    |\n114 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmpaoc4ogev.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp3n7l25te.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ *x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| *x == max).unwrap();\n\
    \    let mut min_idx = min_idx / 2;\n    let mut max_idx = max_idx / 2;\n    let\
    \ mut i = 0;\n    while i < lst.len() {\n        if min_idx < max_idx {\n    \
    \        result.push(lst[min_idx]);\n            min_idx += 1;\n        } else\
    \ {\n            result.push(lst[max_idx]);\n            max_idx -= 1;\n     \
    \   }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjuxmgtvq.rs:12:53\n   |\n\
    12 |     let mut min_idx = lst.iter().position(|x| *x == min).unwrap();\n   |\
    \                                                     ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |     let\
    \ mut min_idx = lst.iter().position(|x| *x == *min).unwrap();\n   |          \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjuxmgtvq.rs:13:53\n   |\n13 |     let mut max_idx = lst.iter().position(|x|\
    \ *x == max).unwrap();\n   |                                                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n13 |     let mut max_idx = lst.iter().position(|x| *x == *max).unwrap();\n\
    \   |                                                     +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpurwhlr7x.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.clone();\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ x == min).unwrap();\n    let mut max_idx = lst.iter().position(|x| x == max).unwrap();\n\
    \    let mut mid = min + ((max - min) / 2);\n    while min_idx < max_idx {\n \
    \       lst[min_idx] = mid;\n        min_idx += 1;\n        lst[max_idx] = mid;\n\
    \        max_idx += 1;\n        mid += 1;\n    }\n    lst\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 4 but the index\
    \ is 4', /tmp/tmp5qf7xz01.rs:18:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmppsjd76xo.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpv66wc6hg.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpb7iirews.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmprt_4t6eq.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for ele in lst.iter() {\n        if ele\
    \ < min_value {\n            min_value = ele;\n        }\n        if ele > max_value\
    \ {\n            max_value = ele;\n        }\n    }\n    for i in 1..lst.len()\
    \ {\n        let mut min_value = lst[i];\n        let mut max_value = lst[i];\n\
    \        for j in i..lst.len() {\n            if lst[j] < min_value {\n      \
    \          min_value = lst[j];\n            }\n            if lst[j] > max_value\
    \ {\n                max_value = lst[j];\n            }\n        }\n        if\
    \ min_value < max_value {\n            result.push(i);\n            result.push(min_value);\n\
    \            result.push(max_value);\n        } else {\n            result.push(i);\n\
    \            result.push(max_value);\n            result.push(min_value);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuetby692.rs:13:18\n   |\n\
    13 |         if ele < min_value {\n   |                  ^^^^^^^^^\n   |     \
    \             |\n   |                  expected `&isize`, found `isize`\n   |\
    \                  help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuetby692.rs:14:25\n   |\n10 |     let mut min_value\
    \ = lst[0];\n   |                         ------ expected due to this value\n\
    ...\n14 |             min_value = ele;\n   |                         ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |             min_value = *ele;\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuetby692.rs:16:18\n   |\n16 |         if ele\
    \ > max_value {\n   |                  ^^^^^^^^^\n   |                  |\n  \
    \ |                  expected `&isize`, found `isize`\n   |                  help:\
    \ consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpuetby692.rs:17:25\n   |\n11 |     let mut max_value = lst[0];\n   |\
    \                         ------ expected due to this value\n...\n17 |       \
    \      max_value = ele;\n   |                         ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |        \
    \     max_value = *ele;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuetby692.rs:33:25\n   |\n33 |             result.push(min_value);\n\
    \   |                         ^^^^^^^^^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n33 |             result.push(min_value.try_into().unwrap());\n\
    \   |                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuetby692.rs:34:25\n   |\n34 |             result.push(max_value);\n\
    \   |                         ^^^^^^^^^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n34 |             result.pus"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for value in lst {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    for value in lst {\n  \
    \      if value < min_value {\n            result.push(value);\n        }\n  \
    \      if value > max_value {\n            result.push(value);\n        }\n  \
    \  }\n    for value in lst {\n        if value < max_value {\n            result.push(value);\n\
    \        }\n    }\n    for value in lst {\n        if value > min_value {\n  \
    \          result.push(value);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpu89_rdjf.rs:20:18\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for value in lst {\n   \
    \ |                  --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for value in lst {\n    |                  ^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n12  |     for value in &lst\
    \ {\n    |                  +\n\nerror[E0382]: use of moved value: `lst`\n  -->\
    \ /tmp/tmpu89_rdjf.rs:28:18\n   |\n8  | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                      --- move occurs because `lst` has\
    \ type `Vec<isize>`, which does not implement the `Copy` trait\n...\n20 |    \
    \ for value in lst {\n   |                  --- `lst` moved due to this implicit\
    \ call to `.into_iter()`\n...\n28 |     for value in lst {\n   |             \
    \     ^^^ value used here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n20\
    \ |     for value in &lst {\n   |                  +\n\nerror[E0382]: use of moved\
    \ value: `lst`\n  --> /tmp/tmpu89_rdjf.rs:33:18\n   |\n8  | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- move occurs because\
    \ `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n\
    28 |     for value in lst {\n   |                  --- `lst` moved due to this\
    \ implicit call to `.into_iter()`\n...\n33 |     for value in lst {\n   |    \
    \              ^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \   |\n28 |     for value in &lst {\n   |                  +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpd6ecmmfu.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    let mut min_value = lst[0];\n \
    \   let mut max_value = lst[0];\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpt12z0zwb.rs:117:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    102 |     for el in lst {\n    |                   - this delimiter might not\
    \ be properly closed...\n103 |         if el < min_\n104 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n117 | }\n    |   ^\n\nerror:\
    \ expected `{`, found `}`\n   --> /tmp/tmpt12z0zwb.rs:104:1\n    |\n103 |    \
    \     if el < min_\n    |         -- this `if` expression has a condition, but\
    \ no block\n104 | }\n    | ^ expected `{`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpt12z0zwb.rs:8:42\n  |\n8 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n  |    -----------------                     ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmppjkz_y1v.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpteb09ovg.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.clone();\n    let mut min_value = lst.iter().min().unwrap();\n\
    \    let mut max_value = lst.iter().max().unwrap();\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_value = min_value;\n    let\
    \ mut max_value = max_value;\n    let mut min_value = min_value;\n    let mut\
    \ max_value = max_value;\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    let mut min_value = min_value;\n    let mut max_value = max_value;\n    let\
    \ mut min_value = min_value;\n    let mut max_value = max_value;\n    let mut\
    \ min_value = min_value;\n    let mut max_value = max_value;\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_value = min_value;\n    let\
    \ mut max_value = max_value;\n    let mut min_value = min_value;\n    let mut\
    \ max_value = max_value;\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    let mut min_value = min_value;\n    let mut max_value = max_value;\n    let\
    \ mut min_value = min_value;\n    let mut max_value = max_value;\n    let mut\
    \ min_value = min_value;\n    let mut max_value = max_value;\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_value = min_value;\n    let\
    \ mut max_value = max_value;\n    let mut min_value = min_value;\n    let mut\
    \ max_value = max_value;\n    let mut min_value = min_value;\n    let mut max_value\
    \ = max_value;\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    let mut min_value = min_value;\n    let mut max_value = max_value;\n    let\
    \ mut min_value = min_value;\n    let mut max_value = max_value;\n    let mut\
    \ min_value = min_value;\n    let mut max_value = max_value;\n    let mut min_value\
    \ = min_value;\n    let mut max_value = max_value;\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_value = min_value;\n    let\
    \ mut max_value = max_value;\n    let mut min_value = min_value;\n    let mut\
    \ \n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp7gyr4fx0.rs:72:1\n\
    \   |\n72 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut min = lst[0];\n    let\
    \ mut max = lst[0];\n    for el in lst {\n        if el < min {\n            min\
    \ = el;\n        }\n        if el > max {\n            max = el;\n        }\n\
    \    }\n    for el in lst {\n        if el == min {\n            result.push(max);\n\
    \            max = el;\n        } else if el == max {\n            result.push(min);\n\
    \            min = el;\n        } else {\n            result.push(el);\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpje0e35zu.rs:20:15\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for el in lst {\n    | \
    \              --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for el in lst {\n    |               ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n12  |     for el in &lst {\n    | \
    \              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp2531rv95.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value = lst[0];\n\
    \    let mut max_value = lst[0];\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < min_value\
    \ {\n            min_value = el;\n        }\n        if el > max_value {\n   \
    \         max_value = el;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    for el in lst {\n        if el < \n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpk_xtbih_.rs:117:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    102 |     for el in lst {\n    |                   - this delimiter might not\
    \ be properly closed...\n103 |         if el < \n104 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n117 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpk_xtbih_.rs:104:1\n    |\n104 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmpk_xtbih_.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpmm4s_8qy.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpvbayvxad.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
