name: HumanEval_74_total_match
language: rust
results:
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > lst1.len() {\n            return vec![];\n\
    \        }\n        if total_chars < lst2.len() {\n            return vec![];\n\
    \        }\n        total_chars += s.len();\n    }\n    return vec![lst1[0]];\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst2`\n   --> /tmp/tmpjjr1itwn.rs:19:26\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n15  |  \
    \   for s in lst2 {\n    |              ---- `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n...\n19  |         if total_chars < lst2.len() {\n \
    \   |                          ^^^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `lst2`\n\
    help: consider iterating over a slice of the `Vec<String>`'s content to avoid\
    \ moving into the `for` loop\n    |\n15  |     for s in &lst2 {\n    |       \
    \       +\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpjjr1itwn.rs:24:17\n\
    \   |\n24 |     return vec![lst1[0]];\n   |                 ^^^^^^^ move occurs\
    \ because value has type `String`, which does not implement the `Copy` trait\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0382, E0507.\nFor more information about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    let mut total_chars = lst1[0].len();\n    for elem\
    \ in lst1 {\n        if elem.len() > total_chars {\n            total_chars =\
    \ elem.len();\n        }\n    }\n    for elem in lst2 {\n        if elem.len()\
    \ > total_chars {\n            total_chars = elem.len();\n        }\n    }\n \
    \   let mut result = vec![];\n    for elem in lst1 {\n        if elem.len() <=\
    \ total_chars {\n            result.push(elem);\n        }\n    }\n    for elem\
    \ in lst2 {\n        if elem.len() <= total_chars {\n            result.push(elem);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpbqnx_vjr.rs:15:21\n\
    \   |\n15 |         return vec![lst1[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0382]: use of moved value: `lst1`\n   --> /tmp/tmpbqnx_vjr.rs:29:17\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n18  |     for elem in lst1 {\n\
    \    |                 ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n29  |     for elem in lst1 {\n    |                 ^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `lst1`\nhelp: consider iterating over a slice of the `Vec<String>`'s\
    \ content to avoid moving into the `for` loop\n    |\n18  |     for elem in &lst1\
    \ {\n    |                 +\n\nerror[E0382]: use of moved value: `lst2`\n  -->\
    \ /tmp/tmpbqnx_vjr.rs:34:17\n   |\n10 | fn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n   |                                   ---- move\
    \ occurs because `lst2` has type `Vec<String>`, which does not implement the `Copy`\
    \ trait\n...\n23 |     for elem in lst2 {\n   |                 ---- `lst2` moved\
    \ due to this implicit call to `.into_iter()`\n...\n34 |     for elem in lst2\
    \ {\n   |                 ^^^^ value used here after move\n   |\nhelp: consider\
    \ iterating over a slice of the `Vec<String>`'s content to avoid moving into the\
    \ `for` loop\n   |\n23 |     for elem in &lst2 {\n   |                 +\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0382, E0507.\nFor more information about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = Vec::new();\n    for el1 in\
    \ lst1 {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n\
    \                res.push(el1);\n                break;\n            }\n     \
    \   }\n    }\n    if res.len() == 0 {\n        res\n    } else {\n        res\n\
    \    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp4bmj5th4.rs:13:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n13  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    let mut total_chars = lst1.len();\n    for i in 0..(lst1.len()\
    \ - 1) {\n        total_chars += lst1[i].len();\n    }\n    for i in 0..(lst2.len()\
    \ - 1) {\n        total_chars += lst2[i].len();\n    }\n    if total_chars ==\
    \ lst1.len() {\n        return vec![lst1[0]];\n    }\n    if total_chars == lst2.len()\
    \ {\n        return vec![lst2[0]];\n    }\n    let mut result = vec![];\n    for\
    \ i in 0..(lst1.len() - 1) {\n        if lst1[i].len() < lst2[i].len() {\n   \
    \         result.push(lst1[i]);\n        } else {\n            result.push(lst2[i]);\n\
    \        }\n    }\n    for i in 0..(lst2.len() - 1) {\n        if lst2[i].len()\
    \ < lst1[i].len() {\n            result.push(lst2[i]);\n        } else {\n   \
    \         result.push(lst1[i]);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpnez7o7h_.rs:15:21\n\
    \   |\n15 |         return vec![lst1[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpnez7o7h_.rs:25:21\n\
    \   |\n25 |         return vec![lst1[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpnez7o7h_.rs:28:21\n\
    \   |\n28 |         return vec![lst2[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpnez7o7h_.rs:33:25\n\
    \   |\n33 |             result.push(lst1[i]);\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpnez7o7h_.rs:35:25\n\
    \   |\n35 |             result.push(lst2[i]);\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpnez7o7h_.rs:40:25\n\
    \   |\n40 |             result.push(lst2[i]);\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpnez7o7h_.rs:42:25\n\
    \   |\n42 |             result.push(lst1[i]);\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 7 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    let mut result = vec![];\n    for i in 0..lst1.len()\
    \ {\n        let mut j = 0;\n        let mut found = false;\n        for j in\
    \ 0..lst2.len() {\n            if lst1[i] == lst2[j] {\n                found\
    \ = true;\n                break;\n            }\n        }\n        if found\
    \ {\n            break;\n        }\n        result.push(lst1[i]);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `j`\n  --> /tmp/tmpo8cb4sab.rs:19:17\n   |\n\
    19 |         let mut j = 0;\n   |                 ^ help: if this is intentional,\
    \ prefix it with an underscore: `_j`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpo8cb4sab.rs:19:13\n\
    \   |\n19 |         let mut j = 0;\n   |             ----^\n   |             |\n\
    \   |             help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n \
    \ --> /tmp/tmpo8cb4sab.rs:15:21\n   |\n15 |         return vec![lst1[0]];\n  \
    \ |                     ^^^^^^^ move occurs because value has type `String`, which\
    \ does not implement the `Copy` trait\n\nerror[E0507]: cannot move out of index\
    \ of `Vec<String>`\n  --> /tmp/tmpo8cb4sab.rs:30:21\n   |\n30 |         result.push(lst1[i]);\n\
    \   |                     ^^^^^^^ move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror: aborting due to 2 previous\
    \ errors; 2 warnings emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for el1 in lst1\
    \ {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n     \
    \           total_len += el1.len();\n            }\n        }\n    }\n    if total_len\
    \ == 0 {\n        return lst1;\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = total_len;\n    for el1 in lst1 {\n        for\
    \ el2 in lst2 {\n            if el1.len() < el2.len() {\n                total_len\
    \ += el1.len();\n            }\n        }\n    }\n    if total_len == 0 {\n  \
    \      return lst1;\n    }\n    if total_len == lst1.len() {\n        return lst1;\n\
    \    }\n    if total_len == lst2.len() {\n        return lst2;\n    }\n    let\
    \ mut total_len = total_len;\n    for el1 in lst1 {\n        for el2 in lst2 {\n\
    \            if el1.len() < el2.len() {\n                total_len += el1.len();\n\
    \            }\n        }\n    }\n    if total_len == 0 {\n        return lst1;\n\
    \    }\n    if total_len == lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_len == lst2.len() {\n        return lst2;\n    }\n    let mut total_len\
    \ = total_len;\n    for el1 in lst1 {\n        for el2 in lst2 {\n           \
    \ if el1.len() < el2.len() {\n                total_len += el1.len();\n      \
    \      }\n        }\n    }\n    if total_len == 0 {\n        return lst1;\n  \
    \  }\n    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = total_len;\n\
    \    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len() <\
    \ el2.len() {\n                total_len += el1.len();\n            }\n      \
    \  }\n    }\n    if total_len == 0 {\n        return lst1;\n    }\n    if total_len\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_len == lst2.len()\
    \ {\n        return lst2;\n    }\n    let mut total_len = total_len;\n    for\
    \ el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len() < el2.len()\
    \ {\n                total_len += el1.len();\n            }\n        }\n    }\n\
    \    if total_len == 0 {\n        return lst1;\n    }\n    if total_len == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_len == lst2.\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n   --> /tmp/tmp1dotwrsi.rs:111:1\n    |\n\
    111 | }\n    | ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmp1dotwrsi.rs:111:1\n\
    \    |\n110 |     if total_len == lst2.\n    |     -- this `if` expression has\
    \ a condition, but no block\n111 | }\n    | ^ expected `{`\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = vec![];\n    for str1\
    \ in lst1 {\n        for str2 in lst2 {\n            if str1.len() < str2.len()\
    \ {\n                total_chars.push(str1);\n            } else {\n         \
    \       total_chars.push(str2);\n            }\n        }\n    }\n    total_chars\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpt6ktx_lm.rs:16:21\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n16  |  \
    \       for str2 in lst2 {\n    |                     ^^^^ `lst2` moved due to\
    \ this implicit call to `.into_iter()`, in previous iteration of loop\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `lst2`\n\
    help: consider iterating over a slice of the `Vec<String>`'s content to avoid\
    \ moving into the `for` loop\n    |\n16  |         for str2 in &lst2 {\n    |\
    \                     +\n\nerror[E0382]: borrow of moved value: `str1`\n  -->\
    \ /tmp/tmpt6ktx_lm.rs:17:16\n   |\n15 |     for str1 in lst1 {\n   |         ----\n\
    \   |         |\n   |         this reinitialization might get skipped\n   |  \
    \       move occurs because `str1` has type `String`, which does not implement\
    \ the `Copy` trait\n16 |         for str2 in lst2 {\n17 |             if str1.len()\
    \ < str2.len() {\n   |                ^^^^^^^^^^ value borrowed here after move\n\
    18 |                 total_chars.push(str1);\n   |                           \
    \       ---- value moved here, in previous iteration of loop\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut res = vec![];\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < lst1.len() && j < lst2.len() {\n        if\
    \ lst1[i] < lst2[j] {\n            i += 1;\n        } else {\n            res.push(lst1[i]);\n\
    \            i += 1;\n            j += 1;\n        }\n    }\n    res.push(lst1[i]);\n\
    \    res.push(lst2[j]);\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp4l101_5x.rs:21:22\n\
    \   |\n21 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp4l101_5x.rs:26:14\n\
    \   |\n26 |     res.push(lst1[i]);\n   |              ^^^^^^^ move occurs because\
    \ value has type `String`, which does not implement the `Copy` trait\n\nerror[E0507]:\
    \ cannot move out of index of `Vec<String>`\n  --> /tmp/tmp4l101_5x.rs:27:14\n\
    \   |\n27 |     res.push(lst2[j]);\n   |              ^^^^^^^ move occurs because\
    \ value has type `String`, which does not implement the `Copy` trait\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = vec![];\n    for x in\
    \ lst1 {\n        if lst2.iter().any(|y| y < x) {\n            total_chars.push(x);\n\
    \        }\n    }\n    for x in lst2 {\n        if lst1.iter().any(|y| y < x)\
    \ {\n            total_chars.push(x);\n        }\n    }\n    total_chars\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplp55ofwt.rs:16:36\n   |\n\
    16 |         if lst2.iter().any(|y| y < x) {\n   |                           \
    \         ^\n   |                                    |\n   |                 \
    \                   expected `&String`, found struct `String`\n   |          \
    \                          help: consider borrowing here: `&x`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplp55ofwt.rs:21:36\n   |\n21 |         if lst1.iter().any(|y|\
    \ y < x) {\n   |                                    ^\n   |                  \
    \                  |\n   |                                    expected `&String`,\
    \ found struct `String`\n   |                                    help: consider\
    \ borrowing here: `&x`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst1 {\n        total_chars += s.len();\n    }\n    for s in lst2 {\n \
    \       total_chars += s.len();\n    }\n    if total_chars < lst2.len() {\n  \
    \      return vec![lst1[0]];\n    }\n    return vec![lst1[0]];\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst2`\n   --> /tmp/tmp1mla0blg.rs:21:22\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \   for s in lst2 {\n    |              ---- `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     if total_chars < lst2.len() {\n    |\
    \                      ^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n18  |     for s in &lst2 {\n    |              +\n\
    \nerror[E0382]: borrow of moved value: `lst1`\n  --> /tmp/tmp1mla0blg.rs:22:21\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15 |     for s in lst1 {\n \
    \  |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n22 |         return vec![lst1[0]];\n   |                     ^^^^ value borrowed\
    \ here after move\n   |\nhelp: consider iterating over a slice of the `Vec<String>`'s\
    \ content to avoid moving into the `for` loop\n   |\n15 |     for s in &lst1 {\n\
    \   |              +\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n\
    \  --> /tmp/tmp1mla0blg.rs:22:21\n   |\n22 |         return vec![lst1[0]];\n \
    \  |                     ^^^^^^^ move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror[E0507]: cannot move out of\
    \ index of `Vec<String>`\n  --> /tmp/tmp1mla0blg.rs:24:17\n   |\n24 |     return\
    \ vec![lst1[0]];\n   |                 ^^^^^^^ move occurs because value has type\
    \ `String`, which does not implement the `Copy` trait\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0382, E0507.\n\
    For more information about an error, try `rustc --e"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut result = vec![];\n    for s in lst1 {\n        if s.len() <= total_len\
    \ {\n            result.push(s);\n        }\n    }\n    for s in lst2 {\n    \
    \    if s.len() <= total_len {\n            result.push(s);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmpcmsb5u8_.rs:25:14\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for s in lst1 {\n\
    \    |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n25  |     for s in lst1 {\n    |              ^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst1`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n15  |     for s in &lst1 {\n   \
    \ |              +\n\nerror[E0382]: use of moved value: `lst2`\n  --> /tmp/tmpcmsb5u8_.rs:30:14\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18 |   \
    \  for s in lst2 {\n   |              ---- `lst2` moved due to this implicit call\
    \ to `.into_iter()`\n...\n30 |     for s in lst2 {\n   |              ^^^^ value\
    \ used here after move\n   |\nhelp: consider iterating over a slice of the `Vec<String>`'s\
    \ content to avoid moving into the `for` loop\n   |\n18 |     for s in &lst2 {\n\
    \   |              +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for s in lst1 {\n        total_chars += s.len();\n    }\n    for s in lst2 {\n\
    \        total_chars += s.len();\n    }\n    if total_chars == lst1[0].len() {\n\
    \        return vec![];\n    }\n    if total_chars == lst2[0].len() {\n      \
    \  return vec![];\n    }\n    let mut res = vec![];\n    for s in lst1 {\n   \
    \     if s.len() < total_chars {\n            match total_match(s.split_whitespace(),\
    \ lst2) {\n                Some(matched) => res.append(matched),\n           \
    \     None => return vec![],\n            }\n        } else {\n            match\
    \ total_match(s.split_whitespace(), lst2) {\n                Some(matched) =>\
    \ res.append(matched),\n                None => return vec![],\n            }\n\
    \        }\n    }\n    for s in lst2 {\n        if s.len() < total_chars {\n \
    \           match total_match(lst1, s.split_whitespace()) {\n                Some(matched)\
    \ => res.append(matched),\n                None => return vec![],\n          \
    \  }\n        } else {\n            match total_match(lst1, s.split_whitespace())\
    \ {\n                Some(matched) => res.append(matched),\n                None\
    \ => return vec![],\n            }\n        }\n    }\n    return res;\n}\n\nfn\
    \ main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_e8bfnj0.rs:30:31\n   |\n\
    30 |             match total_match(s.split_whitespace(), lst2) {\n   |       \
    \                        ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |\n   = note: expected struct `Vec<String>`\n        \
    \      found struct `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_e8bfnj0.rs:31:17\n   |\n30 |             match total_match(s.split_whitespace(),\
    \ lst2) {\n   |                   --------------------------------------- this\
    \ expression has type `Vec<String>`\n31 |                 Some(matched) => res.append(matched),\n\
    \   |                 ^^^^^^^^^^^^^ expected struct `Vec`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<String>`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_e8bfnj0.rs:32:17\n   |\n30 |\
    \             match total_match(s.split_whitespace(), lst2) {\n   |          \
    \         --------------------------------------- this expression has type `Vec<String>`\n\
    31 |                 Some(matched) => res.append(matched),\n32 |             \
    \    None => return vec![],\n   |                 ^^^^ expected struct `Vec`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<String>`\n      \
    \          found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_e8bfnj0.rs:35:31\n\
    \   |\n35 |             match total_match(s.split_whitespace(), lst2) {\n   |\
    \                               ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ struct `SplitWhitespace`\n   |\n   = note: expected struct `Vec<String>`\n \
    \             found struct `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_e8bfnj0.rs:36:17\n   |\n35 |             match total_match(s.split_whitespace(),\
    \ lst2) {\n   |                   --------------------------------------- this\
    \ expression has type `Vec<String>`\n36 |                 Some(matched) => res.append(matched),\n\
    \   |                 ^^^^^^^^^^^^^ expected struct `Vec`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<String>`\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_len = 0;\n    for x in lst1\
    \ {\n        total_len += x.len();\n    }\n    for x in lst2 {\n        total_len\
    \ += x.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut result = vec![];\n    for x in lst1 {\n        if x < lst2 {\n  \
    \          result.push(x);\n        }\n    }\n    for x in lst2 {\n        if\
    \ x < lst1 {\n            result.push(x);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5gn1w26i.rs:26:16\n   |\n\
    26 |         if x < lst2 {\n   |                ^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5gn1w26i.rs:31:16\n\
    \   |\n31 |         if x < lst1 {\n   |                ^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<String>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = vec![];\n    for el1\
    \ in lst1 {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n\
    \                total_chars.push(el1);\n                break;\n            }\n\
    \        }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpjf2mub1g.rs:16:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n16  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n16  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    if total_chars == lst1.len() {\n        return lst1;\n\
    \    }\n    return lst1;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpe9pbiu57.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_len = 0;\n    for x in lst1\
    \ {\n        total_len += x.len();\n    }\n    for x in lst2 {\n        total_len\
    \ += x.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut total_match_len = 0;\n    for x in lst1 {\n        if x < lst2 {\n\
    \            total_match_len += x.len();\n        }\n    }\n    for x in lst2\
    \ {\n        if x < lst1 {\n            total_match_len += x.len();\n        }\n\
    \    }\n    if total_match_len == total_len {\n        return vec![];\n    }\n\
    \    let mut total_match_len = total_len;\n    for x in lst1 {\n        if x <\
    \ lst2 {\n            total_match_len -= x.len();\n        }\n    }\n    for x\
    \ in lst2 {\n        if x < lst1 {\n            total_match_len -= x.len();\n\
    \        }\n    }\n    if total_match_len == 0 {\n        return vec![];\n   \
    \ }\n    let mut total_match_len = total_len;\n    for x in lst1 {\n        if\
    \ x < lst2 {\n            total_match_len -= x.len();\n        }\n    }\n    for\
    \ x in lst2 {\n        if x < lst1 {\n            total_match_len -= x.len();\n\
    \        }\n    }\n    if total_match_len == 0 {\n        return vec![];\n   \
    \ }\n    let mut total_match_len = total_len;\n    for x in lst1 {\n        if\
    \ x < lst2 {\n            total_match_len -= x.len();\n        }\n    }\n    for\
    \ x in lst2 {\n        if x < lst1 {\n            total_match_len -= x.len();\n\
    \        }\n    }\n    if total_match_len == 0 {\n        return vec![];\n   \
    \ }\n    let mut total_match_len = total_len;\n    for x in lst1 {\n        if\
    \ x < lst2 {\n            total_match_len -= x.len();\n        }\n    }\n    for\
    \ x in lst2 {\n        if x < lst1 {\n            total_match_len -= x.len();\n\
    \        }\n    }\n    if total_match_len == 0 {\n        return vec![];\n   \
    \ }\n    let mut total_match_len = total_len;\n    for x in lst1 {\n        if\
    \ x < lst2 {\n            total_match_len -= x.len();\n        }\n    }\n    for\
    \ x in lst2 {\n        if x < lst1 {\n            total_match_len -= x.len();\n\
    \        }\n    }\n    if total_match_len == 0 {\n        return vec![];\n   \
    \ }\n    let mut total_match_len = total_len;\n    for x in lst1 {\n        if\
    \ x < lst2 {\n            total_match_len -= x.len();\n        }\n    }\n    for\
    \ x in lst2 {\n        if x < lst1 {\n            total_\n}\n\nfn main() {\n \
    \   let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp01ai_3cb.rs:130:3\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n114 |     for x in lst2 {\n    |               \
    \    - unclosed delimiter\n115 |         if x < lst1 {\n    |                \
    \     - this delimiter might not be properly closed...\n116 |             total_\n\
    117 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    130 | }\n    |   ^\n\nerror[E0425]: cannot find value `total_` in this scope\n\
    \   --> /tmp/tmp01ai_3cb.rs:116:13\n    |\n116 |             total_\n    |   \
    \          ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp01ai_3cb.rs:26:16\n   |\n26 |         if x < lst2 {\n   |     \
    \           ^^^^ expected struct `String`, found struct `Vec`\n   |\n   = note:\
    \ expected struct `String`\n              found struct `Vec<String>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp01ai_3cb.rs:31:16\n   |\n31 |         if x <\
    \ lst1 {\n   |                ^^^^ expected struct `String`, found struct `Vec`\n\
    \   |\n   = note: expected struct `String`\n              found struct `Vec<String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp01ai_3cb.rs:40:16\n   |\n40 |\
    \         if x < lst2 {\n   |                ^^^^ expected struct `String`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `String`\n              found\
    \ struct `Vec<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp01ai_3cb.rs:45:16\n\
    \   |\n45 |         if x < lst1 {\n   |                ^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp01ai_3cb.rs:54:16\n\
    \   |\n54 |         if x < lst2 {\n   |                ^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp01ai_3cb.rs:59:16\n\
    \   |\n59 |         if"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_match = 0;\n    for x in lst1\
    \ {\n        if lst2.contains(&x) {\n            total_match += 1;\n        }\n\
    \    }\n    if total_match == lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_match == lst2.len() {\n        return lst2;\n    }\n    let mut total_match_chars\
    \ = 0;\n    for x in lst1 {\n        if lst2.contains(&x) {\n            total_match_chars\
    \ += x.len();\n        }\n    }\n    if total_match_chars == total_match {\n \
    \       return lst1;\n    }\n    if total_match_chars == total_match {\n     \
    \   return lst2;\n    }\n    vec![]\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmpy09_9yds.rs:17:23\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11  |     let mut total_match = 0;\n\
    12  |     for x in lst1 {\n    |              ---- `lst1` moved due to this implicit\
    \ call to `.into_iter()`\n...\n17  |     if total_match == lst1.len() {\n    |\
    \                       ^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst1`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |     for x in &lst1 {\n    |              +\n\
    \nerror[E0382]: use of moved value: `lst1`\n  --> /tmp/tmpy09_9yds.rs:30:16\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n24 |     for x in lst1 {\n \
    \  |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n30 |         return lst1;\n   |                ^^^^ value used here after\
    \ move\n   |\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n   |\n24 |     for x in &lst1 {\n   | \
    \             +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut res = vec![];\n    let mut cnt = 0;\n\
    \    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len() <\
    \ el2.len() {\n                cnt += el1.len();\n            } else {\n     \
    \           cnt += el2.len();\n            }\n            if cnt > 0 {\n     \
    \           res.push(el1);\n                break;\n            }\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpz5trs9ke.rs:17:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n17  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for x in lst1\
    \ {\n        total_len += x.len();\n    }\n    for x in lst2 {\n        total_len\
    \ += x.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut total_matches: Vec<String> = vec![];\n    for x in lst1 {\n     \
    \   if total_len < x.len() {\n            break;\n        }\n        total_matches.push(x);\n\
    \    }\n    for x in lst2 {\n        if total_len < x.len() {\n            break;\n\
    \        }\n        total_matches.push(x);\n    }\n    total_matches\n}\n\nfn\
    \ main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmpt7xxaab2.rs:22:14\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11  |     let mut total_len = 0;\n\
    12  |     for x in lst1 {\n    |              ---- `lst1` moved due to this implicit\
    \ call to `.into_iter()`\n...\n22  |     for x in lst1 {\n    |              ^^^^\
    \ value used here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n12 \
    \ |     for x in &lst1 {\n    |              +\n\nerror[E0382]: use of moved value:\
    \ `lst2`\n  --> /tmp/tmpt7xxaab2.rs:28:14\n   |\n10 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                                  \
    \ ---- move occurs because `lst2` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n...\n15 |     for x in lst2 {\n   |              ---- `lst2`\
    \ moved due to this implicit call to `.into_iter()`\n...\n28 |     for x in lst2\
    \ {\n   |              ^^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n15 |     for x in &lst2 {\n   |              +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return lst1;\n    }\n \
    \   if total_len == lst1.len() {\n        return lst2;\n    }\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    let mut total_matches: Vec<String> = vec![];\n \
    \   while i < lst1.len() && j < lst2.len() {\n        if lst1[i].len() < lst2[j].len()\
    \ {\n            i += 1;\n            total_matches.push(lst1[i]);\n        }\
    \ else {\n            j += 1;\n            total_matches.push(lst2[j]);\n    \
    \    }\n    }\n    total_matches.sort_unstable();\n    return total_matches;\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmps0f95fbl.rs:19:16\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11  |     let mut total_len = 0;\n\
    12  |     for s in lst1 {\n    |              ---- `lst1` moved due to this implicit\
    \ call to `.into_iter()`\n...\n19  |         return lst1;\n    |             \
    \   ^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `lst1`\nhelp: consider iterating over a\
    \ slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n \
    \   |\n12  |     for s in &lst1 {\n    |              +\n\nerror[E0382]: use of\
    \ moved value: `lst2`\n  --> /tmp/tmps0f95fbl.rs:22:16\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n15 |     for s in lst2 {\n   |        \
    \      ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n22\
    \ |         return lst2;\n   |                ^^^^ value used here after move\n\
    \   |\nhelp: consider iterating over a slice of the `Vec<String>`'s content to\
    \ avoid moving into the `for` loop\n   |\n15 |     for s in &lst2 {\n   |    \
    \          +\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  -->\
    \ /tmp/tmps0f95fbl.rs:30:32\n   |\n30 |             total_matches.push(lst1[i]);\n\
    \   |                                ^^^^^^^ move occurs because value has type\
    \ `String`, which does not implement the `Copy` trait\n\nerror[E0507]: cannot\
    \ move out of index of `Vec<String>`\n  --> /tmp/tmps0f95fbl.rs:33:32\n   |\n\
    33 |             total_matches.push(lst2[j]);\n   |                          \
    \      ^^^^^^^ move occurs because value has type `String`, which does not implement\
    \ the `Copy` trait\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0382, E0507.\nFor more information ab"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut res = vec![];\n    for i in 0..lst1.len() {\n    \
    \    if lst1[i] < lst2[i] {\n            res.push(lst1[i]);\n        } else {\n\
    \            res.push(lst2[i]);\n        }\n    }\n    return res;\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp30t6868y.rs:17:22\n\
    \   |\n17 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp30t6868y.rs:19:22\n\
    \   |\n19 |             res.push(lst2[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut result = vec![];\n    for el1 in\
    \ lst1 {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n\
    \                result.push(el1);\n                break;\n            }\n  \
    \      }\n    }\n    if lst1.len() == lst2.len() {\n        result\n    } else\
    \ {\n        total_match(result, lst2)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp_fy7hpy8.rs:13:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n13  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror[E0382]: borrow of moved value: `lst1`\n  --> /tmp/tmp_fy7hpy8.rs:20:8\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11 |     let mut result = vec![];\n\
    12 |     for el1 in lst1 {\n   |                ---- `lst1` moved due to this\
    \ implicit call to `.into_iter()`\n...\n20 |     if lst1.len() == lst2.len() {\n\
    \   |        ^^^^^^^^^^ value borrowed here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n12 |     for el1 in &lst1 {\n   |                +\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ elem in lst2 {\n        if elem.len() > total_chars {\n            total_chars\
    \ = elem.len();\n        }\n    }\n    if total_chars == lst1.len() {\n      \
    \  return lst1;\n    }\n    return lst1;\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmplim1mxzu.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = Vec::new();\n    for i in 0..lst1.len()\
    \ {\n        for j in 0..lst2.len() {\n            if lst1[i].len() < lst2[j].len()\
    \ {\n                res.push(lst1[i]);\n                break;\n            }\n\
    \            if lst1[i].len() == lst2[j].len() {\n                res.push(lst1[i]);\n\
    \                break;\n            }\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpsl2dtj0w.rs:15:26\n\
    \   |\n15 |                 res.push(lst1[i]);\n   |                         \
    \ ^^^^^^^ move occurs because value has type `String`, which does not implement\
    \ the `Copy` trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n\
    \  --> /tmp/tmpsl2dtj0w.rs:19:26\n   |\n19 |                 res.push(lst1[i]);\n\
    \   |                          ^^^^^^^ move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    let mut result = vec![];\n    for el1 in lst1 {\n\
    \        for el2 in lst2 {\n            if el1.len() < el2.len() {\n         \
    \       result.push(el1);\n                break;\n            }\n           \
    \ if el1.len() > el2.len() {\n                result.push(el2);\n            \
    \    break;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp3iql11yy.rs:15:21\n\
    \   |\n15 |         return vec![lst1[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp3iql11yy.rs:19:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n19  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0382, E0507.\nFor more information about an error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ x in lst1 {\n        total_chars += x.len();\n    }\n    for x in lst2 {\n \
    \       total_chars += x.len();\n    }\n    if total_chars < lst2.len() {\n  \
    \      return vec![];\n    }\n    return vec![lst1[0]];\n}\n\nfn main() {\n  \
    \  let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst2`\n   --> /tmp/tmp8y5zfsdy.rs:21:22\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \   for x in lst2 {\n    |              ---- `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     if total_chars < lst2.len() {\n    |\
    \                      ^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n18  |     for x in &lst2 {\n    |              +\n\
    \nerror[E0382]: borrow of moved value: `lst1`\n  --> /tmp/tmp8y5zfsdy.rs:24:17\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15 |     for x in lst1 {\n \
    \  |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n24 |     return vec![lst1[0]];\n   |                 ^^^^ value borrowed\
    \ here after move\n   |\nhelp: consider iterating over a slice of the `Vec<String>`'s\
    \ content to avoid moving into the `for` loop\n   |\n15 |     for x in &lst1 {\n\
    \   |              +\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n\
    \  --> /tmp/tmp8y5zfsdy.rs:24:17\n   |\n24 |     return vec![lst1[0]];\n   | \
    \                ^^^^^^^ move occurs because value has type `String`, which does\
    \ not implement the `Copy` trait\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0382, E0507.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_len = 0;\n    for &s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for &s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut total_chars = 0;\n    for &s in lst1 {\n        total_chars += s.chars().count();\n\
    \    }\n    for &s in lst2 {\n        total_chars += s.chars().count();\n    }\n\
    \    if total_chars < total_len {\n        return vec![];\n    }\n    let mut\
    \ res = vec![];\n    for &s in lst1 {\n        if s.len() < total_len {\n    \
    \        res.push(s);\n        }\n    }\n    for &s in lst2 {\n        if s.len()\
    \ < total_len {\n            res.push(s);\n        }\n    }\n    if res.len()\
    \ == 0 {\n        return vec![];\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpozlivyq6.rs:15:9\n   |\n\
    15 |     for &s in lst1 {\n   |         ^^    ---- this expression has type `Option<String>`\n\
    \   |         |\n   |         expected struct `String`, found reference\n   |\
    \         help: you can probably remove the explicit borrow: `s`\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpozlivyq6.rs:18:9\n   |\n18 |     for &s in lst2 {\n   |\
    \         ^^    ---- this expression has type `Option<String>`\n   |         |\n\
    \   |         expected struct `String`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `s`\n   |\n   = note: expected struct\
    \ `String`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpozlivyq6.rs:25:9\n   |\n25 |     for &s in lst1 {\n   |       \
    \  ^^    ---- this expression has type `Option<String>`\n   |         |\n   |\
    \         expected struct `String`, found reference\n   |         help: you can\
    \ probably remove the explicit borrow: `s`\n   |\n   = note: expected struct `String`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpozlivyq6.rs:28:9\n\
    \   |\n28 |     for &s in lst2 {\n   |         ^^    ---- this expression has\
    \ type `Option<String>`\n   |         |\n   |         expected struct `String`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `s`\n   |\n   = note: expected struct `String`\n           found reference `&_`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpozlivyq6.rs:35:9\n   |\n35 | \
    \    for &s in lst1 {\n   |         ^^    ---- this expression has type `Option<String>`\n\
    \   |         |\n   |         expected struct `String`, found reference\n   |\
    \         help: you can probably remove the explicit borrow: `s`\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpozlivyq6.rs:40:9\n   |\n40 |     for &s in lst2 {\n   |\
    \         ^^    ---- this expression has type `Option<String>`\n   |         |\n\
    \   |         expect"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for s in lst1\
    \ {\n        if lst2.contains(&s) {\n            res.push(s);\n        }\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpc46cc5xu.rs:23:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut total_chars = lst1.len();\n    for i in 0..(lst1.len()\
    \ - lst2.len()) {\n        total_chars += lst1[i].chars().filter(|&x| x < lst2[i].chars()).count();\n\
    \    }\n    return lst1.iter().take(total_chars).collect();\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuunm07d8.rs:16:56\n   |\n\
    16 |         total_chars += lst1[i].chars().filter(|&x| x < lst2[i].chars()).count();\n\
    \   |                                                        ^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `Chars`\n\nerror[E0277]: a value of type `Vec<String>`\
    \ cannot be built from an iterator over elements of type `&String`\n    --> /tmp/tmpuunm07d8.rs:18:42\n\
    \     |\n18   |     return lst1.iter().take(total_chars).collect();\n     |  \
    \                                        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&String>`\n     |\n     = help: the\
    \ trait `FromIterator<&String>` is not implemented for `Vec<String>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for el1 in lst1\
    \ {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n     \
    \           total_len += el1.len();\n            }\n        }\n    }\n    if total_len\
    \ == 0 {\n        return lst1;\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_match_lst = vec![];\n    for el1 in lst1 {\n       \
    \ for el2 in lst2 {\n            if el1.len() < el2.len() {\n                total_match_lst.push(el1);\n\
    \                break;\n            }\n        }\n    }\n    return total_match_lst;\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp68tdgh7h.rs:13:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n13  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror[E0382]: use of moved value: `lst1`\n  --> /tmp/tmp68tdgh7h.rs:20:16\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11 |     let mut total_len = 0;\n\
    12 |     for el1 in lst1 {\n   |                ---- `lst1` moved due to this\
    \ implicit call to `.into_iter()`\n...\n20 |         return lst1;\n   |      \
    \          ^^^^ value used here after move\n   |\nhelp: consider iterating over\
    \ a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n12 |     for el1 in &lst1 {\n   |                +\n\nerror[E0382]: use\
    \ of moved value: `lst2`\n  --> /tmp/tmp68tdgh7h.rs:30:20\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n13 |         for el2 in lst2 {\n   |  \
    \                  ---- `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n...\n30 |         for el2 in lst2 {\n   |   \
    \                 ^^^^ `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n   |\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut result = Vec::new();\n    for i in\
    \ 0..lst1.len() {\n        if lst1[i].len() < lst2[i].len() {\n            result.push(lst1[i]);\n\
    \        } else {\n            result.push(lst2[i]);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp7alckrtp.rs:14:25\n\
    \   |\n14 |             result.push(lst1[i]);\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp7alckrtp.rs:16:25\n\
    \   |\n16 |             result.push(lst2[i]);\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_match: Vec<String> = vec![];\n\
    \    let mut total_match_len: usize = 0;\n    for el1 in lst1 {\n        for el2\
    \ in lst2 {\n            if el1.len() < el2.len() {\n                total_match_len\
    \ += el1.len();\n            } else {\n                total_match_len += el2.len();\n\
    \            }\n        }\n        total_match.push(el1);\n    }\n    if total_match_len\
    \ == 0 {\n        total_match.push(\"\");\n    }\n    total_match\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpph6gl9u0.rs:24:26\n   |\n\
    24 |         total_match.push(\"\");\n   |                          ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \  |\n   |                          expected struct `String`, found `&str`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for el1 in lst1\
    \ {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n     \
    \           res.push(el1);\n                break;\n            }\n        }\n\
    \    }\n    if res.len() == 0 {\n        res\n    } else {\n        res\n    }\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpz82_q3gd.rs:13:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n13  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ i in 0..lst1.len() {\n        total_chars += lst1[i].len();\n    }\n    for\
    \ i in 0..lst2.len() {\n        total_chars += lst2[i].len();\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_chars == lst2.len()\
    \ {\n        return lst2;\n    }\n    for i in 0..total_chars {\n        if lst1[i].len()\
    \ < lst2[i].len() {\n            return lst1;\n        }\n        if lst2[i].len()\
    \ < lst1[i].len() {\n            return lst2;\n        }\n    }\n    return lst1;\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"hi\", \"admin\", \"project\"]`,\n right: `[\"hi\", \"admin\"]`',\
    \ /tmp/tmp7s4a8bi2.rs:39:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for s in &lst1 {\n        total_chars += s.len();\n    }\n    let mut total_chars2\
    \ = lst2[0].len();\n    for s in &lst2 {\n        total_chars2 += s.len();\n \
    \   }\n    if total_chars == total_chars2 {\n        return vec![lst1[0]];\n \
    \   }\n    let mut res = vec![];\n    for s in &lst1 {\n        if total_chars\
    \ > total_chars2 {\n            if s.len() < total_chars {\n                res.push(s);\n\
    \            }\n        } else {\n            if s.len() > total_chars2 {\n  \
    \              res.push(s);\n            }\n        }\n    }\n    for s in &lst2\
    \ {\n        if total_chars > total_chars2 {\n            if s.len() < total_chars\
    \ {\n                res.push(s);\n            }\n        } else {\n         \
    \   if s.len() > total_chars2 {\n                res.push(s);\n            }\n\
    \        }\n    }\n    return res;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpae1xx7o_.rs:48:12\n   |\n\
    10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n48 |     return res;\n   |      \
    \      ^^^ expected struct `String`, found `&String`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<&String>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst2;\n    }\n    lst1\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpcabak1dn.rs:19:16\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n19  | \
    \        return lst2;\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst2`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n12  |     for s in &lst2 {\n   \
    \ |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for i in 0..lst1.len()\
    \ {\n        for j in 0..lst2.len() {\n            if lst1[i].len() < lst2[j].len()\
    \ {\n                res.push(lst1[i]);\n                break;\n            }\n\
    \        }\n    }\n    if res.len() == lst1.len() {\n        res\n    } else {\n\
    \        total_match(res, lst2)\n    }\n}\n\nfn main() {\n    let candidate =\
    \ total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpmfy4o34y.rs:15:26\n\
    \   |\n15 |                 res.push(lst1[i]);\n   |                         \
    \ ^^^^^^^ move occurs because value has type `String`, which does not implement\
    \ the `Copy` trait\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut res = vec![];\n    for s in lst1 {\n        if s.len() < total_len\
    \ {\n            res.push(s);\n        }\n    }\n    for s in lst2 {\n       \
    \ if s.len() < total_len {\n            res.push(s);\n        }\n    }\n    if\
    \ res.len() == 0 {\n        return vec![];\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmpe3u5qtgg.rs:22:14\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11  |     let mut total_len = 0;\n\
    12  |     for s in lst1 {\n    |              ---- `lst1` moved due to this implicit\
    \ call to `.into_iter()`\n...\n22  |     for s in lst1 {\n    |              ^^^^\
    \ value used here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n12 \
    \ |     for s in &lst1 {\n    |              +\n\nerror[E0382]: use of moved value:\
    \ `lst2`\n  --> /tmp/tmpe3u5qtgg.rs:27:14\n   |\n10 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                                  \
    \ ---- move occurs because `lst2` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n...\n15 |     for s in lst2 {\n   |              ---- `lst2`\
    \ moved due to this implicit call to `.into_iter()`\n...\n27 |     for s in lst2\
    \ {\n   |              ^^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n15 |     for s in &lst2 {\n   |              +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    if total_chars == lst1.len() {\n        return lst1;\n\
    \    }\n    return lst1;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp6i3k3her.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for x in lst1\
    \ {\n        if lst2.contains(&x) {\n            res.push(x);\n        }\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpt6plkp1k.rs:23:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut total_chars = lst1.len();\n    for i in 0..lst1.len()\
    \ {\n        total_chars += lst1[i].len();\n    }\n    for i in 0..lst2.len()\
    \ {\n        total_chars += lst2[i].len();\n    }\n    for i in 0..total_chars\
    \ {\n        if lst1[i] < lst2[i] {\n            return vec![lst1[i]];\n     \
    \   }\n    }\n    return vec![lst2[0]];\n}\n\nfn main() {\n    let candidate =\
    \ total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpli5_4q7c.rs:26:25\n\
    \   |\n26 |             return vec![lst1[i]];\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpli5_4q7c.rs:29:17\n\
    \   |\n29 |     return vec![lst2[0]];\n   |                 ^^^^^^^ move occurs\
    \ because value has type `String`, which does not implement the `Copy` trait\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    let mut result = vec![];\n    let mut i = 0;\n  \
    \  let mut j = 0;\n    while i < lst1.len() && j < lst2.len() {\n        if lst1[i]\
    \ < lst2[j] {\n            i += 1;\n        } else {\n            j += 1;\n  \
    \      }\n    }\n    while i < lst1.len() {\n        result.push(lst1[i]);\n \
    \       i += 1;\n    }\n    while j < lst2.len() {\n        result.push(lst2[j]);\n\
    \        j += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpb8e7je2v.rs:15:21\n\
    \   |\n15 |         return vec![lst1[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpb8e7je2v.rs:28:21\n\
    \   |\n28 |         result.push(lst1[i]);\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpb8e7je2v.rs:32:21\n\
    \   |\n32 |         result.push(lst2[j]);\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst1 {\n        total_chars += s.len();\n    }\n    for s in lst2 {\n \
    \       total_chars += s.len();\n    }\n    if total_chars == lst1.len() {\n \
    \       return vec![];\n    }\n    let mut res = vec![];\n    for s in lst1 {\n\
    \        if total_chars < s.len() {\n            break;\n        }\n        res.push(s);\n\
    \        total_chars -= s.len();\n    }\n    for s in lst2 {\n        if total_chars\
    \ < s.len() {\n            break;\n        }\n        res.push(s);\n        total_chars\
    \ -= s.len();\n    }\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmp17sjpk8c.rs:21:23\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for s in lst1 {\n\
    \    |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     if total_chars == lst1.len() {\n    |                       ^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice\
    \ of the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n\
    15  |     for s in &lst1 {\n    |              +\n\nerror[E0382]: borrow of moved\
    \ value: `s`\n  --> /tmp/tmp17sjpk8c.rs:30:24\n   |\n25 |     for s in lst1 {\n\
    \   |         - move occurs because `s` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n29 |         res.push(s);\n   |                  - value\
    \ moved here\n30 |         total_chars -= s.len();\n   |                     \
    \   ^^^^^^^ value borrowed here after move\n\nerror[E0382]: use of moved value:\
    \ `lst2`\n  --> /tmp/tmp17sjpk8c.rs:32:14\n   |\n10 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                                  \
    \ ---- move occurs because `lst2` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n...\n18 |     for s in lst2 {\n   |              ---- `lst2`\
    \ moved due to this implicit call to `.into_iter()`\n...\n32 |     for s in lst2\
    \ {\n   |              ^^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n18 |     for s in &lst2 {\n   |              +\n\nerror[E0382]: borrow\
    \ of moved value: `s`\n  --> /tmp/tmp17sjpk8c.rs:37:24\n   |\n32 |     for s in\
    \ lst2 {\n   |         - move occurs because `s` has type `String`, which does\
    \ not implement the `Copy` trait\n...\n36 |         res.push(s);\n   |       \
    \           - value moved here\n37 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for el1 in lst1\
    \ {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n     \
    \           res.push(el1);\n                break;\n            }\n        }\n\
    \    }\n    if res.len() == 0 {\n        res\n    } else {\n        res\n    }\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpbpqyg7m6.rs:13:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n13  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars > lst1.len() {\n        return lst2;\n    }\n\
    \    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpakwcrxmq.rs:22:16\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n22  | \
    \        return lst2;\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst2`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n12  |     for s in &lst2 {\n   \
    \ |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return lst1;\n    }\n \
    \   if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len == 0 {\n        return\
    \ lst2;\n    }\n    if total_len == lst1.len() {\n        return lst2;\n    }\n\
    \    if total_len == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n    for s in\
    \ lst2 {\n        total_len += s.len();\n    }\n    if total_len == 0 {\n    \
    \    return lst1;\n    }\n    if total_len == lst1.len() {\n        return lst2;\n\
    \    }\n    if total_len == lst2.len() {\n        return lst1;\n    }\n    let\
    \ mut total_len = 0;\n    for s in lst1 {\n        total_len += s.len();\n   \
    \ }\n    for s in lst2 {\n        total_len += s.len();\n    }\n    if total_len\
    \ == 0 {\n        return lst2;\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst2;\n    }\n    if total_len == lst2.len() {\n        return lst1;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len == 0 {\n        return lst2;\n    }\n    if total_len == lst1.len()\
    \ {\n        return lst2;\n    }\n    if total_len == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len\
    \ += s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n   \
    \ }\n    if total_len == 0 {\n        return lst2;\n    }\n    if total_len ==\
    \ lst1.len() {\n        return lst2;\n    }\n    if total_len == lst2.len() {\n\
    \        return lst1;\n    }\n    let mut total_len = 0;\n    for s in lst1 {\n\
    \        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return lst2;\n    }\n \
    \   if total_len\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmplr844x0h.rs:118:1\n    |\n\
    117 |     if total_len\n    |     -- this `if` expression has a condition, but\
    \ no block\n118 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars > lst1.len() {\n        return lst2;\n    }\n\
    \    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp47pqgr_2.rs:22:16\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n22  | \
    \        return lst2;\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst2`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n12  |     for s in &lst2 {\n   \
    \ |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst1 {\n        total_chars += s.len();\n    }\n    for s in lst2 {\n \
    \       total_chars += s.len();\n    }\n    if total_chars == lst1.len() {\n \
    \       return vec!lst1;\n    }\n    if total_chars == lst2.len() {\n        return\
    \ vec!lst2;\n    }\n    if total_chars < lst1.len() {\n        return vec!lst1;\n\
    \    }\n    if total_chars < lst2.len() {\n        return vec!lst2;\n    }\n \
    \   return vec![];\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: expected one of `(`, `[`, or `{`, found `lst1`\n  --> /tmp/tmpmy3zunuo.rs:22:20\n\
    \   |\n22 |         return vec!lst1;\n   |                    ^^^^ expected one\
    \ of `(`, `[`, or `{`\n\nerror: expected one of `(`, `[`, or `{`, found `lst2`\n\
    \  --> /tmp/tmpmy3zunuo.rs:25:20\n   |\n25 |         return vec!lst2;\n   |  \
    \                  ^^^^ expected one of `(`, `[`, or `{`\n\nerror: expected one\
    \ of `(`, `[`, or `{`, found `lst1`\n  --> /tmp/tmpmy3zunuo.rs:28:20\n   |\n28\
    \ |         return vec!lst1;\n   |                    ^^^^ expected one of `(`,\
    \ `[`, or `{`\n\nerror: expected one of `(`, `[`, or `{`, found `lst2`\n  -->\
    \ /tmp/tmpmy3zunuo.rs:31:20\n   |\n31 |         return vec!lst2;\n   |       \
    \             ^^^^ expected one of `(`, `[`, or `{`\n\nerror: aborting due to\
    \ 4 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars > lst1.len() {\n        return lst2;\n    }\n\
    \    let mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars\
    \ += s.len();\n    }\n    if total_chars == lst1.len() {\n        return lst1;\n\
    \    }\n    if total_chars < lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_chars > lst1.len() {\n        return lst2;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    if total_chars\
    \ < lst1.len() {\n        return lst1;\n    }\n    if total_chars > lst1.len()\
    \ {\n        return lst2;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars > lst1.len() {\n        return lst2;\n    }\n\
    \    let mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars\
    \ += s.len();\n    }\n    if total_chars == lst1.len() {\n        return lst1;\n\
    \    }\n    if total_chars < lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_chars > lst1.len() {\n        return lst2;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    if total_chars\
    \ < lst1.len() {\n        return lst1;\n    }\n    if total_chars > lst1.len()\
    \ {\n        return lst2;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars > lst1.len() {\n        return lst2;\n    }\n\
    \    let mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars\
    \ += s.len();\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9sxfy05j.rs:118:3\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n103 |     for s in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n104 |         total_chars\
    \ += s.len();\n105 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n118 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9sxfy05j.rs:10:57\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for s in &lst1 {\n        total_chars += s.len();\n    }\n    let mut total_chars2\
    \ = lst2[0].len();\n    for s in &lst2 {\n        total_chars2 += s.len();\n \
    \   }\n    if total_chars == total_chars2 {\n        return vec![];\n    }\n \
    \   let mut result = vec![];\n    for s in &lst1 {\n        if total_chars > total_chars2\
    \ {\n            result.push(s);\n        }\n    }\n    for s in &lst2 {\n   \
    \     if total_chars < total_chars2 {\n            result.push(s);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl92s153t.rs:36:5\n   |\n\
    10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n36 |     result\n   |     ^^^^^^\
    \ expected struct `String`, found `&String`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<&String>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = Vec::new();\n    for s in lst1\
    \ {\n        if lst2.contains(&s) {\n            res.push(s);\n        }\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpye4c9k_h.rs:23:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for i in 0..lst1.len() {\n        total_chars += lst1[i].len();\n    }\n   \
    \ for i in 0..lst2.len() {\n        total_chars += lst2[i].len();\n    }\n   \
    \ if total_chars == lst1[0].len() {\n        return vec![];\n    }\n    for i\
    \ in 0..lst1.len() {\n        if lst1[i].len() < lst2[i].len() {\n           \
    \ return vec![lst1[i]];\n        }\n    }\n    for i in 0..lst2.len() {\n    \
    \    if lst2[i].len() < lst1[i].len() {\n            return vec![lst2[i]];\n \
    \       }\n    }\n    return vec![lst1[0], lst2[0]];\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpfijrqsxk.rs:26:25\n\
    \   |\n26 |             return vec![lst1[i]];\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpfijrqsxk.rs:31:25\n\
    \   |\n31 |             return vec![lst2[i]];\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpfijrqsxk.rs:34:17\n\
    \   |\n34 |     return vec![lst1[0], lst2[0]];\n   |                 ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpfijrqsxk.rs:34:26\n\
    \   |\n34 |     return vec![lst1[0], lst2[0]];\n   |                         \
    \ ^^^^^^^ move occurs because value has type `String`, which does not implement\
    \ the `Copy` trait\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for s in lst1 {\n        total_chars += s.len();\n    }\n    for s in lst2 {\n\
    \        total_chars += s.len();\n    }\n    if total_chars < lst2.len() {\n \
    \       return lst1;\n    }\n    return lst2;\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst2`\n   --> /tmp/tmpwk2qf11g.rs:21:22\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \   for s in lst2 {\n    |              ---- `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     if total_chars < lst2.len() {\n    |\
    \                      ^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n18  |     for s in &lst2 {\n    |              +\n\
    \nerror[E0382]: use of moved value: `lst1`\n  --> /tmp/tmpwk2qf11g.rs:22:16\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15 |     for s in lst1 {\n \
    \  |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n22 |         return lst1;\n   |                ^^^^ value used here after\
    \ move\n   |\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n   |\n15 |     for s in &lst1 {\n   | \
    \             +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars > lst1.len() {\n        return lst2;\n    }\n\
    \    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpihr2jli1.rs:22:16\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n22  | \
    \        return lst2;\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst2`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n12  |     for s in &lst2 {\n   \
    \ |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for el1 in lst1\
    \ {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n     \
    \           total_len += el1.len();\n            } else {\n                total_len\
    \ += el2.len();\n            }\n        }\n    }\n    if total_len == 0 {\n  \
    \      return lst1;\n    }\n    if total_len == lst1.len() {\n        return lst1;\n\
    \    }\n    if total_len == lst2.len() {\n        return lst2;\n    }\n    let\
    \ mut total_len = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n     \
    \       if el1.len() < el2.len() {\n                total_len += el1.len();\n\
    \            } else {\n                total_len += el2.len();\n            }\n\
    \        }\n    }\n    if total_len == 0 {\n        return lst2;\n    }\n    if\
    \ total_len == lst1.len() {\n        return lst2;\n    }\n    if total_len ==\
    \ lst2.len() {\n        return lst1;\n    }\n    let mut total_len = 0;\n    for\
    \ el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len() < el2.len()\
    \ {\n                total_len += el1.len();\n            } else {\n         \
    \       total_len += el2.len();\n            }\n        }\n    }\n    if total_len\
    \ == 0 {\n        return lst1;\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for el1 in lst1 {\n        for el2 in\
    \ lst2 {\n            if el1.len() < el2.len() {\n                total_len +=\
    \ el1.len();\n            } else {\n                total_len += el2.len();\n\
    \            }\n        }\n    }\n    if total_len == 0 {\n        return lst2;\n\
    \    }\n    if total_len == lst1.len() {\n        return lst2;\n    }\n    if\
    \ total_len == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len()\
    \ < el2.len() {\n                total_len += el1.len();\n            } else {\n\
    \                total_len += el2.len();\n            }\n        }\n    }\n  \
    \  if total_len == 0 {\n        return lst2;\n    }\n    if total_len == lst1.len()\
    \ {\n        return lst2;\n    }\n    if total_len == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut total_len = 0;\n    for el1 in lst1 {\n        for\
    \ el2 in lst2 {\n            if el1.len() < el2.len(\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5gw22wy9.rs:123:3\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n107 |     for el1 in lst1 {\n    |             \
    \        - unclosed delimiter\n108 |         for el2 in lst2 {\n    |        \
    \                 - this delimiter might not be properly closed...\n109 |    \
    \         if el1.len() < el2.len(\n110 | }\n    | - ...as it matches this but\
    \ it has different indentation\n...\n123 | }\n    |   ^\n\nerror: expected `{`,\
    \ found `}`\n   --> /tmp/tmp5gw22wy9.rs:110:1\n    |\n109 |             if el1.len()\
    \ < el2.len(\n    |             -- this `if` expression has a condition, but no\
    \ block\n110 | }\n    | ^ expected `{`\n\nerror: mismatched closing delimiter:\
    \ `}`\n   --> /tmp/tmp5gw22wy9.rs:109:35\n    |\n10  | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n    |                                 \
    \                                    - closing delimiter possibly meant for this\n\
    ...\n109 |             if el1.len() < el2.len(\n    |                        \
    \           ^ unclosed delimiter\n110 | }\n    | ^ mismatched closing delimiter\n\
    \nerror[E0308]: mismatched types\n   --> /tmp/tmp5gw22wy9.rs:107:5\n    |\n10\
    \  |   fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    |                                                           ----------- expected\
    \ `Vec<String>` because of return type\n...\n107 | /     for el1 in lst1 {\n108\
    \ | |         for el2 in lst2 {\n109 | |             if el1.len() < el2.len(\n\
    110 | | }\n...   |\n122 | |     assert_eq!(candidate(vec![String::from(\"this\"\
    )], Vec::<String>::new()), Vec::<String>::new());\n123 | | }\n    | |__^ expected\
    \ struct `Vec`, found `()`\n    |\n    = note: expected struct `Vec<String>`\n\
    \            found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut result = vec![];\n    for i in 0..lst1.len()\
    \ {\n        let mut found = false;\n        for j in 0..lst2.len() {\n      \
    \      if lst1[i] == lst2[j] {\n                found = true;\n              \
    \  break;\n            }\n        }\n        if found {\n            result.push(lst1[i]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp9h0praz5.rs:24:25\n\
    \   |\n24 |             result.push(lst1[i]);\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut res = vec![];\n    let mut l1 = lst1.len();\n\
    \    let mut l2 = lst2.len();\n    while l1 > 0 || l2 > 0 {\n        if l1 > 0\
    \ {\n            if l2 > 0 {\n                if lst1[l1-1] == lst2[l2-1] {\n\
    \                    l1 -= 1;\n                    l2 -= 1;\n                }\
    \ else {\n                    res.push(lst1[l1-1]);\n                    l1 -=\
    \ 1;\n                }\n            } else {\n                res.push(lst1[l1-1]);\n\
    \                l1 -= 1;\n            }\n        } else {\n            if l2\
    \ > 0 {\n                res.push(lst2[l2-1]);\n                l2 -= 1;\n   \
    \         } else {\n                res.push(\"\");\n            }\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2rwv_vl2.rs:36:26\n   |\n\
    36 |                 res.push(\"\");\n   |                          ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \  |\n   |                          expected struct `String`, found `&str`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    let mut total_chars = vec![];\n    for el1 in lst1\
    \ {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n     \
    \           total_chars.push(el1);\n                break;\n            }\n  \
    \      }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpnpwccg2_.rs:15:21\n\
    \   |\n15 |         return vec![lst1[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpnpwccg2_.rs:19:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n19  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0382, E0507.\nFor more information about an error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut total_chars = lst1.len();\n    for x in lst2 {\n \
    \       total_chars += x.len();\n    }\n    if total_chars == lst1.len() {\n \
    \       return lst1;\n    }\n    let mut total_chars = lst1.len();\n    for x\
    \ in lst2 {\n        total_chars += x.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ x in lst2 {\n        total_chars += x.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ x in lst2 {\n        total_chars += x.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ x in lst2 {\n        total_chars += x.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ x in lst2 {\n        total_chars += x.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ x in lst2 {\n        total_chars += x.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ x in lst2 {\n        total_chars += x.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ x in lst2 {\n        total_chars += x.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ x in lst2 {\n        total_chars += x.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ x in lst2 {\n        total_chars += x.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ x in lst2 {\n        total_chars += x.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ x in lst2 {\n\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpgi30w6rx.rs:114:3\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n99  |     for x in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n100 | \n101 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n114 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgi30w6rx.rs:10:57\n \
    \  |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ i in 0..total_chars {\n        if lst1[i] < lst2[i] {\n            total_chars\
    \ -= 1;\n        }\n    }\n    if total_chars == 0 {\n        return vec![];\n\
    \    }\n    let mut res = vec![];\n    for i in 0..total_chars {\n        if lst1[i]\
    \ < lst2[i] {\n            res.push(lst1[i]);\n        } else {\n            res.push(lst2[i]);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpcto5rbg2.rs:26:22\n\
    \   |\n26 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpcto5rbg2.rs:28:22\n\
    \   |\n28 |             res.push(lst2[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    if total_chars == lst1.len() {\n        lst1\n    } else\
    \ {\n        lst1\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmprmxr0pwc.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ x in lst1 {\n        total_chars += x.len();\n    }\n    for x in lst2 {\n \
    \       total_chars += x.len();\n    }\n    if total_chars == lst1.len() {\n \
    \       return lst1;\n    }\n    if total_chars == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_chars = lst1.len();\n    for x in lst1 {\n \
    \       total_chars += x.len();\n    }\n    for x in lst2 {\n        total_chars\
    \ += x.len();\n    }\n    if total_chars < lst1.len() {\n        return vec![];\n\
    \    }\n    if total_chars < lst2.len() {\n        return vec![];\n    }\n   \
    \ let mut total_chars = lst1.len();\n    for x in lst1 {\n        total_chars\
    \ += x.len();\n    }\n    for x in lst2 {\n        total_chars += x.len();\n \
    \   }\n    if total_chars == lst1.len() {\n        return vec![];\n    }\n   \
    \ if total_chars == lst2.len() {\n        return vec![];\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for x in lst1 {\n        total_chars += x.len();\n    }\n\
    \    for x in lst2 {\n        total_chars += x.len();\n    }\n    if total_chars\
    \ < lst1.len() {\n        return vec![];\n    }\n    if total_chars < lst2.len()\
    \ {\n        return vec![];\n    }\n    let mut total_chars = lst1.len();\n  \
    \  for x in lst1 {\n        total_chars += x.len();\n    }\n    for x in lst2\
    \ {\n        total_chars += x.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return vec![];\n    }\n    if total_chars == lst2.len() {\n     \
    \   return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for x in\
    \ lst1 {\n        total_chars += x.len();\n    }\n    for x in lst2 {\n      \
    \  total_chars += x.len();\n    }\n    if total_chars < lst1.len() {\n       \
    \ return vec![];\n    }\n    if total_chars < lst2.len() {\n        return vec![];\n\
    \    }\n    let mut total_chars = lst1.len();\n    for x in lst1 {\n        total_chars\
    \ += x.len();\n    }\n    for x in lst2 {\n        total_chars += x.len();\n \
    \   }\n    if total_chars == lst1.len() {\n        return vec![];\n    }\n   \
    \ if total_chars == lst2.len() {\n        return vec![];\n\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpoc7f_26t.rs:118:3\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n102 |     if total_chars == lst2.len() {\n    |\
    \                                  - this delimiter might not be properly closed...\n\
    ...\n105 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n118 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoc7f_26t.rs:10:57\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for s in lst1 {\n        total_chars += s.len();\n    }\n    for s in lst2 {\n\
    \        total_chars += s.len();\n    }\n    if total_chars == lst1.len() {\n\
    \        return vec![];\n    }\n    let mut res = vec![];\n    for s in lst1 {\n\
    \        if total_chars < s.len() {\n            return vec![];\n        }\n \
    \       res.push(s);\n        total_chars -= s.len();\n    }\n    for s in lst2\
    \ {\n        if total_chars < s.len() {\n            return vec![];\n        }\n\
    \        res.push(s);\n        total_chars -= s.len();\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmpobt4qdop.rs:21:23\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for s in lst1 {\n\
    \    |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     if total_chars == lst1.len() {\n    |                       ^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice\
    \ of the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n\
    15  |     for s in &lst1 {\n    |              +\n\nerror[E0382]: borrow of moved\
    \ value: `s`\n  --> /tmp/tmpobt4qdop.rs:30:24\n   |\n25 |     for s in lst1 {\n\
    \   |         - move occurs because `s` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n29 |         res.push(s);\n   |                  - value\
    \ moved here\n30 |         total_chars -= s.len();\n   |                     \
    \   ^^^^^^^ value borrowed here after move\n\nerror[E0382]: use of moved value:\
    \ `lst2`\n  --> /tmp/tmpobt4qdop.rs:32:14\n   |\n10 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                                  \
    \ ---- move occurs because `lst2` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n...\n18 |     for s in lst2 {\n   |              ---- `lst2`\
    \ moved due to this implicit call to `.into_iter()`\n...\n32 |     for s in lst2\
    \ {\n   |              ^^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n18 |     for s in &lst2 {\n   |              +\n\nerror[E0382]: borrow\
    \ of moved value: `s`\n  --> /tmp/tmpobt4qdop.rs:37:24\n   |\n32 |     for s in\
    \ lst2 {\n   |         - move occurs because `s` has type `String`, which does\
    \ not implement the `Copy` trait\n...\n36 |         res.push(s);\n   |       \
    \           - value moved here\n37 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for i in 0..lst1.len()\
    \ {\n        let mut found = false;\n        for j in 0..lst2.len() {\n      \
    \      if lst1[i] == lst2[j] {\n                found = true;\n              \
    \  break;\n            }\n        }\n        if !found {\n            res.push(lst1[i]);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp1a8lmznc.rs:21:22\n\
    \   |\n21 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut total_chars = lst1.len();\n    for str1 in lst1 {\n\
    \        for str2 in lst2 {\n            if str1.len() < str2.len() {\n      \
    \          total_chars += str1.len();\n            }\n        }\n    }\n    lst1.iter().filter(|x|\
    \ x < total_chars).collect()\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp613hbs3e.rs:25:32\n   |\n\
    25 |     lst1.iter().filter(|x| x < total_chars).collect()\n   |             \
    \                   ^^^^^^^^^^^ expected `&&String`, found `usize`\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `&String`\n    --> /tmp/tmp613hbs3e.rs:25:45\n     |\n25   |     lst1.iter().filter(|x|\
    \ x < total_chars).collect()\n     |                                         \
    \    ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for el1 in lst1\
    \ {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n     \
    \           total_len += el1.len();\n            } else {\n                total_len\
    \ += el2.len();\n            }\n        }\n    }\n    if total_len == 0 {\n  \
    \      return lst1;\n    }\n    if total_len == lst1.len() {\n        return lst1;\n\
    \    }\n    if total_len == lst2.len() {\n        return lst2;\n    }\n    let\
    \ mut total_match = Vec::new();\n    for el1 in lst1 {\n        for el2 in lst2\
    \ {\n            if el1.len() < el2.len() {\n                total_match.push(el1);\n\
    \            } else {\n                total_match.push(el2);\n            }\n\
    \        }\n    }\n    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpsheownkt.rs:13:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n13  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror[E0382]: use of moved value: `lst1`\n  --> /tmp/tmpsheownkt.rs:22:16\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11 |     let mut total_len = 0;\n\
    12 |     for el1 in lst1 {\n   |                ---- `lst1` moved due to this\
    \ implicit call to `.into_iter()`\n...\n22 |         return lst1;\n   |      \
    \          ^^^^ value used here after move\n   |\nhelp: consider iterating over\
    \ a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n12 |     for el1 in &lst1 {\n   |                +\n\nerror[E0382]: use\
    \ of moved value: `lst2`\n  --> /tmp/tmpsheownkt.rs:32:20\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n13 |         for el2 in lst2 {\n   |  \
    \                  ---- `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n...\n32 |         for el2 in lst2 {\n   |   \
    \                 ^^^^ `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n   |\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut total_chars = lst1.len();\n    for x in lst1 {\n \
    \       total_chars += x.len();\n    }\n    for x in lst2 {\n        total_chars\
    \ += x.len();\n    }\n    if total_chars < lst2.len() {\n        return lst1;\n\
    \    }\n    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst2`\n   --> /tmp/tmp97olzzek.rs:21:22\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \   for x in lst2 {\n    |              ---- `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     if total_chars < lst2.len() {\n    |\
    \                      ^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n18  |     for x in &lst2 {\n    |              +\n\
    \nerror[E0382]: use of moved value: `lst1`\n  --> /tmp/tmp97olzzek.rs:22:16\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15 |     for x in lst1 {\n \
    \  |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n22 |         return lst1;\n   |                ^^^^ value used here after\
    \ move\n   |\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n   |\n15 |     for x in &lst1 {\n   | \
    \             +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return lst1;\n    }\n \
    \   if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = total_len\
    \ as usize;\n    let mut res = Vec::new();\n    for s in lst1 {\n        if total_len\
    \ < s.len() {\n            res.push(s);\n            total_len += s.len();\n \
    \       }\n    }\n    for s in lst2 {\n        if total_len < s.len() {\n    \
    \        res.push(s);\n            total_len += s.len();\n        }\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmpyz9fjyn4.rs:19:16\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11  |     let mut total_len = 0;\n\
    12  |     for s in lst1 {\n    |              ---- `lst1` moved due to this implicit\
    \ call to `.into_iter()`\n...\n19  |         return lst1;\n    |             \
    \   ^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `lst1`\nhelp: consider iterating over a\
    \ slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n \
    \   |\n12  |     for s in &lst1 {\n    |              +\n\nerror[E0382]: borrow\
    \ of moved value: `lst2`\n  --> /tmp/tmpyz9fjyn4.rs:24:21\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n15 |     for s in lst2 {\n   |        \
    \      ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n24\
    \ |     if total_len == lst2.len() {\n   |                     ^^^^^^^^^^ value\
    \ borrowed here after move\n   |\nhelp: consider iterating over a slice of the\
    \ `Vec<String>`'s content to avoid moving into the `for` loop\n   |\n15 |    \
    \ for s in &lst2 {\n   |              +\n\nerror[E0382]: borrow of moved value:\
    \ `s`\n  --> /tmp/tmpyz9fjyn4.rs:32:26\n   |\n29 |     for s in lst1 {\n   | \
    \        - move occurs because `s` has type `String`, which does not implement\
    \ the `Copy` trait\n30 |         if total_len < s.len() {\n31 |             res.push(s);\n\
    \   |                      - value moved here\n32 |             total_len += s.len();\n\
    \   |                          ^^^^^^^ value borrowed here after move\n\nerror[E0382]:\
    \ borrow of moved value: `s`\n  --> /tmp/tmpyz9fjyn4.rs:38:26\n   |\n35 |    \
    \ for s in lst2 {\n   |         - move occurs because `s` has type `String`, which\
    \ does not implement the `Copy` trait\n36 "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ x in lst1 {\n        if lst2.contains(&x) {\n            total_chars += 1;\n\
    \        }\n    }\n    if total_chars == lst2.len() {\n        return vec![];\n\
    \    }\n    let mut result = vec![];\n    for x in lst1 {\n        if lst2.contains(&x)\
    \ {\n            result.push(x);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmp2n9v8n9k.rs:24:14\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for x in lst1 {\n\
    \    |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n24  |     for x in lst1 {\n    |              ^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst1`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n15  |     for x in &lst1 {\n   \
    \ |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst1 {\n        total_chars += s.len();\n    }\n    for s in lst2 {\n \
    \       total_chars += s.len();\n    }\n    if total_chars < lst2.len() {\n  \
    \      return lst1;\n    }\n    return lst2;\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst2`\n   --> /tmp/tmpxieroddw.rs:21:22\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \   for s in lst2 {\n    |              ---- `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     if total_chars < lst2.len() {\n    |\
    \                      ^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n18  |     for s in &lst2 {\n    |              +\n\
    \nerror[E0382]: use of moved value: `lst1`\n  --> /tmp/tmpxieroddw.rs:22:16\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15 |     for s in lst1 {\n \
    \  |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n22 |         return lst1;\n   |                ^^^^ value used here after\
    \ move\n   |\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n   |\n15 |     for s in &lst1 {\n   | \
    \             +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars == lst1.len() {\n        return lst2;\n   \
    \ }\n    if total_chars < lst1.len() {\n        return lst2;\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_chars < lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars == lst1.len() {\n       \
    \ return lst2;\n    }\n    if total_chars < lst1.len() {\n        return lst2;\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_chars < lst1.len() {\n        return lst1;\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst2;\n    }\n    if total_chars < lst1.len()\
    \ {\n        return lst2;\n    }\n    if total_chars == lst1.len() {\n       \
    \ return lst1;\n    }\n    if total_chars < lst1.len() {\n        return lst2;\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_chars < lst1.len() {\n        return lst2;\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_chars < lst1.len()\
    \ {\n        return lst2;\n    }\n    if total_chars == lst1.len() {\n       \
    \ return lst1;\n    }\n    if total_chars < lst1.len() {\n        return lst2;\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_chars < lst1.len() {\n        return lst2;\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_chars < lst1.len()\
    \ {\n        return lst2;\n    }\n    if total_chars == lst1.len() {\n       \
    \ return lst1;\n    }\n    if total_chars < lst1.len() {\n        return lst2;\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_chars < lst1.len() {\n        return lst2;\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_chars < lst1.len()\
    \ {\n        return lst2;\n    }\n    if total_chars == lst1.len() {\n       \
    \ return lst1;\n    }\n    if total_chars < lst1.len() {\n        return lst2;\n\
    \    }\n    if total_chars == lst1.len(\n}\n\nfn main() {\n    let candidate =\
    \ total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmplionzi79.rs:112:1\n    |\n\
    111 |     if total_chars == lst1.len(\n    |     -- this `if` expression has a\
    \ condition, but no block\n112 | }\n    | ^ expected `{`\n\nerror: mismatched\
    \ closing delimiter: `}`\n   --> /tmp/tmplionzi79.rs:111:31\n    |\n10  | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n    |                    \
    \                                                 - closing delimiter possibly\
    \ meant for this\n...\n111 |     if total_chars == lst1.len(\n    |          \
    \                     ^ unclosed delimiter\n112 | }\n    | ^ mismatched closing\
    \ delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    lst1.iter().filter(|s| total_chars < s.len()).collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpuabqt99t.rs:17:51\n     |\n\
    17   |     lst1.iter().filter(|s| total_chars < s.len()).collect()\n     |   \
    \                                                ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n     |\n     = help:\
    \ the trait `FromIterator<&String>` is not implemented for `Vec<String>`\n   \
    \  = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for i in 0..lst1.len() {\n        total_chars += lst1[i].len();\n    }\n   \
    \ for i in 0..lst2.len() {\n        total_chars += lst2[i].len();\n    }\n   \
    \ if total_chars == lst1.len() {\n        return vec![lst1[0]];\n    }\n    if\
    \ total_chars == lst2.len() {\n        return vec![lst2[0]];\n    }\n    if total_chars\
    \ < lst1.len() {\n        return vec![lst1[0]];\n    }\n    if total_chars < lst2.len()\
    \ {\n        return vec![lst2[0]];\n    }\n    let mut result = vec![];\n    for\
    \ i in 0..(total_chars - lst1.len() - lst2.len()) {\n        result.push(vec![]);\n\
    \    }\n    for i in 0..(lst1.len() - total_chars) {\n        result[0].push(lst1[i]);\n\
    \    }\n    for i in 0..(lst2.len() - total_chars) {\n        result[0].push(lst2[i]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy33pz1iz.rs:43:5\n   |\n\
    10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n43 |     result\n   |     ^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut res = vec![];\n    for i in 0..lst1.len()\
    \ {\n        if lst1[i] < lst2[i] {\n            res.push(lst1[i]);\n        }\n\
    \    }\n    for i in 0..lst2.len() {\n        if lst1[i] < lst2[i] {\n       \
    \     res.push(lst2[i]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpvs8t9mfy.rs:17:22\n\
    \   |\n17 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpvs8t9mfy.rs:22:22\n\
    \   |\n22 |             res.push(lst2[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut result = vec![];\n    for el1 in\
    \ lst1 {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n\
    \                result.push(el1);\n                break;\n            }\n  \
    \      }\n    }\n    if result.len() == 0 {\n        result\n    } else {\n  \
    \      result\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n   \
    \ assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpllidminl.rs:13:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n13  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for i in 0..lst1.len()\
    \ {\n        let mut found = false;\n        for j in 0..lst2.len() {\n      \
    \      if lst1[i] == lst2[j] {\n                found = true;\n              \
    \  break;\n            }\n        }\n        if found {\n            res.push(lst1[i]);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpuj6resy5.rs:21:22\n\
    \   |\n21 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = Vec::new();\n    for s in lst1\
    \ {\n        if lst2.contains(&s) {\n            res.push(s);\n        }\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpp9w_n6jb.rs:23:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars == lst2.len() {\n       \
    \ return lst2;\n    }\n    if total_chars > lst1.len() {\n        return lst1;\n\
    \    }\n    if total_chars > lst2.len() {\n        return lst2;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_chars == lst2.len() {\n        return lst2;\n    }\n    if total_chars\
    \ > lst1.len() {\n        return lst1;\n    }\n    if total_chars > lst2.len()\
    \ {\n        return lst2;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars == lst2.len() {\n       \
    \ return lst2;\n    }\n    if total_chars > lst1.len() {\n        return lst1;\n\
    \    }\n    if total_chars > lst2.len() {\n        return lst2;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_chars == lst2.len() {\n        return lst2;\n    }\n    if total_chars\
    \ > lst1.len() {\n        return lst1;\n    }\n    if total_chars > lst2.len()\
    \ {\n        return lst2;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars == lst2.len() {\n       \
    \ return lst2;\n    }\n    if total_chars > lst1.len() {\n        return lst1;\n\
    \    }\n    if total_chars > lst2.len() {\n        return lst2;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_chars == lst2.len() {\n        return lst2;\n    }\n    if total_chars\
    \ > lst1.len() {\n        return lst1;\n    }\n    if total_chars > lst2.len()\
    \ {\n        return lst2;\n    }\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n   --> /tmp/tmp7f16q463.rs:107:11\n   \
    \ |\n107 |     let mu\n    |           ^ help: add `;` here\n108 | }\n    | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7f16q463.rs:10:57\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut total_chars = lst1.len();\n    for x in lst2 {\n \
    \       if total_chars > lst1.len() {\n            break;\n        }\n       \
    \ if x == &lst1[0] {\n            total_chars -= 1;\n        } else {\n      \
    \      break;\n        }\n    }\n    return lst1;\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpd9dgs02b.rs:19:14\n\
    \   |\n19 |         if x == &lst1[0] {\n   |              ^^ no implementation\
    \ for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for i in 0..lst1.len() {\n        total_chars += lst1[i].len();\n    }\n   \
    \ for i in 0..lst2.len() {\n        total_chars += lst2[i].len();\n    }\n   \
    \ if total_chars == 0 {\n        return vec![];\n    }\n    for i in 0..lst1.len()\
    \ {\n        if lst1[i].len() < lst2[i].len() {\n            return vec![lst1[i]];\n\
    \        }\n    }\n    for i in 0..lst2.len() {\n        if lst2[i].len() < lst1[i].len()\
    \ {\n            return vec![lst2[i]];\n        }\n    }\n    return vec![lst1[0],\
    \ lst2[0]];\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpfy1d1z41.rs:26:25\n\
    \   |\n26 |             return vec![lst1[i]];\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpfy1d1z41.rs:31:25\n\
    \   |\n31 |             return vec![lst2[i]];\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpfy1d1z41.rs:34:17\n\
    \   |\n34 |     return vec![lst1[0], lst2[0]];\n   |                 ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpfy1d1z41.rs:34:26\n\
    \   |\n34 |     return vec![lst1[0], lst2[0]];\n   |                         \
    \ ^^^^^^^ move occurs because value has type `String`, which does not implement\
    \ the `Copy` trait\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = vec![];\n    for x in\
    \ lst1 {\n        for y in lst2 {\n            if x.len() < y.len() {\n      \
    \          total_chars.push(x.len());\n            }\n        }\n    }\n    total_chars.sort();\n\
    \    total_chars.reverse();\n    total_chars.dedup();\n    total_chars\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo1ghj56y.rs:25:5\n   |\n\
    10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n25 |     total_chars\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found `usize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut res = vec![];\n    for s in lst1 {\n        if s.len() < total_len\
    \ {\n            res.push(s);\n        }\n    }\n    for s in lst2 {\n       \
    \ if s.len() < total_len {\n            res.push(s);\n        }\n    }\n    if\
    \ res.len() == 0 {\n        return vec![];\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmp7bps0q0f.rs:22:14\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11  |     let mut total_len = 0;\n\
    12  |     for s in lst1 {\n    |              ---- `lst1` moved due to this implicit\
    \ call to `.into_iter()`\n...\n22  |     for s in lst1 {\n    |              ^^^^\
    \ value used here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n12 \
    \ |     for s in &lst1 {\n    |              +\n\nerror[E0382]: use of moved value:\
    \ `lst2`\n  --> /tmp/tmp7bps0q0f.rs:27:14\n   |\n10 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                                  \
    \ ---- move occurs because `lst2` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n...\n15 |     for s in lst2 {\n   |              ---- `lst2`\
    \ moved due to this implicit call to `.into_iter()`\n...\n27 |     for s in lst2\
    \ {\n   |              ^^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n15 |     for s in &lst2 {\n   |              +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for s in &lst1 {\n        total_chars += s.len();\n    }\n    let mut total_chars2\
    \ = lst2[0].len();\n    for s in &lst2 {\n        total_chars2 += s.len();\n \
    \   }\n    if total_chars == total_chars2 {\n        return vec![];\n    }\n \
    \   let mut res = vec![];\n    for s in &lst1 {\n        if total_chars > total_chars2\
    \ {\n            if s.len() < total_chars {\n                res.push(s);\n  \
    \          }\n        } else {\n            if s.len() > total_chars2 {\n    \
    \            res.push(s);\n            }\n        }\n    }\n    for s in &lst2\
    \ {\n        if total_chars > total_chars2 {\n            if s.len() < total_chars\
    \ {\n                res.push(s);\n            }\n        } else {\n         \
    \   if s.len() > total_chars2 {\n                res.push(s);\n            }\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa8qih7a6.rs:48:5\n   |\n\
    10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n48 |     res\n   |     ^^^ expected\
    \ struct `String`, found `&String`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&String>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return lst1;\n    }\n \
    \   if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_match_len =\
    \ 0;\n    for s in lst1 {\n        total_match_len += s.len();\n    }\n    for\
    \ s in lst2 {\n        total_match_len += s.len();\n    }\n    if total_match_len\
    \ == total_len {\n        return lst1;\n    }\n    if total_match_len == total_len\
    \ {\n        return lst2;\n    }\n    let mut total_match_len = 0;\n    for s\
    \ in lst1 {\n        total_match_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_match_len += s.len();\n    }\n    if total_match_len == total_len\
    \ {\n        return lst1;\n    }\n    if total_match_len == total_len {\n    \
    \    return lst2;\n    }\n    let mut total_match_len = 0;\n    for s in lst1\
    \ {\n        total_match_len += s.len();\n    }\n    for s in lst2 {\n       \
    \ total_match_len += s.len();\n    }\n    if total_match_len == total_len {\n\
    \        return lst1;\n    }\n    if total_match_len == total_len {\n        return\
    \ lst2;\n    }\n    let mut total_match_len = 0;\n    for s in lst1 {\n      \
    \  total_match_len += s.len();\n    }\n    for s in lst2 {\n        total_match_len\
    \ += s.len();\n    }\n    if total_match_len == total_len {\n        return lst1;\n\
    \    }\n    if total_match_len == total_len {\n        return lst2;\n    }\n \
    \   let mut total_match_len = 0;\n    for s in lst1 {\n        total_match_len\
    \ += s.len();\n    }\n    for s in lst2 {\n        total_match_len += s.len();\n\
    \    }\n    if total_match_len == total_len {\n        return lst1;\n    }\n \
    \   if total_match_len == total_len {\n        return lst2;\n    }\n    let mut\
    \ total_match_len = 0;\n    for s in lst1 {\n        total_match_len += s.len();\n\
    \    }\n    for s in lst2 {\n        total_match_len += s.len();\n    }\n    if\
    \ total_match_len == total_len {\n        return lst1;\n    }\n    if total_match_len\
    \ == total_len {\n        return lst2;\n    }\n    let mut total_match_len = 0;\n\
    \    for s in lst1 {\n        total_match_len += s.len();\n    }\n    for s in\
    \ lst2 {\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpkwj84q8g.rs:123:3\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n109 |     for s in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n110 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n123 | }\n    |   ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpkwj84q8g.rs:10:57\n   |\n10 | fn\
    \ total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |   \
    \ -----------                                          ^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return lst1;\n    }\n \
    \   if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_match_len =\
    \ 0;\n    for s in lst1 {\n        total_match_len += s.len();\n    }\n    for\
    \ s in lst2 {\n        total_match_len += s.len();\n    }\n    if total_match_len\
    \ == 0 {\n        return lst1;\n    }\n    if total_match_len == lst1.len() {\n\
    \        return lst2;\n    }\n    if total_match_len == lst2.len() {\n       \
    \ return lst1;\n    }\n    let mut total_match_len = 0;\n    for s in lst1 {\n\
    \        total_match_len += s.len();\n    }\n    for s in lst2 {\n        total_match_len\
    \ += s.len();\n    }\n    if total_match_len == 0 {\n        return lst2;\n  \
    \  }\n    if total_match_len == lst1.len() {\n        return lst1;\n    }\n  \
    \  if total_match_len == lst2.len() {\n        return lst2;\n    }\n    let mut\
    \ total_match_len = 0;\n    for s in lst1 {\n        total_match_len += s.len();\n\
    \    }\n    for s in lst2 {\n        total_match_len += s.len();\n    }\n    if\
    \ total_match_len == 0 {\n        return lst1;\n    }\n    if total_match_len\
    \ == lst1.len() {\n        return lst2;\n    }\n    if total_match_len == lst2.len()\
    \ {\n        return lst1;\n    }\n    let mut total_match_len = 0;\n    for s\
    \ in lst1 {\n        total_match_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_match_len += s.len();\n    }\n    if total_match_len == 0 {\n \
    \       return lst2;\n    }\n    if total_match_len == lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_match_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_match_len = 0;\n    for s in lst1 {\n        total_match_len\
    \ += s.len();\n    }\n    for s in lst2 {\n        total_match_len += s.len();\n\
    \    }\n    if total_match_len == 0 {\n        return lst1;\n    }\n    if total_match_len\
    \ == lst1.len() {\n        return lst2;\n    }\n    if total_match_len == lst2.len()\
    \ {\n        return lst1;\n    }\n    let mut total_match_len = 0;\n    for s\
    \ in lst1 {\n        total_match_len += s.len();\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0x6ucx65.rs:123:3\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n108 |     for s in lst1 {\n    |               \
    \    - this delimiter might not be properly closed...\n109 |         total_match_len\
    \ += s.len();\n110 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n123 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0x6ucx65.rs:10:57\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    lst1\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpzud74rnu.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    if total_chars == lst1.len() {\n        lst1\n    } else\
    \ {\n        lst1\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp7wcxna3p.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_len = 0;\n    for x in lst1\
    \ {\n        total_len += x.len();\n    }\n    for x in lst2 {\n        total_len\
    \ += x.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut result = vec![];\n    for x in lst1 {\n        if x < lst2 {\n  \
    \          result.push(x);\n        }\n    }\n    for x in lst2 {\n        if\
    \ x < lst1 {\n            result.push(x);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6evy8p88.rs:26:16\n   |\n\
    26 |         if x < lst2 {\n   |                ^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6evy8p88.rs:31:16\n\
    \   |\n31 |         if x < lst1 {\n   |                ^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<String>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for el1 in lst1\
    \ {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n     \
    \           res.push(el1);\n                break;\n            }\n        }\n\
    \    }\n    if res.len() == 0 {\n        res\n    } else {\n        res\n    }\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpcn9vramf.rs:13:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n13  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    if total_chars == lst1.len() {\n        return lst1;\n\
    \    }\n    return lst1;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpnmctnb33.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    if total_chars == lst1.len() {\n        return lst1;\n\
    \    }\n    return lst1;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpe6ei9dc4.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = vec![];\n    for s in\
    \ lst1 {\n        total_chars.iter().for_each(|c| {\n            if s.chars().count()\
    \ < lst2.iter().for_each(|c| {\n                total_chars.push(c);\n       \
    \     });\n        });\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `;`\n  --> /tmp/tmpk74l6o6e.rs:19:15\n   |\n\
    17 |             if s.chars().count() < lst2.iter().for_each(|c| {\n   |     \
    \        -- this `if` expression has a condition, but no block\n18 |         \
    \        total_chars.push(c);\n19 |             });\n   |               ^ expected\
    \ `{`\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].chars().count();\n\
    \    for elem in lst1 {\n        if elem.chars().count() > total_chars {\n   \
    \         total_chars = elem.chars().count();\n        }\n    }\n    for elem\
    \ in lst2 {\n        if elem.chars().count() > total_chars {\n            total_chars\
    \ = elem.chars().count();\n        }\n    }\n    if total_chars == lst1[0].chars().count()\
    \ {\n        return vec![];\n    }\n    if total_chars == lst2[0].chars().count()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    for elem\
    \ in lst1 {\n        if elem.chars().count() < total_chars {\n            result.push(elem);\n\
    \        }\n    }\n    for elem in lst2 {\n        if elem.chars().count() < total_chars\
    \ {\n            result.push(elem);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmph9c7gmgu.rs:25:23\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for elem in lst1 {\n\
    \    |                 ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n25  |     if total_chars == lst1[0].chars().count() {\n    |            \
    \           ^^^^ value borrowed here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst1`\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \    |\n15  |     for elem in &lst1 {\n    |                 +\n\nerror[E0382]:\
    \ borrow of moved value: `lst2`\n  --> /tmp/tmph9c7gmgu.rs:28:23\n   |\n10 | fn\
    \ total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |   \
    \                                ---- move occurs because `lst2` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n20 |     for elem in lst2 {\n\
    \   |                 ---- `lst2` moved due to this implicit call to `.into_iter()`\n\
    ...\n28 |     if total_chars == lst2[0].chars().count() {\n   |              \
    \         ^^^^ value borrowed here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n20 |     for elem in &lst2 {\n   |                 +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for el1 in lst1\
    \ {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n     \
    \           total_len += el1.len();\n            } else {\n                total_len\
    \ += el2.len();\n            }\n        }\n    }\n    if total_len == 0 {\n  \
    \      return lst1;\n    }\n    if total_len == lst1.len() {\n        return lst1;\n\
    \    }\n    if total_len == lst2.len() {\n        return lst2;\n    }\n    let\
    \ mut total_match_lst = vec![];\n    for el1 in lst1 {\n        for el2 in lst2\
    \ {\n            if el1.len() < el2.len() {\n                total_match_lst.push(el1);\n\
    \                break;\n            }\n        }\n    }\n    for el1 in lst1\
    \ {\n        for el2 in lst2 {\n            if el1.len() == el2.len() {\n    \
    \            total_match_lst.push(el1);\n                break;\n            }\n\
    \        }\n    }\n    return total_match_lst;\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpqujsoyi_.rs:13:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n13  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror[E0382]: use of moved value: `lst1`\n  --> /tmp/tmpqujsoyi_.rs:22:16\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11 |     let mut total_len = 0;\n\
    12 |     for el1 in lst1 {\n   |                ---- `lst1` moved due to this\
    \ implicit call to `.into_iter()`\n...\n22 |         return lst1;\n   |      \
    \          ^^^^ value used here after move\n   |\nhelp: consider iterating over\
    \ a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n12 |     for el1 in &lst1 {\n   |                +\n\nerror[E0382]: use\
    \ of moved value: `lst2`\n  --> /tmp/tmpqujsoyi_.rs:32:20\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n13 |         for el2 in lst2 {\n   |  \
    \                  ---- `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n...\n32 |         for el2 in lst2 {\n   |   \
    \                 ^^^^ `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n   |\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    if total_chars == lst1.len() {\n        return lst1;\n\
    \    }\n    return lst1;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp0nqpmv0t.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = Vec::new();\n    for el1 in\
    \ lst1 {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n\
    \                res.push(el1);\n                break;\n            }\n     \
    \   }\n    }\n    if res.len() == 0 {\n        res\n    } else {\n        res\n\
    \    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpo7aqj4jp.rs:13:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n13  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for i in 0..lst1.len()\
    \ {\n        if lst1[i].len() < lst2[i].len() {\n            res.push(lst1[i]);\n\
    \        } else {\n            res.push(lst2[i]);\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpcsigp4b0.rs:14:22\n\
    \   |\n14 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpcsigp4b0.rs:16:22\n\
    \   |\n16 |             res.push(lst2[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ i in 0..lst1.len() {\n        total_chars += lst1[i].len();\n    }\n    for\
    \ i in 0..lst2.len() {\n        total_chars += lst2[i].len();\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_chars == lst2.len()\
    \ {\n        return lst2;\n    }\n    for i in 0..(lst1.len() + lst2.len()) {\n\
    \        if lst1[i].len() > lst2[i].len() {\n            lst1.swap(i, i + 1);\n\
    \        }\n        if lst2[i].len() > lst1[i].len() {\n            lst2.swap(i,\
    \ i + 1);\n        }\n    }\n    lst1\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `lst1` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp54wl13ov.rs:26:13\n   |\n10 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                ---- help: consider\
    \ changing this to be mutable: `mut lst1`\n...\n26 |             lst1.swap(i,\
    \ i + 1);\n   |             ^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `lst2` as mutable, as it is not declared as mutable\n  --> /tmp/tmp54wl13ov.rs:29:13\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                   ---- help: consider changing this\
    \ to be mutable: `mut lst2`\n...\n29 |             lst2.swap(i, i + 1);\n   |\
    \             ^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut result = vec![];\n    for s in lst1 {\n        if s.len() < total_len\
    \ {\n            result.push(s);\n        }\n    }\n    for s in lst2 {\n    \
    \    if s.len() < total_len {\n            result.push(s);\n        }\n    }\n\
    \    if result.len() == 0 {\n        return vec![];\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmprdh34bfv.rs:22:14\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11  |     let mut total_len = 0;\n\
    12  |     for s in lst1 {\n    |              ---- `lst1` moved due to this implicit\
    \ call to `.into_iter()`\n...\n22  |     for s in lst1 {\n    |              ^^^^\
    \ value used here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n12 \
    \ |     for s in &lst1 {\n    |              +\n\nerror[E0382]: use of moved value:\
    \ `lst2`\n  --> /tmp/tmprdh34bfv.rs:27:14\n   |\n10 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                                  \
    \ ---- move occurs because `lst2` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n...\n15 |     for s in lst2 {\n   |              ---- `lst2`\
    \ moved due to this implicit call to `.into_iter()`\n...\n27 |     for s in lst2\
    \ {\n   |              ^^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n15 |     for s in &lst2 {\n   |              +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut res = vec![];\n    for i in 0..lst1.len() {\n    \
    \    if lst1[i] < lst2[i] {\n            res.push(lst1[i]);\n        }\n    }\n\
    \    return res;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpriv923g1.rs:17:22\n\
    \   |\n17 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut res = vec![];\n    for x in lst1 {\n\
    \        if lst2.iter().any(|y| x.chars().any(|z| z.cmp(y) < 0)) {\n         \
    \   res.push(x);\n        }\n    }\n    for x in lst2 {\n        if lst1.iter().any(|y|\
    \ x.chars().any(|z| z.cmp(y) < 0)) {\n            res.push(x);\n        }\n  \
    \  }\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbryqmw3.rs:16:56\n   |\n\
    16 |         if lst2.iter().any(|y| x.chars().any(|z| z.cmp(y) < 0)) {\n   | \
    \                                                       ^ expected `char`, found\
    \ struct `String`\n   |\n   = note: expected reference `&char`\n             \
    \ found reference `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxbryqmw3.rs:16:61\n\
    \   |\n16 |         if lst2.iter().any(|y| x.chars().any(|z| z.cmp(y) < 0)) {\n\
    \   |                                                             ^ expected enum\
    \ `std::cmp::Ordering`, found integer\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxbryqmw3.rs:21:56\n   |\n21 |         if lst1.iter().any(|y| x.chars().any(|z|\
    \ z.cmp(y) < 0)) {\n   |                                                     \
    \   ^ expected `char`, found struct `String`\n   |\n   = note: expected reference\
    \ `&char`\n              found reference `&String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxbryqmw3.rs:21:61\n   |\n21 |         if lst1.iter().any(|y|\
    \ x.chars().any(|z| z.cmp(y) < 0)) {\n   |                                   \
    \                          ^ expected enum `std::cmp::Ordering`, found integer\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    let mut res = vec![];\n    for el1 in lst1 {\n  \
    \      for el2 in lst2 {\n            if el1.len() < el2.len() {\n           \
    \     res.push(el1);\n                break;\n            }\n        }\n    }\n\
    \    return res;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpwalq543e.rs:15:21\n\
    \   |\n15 |         return vec![lst1[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpwalq543e.rs:19:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n19  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0382, E0507.\nFor more information about an error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    let mut res = vec![];\n    for i in 0..lst1.len()\
    \ {\n        for j in 0..lst2.len() {\n            if lst1[i] < lst2[j] {\n  \
    \              break;\n            }\n        }\n        if j == lst2.len() {\n\
    \            res.push(lst1[i]);\n        }\n    }\n    return res;\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmpmden_7v_.rs:24:12\n\
    \   |\n24 |         if j == lst2.len() {\n   |            ^ help: a local variable\
    \ with a similar name exists: `i`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    let mut total_len = 0;\n    for &s in lst1 {\n  \
    \      total_len += s.len();\n    }\n    for &s in lst2 {\n        total_len +=\
    \ s.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n  \
    \  let mut total_matches: Vec<String> = vec![];\n    for &s in lst1 {\n      \
    \  if total_len < s.len() {\n            break;\n        }\n        total_matches.push(s);\n\
    \    }\n    for &s in lst2 {\n        if total_len < s.len() {\n            break;\n\
    \        }\n        total_matches.push(s);\n    }\n    total_matches\n}\n\nfn\
    \ main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8wrcv8he.rs:18:9\n   |\n\
    18 |     for &s in lst1 {\n   |         ^^    ---- this expression has type `Option<String>`\n\
    \   |         |\n   |         expected struct `String`, found reference\n   |\
    \         help: you can probably remove the explicit borrow: `s`\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8wrcv8he.rs:21:9\n   |\n21 |     for &s in lst2 {\n   |\
    \         ^^    ---- this expression has type `Option<String>`\n   |         |\n\
    \   |         expected struct `String`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `s`\n   |\n   = note: expected struct\
    \ `String`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8wrcv8he.rs:28:9\n   |\n28 |     for &s in lst1 {\n   |       \
    \  ^^    ---- this expression has type `Option<String>`\n   |         |\n   |\
    \         expected struct `String`, found reference\n   |         help: you can\
    \ probably remove the explicit borrow: `s`\n   |\n   = note: expected struct `String`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wrcv8he.rs:34:9\n\
    \   |\n34 |     for &s in lst2 {\n   |         ^^    ---- this expression has\
    \ type `Option<String>`\n   |         |\n   |         expected struct `String`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `s`\n   |\n   = note: expected struct `String`\n           found reference `&_`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    let mut total_chars = vec![];\n    for el1 in lst1\
    \ {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n     \
    \           total_chars.push(el1);\n                break;\n            }\n  \
    \      }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpd6k50yas.rs:15:21\n\
    \   |\n15 |         return vec![lst1[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpd6k50yas.rs:19:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n19  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0382, E0507.\nFor more information about an error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    for s in\
    \ lst1 {\n        if total_chars < s.len() {\n            result.push(s);\n  \
    \          total_chars += s.len();\n        } else {\n            result.push(s);\n\
    \            total_chars = total_chars - s.len();\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp_re1ggco.rs:25:28\n\
    \   |\n22 |     for s in lst1 {\n   |         - move occurs because `s` has type\
    \ `String`, which does not implement the `Copy` trait\n23 |         if total_chars\
    \ < s.len() {\n24 |             result.push(s);\n   |                        \
    \ - value moved here\n25 |             total_chars += s.len();\n   |         \
    \                   ^^^^^^^ value borrowed here after move\n\nerror[E0382]: borrow\
    \ of moved value: `s`\n  --> /tmp/tmp_re1ggco.rs:28:41\n   |\n22 |     for s in\
    \ lst1 {\n   |         - move occurs because `s` has type `String`, which does\
    \ not implement the `Copy` trait\n...\n27 |             result.push(s);\n   |\
    \                         - value moved here\n28 |             total_chars = total_chars\
    \ - s.len();\n   |                                         ^^^^^^^ value borrowed\
    \ here after move\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpjqr06gna.rs:21:12\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n21  | \
    \    return lst2;\n    |            ^^^^ value used here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |     for s in &lst2 {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for i in 0..lst1.len()\
    \ {\n        if lst1[i].len() < lst2[i].len() {\n            res.push(lst1[i]);\n\
    \        } else {\n            res.push(lst2[i]);\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpogg50j1w.rs:14:22\n\
    \   |\n14 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpogg50j1w.rs:16:22\n\
    \   |\n16 |             res.push(lst2[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars > lst1.len() {\n        return lst2;\n    }\n\
    \    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmplrqbqnm2.rs:22:16\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n22  | \
    \        return lst2;\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst2`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n12  |     for s in &lst2 {\n   \
    \ |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    if total_chars == lst1.len() {\n        lst1\n    } else\
    \ {\n        lst1\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpilhsw56w.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ i in 0..lst1.len() {\n        total_chars += lst1[i].len();\n    }\n    for\
    \ i in 0..lst2.len() {\n        total_chars += lst2[i].len();\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_chars == lst2.len()\
    \ {\n        return lst2;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars < lst2.len() {\n        return lst2;\n    }\n\
    \    return vec![];\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpcxqa3vcw.rs:39:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    if total_chars == lst1.len() {\n        return lst1;\n\
    \    }\n    if total_chars == lst2.len() {\n        return lst2;\n    }\n    let\
    \ mut lst3 = vec![\"\".to_string(); lst1.len()];\n    for i in 0..(total_chars\
    \ - lst2.len()) {\n        lst3[i] = lst1[i];\n    }\n    for i in 0..(lst2.len()\
    \ - total_chars) {\n        lst3[i + lst1.len()] = lst2[i];\n    }\n    lst3\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst2`\n   --> /tmp/tmpxhghktib.rs:20:23\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n20  | \
    \    if total_chars == lst2.len() {\n    |                       ^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst2`\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n12 \
    \ |     for s in &lst2 {\n    |              +\n\nerror[E0507]: cannot move out\
    \ of index of `Vec<String>`\n  --> /tmp/tmpxhghktib.rs:25:19\n   |\n25 |     \
    \    lst3[i] = lst1[i];\n   |                   ^^^^^^^ move occurs because value\
    \ has type `String`, which does not implement the `Copy` trait\n\nerror[E0507]:\
    \ cannot move out of index of `Vec<String>`\n  --> /tmp/tmpxhghktib.rs:28:32\n\
    \   |\n28 |         lst3[i + lst1.len()] = lst2[i];\n   |                    \
    \            ^^^^^^^ move occurs because value has type `String`, which does not\
    \ implement the `Copy` trait\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0507.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst1 {\n        total_chars += s.len();\n    }\n    for s in lst2 {\n \
    \       total_chars += s.len();\n    }\n    if total_chars == lst1.len() {\n \
    \       return vec![];\n    }\n    let mut result = vec![];\n    for s in lst1\
    \ {\n        if total_chars < s.len() {\n            result.push(s);\n       \
    \ }\n    }\n    for s in lst2 {\n        if total_chars < s.len() {\n        \
    \    result.push(s);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmpp1hlhl3h.rs:21:23\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for s in lst1 {\n\
    \    |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     if total_chars == lst1.len() {\n    |                       ^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice\
    \ of the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n\
    15  |     for s in &lst1 {\n    |              +\n\nerror[E0382]: use of moved\
    \ value: `lst2`\n  --> /tmp/tmpp1hlhl3h.rs:30:14\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n18 |     for s in lst2 {\n   |        \
    \      ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n30\
    \ |     for s in lst2 {\n   |              ^^^^ value used here after move\n \
    \  |\nhelp: consider iterating over a slice of the `Vec<String>`'s content to\
    \ avoid moving into the `for` loop\n   |\n18 |     for s in &lst2 {\n   |    \
    \          +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_len = 0;\n    for x in lst1\
    \ {\n        total_len += x.len();\n    }\n    for x in lst2 {\n        total_len\
    \ += x.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut res = vec![];\n    for x in lst1 {\n        if x < lst2 {\n     \
    \       res.push(x);\n        }\n    }\n    for x in lst2 {\n        if x < lst1\
    \ {\n            res.push(x);\n        }\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2bxzc8pk.rs:26:16\n   |\n\
    26 |         if x < lst2 {\n   |                ^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2bxzc8pk.rs:31:16\n\
    \   |\n31 |         if x < lst1 {\n   |                ^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<String>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].chars().count();\n\
    \    for i in 1..lst1.len() {\n        total_chars += lst1[i].chars().count();\n\
    \    }\n    for i in 1..lst2.len() {\n        total_chars += lst2[i].chars().count();\n\
    \    }\n    if total_chars == lst1.len() {\n        return vec![lst1[0]];\n  \
    \  }\n    if total_chars == lst2.len() {\n        return vec![lst2[0]];\n    }\n\
    \    if total_chars < lst1.len() {\n        return vec![lst1[0]];\n    }\n   \
    \ if total_chars < lst2.len() {\n        return vec![lst2[0]];\n    }\n    let\
    \ mut result = vec![];\n    for i in 1..lst1.len() {\n        if lst1[i].chars().count()\
    \ < lst2[i].chars().count() {\n            result.push(lst1[i]);\n        } else\
    \ {\n            result.push(lst2[i]);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpivqfjken.rs:22:21\n\
    \   |\n22 |         return vec![lst1[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpivqfjken.rs:25:21\n\
    \   |\n25 |         return vec![lst2[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpivqfjken.rs:28:21\n\
    \   |\n28 |         return vec![lst1[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpivqfjken.rs:31:21\n\
    \   |\n31 |         return vec![lst2[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpivqfjken.rs:36:25\n\
    \   |\n36 |             result.push(lst1[i]);\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpivqfjken.rs:38:25\n\
    \   |\n38 |             result.push(lst2[i]);\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 6 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for i in 0..lst1.len()\
    \ {\n        for j in 0..lst2.len() {\n            if lst1[i].len() < lst2[j].len()\
    \ {\n                res.push(lst1[i]);\n                break;\n            }\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp4lz_rqc9.rs:15:26\n\
    \   |\n15 |                 res.push(lst1[i]);\n   |                         \
    \ ^^^^^^^ move occurs because value has type `String`, which does not implement\
    \ the `Copy` trait\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for s in lst1 {\n        total_chars += s.len();\n    }\n    for s in lst2 {\n\
    \        total_chars += s.len();\n    }\n    if total_chars == lst1[0].len() {\n\
    \        return vec![];\n    }\n    let mut result = vec![];\n    for s in lst1\
    \ {\n        if total_chars < s.len() {\n            return vec![];\n        }\n\
    \        result.push(s);\n        total_chars -= s.len();\n    }\n    for s in\
    \ lst2 {\n        if total_chars < s.len() {\n            return vec![];\n   \
    \     }\n        result.push(s);\n        total_chars -= s.len();\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmpii9xaga2.rs:21:23\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for s in lst1 {\n\
    \    |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     if total_chars == lst1[0].len() {\n    |                      \
    \ ^^^^ value borrowed here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `lst1`\nhelp: consider iterating over a\
    \ slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n \
    \   |\n15  |     for s in &lst1 {\n    |              +\n\nerror[E0382]: borrow\
    \ of moved value: `s`\n  --> /tmp/tmpii9xaga2.rs:30:24\n   |\n25 |     for s in\
    \ lst1 {\n   |         - move occurs because `s` has type `String`, which does\
    \ not implement the `Copy` trait\n...\n29 |         result.push(s);\n   |    \
    \                 - value moved here\n30 |         total_chars -= s.len();\n \
    \  |                        ^^^^^^^ value borrowed here after move\n\nerror[E0382]:\
    \ use of moved value: `lst2`\n  --> /tmp/tmpii9xaga2.rs:32:14\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n18 |     for s in lst2 {\n   |        \
    \      ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n32\
    \ |     for s in lst2 {\n   |              ^^^^ value used here after move\n \
    \  |\nhelp: consider iterating over a slice of the `Vec<String>`'s content to\
    \ avoid moving into the `for` loop\n   |\n18 |     for s in &lst2 {\n   |    \
    \          +\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpii9xaga2.rs:37:24\n\
    \   |\n32 |     for s in lst2 {\n   |         - move occurs because `s` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n36 |         result.push(s);\n\
    \   |                     - value moved he"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for s in &lst1 {\n        total_chars += s.len();\n    }\n    let mut total_chars2\
    \ = lst2[0].len();\n    for s in &lst2 {\n        total_chars2 += s.len();\n \
    \   }\n    if total_chars == total_chars2 {\n        return vec![lst1[0]];\n \
    \   }\n    if total_chars < total_chars2 {\n        return vec![lst1[0]];\n  \
    \  }\n    vec![lst1[0]]\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpcurydh4n.rs:23:21\n\
    \   |\n23 |         return vec![lst1[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpcurydh4n.rs:26:21\n\
    \   |\n26 |         return vec![lst1[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpcurydh4n.rs:28:10\n\
    \   |\n28 |     vec![lst1[0]]\n   |          ^^^^^^^ move occurs because value\
    \ has type `String`, which does not implement the `Copy` trait\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for i in 0..lst1.len()\
    \ {\n        if lst1[i].len() < lst2[i].len() {\n            res.push(lst1[i]);\n\
    \        } else {\n            res.push(lst2[i]);\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpque1ocns.rs:14:22\n\
    \   |\n14 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpque1ocns.rs:16:22\n\
    \   |\n16 |             res.push(lst2[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    if total_chars == lst1.len() {\n        return lst1;\n\
    \    }\n    if total_chars == lst2.len() {\n        return lst2;\n    }\n    let\
    \ mut res = vec![];\n    for s in lst1 {\n        if total_chars > s.len() {\n\
    \            total_chars = s.len();\n        }\n    }\n    for s in lst2 {\n \
    \       if total_chars > s.len() {\n            total_chars = s.len();\n     \
    \   }\n    }\n    for s in lst1 {\n        if total_chars > s.len() {\n      \
    \      total_chars = s.len();\n        }\n    }\n    for s in lst2 {\n       \
    \ if total_chars > s.len() {\n            total_chars = s.len();\n        }\n\
    \    }\n    for s in lst1 {\n        if total_chars > s.len() {\n            total_chars\
    \ = s.len();\n        }\n    }\n    for s in lst2 {\n        if total_chars >\
    \ s.len() {\n            total_chars = s.len();\n        }\n    }\n    for s in\
    \ lst1 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    for s in lst2 {\n        if total_chars > s.len() {\n \
    \           total_chars = s.len();\n        }\n    }\n    for s in lst1 {\n  \
    \      if total_chars > s.len() {\n            total_chars = s.len();\n      \
    \  }\n    }\n    for s in lst2 {\n        if total_chars > s.len() {\n       \
    \     total_chars = s.len();\n        }\n    }\n    for s in lst1 {\n        if\
    \ total_chars > s.len() {\n            total_chars = s.len();\n        }\n   \
    \ }\n    for s in lst2 {\n        if total_chars > s.len() {\n            total_chars\
    \ = s.len();\n        }\n    }\n    for s in lst1 {\n        if total_chars >\
    \ s.len() {\n            total_chars = s.len();\n        }\n    }\n    for s in\
    \ lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    for s in lst1 {\n        if total_chars > s.len() {\n \
    \           total_chars = s.len();\n        }\n    }\n    for s in lst2 {\n  \
    \      if total_chars > s.len() {\n            total_chars = s.len();\n      \
    \  }\n    }\n    for s in lst1 {\n        if total_chars > s.len() {\n       \
    \     total_chars = s.len();\n        }\n    }\n    for s in lst2 {\n        if\
    \ total_chars > s.len() {\n            total_chars = s.len();\n        }\n   \
    \ }\n    for s in lst1 {\n        if total_\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpulbtsqhr.rs:129:3\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n114 |     for s in lst1 {\n    |               \
    \    - this delimiter might not be properly closed...\n115 |         if total_\n\
    116 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    129 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpulbtsqhr.rs:116:1\n\
    \    |\n115 |         if total_\n    |         -- this `if` expression has a condition,\
    \ but no block\n116 | }\n    | ^ expected `{`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpulbtsqhr.rs:10:57\n   |\n10 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |    -----------                   \
    \                       ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |  \
    \  |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for elem in lst1\
    \ {\n        total_len += elem.len();\n    }\n    for elem in lst2 {\n       \
    \ total_len += elem.len();\n    }\n    if total_len == 0 {\n        return vec![];\n\
    \    }\n    let mut result = vec![];\n    for elem in lst1 {\n        if elem.len()\
    \ < total_len {\n            result.push(elem);\n        }\n    }\n    for elem\
    \ in lst2 {\n        if elem.len() < total_len {\n            result.push(elem);\n\
    \        }\n    }\n    if result.len() == 0 {\n        return vec![];\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmp16k1t3bk.rs:22:17\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11  |     let mut total_len = 0;\n\
    12  |     for elem in lst1 {\n    |                 ---- `lst1` moved due to this\
    \ implicit call to `.into_iter()`\n...\n22  |     for elem in lst1 {\n    |  \
    \               ^^^^ value used here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst1`\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \    |\n12  |     for elem in &lst1 {\n    |                 +\n\nerror[E0382]:\
    \ use of moved value: `lst2`\n  --> /tmp/tmp16k1t3bk.rs:27:17\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n15 |     for elem in lst2 {\n   |     \
    \            ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n\
    27 |     for elem in lst2 {\n   |                 ^^^^ value used here after move\n\
    \   |\nhelp: consider iterating over a slice of the `Vec<String>`'s content to\
    \ avoid moving into the `for` loop\n   |\n15 |     for elem in &lst2 {\n   | \
    \                +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    let mut res = vec![];\n    for i in 0..lst1.len()\
    \ {\n        if lst1[i].len() < lst2[i].len() {\n            for j in 0..lst1[i].len()\
    \ {\n                if lst1[i][j] < lst2[i][j] {\n                    res.push(lst1[i]);\n\
    \                    break;\n                }\n            }\n        } else\
    \ {\n            for j in 0..lst2[i].len() {\n                if lst1[i][j] >\
    \ lst2[i][j] {\n                    res.push(lst2[i]);\n                    break;\n\
    \                }\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv2u09ayl.rs:21:20\n\
    \   |\n21 |                 if lst1[i][j] < lst2[i][j] {\n   |               \
    \     ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpv2u09ayl.rs:21:33\n   |\n21 |                 if lst1[i][j] < lst2[i][j]\
    \ {\n   |                                 ^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpv2u09ayl.rs:28:20\n   |\n28 |                 if lst1[i][j] > lst2[i][j]\
    \ {\n   |                    ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std:"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpkxlr86wq.rs:21:12\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n21  | \
    \    return lst2;\n    |            ^^^^ value used here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |     for s in &lst2 {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    if total_chars == lst1.len() {\n        return lst1;\n\
    \    }\n    return lst1;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmplaypdafa.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst1 {\n        total_chars += s.len();\n    }\n    for s in lst2 {\n \
    \       total_chars += s.len();\n    }\n    if total_chars == lst1.len() {\n \
    \       return lst1;\n    }\n    if total_chars == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_chars = lst1.len();\n    for s in lst1 {\n \
    \       total_chars += s.len();\n    }\n    for s in lst2 {\n        total_chars\
    \ += s.len();\n    }\n    if total_chars < lst1.len() {\n        return lst1;\n\
    \    }\n    if total_chars < lst2.len() {\n        return lst2;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst1 {\n        total_chars += s.len();\n\
    \    }\n    for s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars\
    \ == lst1.len() {\n        return vec![];\n    }\n    if total_chars == lst2.len()\
    \ {\n        return vec![];\n    }\n    let mut total_chars = lst1.len();\n  \
    \  for s in lst1 {\n        total_chars += s.len();\n    }\n    for s in lst2\
    \ {\n        total_chars += s.len();\n    }\n    if total_chars > lst1.len() {\n\
    \        return vec![];\n    }\n    if total_chars > lst2.len() {\n        return\
    \ vec![];\n    }\n    let mut total_chars = lst1.len();\n    for s in lst1 {\n\
    \        total_chars += s.len();\n    }\n    for s in lst2 {\n        total_chars\
    \ += s.len();\n    }\n    if total_chars == lst1.len() {\n        return vec![];\n\
    \    }\n    if total_chars == lst2.len() {\n        return vec![];\n    }\n  \
    \  let mut total_chars = lst1.len();\n    for s in lst1 {\n        total_chars\
    \ += s.len();\n    }\n    for s in lst2 {\n        total_chars += s.len();\n \
    \   }\n    if total_chars > lst1.len() {\n        return vec![];\n    }\n    if\
    \ total_chars > lst2.len() {\n        return vec![];\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst1 {\n        total_chars += s.len();\n    }\n\
    \    for s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars\
    \ == lst1.len() {\n        return vec![];\n    }\n    if total_chars == lst2.len()\
    \ {\n        return vec![];\n    }\n\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0317]: `if` may be missing an `else` clause\n   --> /tmp/tmpsr6emvcy.rs:102:5\n\
    \    |\n10  |   fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                           -----------\
    \ expected `Vec<String>` because of this return type\n...\n102 | /     if total_chars\
    \ == lst2.len() {\n103 | |         return vec![];\n104 | |     }\n    | |_____^\
    \ expected struct `Vec`, found `()`\n    |\n    = note: expected struct `Vec<String>`\n\
    \            found unit type `()`\n    = note: `if` expressions without `else`\
    \ evaluate to `()`\n    = help: consider adding an `else` block that evaluates\
    \ to the expected type\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0317`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst1 {\n        total_chars += s.len();\n    }\n    for s in lst2 {\n \
    \       total_chars += s.len();\n    }\n    if total_chars == lst1.len() {\n \
    \       return vec![];\n    }\n    let mut result = vec![];\n    for s in lst1\
    \ {\n        if total_chars < s.len() {\n            return vec![];\n        }\n\
    \        let mut found = false;\n        for s2 in lst2 {\n            if s.contains(&s2)\
    \ {\n                found = true;\n                break;\n            }\n  \
    \      }\n        if found {\n            result.push(s);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmp_n7o30t9.rs:21:23\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for s in lst1 {\n\
    \    |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     if total_chars == lst1.len() {\n    |                       ^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice\
    \ of the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n\
    15  |     for s in &lst1 {\n    |              +\n\nerror[E0382]: use of moved\
    \ value: `lst2`\n  --> /tmp/tmp_n7o30t9.rs:30:19\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n18 |     for s in lst2 {\n   |        \
    \      ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n30\
    \ |         for s2 in lst2 {\n   |                   ^^^^ value used here after\
    \ move\n   |\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n   |\n18 |     for s in &lst2 {\n   | \
    \             +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst1 {\n        total_chars += s.len();\n    }\n    for s in lst2 {\n \
    \       total_chars += s.len();\n    }\n    if total_chars == lst1.len() {\n \
    \       return lst1;\n    }\n    if total_chars == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut result = vec![];\n    for s in lst1 {\n        if\
    \ total_chars > lst2.len() {\n            break;\n        }\n        if s.len()\
    \ < total_chars {\n            continue;\n        }\n        for s2 in lst2 {\n\
    \            if s2.len() < total_chars {\n                continue;\n        \
    \    }\n            if s == s2 {\n                result.push(s);\n          \
    \      break;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmpqvk33px8.rs:21:23\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for s in lst1 {\n\
    \    |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     if total_chars == lst1.len() {\n    |                       ^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice\
    \ of the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n\
    15  |     for s in &lst1 {\n    |              +\n\nerror[E0382]: borrow of moved\
    \ value: `lst2`\n  --> /tmp/tmpqvk33px8.rs:24:23\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n18 |     for s in lst2 {\n   |        \
    \      ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n24\
    \ |     if total_chars == lst2.len() {\n   |                       ^^^^^^^^^^\
    \ value borrowed here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<String>`'s content to avoid moving into the `for` loop\n   |\n18\
    \ |     for s in &lst2 {\n   |              +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for i in 0..lst1.len()\
    \ {\n        let mut count = 0;\n        for j in 0..lst2.len() {\n          \
    \  if lst1[i] == lst2[j] {\n                count += 1;\n            }\n     \
    \   }\n        if count < lst2.len() {\n            res.push(lst1[i]);\n     \
    \   }\n    }\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n  \
    \  assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpb04eelh0.rs:20:22\n\
    \   |\n20 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for el1 in lst1\
    \ {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n     \
    \           res.push(el1);\n                break;\n            }\n        }\n\
    \    }\n    if res.len() == 0 {\n        res\n    } else {\n        res\n    }\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpuh9djjxu.rs:13:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n13  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    if total_chars == lst1.len() {\n        return lst1;\n\
    \    }\n    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpkp7e4g4v.rs:20:12\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n20  | \
    \    return lst2;\n    |            ^^^^ value used here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |     for s in &lst2 {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = vec![];\n    for s in\
    \ lst1 {\n        for s2 in lst2 {\n            if s.len() < s2.len() {\n    \
    \            break;\n            }\n            total_chars.extend_from_slice(&s);\n\
    \            total_chars.extend_from_slice(&s2);\n        }\n    }\n    if total_chars.len()\
    \ == 0 {\n        return vec![];\n    }\n    total_chars.sort();\n    return total_chars;\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpldp4ev85.rs:20:43\n   |\n\
    20 |             total_chars.extend_from_slice(&s);\n   |                    \
    \                       ^^ expected slice, found struct `String`\n   |\n   = note:\
    \ expected reference `&[_]`\n              found reference `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpldp4ev85.rs:21:43\n   |\n21 |             total_chars.extend_from_slice(&s2);\n\
    \   |                                           ^^^ expected slice, found struct\
    \ `String`\n   |\n   = note: expected reference `&[_]`\n              found reference\
    \ `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    let mut res = vec![];\n    for el1 in lst1 {\n  \
    \      for el2 in lst2 {\n            if el1.len() < el2.len() {\n           \
    \     res.push(el1);\n                break;\n            }\n            if el1.len()\
    \ == el2.len() {\n                res.push(el1);\n                break;\n   \
    \         }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmplwvcn_ru.rs:15:21\n\
    \   |\n15 |         return vec![lst1[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0382]: use of moved value: `lst2`\n   --> /tmp/tmplwvcn_ru.rs:19:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n19  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0382, E0507.\nFor more information about an error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    let mut result = vec![];\n    let mut i = 0;\n  \
    \  let mut j = 0;\n    while i < lst1.len() && j < lst2.len() {\n        if lst1[i].len()\
    \ < lst2[j].len() {\n            i += 1;\n        } else {\n            j += 1;\n\
    \        }\n    }\n    while i < lst1.len() {\n        result.push(lst1[i]);\n\
    \        i += 1;\n    }\n    while j < lst2.len() {\n        result.push(lst2[j]);\n\
    \        j += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpxnmkzn9w.rs:15:21\n\
    \   |\n15 |         return vec![lst1[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpxnmkzn9w.rs:28:21\n\
    \   |\n28 |         result.push(lst1[i]);\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpxnmkzn9w.rs:32:21\n\
    \   |\n32 |         result.push(lst2[j]);\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars == lst1.len() {\n        return lst2;\n   \
    \ }\n    if total_chars < lst1.len() {\n        return lst2;\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_chars < lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars == lst1.len() {\n       \
    \ return lst2;\n    }\n    if total_chars < lst1.len() {\n        return lst2;\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_chars < lst1.len() {\n        return lst1;\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst2;\n    }\n    if total_chars < lst1.len()\
    \ {\n        return lst2;\n    }\n    if total_chars == lst1.len() {\n       \
    \ return lst1;\n    }\n    if total_chars < lst1.len() {\n        return lst2;\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_chars < lst1.len() {\n        return lst2;\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_chars < lst1.len()\
    \ {\n        return lst2;\n    }\n    if total_chars == lst1.len() {\n       \
    \ return lst1;\n    }\n    if total_chars < lst1.len() {\n        return lst2;\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_chars < lst1.len() {\n        return lst2;\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_chars < lst1.len()\
    \ {\n        return lst2;\n    }\n    if total_chars == lst1.len() {\n       \
    \ return lst1;\n    }\n    if total_chars < lst1.len() {\n        return lst2;\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_chars < lst1.len() {\n        return lst2;\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_chars < lst1.len()\
    \ {\n        return lst2;\n    }\n    if total_chars == lst1.len() {\n       \
    \ return lst1;\n    }\n    if total_chars < lst1.len() {\n        return lst2;\n\
    \    }\n    if total_chars == lst1.len(\n}\n\nfn main() {\n    let candidate =\
    \ total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmp4kjas063.rs:112:1\n    |\n\
    111 |     if total_chars == lst1.len(\n    |     -- this `if` expression has a\
    \ condition, but no block\n112 | }\n    | ^ expected `{`\n\nerror: mismatched\
    \ closing delimiter: `}`\n   --> /tmp/tmp4kjas063.rs:111:31\n    |\n10  | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n    |                    \
    \                                                 - closing delimiter possibly\
    \ meant for this\n...\n111 |     if total_chars == lst1.len(\n    |          \
    \                     ^ unclosed delimiter\n112 | }\n    | ^ mismatched closing\
    \ delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst1 {\n        total_chars += s.len();\n    }\n    let mut total_chars2\
    \ = lst2.len();\n    for s in lst2 {\n        total_chars2 += s.len();\n    }\n\
    \    if total_chars == total_chars2 {\n        return vec![lst1[0]];\n    }\n\
    \    return vec![];\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmpl8dizvzh.rs:23:21\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for s in lst1 {\n\
    \    |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |         return vec![lst1[0]];\n    |                     ^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n15 \
    \ |     for s in &lst1 {\n    |              +\n\nerror[E0507]: cannot move out\
    \ of index of `Vec<String>`\n  --> /tmp/tmpl8dizvzh.rs:23:21\n   |\n23 |     \
    \    return vec![lst1[0]];\n   |                     ^^^^^^^ move occurs because\
    \ value has type `String`, which does not implement the `Copy` trait\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0382, E0507.\nFor more information about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst2;\n    }\n    lst1\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpf1whdgye.rs:19:16\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n19  | \
    \        return lst2;\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst2`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n12  |     for s in &lst2 {\n   \
    \ |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut result = vec![];\n    for el1 in\
    \ lst1 {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n\
    \                result.push(el1);\n                break;\n            }\n  \
    \      }\n    }\n    if result.len() == 0 {\n        result\n    } else {\n  \
    \      result\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n   \
    \ assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp9_046b7z.rs:13:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n13  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars > lst1.len() {\n        return lst2;\n    }\n\
    \    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp5lzocuen.rs:22:16\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n22  | \
    \        return lst2;\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst2`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n12  |     for s in &lst2 {\n   \
    \ |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for s in lst1 {\n        total_chars += s.len();\n    }\n    for s in lst2 {\n\
    \        total_chars += s.len();\n    }\n    if total_chars == lst1[0].len() {\n\
    \        return lst1;\n    }\n    if total_chars == lst2[0].len() {\n        return\
    \ lst2;\n    }\n    let mut result = vec![];\n    for s in lst1 {\n        if\
    \ s.len() < total_chars {\n            result.push(s);\n        }\n    }\n   \
    \ for s in lst2 {\n        if s.len() < total_chars {\n            result.push(s);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmpqub7a48r.rs:21:23\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for s in lst1 {\n\
    \    |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     if total_chars == lst1[0].len() {\n    |                      \
    \ ^^^^ value borrowed here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `lst1`\nhelp: consider iterating over a\
    \ slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n \
    \   |\n15  |     for s in &lst1 {\n    |              +\n\nerror[E0382]: borrow\
    \ of moved value: `lst2`\n  --> /tmp/tmpqub7a48r.rs:24:23\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n18 |     for s in lst2 {\n   |        \
    \      ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n24\
    \ |     if total_chars == lst2[0].len() {\n   |                       ^^^^ value\
    \ borrowed here after move\n   |\nhelp: consider iterating over a slice of the\
    \ `Vec<String>`'s content to avoid moving into the `for` loop\n   |\n18 |    \
    \ for s in &lst2 {\n   |              +\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut result = vec![];\n    for s in lst1 {\n        if s.len() < total_len\
    \ {\n            result.push(s);\n        }\n    }\n    for s in lst2 {\n    \
    \    if s.len() < total_len {\n            result.push(s);\n        }\n    }\n\
    \    if result.len() == 0 {\n        return vec![];\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmp8_h7qvd2.rs:25:14\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for s in lst1 {\n\
    \    |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n25  |     for s in lst1 {\n    |              ^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst1`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n15  |     for s in &lst1 {\n   \
    \ |              +\n\nerror[E0382]: use of moved value: `lst2`\n  --> /tmp/tmp8_h7qvd2.rs:30:14\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18 |   \
    \  for s in lst2 {\n   |              ---- `lst2` moved due to this implicit call\
    \ to `.into_iter()`\n...\n30 |     for s in lst2 {\n   |              ^^^^ value\
    \ used here after move\n   |\nhelp: consider iterating over a slice of the `Vec<String>`'s\
    \ content to avoid moving into the `for` loop\n   |\n18 |     for s in &lst2 {\n\
    \   |              +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].chars().count();\n\
    \    for i in 1..lst1.len() {\n        total_chars += lst1[i].chars().count();\n\
    \    }\n    for i in 1..lst2.len() {\n        total_chars += lst2[i].chars().count();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_chars == lst2.len() {\n        return lst2;\n    }\n    let mut result\
    \ = vec![];\n    for i in 0..total_chars {\n        let mut found = false;\n \
    \       for j in 0..lst1.len() {\n            if lst1[j].chars().count() > i {\n\
    \                found = true;\n                break;\n            }\n      \
    \  }\n        if !found {\n            for j in 0..lst2.len() {\n            \
    \    if lst2[j].chars().count() > i {\n                    found = true;\n   \
    \                 break;\n                }\n            }\n        }\n      \
    \  if found {\n            result.push(lst1[i]);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpny76ofbs.rs:45:25\n\
    \   |\n45 |             result.push(lst1[i]);\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = Vec::new();\n    for s in lst1\
    \ {\n        if lst2.contains(&s) {\n            res.push(s);\n        }\n   \
    \ }\n    if res.is_empty() {\n        res\n    } else {\n        res\n    }\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmplacotxz8.rs:27:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return lst1;\n    }\n \
    \   if total_len == lst1.len() {\n        return lst2;\n    }\n    let mut res\
    \ = vec![];\n    for s in lst1 {\n        if s.len() < total_len {\n         \
    \   res.push(s);\n        }\n    }\n    for s in lst2 {\n        if s.len() <\
    \ total_len {\n            res.push(s);\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmpbyazc27u.rs:19:16\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11  |     let mut total_len = 0;\n\
    12  |     for s in lst1 {\n    |              ---- `lst1` moved due to this implicit\
    \ call to `.into_iter()`\n...\n19  |         return lst1;\n    |             \
    \   ^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `lst1`\nhelp: consider iterating over a\
    \ slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n \
    \   |\n12  |     for s in &lst1 {\n    |              +\n\nerror[E0382]: use of\
    \ moved value: `lst2`\n  --> /tmp/tmpbyazc27u.rs:22:16\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n15 |     for s in lst2 {\n   |        \
    \      ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n22\
    \ |         return lst2;\n   |                ^^^^ value used here after move\n\
    \   |\nhelp: consider iterating over a slice of the `Vec<String>`'s content to\
    \ avoid moving into the `for` loop\n   |\n15 |     for s in &lst2 {\n   |    \
    \          +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = vec![];\n    for str1\
    \ in lst1 {\n        for str2 in lst2 {\n            if str1.len() < str2.len()\
    \ {\n                total_chars.insert(str1.len(), str1);\n            } else\
    \ {\n                total_chars.insert(str2.len(), str2);\n            }\n  \
    \      }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmplapotjhu.rs:16:21\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n16  |  \
    \       for str2 in lst2 {\n    |                     ^^^^ `lst2` moved due to\
    \ this implicit call to `.into_iter()`, in previous iteration of loop\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `lst2`\n\
    help: consider iterating over a slice of the `Vec<String>`'s content to avoid\
    \ moving into the `for` loop\n    |\n16  |         for str2 in &lst2 {\n    |\
    \                     +\n\nerror[E0382]: borrow of moved value: `str1`\n  -->\
    \ /tmp/tmplapotjhu.rs:17:16\n   |\n15 |     for str1 in lst1 {\n   |         ----\n\
    \   |         |\n   |         this reinitialization might get skipped\n   |  \
    \       move occurs because `str1` has type `String`, which does not implement\
    \ the `Copy` trait\n16 |         for str2 in lst2 {\n17 |             if str1.len()\
    \ < str2.len() {\n   |                ^^^^^^^^^^ value borrowed here after move\n\
    18 |                 total_chars.insert(str1.len(), str1);\n   |             \
    \                                   ---- value moved here, in previous iteration\
    \ of loop\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_match: Vec<String> = Vec::new();\n\
    \    for elem in lst1 {\n        if lst2.contains(elem) {\n            total_match.push(elem);\n\
    \        }\n    }\n    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9_azh4li.rs:13:26\n   |\n\
    13 |         if lst2.contains(elem) {\n   |                          ^^^^\n  \
    \ |                          |\n   |                          expected `&String`,\
    \ found struct `String`\n   |                          help: consider borrowing\
    \ here: `&elem`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut res = vec![];\n    for s in lst1 {\n        if s.len() < total_len\
    \ {\n            res.push(s);\n        }\n    }\n    for s in lst2 {\n       \
    \ if s.len() < total_len {\n            res.push(s);\n        }\n    }\n    if\
    \ res.len() == 0 {\n        return vec![];\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmpob0c82t7.rs:22:14\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11  |     let mut total_len = 0;\n\
    12  |     for s in lst1 {\n    |              ---- `lst1` moved due to this implicit\
    \ call to `.into_iter()`\n...\n22  |     for s in lst1 {\n    |              ^^^^\
    \ value used here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n12 \
    \ |     for s in &lst1 {\n    |              +\n\nerror[E0382]: use of moved value:\
    \ `lst2`\n  --> /tmp/tmpob0c82t7.rs:27:14\n   |\n10 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                                  \
    \ ---- move occurs because `lst2` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n...\n15 |     for s in lst2 {\n   |              ---- `lst2`\
    \ moved due to this implicit call to `.into_iter()`\n...\n27 |     for s in lst2\
    \ {\n   |              ^^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n15 |     for s in &lst2 {\n   |              +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut total_len2 = 0;\n    for s in lst1 {\n        total_len2 += s.len();\n\
    \    }\n    for s in lst2 {\n        total_len2 += s.len();\n    }\n    if total_len2\
    \ == total_len {\n        return vec![];\n    }\n    let mut total_len3 = 0;\n\
    \    for s in lst1 {\n        total_len3 += s.len();\n    }\n    for s in lst2\
    \ {\n        total_len3 += s.len();\n    }\n    if total_len3 == total_len {\n\
    \        return vec![];\n    }\n    let mut total_len4 = 0;\n    for s in lst1\
    \ {\n        total_len4 += s.len();\n    }\n    for s in lst2 {\n        total_len4\
    \ += s.len();\n    }\n    if total_len4 == total_len {\n        return vec![];\n\
    \    }\n    let mut total_len5 = 0;\n    for s in lst1 {\n        total_len5 +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len5 += s.len();\n    }\n\
    \    if total_len5 == total_len {\n        return vec![];\n    }\n    let mut\
    \ total_len6 = 0;\n    for s in lst1 {\n        total_len6 += s.len();\n    }\n\
    \    for s in lst2 {\n        total_len6 += s.len();\n    }\n    if total_len6\
    \ == total_len {\n        return vec![];\n    }\n    let mut total_len7 = 0;\n\
    \    for s in lst1 {\n        total_len7 += s.len();\n    }\n    for s in lst2\
    \ {\n        total_len7 += s.len();\n    }\n    if total_len7 == total_len {\n\
    \        return vec![];\n    }\n    let mut total_len8 = 0;\n    for s in lst1\
    \ {\n        total_len8 += s.len();\n    }\n    for s in lst2 {\n        total_len8\
    \ += s.len();\n    }\n    if total_len8 == total_len {\n        return vec![];\n\
    \    }\n    let mut total_len9 = 0;\n    for s in lst1 {\n        total_len9 +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len9 += s.len();\n    }\n\
    \    if total_len9 == total_len {\n        return vec![];\n    }\n    let mut\
    \ total_len10 = 0;\n    for s in lst1 {\n        total_len10 += s.len();\n   \
    \ }\n    for s in lst2 {\n        total_len10 += s.len();\n    }\n\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n   --> /tmp/tmp7ad7ku13.rs:105:5\n    |\n\
    10  |   fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    |                                                           ----------- expected\
    \ `Vec<String>` because of return type\n...\n105 | /     for s in lst2 {\n106\
    \ | |         total_len10 += s.len();\n107 | |     }\n    | |_____^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<String>`\n      \
    \      found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars > lst1.len() {\n        return lst2;\n    }\n\
    \    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpwq1hlgbm.rs:22:16\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n22  | \
    \        return lst2;\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst2`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n12  |     for s in &lst2 {\n   \
    \ |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut total_chars = lst1.len();\n    for elem in lst2 {\n\
    \        if elem.len() > total_chars {\n            total_chars = elem.len();\n\
    \        }\n    }\n    return lst1.iter().filter(|&x| x.len() < total_chars).cloned().collect();\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp7p2gu61k.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for elem in lst1 {\n        total_chars += elem.len();\n    }\n    for elem\
    \ in lst2 {\n        total_chars += elem.len();\n    }\n    if total_chars ==\
    \ lst1[0].len() {\n        return vec![];\n    }\n    let mut res = vec![];\n\
    \    for elem in lst1 {\n        if elem.len() < total_chars {\n            res.push(elem);\n\
    \        }\n    }\n    for elem in lst2 {\n        if elem.len() < total_chars\
    \ {\n            res.push(elem);\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmper6cknwi.rs:21:23\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for elem in lst1 {\n\
    \    |                 ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     if total_chars == lst1[0].len() {\n    |                      \
    \ ^^^^ value borrowed here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `lst1`\nhelp: consider iterating over a\
    \ slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n \
    \   |\n15  |     for elem in &lst1 {\n    |                 +\n\nerror[E0382]:\
    \ use of moved value: `lst2`\n  --> /tmp/tmper6cknwi.rs:30:17\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n18 |     for elem in lst2 {\n   |     \
    \            ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n\
    30 |     for elem in lst2 {\n   |                 ^^^^ value used here after move\n\
    \   |\nhelp: consider iterating over a slice of the `Vec<String>`'s content to\
    \ avoid moving into the `for` loop\n   |\n18 |     for elem in &lst2 {\n   | \
    \                +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = Vec::new();\n    for el1 in\
    \ lst1 {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n\
    \                res.push(el1);\n                break;\n            }\n     \
    \   }\n    }\n    if res.len() == 0 {\n        res\n    } else {\n        res\n\
    \    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp92p96z5y.rs:13:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n13  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut total_chars = lst1.len();\n    for x in lst2 {\n \
    \       if total_chars > lst1.len() {\n            break;\n        }\n       \
    \ total_chars = total_chars - 1;\n    }\n    return lst1;\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpqlf9pmzq.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return lst1;\n    }\n \
    \   if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_match_len =\
    \ 0;\n    for s in lst1 {\n        if total_len < s.len() {\n            break;\n\
    \        }\n        total_match_len += s.len();\n    }\n    for s in lst2 {\n\
    \        if total_len < s.len() {\n            break;\n        }\n        total_match_len\
    \ += s.len();\n    }\n    if total_match_len == 0 {\n        return lst1;\n  \
    \  }\n    if total_match_len == lst1.len() {\n        return lst1;\n    }\n  \
    \  if total_match_len == lst2.len() {\n        return lst2;\n    }\n    let mut\
    \ total_match_len = 0;\n    for s in lst1 {\n        if total_len < s.len() {\n\
    \            break;\n        }\n        total_match_len += s.len();\n    }\n \
    \   for s in lst2 {\n        if total_len < s.len() {\n            break;\n  \
    \      }\n        total_match_len += s.len();\n    }\n    if total_match_len ==\
    \ 0 {\n        return lst1;\n    }\n    if total_match_len == lst1.len() {\n \
    \       return lst1;\n    }\n    if total_match_len == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_match_len = 0;\n    for s in lst1 {\n      \
    \  if total_len < s.len() {\n            break;\n        }\n        total_match_len\
    \ += s.len();\n    }\n    for s in lst2 {\n        if total_len < s.len() {\n\
    \            break;\n        }\n        total_match_len += s.len();\n    }\n \
    \   if total_match_len == 0 {\n        return lst1;\n    }\n    if total_match_len\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_match_len == lst2.len()\
    \ {\n        return lst2;\n    }\n    let mut total_match_len = 0;\n    for s\
    \ in lst1 {\n        if total_len < s.len() {\n            break;\n        }\n\
    \        total_match_len += s.len();\n    }\n    for s in lst2 {\n        if total_len\
    \ < s.len() {\n            break;\n        }\n        total_match_len += s.len();\n\
    \    }\n    if total_match_len == 0 {\n        return lst1;\n    }\n    if total_match_len\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_match_len == lst2.len()\
    \ {\n        return lst2;\n    }\n    let mut total_match_len = 0;\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzd8_t6lw.rs:10:57\n   |\n\
    10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |    -----------                                          ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    let mut total_chars = lst1[0].len();\n    for i in\
    \ 1..lst1.len() {\n        total_chars += lst1[i].len();\n    }\n    for i in\
    \ 1..lst2.len() {\n        total_chars += lst2[i].len();\n    }\n    if total_chars\
    \ == 0 {\n        return vec![];\n    }\n    let mut result = vec![];\n    for\
    \ i in 0..(total_chars - lst1[0].len()) {\n        result.push(lst1[0]);\n   \
    \ }\n    for i in 0..(total_chars - lst2[0].len()) {\n        result.push(lst2[0]);\n\
    \    }\n    for i in 1..(total_chars - lst1[0].len() - lst2[0].len()) {\n    \
    \    result.push(lst1[i - 1] + lst2[i - 1]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_snuw7_o.rs:35:35\n   |\n\
    35 |         result.push(lst1[i - 1] + lst2[i - 1]);\n   |                   \
    \                ^^^^^^^^^^^\n   |                                   |\n   | \
    \                                  expected `&str`, found struct `String`\n  \
    \ |                                   help: consider borrowing here: `&lst2[i\
    \ - 1]`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_len = 0;\n    for el1 in lst1\
    \ {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n     \
    \           total_len += el1.len();\n            } else {\n                total_len\
    \ += el2.len();\n            }\n        }\n    }\n    if total_len == lst1.len()\
    \ {\n        return vec![];\n    }\n    if total_len == lst2.len() {\n       \
    \ return vec![];\n    }\n    let mut result = vec![];\n    for el1 in lst1 {\n\
    \        for el2 in lst2 {\n            if el1.len() < el2.len() {\n         \
    \       result.push(el1);\n            } else {\n                result.push(el2);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpji236q5m.rs:16:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n16  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n16  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror[E0382]: borrow of moved value: `lst1`\n  --> /tmp/tmpji236q5m.rs:24:21\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15 |     for el1 in lst1 {\n\
    \   |                ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n24 |     if total_len == lst1.len() {\n   |                     ^^^^^^^^^^\
    \ value borrowed here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<String>`'s content to avoid moving into the `for` loop\n   |\n15\
    \ |     for el1 in &lst1 {\n   |                +\n\nerror[E0382]: use of moved\
    \ value: `lst2`\n  --> /tmp/tmpji236q5m.rs:32:20\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n16 |         for el2 in lst2 {\n   |  \
    \                  ---- `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n...\n32 |         for el2 in lst2 {\n   |   \
    \                 ^^^^ `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n   |\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid movi"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return lst1;\n    }\n \
    \   if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len < lst1.len() {\n     \
    \   return lst1;\n    }\n    if total_len < lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len == 0 {\n        return lst1;\n    }\n    if total_len == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_len == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len\
    \ += s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n   \
    \ }\n    if total_len < lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ < lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n  \
    \  for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len == 0 {\n        return\
    \ lst1;\n    }\n    if total_len == lst1.len() {\n        return lst1;\n    }\n\
    \    if total_len == lst2.len() {\n        return lst2;\n    }\n    let mut total_len\
    \ = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n    for s in\
    \ lst2 {\n        total_len += s.len();\n    }\n    if total_len < lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_len < lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len\
    \ += s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n   \
    \ }\n    if total_len == 0 {\n        return lst1;\n    }\n    if total_len ==\
    \ lst1.len() {\n        return lst1;\n    }\n    if total_len == lst2.len() {\n\
    \        return lst2;\n    }\n    let mut total_len = 0;\n    for s in \n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmpl20eqc0y.rs:116:1\n\
    \    |\n116 | }\n    | ^ expected expression\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut result = vec![];\n    let mut cnt\
    \ = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len()\
    \ < el2.len() {\n                cnt += el1.len();\n            } else {\n   \
    \             cnt += el2.len();\n            }\n            if cnt > result.len()\
    \ {\n                result = vec![el1];\n            }\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpva9yi_er.rs:17:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n17  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror[E0382]: borrow of moved value: `el1`\n  --> /tmp/tmpva9yi_er.rs:18:16\n\
    \   |\n16 |     for el1 in lst1 {\n   |         ---\n   |         |\n   |    \
    \     this reinitialization might get skipped\n   |         move occurs because\
    \ `el1` has type `String`, which does not implement the `Copy` trait\n17 |   \
    \      for el2 in lst2 {\n18 |             if el1.len() < el2.len() {\n   |  \
    \              ^^^^^^^^^ value borrowed here after move\n...\n24 |           \
    \      result = vec![el1];\n   |                               --- value moved\
    \ here, in previous iteration of loop\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    let mut total_chars = vec![];\n    for el1 in lst1\
    \ {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n     \
    \           total_chars.push(el1);\n                break;\n            }\n  \
    \      }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpccylgu6x.rs:15:21\n\
    \   |\n15 |         return vec![lst1[0]];\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpccylgu6x.rs:19:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n19  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0382, E0507.\nFor more information about an error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst1 {\n        total_chars += s.len();\n    }\n    for s in lst2 {\n \
    \       total_chars += s.len();\n    }\n    if total_chars == lst1.len() {\n \
    \       return lst1;\n    }\n    if total_chars == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut result = vec![];\n    for s in lst1 {\n        if\
    \ total_chars < lst2.len() {\n            if s.len() < lst2[total_chars].len()\
    \ {\n                result.push(s);\n            }\n        }\n    }\n    for\
    \ s in lst2 {\n        if total_chars < lst1.len() {\n            if s.len() <\
    \ lst1[total_chars].len() {\n                result.push(s);\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmpq6h5gxp5.rs:21:23\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for s in lst1 {\n\
    \    |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     if total_chars == lst1.len() {\n    |                       ^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice\
    \ of the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n\
    15  |     for s in &lst1 {\n    |              +\n\nerror[E0382]: borrow of moved\
    \ value: `lst2`\n  --> /tmp/tmpq6h5gxp5.rs:24:23\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n18 |     for s in lst2 {\n   |        \
    \      ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n24\
    \ |     if total_chars == lst2.len() {\n   |                       ^^^^^^^^^^\
    \ value borrowed here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<String>`'s content to avoid moving into the `for` loop\n   |\n18\
    \ |     for s in &lst2 {\n   |              +\n\nerror[E0382]: borrow of moved\
    \ value: `lst1`\n  --> /tmp/tmpq6h5gxp5.rs:36:26\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                ---- move\
    \ occurs because `lst1` has type `Vec<String>`, which does not implement the `Copy`\
    \ trait\n...\n28 |     for s in lst1 {\n   |              ---- `lst1` moved due\
    \ to this implicit call to `.into_iter()`\n...\n36 |         if total_chars <\
    \ lst1.len() {\n   |                          ^^^^^^^^^^ value borrowed here after\
    \ move\n   |\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n   |\n28 | "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut res = vec![];\n    for s in lst1 {\n        if s.len() < total_len\
    \ {\n            res.push(s);\n        }\n    }\n    for s in lst2 {\n       \
    \ if s.len() < total_len {\n            res.push(s);\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmpz6mbvcjt.rs:25:14\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for s in lst1 {\n\
    \    |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n25  |     for s in lst1 {\n    |              ^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst1`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n15  |     for s in &lst1 {\n   \
    \ |              +\n\nerror[E0382]: use of moved value: `lst2`\n  --> /tmp/tmpz6mbvcjt.rs:30:14\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18 |   \
    \  for s in lst2 {\n   |              ---- `lst2` moved due to this implicit call\
    \ to `.into_iter()`\n...\n30 |     for s in lst2 {\n   |              ^^^^ value\
    \ used here after move\n   |\nhelp: consider iterating over a slice of the `Vec<String>`'s\
    \ content to avoid moving into the `for` loop\n   |\n18 |     for s in &lst2 {\n\
    \   |              +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut result = vec![];\n    for x in lst1\
    \ {\n        if lst2.iter().any(|y| y.contains(&x)) {\n            result.push(x);\n\
    \        }\n    }\n    for x in lst2 {\n        if !result.contains(&x) {\n  \
    \          result.push(x);\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpxxz3pt84.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut total_chars = lst1.len();\n    for elem in lst2 {\n\
    \        total_chars += elem.len();\n    }\n    if total_chars < lst1.len() {\n\
    \        return lst1;\n    }\n    return lst2;\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp653up6f7.rs:21:12\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n15  |  \
    \   for elem in lst2 {\n    |                 ---- `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     return lst2;\n    |            ^^^^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `lst2`\nhelp: consider iterating over a slice of the `Vec<String>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for elem in &lst2\
    \ {\n    |                 +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst2;\n    }\n    return lst1;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmps661b75i.rs:19:16\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n19  | \
    \        return lst2;\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst2`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n12  |     for s in &lst2 {\n   \
    \ |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut total_chars = 0;\n    for s in lst1 {\n        total_chars += s.chars().count();\n\
    \    }\n    for s in lst2 {\n        total_chars += s.chars().count();\n    }\n\
    \    if total_chars == total_len {\n        return lst1;\n    }\n    return lst2;\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmprjurfg4k.rs:22:14\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11  |     let mut total_len = 0;\n\
    12  |     for s in lst1 {\n    |              ---- `lst1` moved due to this implicit\
    \ call to `.into_iter()`\n...\n22  |     for s in lst1 {\n    |              ^^^^\
    \ value used here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n12 \
    \ |     for s in &lst1 {\n    |              +\n\nerror[E0382]: use of moved value:\
    \ `lst2`\n  --> /tmp/tmprjurfg4k.rs:25:14\n   |\n10 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                                  \
    \ ---- move occurs because `lst2` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n...\n15 |     for s in lst2 {\n   |              ---- `lst2`\
    \ moved due to this implicit call to `.into_iter()`\n...\n25 |     for s in lst2\
    \ {\n   |              ^^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n15 |     for s in &lst2 {\n   |              +\n\nerror[E0382]: use of\
    \ moved value: `lst1`\n  --> /tmp/tmprjurfg4k.rs:29:16\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                ---- move\
    \ occurs because `lst1` has type `Vec<String>`, which does not implement the `Copy`\
    \ trait\n...\n22 |     for s in lst1 {\n   |              ---- `lst1` moved due\
    \ to this implicit call to `.into_iter()`\n...\n29 |         return lst1;\n  \
    \ |                ^^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n22 |     for s in &lst1 {\n   |              +\n\nerror[E0382]: use of\
    \ moved value: `lst2`\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    if total_chars == lst1.len() {\n        return lst1;\n\
    \    }\n    return lst1;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpjo53xk3u.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    if total_chars == lst1.len() {\n        return lst1;\n\
    \    }\n    return lst1\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp9c4a7472.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut total_chars = lst1.len();\n    for i in 0..lst1.len()\
    \ {\n        total_chars += lst1[i].len();\n    }\n    for i in 0..lst2.len()\
    \ {\n        total_chars += lst2[i].len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars == lst2.len() {\n       \
    \ return lst2;\n    }\n    let mut total_chars = lst1.len();\n    for i in 0..lst1.len()\
    \ {\n        total_chars += lst1[i].len();\n    }\n    for i in 0..lst2.len()\
    \ {\n        total_chars += lst2[i].len();\n    }\n    if total_chars < lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_chars = lst1.len();\n    for i in 0..lst1.len()\
    \ {\n        total_chars += lst1[i].len();\n    }\n    for i in 0..lst2.len()\
    \ {\n        total_chars += lst2[i].len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars == lst2.len() {\n       \
    \ return lst2;\n    }\n    let mut total_chars = lst1.len();\n    for i in 0..lst1.len()\
    \ {\n        total_chars += lst1[i].len();\n    }\n    for i in 0..lst2.len()\
    \ {\n        total_chars += lst2[i].len();\n    }\n    if total_chars < lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_chars = lst1.len();\n    for i in 0..lst1.len()\
    \ {\n        total_chars += lst1[i].len();\n    }\n    for i in 0..lst2.len()\
    \ {\n        total_chars += lst2[i].len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars == lst2.len() {\n       \
    \ return lst2;\n    }\n    let mut total_chars = lst1.len();\n    for i in 0..lst1.len()\
    \ {\n        total_chars += lst1[i].len();\n    }\n    for i in 0..lst2.len()\
    \ {\n        total_chars += lst2[i].len();\n    }\n    if total_chars < lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_chars = lst1.len();\n    for i in 0..lst1.len()\
    \ {\n        total_chars += \n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpb_vwkfzz.rs:108:3\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n93  |     for i in 0..lst1.len() {\n    |      \
    \                      - this delimiter might not be properly closed...\n94  |\
    \         total_chars += \n95  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n108 | }\n    |   ^\n\nerror: expected expression, found `}`\n\
    \  --> /tmp/tmpb_vwkfzz.rs:95:1\n   |\n95 | }\n   | ^ expected expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpb_vwkfzz.rs:10:57\n   |\n10 | fn\
    \ total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |   \
    \ -----------                                          ^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = vec![];\n    for x in\
    \ lst1 {\n        if lst2.iter().any(|y| y.contains(&x)) {\n            total_chars.push(x);\n\
    \        }\n    }\n    for x in lst2 {\n        if total_chars.iter().any(|y|\
    \ y.contains(&x)) {\n            total_chars.push(x);\n        }\n    }\n    total_chars\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"hi\", \"hi\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpps4yx104.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut result = vec![];\n    for el1 in lst1\
    \ {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n     \
    \           result.push(el1);\n                break;\n            }\n       \
    \ }\n    }\n    if result.len() == 0 {\n        return vec![];\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmphw28v10f.rs:16:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n16  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n16  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for i in 0..lst1.len() {\n        total_chars += lst1[i].len();\n    }\n   \
    \ for i in 0..lst2.len() {\n        total_chars += lst2[i].len();\n    }\n   \
    \ if total_chars == lst1[0].len() {\n        return vec![];\n    }\n    if total_chars\
    \ == lst2[0].len() {\n        return vec![];\n    }\n    if total_chars < lst1[0].len()\
    \ {\n        return vec![lst1[0]];\n    }\n    if total_chars < lst2[0].len()\
    \ {\n        return vec![lst2[0]];\n    }\n    let mut res = vec![];\n    for\
    \ i in 0..(total_chars - lst1[0].len()) {\n        res.push(lst1[0]);\n    }\n\
    \    for i in 0..(total_chars - lst2[0].len()) {\n        res.push(lst2[0]);\n\
    \    }\n    for i in 0..(total_chars - lst1[0].len() - lst2[0].len()) {\n    \
    \    res.push(lst1[0]);\n        res.push(lst2[0]);\n    }\n    for i in 0..(total_chars\
    \ - lst1[0].len() - lst2[0].len() - 1) {\n        res.push(lst1[0]);\n       \
    \ res.push(lst2[0]);\n        res.push(lst1[0]);\n        res.push(lst2[0]);\n\
    \    }\n    for i in 0..(total_chars - lst1[0].len() - lst2[0].len() - 2) {\n\
    \        res.push(lst1[0]);\n        res.push(lst2[0]);\n        res.push(lst1[0]);\n\
    \        res.push(lst2[0]);\n        res.push(lst1[0]);\n        res.push(lst2[0]);\n\
    \        res.push(lst1[0]);\n        res.push(lst2[0]);\n        res.push(lst1[0]);\n\
    \        res.push(lst2[0]);\n        res.push(lst1[0]);\n        res.push(lst2[0]);\n\
    \        res.push(lst1[0]);\n        res.push(lst2[0]);\n        res.push(lst1[0]);\n\
    \        res.push(lst2[0]);\n        res.push(lst1[0]);\n        res.push(lst2[0]);\n\
    \        res.push(lst1[0]);\n        res.push(lst2[0]);\n        res.push(lst1[0]);\n\
    \        res.push(lst2[0]);\n        res.push(lst1[0]);\n        res.push(lst2[0]);\n\
    \        res.push(lst1[0]);\n        res.push(lst2[0]);\n        res.push(lst1[0]);\n\
    \        res.push(lst2[0]);\n        res.push(lst1[0]);\n        res.push(lst2[0]);\n\
    \        res.push(lst1[0]);\n        res.push(lst2[0]);\n        res.push(lst1[0]);\n\
    \        res.push(lst2[0]);\n        res.push(lst1[0]);\n        res.push(lst2[0]);\n\
    \        res.push(lst1[0]);\n        re\n}\n\nfn main() {\n    let candidate =\
    \ total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpkw9m607x.rs:102:3\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n50  |     for i in 0..(total_chars - lst1[0].len()\
    \ - lst2[0].len() - 2) {\n    |                                              \
    \                     - this delimiter might not be properly closed...\n...\n\
    89  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    102 | }\n    |   ^\n\nerror[E0425]: cannot find value `re` in this scope\n  -->\
    \ /tmp/tmpkw9m607x.rs:88:9\n   |\n88 |         re\n   |         ^^ help: a local\
    \ variable with a similar name exists: `res`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkw9m607x.rs:10:57\n   |\n10 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |    -----------                   \
    \                       ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |  \
    \  |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].chars().count();\n\
    \    for i in 1..lst1.len() {\n        total_chars += lst1[i].chars().count();\n\
    \    }\n    for i in 1..lst2.len() {\n        total_chars += lst2[i].chars().count();\n\
    \    }\n    if total_chars == lst1.len() {\n        return vec![];\n    }\n  \
    \  if total_chars == lst2.len() {\n        return vec![];\n    }\n    for i in\
    \ 1..lst1.len() {\n        if lst1[i].chars().count() > lst2[i].chars().count()\
    \ {\n            return vec![];\n        }\n    }\n    for i in 1..lst2.len()\
    \ {\n        if lst2[i].chars().count() > lst1[i].chars().count() {\n        \
    \    return vec![];\n        }\n    }\n    vec![lst1[0]]\n}\n\nfn main() {\n \
    \   let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpgfgc0pmt.rs:37:10\n\
    \   |\n37 |     vec![lst1[0]]\n   |          ^^^^^^^ move occurs because value\
    \ has type `String`, which does not implement the `Copy` trait\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars > lst1.len() {\n        return lst2;\n    }\n\
    \    let mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars\
    \ += s.len();\n    }\n    if total_chars == lst1.len() {\n        return lst1;\n\
    \    }\n    if total_chars < lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_chars > lst1.len() {\n        return lst2;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    if total_chars\
    \ < lst1.len() {\n        return lst1;\n    }\n    if total_chars > lst1.len()\
    \ {\n        return lst2;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars > lst1.len() {\n        return lst2;\n    }\n\
    \    let mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars\
    \ += s.len();\n    }\n    if total_chars == lst1.len() {\n        return lst1;\n\
    \    }\n    if total_chars < lst1.len() {\n        return lst1;\n    }\n    if\
    \ total_chars > lst1.len() {\n        return lst2;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    if total_chars\
    \ < lst1.len() {\n        return lst1;\n    }\n    if total_chars > lst1.len()\
    \ {\n        return lst2;\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars > lst1.len() {\n        return lst2;\n    }\n\
    \    let mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars\
    \ += s.len();\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp25v0yy03.rs:118:3\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n103 |     for s in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n104 |         total_chars\
    \ += s.len();\n105 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n118 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25v0yy03.rs:10:57\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut res = vec![];\n    for i in 0..lst1.len() {\n    \
    \    if lst1[i] < lst2[i] {\n            res.push(lst1[i]);\n        }\n    }\n\
    \    return res;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpuxufv789.rs:17:22\n\
    \   |\n17 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut res = vec![];\n    for s in lst1 {\n        if s.len() < total_len\
    \ {\n            for s2 in lst2 {\n                if s2.len() > total_len {\n\
    \                    break;\n                }\n                if s == s2 {\n\
    \                    res.push(s);\n                    break;\n              \
    \  }\n            }\n        }\n    }\n    return res;\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmp5sbpyh02.rs:22:14\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11  |     let mut total_len = 0;\n\
    12  |     for s in lst1 {\n    |              ---- `lst1` moved due to this implicit\
    \ call to `.into_iter()`\n...\n22  |     for s in lst1 {\n    |              ^^^^\
    \ value used here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n12 \
    \ |     for s in &lst1 {\n    |              +\n\nerror[E0382]: use of moved value:\
    \ `lst2`\n  --> /tmp/tmp5sbpyh02.rs:24:23\n   |\n10 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                                  \
    \ ---- move occurs because `lst2` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n...\n15 |     for s in lst2 {\n   |              ---- `lst2`\
    \ moved due to this implicit call to `.into_iter()`\n...\n24 |             for\
    \ s2 in lst2 {\n   |                       ^^^^ value used here after move\n \
    \  |\nhelp: consider iterating over a slice of the `Vec<String>`'s content to\
    \ avoid moving into the `for` loop\n   |\n15 |     for s in &lst2 {\n   |    \
    \          +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].chars().count();\n\
    \    for i in 1..lst1.len() {\n        total_chars += lst1[i].chars().count();\n\
    \    }\n    for i in 1..lst2.len() {\n        total_chars += lst2[i].chars().count();\n\
    \    }\n    if total_chars == lst1.len() {\n        return vec![];\n    }\n  \
    \  if total_chars == lst2.len() {\n        return vec![];\n    }\n    for i in\
    \ 1..lst1.len() {\n        if lst1[i].chars().count() > lst2[i].chars().count()\
    \ {\n            return vec![];\n        }\n    }\n    for i in 1..lst2.len()\
    \ {\n        if lst2[i].chars().count() > lst1[i].chars().count() {\n        \
    \    return vec![];\n        }\n    }\n    return vec![lst1[0]];\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpcb409end.rs:37:17\n\
    \   |\n37 |     return vec![lst1[0]];\n   |                 ^^^^^^^ move occurs\
    \ because value has type `String`, which does not implement the `Copy` trait\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for i in 0..lst1.len()\
    \ {\n        if lst1[i] < lst2[i] {\n            res.push(lst1[i]);\n        }\n\
    \    }\n    if lst1.len() == lst2.len() {\n        res\n    } else {\n       \
    \ res\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp8b5goagl.rs:14:22\n\
    \   |\n14 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for i in 1..lst1.len() {\n        total_chars += lst1[i].len();\n    }\n   \
    \ for i in 1..lst2.len() {\n        total_chars += lst2[i].len();\n    }\n   \
    \ if total_chars == lst1[0].len() {\n        return vec![];\n    }\n    if total_chars\
    \ == lst2[0].len() {\n        return vec![];\n    }\n    let mut result = vec![];\n\
    \    for i in 0..total_chars {\n        if lst1[0].chars().all(|c| c < lst2[0].chars().nth(i))\
    \ {\n            result.push(lst1[0]);\n        } else {\n            result.push(lst2[0]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7mmyu84_.rs:29:40\n   |\n\
    29 |         if lst1[0].chars().all(|c| c < lst2[0].chars().nth(i)) {\n   |  \
    \                                      ^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found enum `Option`\n   |\n   = note: expected type `char`\n              found\
    \ enum `Option<char>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for i in 0..lst1.len()\
    \ {\n        if lst1[i] < lst2[i] {\n            res.push(lst1[i]);\n        }\n\
    \    }\n    if res.len() == lst1.len() {\n        res\n    } else {\n        res\n\
    \    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpwifo99ow.rs:14:22\n\
    \   |\n14 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    if lst1.len() == lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    let mut total_chars = lst1[0].len();\n    for str1\
    \ in lst1 {\n        for str2 in lst2 {\n            if str1.len() < str2.len()\
    \ {\n                total_chars += str1.len();\n            }\n            if\
    \ str1.len() > str2.len() {\n                total_chars += str2.len();\n    \
    \        }\n        }\n    }\n    return vec![lst1[0]] + lst1.iter().take(total_chars).collect();\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `_` to `Vec<String>`\n  --> /tmp/tmpg4mt2rh7.rs:28:26\n\
    \   |\n28 |     return vec![lst1[0]] + lst1.iter().take(total_chars).collect();\n\
    \   |            ------------- ^ --------------------------------------- _\n \
    \  |            |\n   |            Vec<String>\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut total_chars = lst1.len();\n    for x in lst1 {\n \
    \       total_chars += x.len();\n    }\n    for x in lst2 {\n        total_chars\
    \ += x.len();\n    }\n    if total_chars < lst2.len() {\n        return lst1;\n\
    \    }\n    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst2`\n   --> /tmp/tmprc0x113_.rs:21:22\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \   for x in lst2 {\n    |              ---- `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n...\n21  |     if total_chars < lst2.len() {\n    |\
    \                      ^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n18  |     for x in &lst2 {\n    |              +\n\
    \nerror[E0382]: use of moved value: `lst1`\n  --> /tmp/tmprc0x113_.rs:22:16\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15 |     for x in lst1 {\n \
    \  |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n22 |         return lst1;\n   |                ^^^^ value used here after\
    \ move\n   |\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n   |\n15 |     for x in &lst1 {\n   | \
    \             +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars > lst1.len() {\n        return lst2;\n    }\n\
    \    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpoyazvjyz.rs:22:16\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n22  | \
    \        return lst2;\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst2`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n12  |     for s in &lst2 {\n   \
    \ |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for i in 0..lst1.len() {\n        total_chars += lst1[i].len();\n    }\n   \
    \ for i in 0..lst2.len() {\n        total_chars += lst2[i].len();\n    }\n   \
    \ if total_chars == lst1.len() {\n        return vec![];\n    }\n    let mut result\
    \ = vec![];\n    for i in 0..lst1.len() {\n        if lst1[i].len() < lst2[i].len()\
    \ {\n            result.push(lst1[i]);\n        }\n    }\n    for i in 0..lst2.len()\
    \ {\n        if lst2[i].len() < lst1[i].len() {\n            result.push(lst2[i]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp1tynlxvx.rs:27:25\n\
    \   |\n27 |             result.push(lst1[i]);\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp1tynlxvx.rs:32:25\n\
    \   |\n32 |             result.push(lst2[i]);\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1[0].len();\n   \
    \ for s in lst1 {\n        total_chars += s.len();\n    }\n    for s in lst2 {\n\
    \        total_chars += s.len();\n    }\n    if total_chars == lst1[0].len() {\n\
    \        return vec![];\n    }\n    if total_chars == lst2[0].len() {\n      \
    \  return vec![];\n    }\n    let mut result = vec![];\n    for s in lst1 {\n\
    \        if total_chars < s.len() {\n            return vec![];\n        }\n \
    \       let mut i = 0;\n        for c in s {\n            if c < lst2[0][i] {\n\
    \                break;\n            }\n            i += 1;\n        }\n     \
    \   result.push(s);\n    }\n    for s in lst2 {\n        if total_chars < s.len()\
    \ {\n            return vec![];\n        }\n        let mut i = 0;\n        for\
    \ c in s {\n            if c < lst1[0][i] {\n                break;\n        \
    \    }\n            i += 1;\n        }\n        result.push(s);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp1_ptxdaf.rs:33:18\n\
    \   |\n33 |         for c in s {\n   |                  ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmp1_ptxdaf.rs:34:20\n   |\n34\
    \ |             if c < lst2[0][i] {\n   |                    ^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp1_ptxdaf.rs:46:18\n\
    \   |\n46 |         for c in s {\n   |                  ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmp1_ptxdaf.rs:47:20\n   |\n47\
    \ |             if c < lst1[0][i] {\n   |                    ^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut result = vec![];\n    for el1 in\
    \ lst1 {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n\
    \                result.push(el1);\n                break;\n            }\n  \
    \      }\n    }\n    if result.len() == 0 {\n        result\n    } else {\n  \
    \      result\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n   \
    \ assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp9o3x5hf_.rs:13:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n13  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpd6ypfe5u.rs:21:12\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n21  | \
    \    return lst2;\n    |            ^^^^ value used here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |     for s in &lst2 {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut res = vec![];\n    for s in lst1 {\n        if s.len() < total_len\
    \ {\n            res.push(s);\n        }\n    }\n    for s in lst2 {\n       \
    \ if s.len() < total_len {\n            res.push(s);\n        }\n    }\n    if\
    \ res.len() == 0 {\n        return vec![];\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmpoc2k7i9p.rs:22:14\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n11  |     let mut total_len = 0;\n\
    12  |     for s in lst1 {\n    |              ---- `lst1` moved due to this implicit\
    \ call to `.into_iter()`\n...\n22  |     for s in lst1 {\n    |              ^^^^\
    \ value used here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n12 \
    \ |     for s in &lst1 {\n    |              +\n\nerror[E0382]: use of moved value:\
    \ `lst2`\n  --> /tmp/tmpoc2k7i9p.rs:27:14\n   |\n10 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                                  \
    \ ---- move occurs because `lst2` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n...\n15 |     for s in lst2 {\n   |              ---- `lst2`\
    \ moved due to this implicit call to `.into_iter()`\n...\n27 |     for s in lst2\
    \ {\n   |              ^^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n15 |     for s in &lst2 {\n   |              +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = Vec::new();\n    let mut i\
    \ = 0;\n    while i < lst1.len() && i < lst2.len() {\n        if lst1[i].len()\
    \ < lst2[i].len() {\n            res.push(lst1[i]);\n            i += 1;\n   \
    \     } else {\n            res.push(lst2[i]);\n            i += 1;\n        }\n\
    \    }\n    if i < lst1.len() {\n        res.extend(lst1[i..]);\n    }\n    if\
    \ i < lst2.len() {\n        res.extend(lst2[i..]);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `[String]` cannot be known at\
    \ compilation time\n   --> /tmp/tmpuzkn41cw.rs:23:20\n    |\n23  |         res.extend(lst1[i..]);\n\
    \    |             ------ ^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |             |\n    |             required by a bound introduced by this\
    \ call\n    |\n    = help: the trait `Sized` is not implemented for `[String]`\n\
    note: required by a bound in `extend`\n\nerror[E0277]: `[String]` is not an iterator\n\
    \   --> /tmp/tmpuzkn41cw.rs:23:20\n    |\n23  |         res.extend(lst1[i..]);\n\
    \    |             ------ ^^^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \    |             |\n    |             required by a bound introduced by this\
    \ call\n    |\n    = note: the trait bound `[String]: IntoIterator` is not satisfied\n\
    \    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `[String]`\nnote: required by a bound in `extend`\nhelp: consider borrowing\
    \ here\n    |\n23  |         res.extend(&lst1[i..]);\n    |                  \
    \  +\n23  |         res.extend(&mut lst1[i..]);\n    |                    ++++\n\
    \nerror[E0277]: the size for values of type `[String]` cannot be known at compilation\
    \ time\n   --> /tmp/tmpuzkn41cw.rs:26:20\n    |\n26  |         res.extend(lst2[i..]);\n\
    \    |             ------ ^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |             |\n    |             required by a bound introduced by this\
    \ call\n    |\n    = help: the trait `Sized` is not implemented for `[String]`\n\
    note: required by a bound in `extend`\n\nerror[E0277]: `[String]` is not an iterator\n\
    \   --> /tmp/tmpuzkn41cw.rs:26:20\n    |\n26  |         res.extend(lst2[i..]);\n\
    \    |             ------ ^^^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \    |             |\n    |             required by a bound introduced by this\
    \ call\n    |\n    = note: the trait bound `[String]: IntoIterator` is not satisfied\n\
    \    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `[String]`\nnote: required by a bound in `extend`\nhelp: consider borrowi"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_len = 0;\n    for el in lst1\
    \ {\n        total_len += el.len();\n    }\n    for el in lst2 {\n        total_len\
    \ += el.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    let mut result = vec![];\n    for el in lst1 {\n        if el.len() < total_len\
    \ {\n            result.push(el);\n        }\n    }\n    for el in lst2 {\n  \
    \      if el.len() < total_len {\n            result.push(el);\n        }\n  \
    \  }\n    if result.len() == 0 {\n        return vec![];\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmpstw358pl.rs:25:15\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for el in lst1 {\n\
    \    |               ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n25  |     for el in lst1 {\n    |               ^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst1`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n15  |     for el in &lst1 {\n  \
    \  |               +\n\nerror[E0382]: use of moved value: `lst2`\n  --> /tmp/tmpstw358pl.rs:30:15\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18 |   \
    \  for el in lst2 {\n   |               ---- `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n...\n30 |     for el in lst2 {\n   |               ^^^^\
    \ value used here after move\n   |\nhelp: consider iterating over a slice of the\
    \ `Vec<String>`'s content to avoid moving into the `for` loop\n   |\n18 |    \
    \ for el in &lst2 {\n   |               +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = vec![];\n    for s in\
    \ lst1 {\n        for s2 in lst2 {\n            if s.len() < s2.len() {\n    \
    \            total_chars.push(s);\n                break;\n            }\n   \
    \     }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp77fb8jmm.rs:16:19\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n16  |  \
    \       for s2 in lst2 {\n    |                   ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n16  |         for s2 in &lst2 {\n    |         \
    \          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = vec![];\n    for i in 0..lst1.len()\
    \ {\n        if lst1[i].len() < lst2[i].len() {\n            res.push(lst1[i]);\n\
    \        } else {\n            res.push(lst2[i]);\n        }\n    }\n    if res.len()\
    \ == lst1.len() {\n        res\n    } else {\n        res\n    }\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp7xijjsp_.rs:14:22\n\
    \   |\n14 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp7xijjsp_.rs:16:22\n\
    \   |\n16 |             res.push(lst2[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut result = vec![];\n    for el1 in\
    \ lst1 {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n\
    \                if el1.len() == el2.len() {\n                    result.push(el1);\n\
    \                }\n            } else {\n                if el1.len() > el2.len()\
    \ {\n                    result.push(el2);\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpny9v6twr.rs:13:20\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n13  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror[E0382]: borrow of moved value: `el1`\n  --> /tmp/tmpny9v6twr.rs:14:16\n\
    \   |\n12 |     for el1 in lst1 {\n   |         ---\n   |         |\n   |    \
    \     this reinitialization might get skipped\n   |         move occurs because\
    \ `el1` has type `String`, which does not implement the `Copy` trait\n13 |   \
    \      for el2 in lst2 {\n14 |             if el1.len() < el2.len() {\n   |  \
    \              ^^^^^^^^^ value borrowed here after move\n15 |                \
    \ if el1.len() == el2.len() {\n16 |                     result.push(el1);\n  \
    \ |                                 --- value moved here, in previous iteration\
    \ of loop\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ x in lst1 {\n        total_chars += x.len();\n    }\n    for x in lst2 {\n \
    \       total_chars += x.len();\n    }\n    if total_chars == lst1.len() {\n \
    \       return vec![];\n    }\n    let mut result = vec![];\n    for x in lst1\
    \ {\n        if x < lst2 {\n            result.push(x);\n        }\n    }\n  \
    \  for x in lst2 {\n        if x < lst1 {\n            result.push(x);\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp53ed_t73.rs:26:16\n   |\n\
    26 |         if x < lst2 {\n   |                ^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp53ed_t73.rs:31:16\n\
    \   |\n31 |         if x < lst1 {\n   |                ^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<String>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst2;\n    }\n    return lst1;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmphfhuuqon.rs:19:16\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n19  | \
    \        return lst2;\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst2`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n12  |     for s in &lst2 {\n   \
    \ |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        if total_chars > s.len() {\n            total_chars = s.len();\n\
    \        }\n    }\n    lst1.iter().filter(|s| s.len() <= total_chars).collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpyk1rihd0.rs:17:52\n     |\n\
    17   |     lst1.iter().filter(|s| s.len() <= total_chars).collect()\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n     |\n     = help:\
    \ the trait `FromIterator<&String>` is not implemented for `Vec<String>`\n   \
    \  = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars > lst1.len() {\n        return lst2;\n    }\n\
    \    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpmv23wfns.rs:22:16\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n22  | \
    \        return lst2;\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst2`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n12  |     for s in &lst2 {\n   \
    \ |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = vec![];\n    for s\
    \ in lst1 {\n        for c in s {\n            total_chars.push(c);\n        }\n\
    \    }\n    for s in lst2 {\n        for c in s {\n            total_chars.push(c);\n\
    \        }\n    }\n    if total_chars.len() == lst1.len() {\n        return lst1;\n\
    \    }\n    if total_chars.len() == lst2.len() {\n        return lst2;\n    }\n\
    \    let mut total_chars = vec![];\n    for s in lst1 {\n        for c in s {\n\
    \            total_chars.push(c);\n        }\n    }\n    for s in lst2 {\n   \
    \     for c in s {\n            total_chars.push(c);\n        }\n    }\n    if\
    \ total_chars.len() == lst1.len() {\n        return lst1;\n    }\n    if total_chars.len()\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_chars = vec![];\n\
    \    for s in lst1 {\n        for c in s {\n            total_chars.push(c);\n\
    \        }\n    }\n    for s in lst2 {\n        for c in s {\n            total_chars.push(c);\n\
    \        }\n    }\n    if total_chars.len() == lst1.len() {\n        return lst1;\n\
    \    }\n    if total_chars.len() == lst2.len() {\n        return lst2;\n    }\n\
    \    let mut total_chars = vec![];\n    for s in lst1 {\n        for c in s {\n\
    \            total_chars.push(c);\n        }\n    }\n    for s in lst2 {\n   \
    \     for c in s {\n            total_chars.push(c);\n        }\n    }\n    if\
    \ total_chars.len() == lst1.len() {\n        return lst1;\n    }\n    if total_chars.len()\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_chars = vec![];\n\
    \    for s in lst1 {\n        for c in s {\n            total_chars.push(c);\n\
    \        }\n    }\n    for s in lst2 {\n        for c in s {\n            total_chars.push(c);\n\
    \        }\n    }\n    if total_chars.len() == lst1.len() {\n        return lst1;\n\
    \    }\n    if total_chars.len() == lst2.len() {\n        return lst2;\n    }\n\
    \    let mut total_chars = vec![];\n    for s in lst1 {\n        for c in s {\n\
    \            total_chars.push(c);\n        }\n    }\n    for s in lst2 {\n   \
    \     for c in s {\n            total_chars.push(c);\n        }\n    }\n    if\
    \ total_chars.len() == lst1.len() {\n        return lst1;\n    }\n    if total_chars.len()\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_chars = vec![];\n\
    \    for s in lst1 {\n        for c in s {\n            total_chars.push(c);\n\
    \        }\n    }\n    for s in lst2 {\n}\n\nfn main() {\n    let candidate =\
    \ total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp85c9s3em.rs:133:3\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n119 |     for s in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n120 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n133 | }\n    |   ^\n\n\
    error[E0277]: `String` is not an iterator\n  --> /tmp/tmp85c9s3em.rs:13:18\n \
    \  |\n13 |         for c in s {\n   |                  ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String` is not\
    \ an iterator\n  --> /tmp/tmp85c9s3em.rs:18:18\n   |\n18 |         for c in s\
    \ {\n   |                  ^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp85c9s3em.rs:30:18\n\
    \   |\n30 |         for c in s {\n   |                  ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String` is not\
    \ an iterator\n  --> /tmp/tmp85c9s3em.rs:35:18\n   |\n35 |         for c in s\
    \ {\n   |                  ^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp85c9s3em.rs:47:18\n\
    \   |\n47 |         for c in s {\n   |                  ^ `String` is not an iterator;\
    \ try calling"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut res = Vec::new();\n    for s in lst1\
    \ {\n        if lst2.iter().any(|s| s.len() < s.len()) {\n            res.push(s);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpjh4ahmaj.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars == lst2.len() {\n       \
    \ return lst2;\n    }\n    let mut total_chars = lst1.len();\n    for s in lst2\
    \ {\n        total_chars += s.len();\n    }\n    if total_chars < lst1.len() {\n\
    \        return lst1;\n    }\n    if total_chars < lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_chars = lst1.len();\n    for s in lst2 {\n \
    \       total_chars += s.len();\n    }\n    if total_chars == lst1.len() {\n \
    \       return lst1;\n    }\n    if total_chars == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_chars = lst1.len();\n    for s in lst2 {\n \
    \       total_chars += s.len();\n    }\n    if total_chars < lst1.len() {\n  \
    \      return lst1;\n    }\n    if total_chars < lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_chars = lst1.len();\n    for s in lst2 {\n \
    \       total_chars += s.len();\n    }\n    if total_chars == lst1.len() {\n \
    \       return lst1;\n    }\n    if total_chars == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_chars = lst1.len();\n    for s in lst2 {\n \
    \       total_chars += s.len();\n    }\n    if total_chars < lst1.len() {\n  \
    \      return lst1;\n    }\n    if total_chars < lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_chars = lst1.len();\n    for s in lst2 {\n \
    \       total_chars += s.len();\n    }\n    if total_chars == lst1.len() {\n \
    \       return lst1;\n    }\n    if total_chars == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_chars = lst1.len();\n    for s in lst2 {\n \
    \       total_chars += s.len();\n    }\n    if total_chars < lst1.len() {\n  \
    \      return lst1;\n    }\n    if total_chars < lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_chars = lst1.len();\n    for s in lst2 {\n \
    \       total_chars += s.len();\n    }\n    if total_chars == lst1.len() {\n \
    \       return lst1;\n    }\n    if total_chars == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_chars = lst1.len();\n    for s in lst2 {\n \
    \       total_\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5f_o0qvp.rs:117:3\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n102 |     for s in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n103 |         total_\n\
    104 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    117 | }\n    |   ^\n\nerror[E0425]: cannot find value `total_` in this scope\n\
    \   --> /tmp/tmp5f_o0qvp.rs:103:9\n    |\n103 |         total_\n    |        \
    \ ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5f_o0qvp.rs:10:57\n\
    \   |\n10 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    let mut total_chars = lst1.len();\n    for\
    \ s in lst2 {\n        total_chars += s.len();\n    }\n    if total_chars == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_chars < lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_chars > lst1.len() {\n        return lst2;\n    }\n\
    \    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpo9g06lh0.rs:22:16\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n11  |     let\
    \ mut total_chars = lst1.len();\n12  |     for s in lst2 {\n    |            \
    \  ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n22  | \
    \        return lst2;\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst2`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n12  |     for s in &lst2 {\n   \
    \ |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts two lists of strings and returns the\
    \ list that has \n/// total number of chars in the all strings of the list less\
    \ than the other list.\n/// if the two lists have the same number of chars, return\
    \ the first list.\n/// Examples\n/// total_match([], []) \u279E []\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n/// total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n/// total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n/// total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) \u279E ['4']\nfn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n    if lst1.len() == 0 || lst2.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut total_chars = lst1.len();\n    for\
    \ el in lst1 {\n        total_chars += el.len();\n    }\n    for el in lst2 {\n\
    \        total_chars += el.len();\n    }\n    if total_chars == lst1.len() {\n\
    \        return vec![];\n    }\n    if total_chars == lst2.len() {\n        return\
    \ vec![];\n    }\n    let mut result = vec![];\n    for el1 in lst1 {\n      \
    \  for el2 in lst2 {\n            if el1.len() < el2.len() {\n               \
    \ result.push(el1);\n                break;\n            }\n        }\n    }\n\
    \    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len() >\
    \ el2.len() {\n                result.push(el2);\n                break;\n   \
    \         }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmpiog3i_jz.rs:21:23\n\
    \    |\n10  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n15  |     for el in lst1 {\n\
    \    |               ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     if total_chars == lst1.len() {\n    |                       ^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice\
    \ of the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n\
    15  |     for el in &lst1 {\n    |               +\n\nerror[E0382]: borrow of\
    \ moved value: `lst2`\n  --> /tmp/tmpiog3i_jz.rs:24:23\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n18 |     for el in lst2 {\n   |       \
    \        ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n\
    24 |     if total_chars == lst2.len() {\n   |                       ^^^^^^^^^^\
    \ value borrowed here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<String>`'s content to avoid moving into the `for` loop\n   |\n18\
    \ |     for el in &lst2 {\n   |               +\n\nerror[E0382]: use of moved\
    \ value: `lst1`\n  --> /tmp/tmpiog3i_jz.rs:36:16\n   |\n10 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                ---- move\
    \ occurs because `lst1` has type `Vec<String>`, which does not implement the `Copy`\
    \ trait\n...\n28 |     for el1 in lst1 {\n   |                ---- `lst1` moved\
    \ due to this implicit call to `.into_iter()`\n...\n36 |     for el1 in lst1 {\n\
    \   |                ^^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n28 |     for el1 in &lst1 {\n   |"
  exit_code: 1
  status: SyntaxError
