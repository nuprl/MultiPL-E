name: HumanEval_72_will_it_fly
language: rust
results:
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max = 0;\n    let\
    \ mut sum = 0;\n    for i in q.iter() {\n        sum += i;\n        if sum > max\
    \ {\n            max = sum;\n        }\n    }\n    if sum < w {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    while i < q.len() {\n        if q[i]\
    \ != q[q.len() - 1 - i] {\n            return false;\n        }\n        i +=\
    \ 1;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnofbnnn2.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for x in q {\n        sum += x;\n        max_weight\
    \ = if sum > max_weight { max_weight } else { sum };\n    }\n    sum == max_weight\
    \ && is_balanced(q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpiye71prt.rs:19:26\n\
    \   |\n19 |     sum == max_weight && is_balanced(q)\n   |                    \
    \      ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ &i in q {\n        sum += i;\n    }\n    if sum < w {\n        return false;\n\
    \    }\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = q.len();\n   \
    \ while i < k {\n        if q[i] != q[j] {\n            return false;\n      \
    \  }\n        i += 1;\n        j += 1;\n    }\n    true\n}\n\nfn main() {\n  \
    \  let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqzjh6559.rs:14:9\n   |\n\
    14 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max = 0;\n    for x in q {\n        sum += x;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    sum == max && is_palindromic(q)\
    \ && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpj1rs6a4d.rs:21:19\n   |\n21 |     sum == max && is_palindromic(q) &&\
    \ sum <= w\n   |                   ^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    let mut sum = 0;\n    for v in q.iter()\
    \ {\n        sum += v;\n        if sum > max_weight {\n            max_weight\
    \ = sum;\n        }\n        if sum == max_weight {\n            is_balanced =\
    \ false;\n        }\n    }\n    sum == max_weight && is_balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp11nb1hs9.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for &i in q {\n        sum += i;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            sum\n\
    \        };\n    }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplytbn4i7.rs:15:9\n   |\n\
    15 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for x in q {\n        sum += x;\n        if sum > max_weight\
    \ {\n            max_weight = sum;\n        }\n    }\n    if max_weight <= w {\n\
    \        return true;\n    }\n    let mut is_balanced = true;\n    let mut i =\
    \ 0;\n    while i < q.len() && is_balanced {\n        if q[i] != q[q.len() - 1\
    \ - i] {\n            is_balanced = false;\n        }\n        i += 1;\n    }\n\
    \    if is_balanced {\n        true\n    } else {\n        false\n    }\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmppey85swb.rs:26:15\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for x in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n26  |     while i < q.len()\
    \ && is_balanced {\n    |               ^^^^^^^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `q`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n15  |     for x in &q {\n    |    \
    \          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = w;\n\
    \    let mut balanced = true;\n    let mut sum = 0;\n    for &x in q {\n     \
    \   sum += x;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if sum < max_weight {\n            balanced = false;\n   \
    \     }\n    }\n    balanced && sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp58l44j4r.rs:16:9\n   |\n\
    16 |     for &x in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = w;\n\
    \    let mut is_balanced = true;\n    let mut sum = 0;\n    for &i in q {\n  \
    \      sum += i;\n        if sum > max_weight {\n            is_balanced = false;\n\
    \            break;\n        }\n    }\n    if is_balanced {\n        true\n  \
    \  } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqdxpnslh.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    let mut is_balanced = true;\n    for e in q {\n   \
    \     sum += e;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if sum < w {\n            is_balanced = false;\n         \
    \   break;\n        }\n    }\n    is_balanced && sum == max_weight\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsv4ca2mr.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for i in q.iter() {\n        sum += i;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n    }\n    if\
    \ max_weight == w {\n        return true;\n    }\n    if sum == w {\n        return\
    \ false;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut i\
    \ = 0;\n    while i < q.len() {\n        if q[i] > w {\n            break;\n \
    \       }\n        i += 1;\n    }\n    let mut j = q.len() - 1;\n    while j >=\
    \ 0 {\n        if q[j] > w {\n            break;\n        }\n        j -= 1;\n\
    \    }\n    if i == j {\n        return false;\n    }\n    let mut k = i;\n  \
    \  while k <= j {\n        if q[k] != q[i] {\n            break;\n        }\n\
    \        k += 1;\n    }\n    if k == i {\n        return true;\n    }\n    if\
    \ k > j {\n        return false;\n    }\n    let mut i = k;\n    while i < q.len()\
    \ {\n        if q[i] > w {\n            break;\n        }\n        i += 1;\n \
    \   }\n    let mut j = q.len() - 1;\n    while j >= 0 {\n        if q[j] > w {\n\
    \            break;\n        }\n        j -= 1;\n    }\n    if i == j {\n    \
    \    return false;\n    }\n    let mut k = i;\n    while k <= j {\n        if\
    \ q[k] != q[i] {\n            break;\n        }\n        k += 1;\n    }\n    if\
    \ k == i {\n        return true;\n    }\n    if k > j {\n        return false;\n\
    \    }\n    let mut i = k;\n    while i < q.len() {\n        if q[i] > w {\n \
    \           break;\n        }\n        i += 1;\n    }\n    let mut j = q.len()\
    \ - 1;\n    while j >= 0 {\n        if q[j] > w {\n            break;\n      \
    \  }\n        j -= 1;\n    }\n    if i == j {\n        return false;\n    }\n\
    \    let mut k = i;\n    while k <= j {\n        if q[k] != q[i] {\n         \
    \   break;\n        }\n        k += 1;\n    }\n    if k == i {\n        return\
    \ true;\n    }\n    if k > j {\n        return false;\n    }\n    let mut i =\
    \ k;\n    while i < q.len() {\n        if q[i] > w {\n            break;\n   \
    \     }\n        i += 1;\n    }\n    let mut j = q.len() - 1;\n    while j >=\
    \ 0 {\n        if q[j] > w {\n            break;\n        }\n        j -= 1;\n\
    \    }\n    if i == j {\n        return false;\n    }\n    let mut k = i;\n  \
    \  while k <= j {\n        if q[k\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpf16foi33.rs:150:3\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n138 |  \
    \   while k <= j {\n    |                  - this delimiter might not be properly\
    \ closed...\n139 |         if q[k\n140 | }\n    | - ...as it matches this but\
    \ it has different indentation\n...\n150 | }\n    |   ^\n\nerror: expected `{`,\
    \ found `}`\n   --> /tmp/tmpf16foi33.rs:140:1\n    |\n139 |         if q[k\n \
    \   |         -- this `if` expression has a condition, but no block\n140 | }\n\
    \    | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n   --> /tmp/tmpf16foi33.rs:139:13\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \                                          - closing delimiter possibly meant\
    \ for this\n...\n139 |         if q[k\n    |             ^ unclosed delimiter\n\
    140 | }\n    | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf16foi33.rs:12:44\n   |\n12 | fn will_it_fly(q: Vec<isize>, w:\
    \ isize) -> bool {\n   |    -----------                             ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ x in q {\n        sum += x;\n    }\n    sum < w && is_palindromic(q) && sum\
    \ == w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpr09pbex1.rs:17:16\n   |\n17 |     sum < w && is_palindromic(q) && sum\
    \ == w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = true;\n\
    \    let mut sum = 0;\n    for i in q {\n        sum += i;\n        if sum > w\
    \ {\n            balanced = false;\n            break;\n        }\n    }\n   \
    \ balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp486rchsi.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = w;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for v in q.iter() {\n\
    \        sum += v;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if v == q[q.len() - 1] {\n            balanced = true;\n \
    \       }\n    }\n    balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp2iqwysh6.rs:21:14\n\
    \   |\n21 |         if v == q[q.len() - 1] {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for v in q {\n        sum += v;\n        if sum > max_weight\
    \ {\n            max_weight = sum;\n        }\n    }\n    if max_weight <= w {\n\
    \        return true;\n    }\n    let mut reversed_q = q.iter().rev();\n    let\
    \ mut sum = 0;\n    let mut max_weight = 0;\n    for v in reversed_q {\n     \
    \   sum += v;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if max_weight <= w {\n        return true;\n    }\n   \
    \ false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpftyf9af4.rs:24:9\n\
    \   |\n24 |     let mut reversed_q = q.iter().rev();\n   |         ----^^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpftyf9af4.rs:24:26\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for v in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n24  |     let mut reversed_q\
    \ = q.iter().rev();\n    |                          ^^^^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `q`\n    = note: borrow occurs due to deref coercion to `[isize]`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for v in &q {\n    |              +\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    let mut is_balanced = true;\n    for v in q.iter()\
    \ {\n        sum += v;\n        if sum > max_weight {\n            max_weight\
    \ = sum;\n        }\n        if sum < w {\n            is_balanced = false;\n\
    \            break;\n        }\n    }\n    return is_balanced && sum == max_weight;\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzja38554.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    for &i in q {\n        sum += i;\n        if sum ==\
    \ w {\n            balanced = true;\n            break;\n        }\n    }\n  \
    \  balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpllbywh5c.rs:15:9\n   |\n\
    15 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for &i in q {\n        sum += i;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            max_weight\
    \ + i\n        };\n    }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgcdv5szg.rs:15:9\n   |\n\
    15 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for x in q {\n        sum += x;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            max_weight\
    \ + x\n        };\n    }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuppcjbx1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q_rev = q.iter().rev();\n\
    \    let mut q_rev_sum = q_rev.sum();\n    let mut max_sum = w;\n    let mut is_balanced\
    \ = true;\n    for x in q {\n        if x > max_sum {\n            is_balanced\
    \ = false;\n            break;\n        }\n        max_sum -= x;\n        q_rev_sum\
    \ -= x;\n    }\n    if is_balanced && q_rev_sum < w {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpztyxl6o5.rs:14:9\n\
    \   |\n14 |     let mut q_rev_sum = q_rev.sum();\n   |         ^^^^^^^^^^^^^ consider\
    \ giving `q_rev_sum` a type\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max = 0;\n    let\
    \ mut sum = 0;\n    for x in q {\n        sum += x;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    sum == max && q == q.iter().rev().collect::<Vec<_>>().is_empty()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `Vec<isize>` with `bool`\n  --> /tmp/tmphzs548a4.rs:21:21\n\
    \   |\n21 |     sum == max && q == q.iter().rev().collect::<Vec<_>>().is_empty()\n\
    \   |                     ^^ no implementation for `Vec<isize> == bool`\n   |\n\
    \   = help: the trait `PartialEq<bool>` is not implemented for `Vec<isize>`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as\
    \ PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n      \
    \       <Vec<T, A> as PartialEq<[U]>>\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q_rev = q.iter().rev();\n\
    \    let mut q_rev_sum = q_rev.sum();\n    let mut q_sum = q.iter().sum();\n \
    \   \n    if q_rev_sum < w {\n        return false;\n    }\n    \n    while q_sum\
    \ < w {\n        q_rev_sum -= q[q.len() - 1];\n        q_sum += q[q.len() - 1];\n\
    \    }\n    \n    q_rev_sum < w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpvbgv_4ts.rs:14:9\n\
    \   |\n14 |     let mut q_rev_sum = q_rev.sum();\n   |         ^^^^^^^^^^^^^ consider\
    \ giving `q_rev_sum` a type\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_sum = 0;\n\
    \    let mut is_balanced = true;\n    let mut sum = 0;\n    for x in q {\n   \
    \     sum += x;\n        if sum > w {\n            is_balanced = false;\n    \
    \        break;\n        }\n        max_sum += x;\n    }\n    if is_balanced {\n\
    \        sum == max_sum\n    } else {\n        false\n    }\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1wqa5ake.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for &i in q {\n        sum += i;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            sum\n\
    \        };\n    }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqyztf1c4.rs:15:9\n   |\n\
    15 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for &i in q {\n        sum += i;\n        if sum >\
    \ max_weight {\n            max_weight = sum;\n        }\n    }\n    if sum <\
    \ w {\n        return false;\n    }\n    let mut reversed_q = q.iter().rev();\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    for &i in reversed_q {\n\
    \        sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if sum < w {\n        return true;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8sz3sftz.rs:15:9\n   |\n\
    15 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ x in q {\n        sum += x;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpdlbaanz6.rs:17:16\n\
    \   |\n17 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ x in q {\n        sum += x;\n    }\n    sum < w && is_palindromic(q) && sum\
    \ == w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpq0m0nqmg.rs:17:16\n   |\n17 |     sum < w && is_palindromic(q) && sum\
    \ == w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max = 0;\n    let\
    \ mut sum = 0;\n    for v in q.iter() {\n        sum += v;\n        if sum > max\
    \ {\n            max = sum;\n        }\n    }\n    if sum < w {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    while i < q.len() {\n        if q[i]\
    \ != q[q.len() - 1 - i] {\n            return false;\n        }\n        i +=\
    \ 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n  \
    \  assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvpaez1z7.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ v in q.iter() {\n        sum += v;\n    }\n    sum < w && is_palindromic(q)\
    \ && sum >= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmprmotbc0b.rs:17:16\n   |\n17 |     sum < w && is_palindromic(q) && sum\
    \ >= w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for &i in q {\n    \
    \    sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if max_weight == w {\n        balanced = true;\n    }\n\
    \    !balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4oawp_se.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut balanced = false;\n    for x in q {\n        if x > max_weight {\n\
    \            max_weight = x;\n        }\n        if x == q[q.len() - 1] {\n  \
    \          balanced = true;\n        }\n    }\n    if balanced && max_weight <=\
    \ w {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmp4ighywt9.rs:19:17\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for x in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n19  |         if x == q[q.len()\
    \ - 1] {\n    |                 ^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `q`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for x in &q {\n    |              +\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    let mut is_balanced =\
    \ true;\n    while q.len() > 0 {\n        sum += q.last();\n        q.pop();\n\
    \        if sum > max_weight {\n            max_weight = sum;\n        }\n   \
    \     if sum == max_weight {\n            is_balanced = false;\n            break;\n\
    \        }\n    }\n    sum == max_weight && is_balanced\n}\n\nfn main() {\n  \
    \  let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `Option<&isize>` to `{integer}`\n  -->\
    \ /tmp/tmp0271puc_.rs:18:13\n   |\n18 |         sum += q.last();\n   |       \
    \      ^^ no implementation for `{integer} += Option<&isize>`\n   |\n   = help:\
    \ the trait `AddAssign<Option<&isize>>` is not implemented for `{integer}`\n \
    \  = help: the following other types implement trait `AddAssign<Rhs>`:\n     \
    \        <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n         \
    \    <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16 as\
    \ AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for x in q {\n        sum += x;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            sum\n\
    \        };\n    }\n    sum == w && max_weight <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfnhqfjh_.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    for el in q {\n        if el > max_weight\
    \ {\n            max_weight = el;\n        }\n        if el != q[q.len() - 1 -\
    \ el] {\n            is_balanced = false;\n            break;\n        }\n   \
    \ }\n    if is_balanced {\n        let mut sum = 0;\n        for el in q {\n \
    \           sum += el;\n        }\n        sum < w && sum == max_weight\n    }\
    \ else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp97ofqj1l.rs:19:34\n   |\n\
    19 |         if el != q[q.len() - 1 - el] {\n   |                            \
    \      ^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize`\
    \ from `usize`\n  --> /tmp/tmp97ofqj1l.rs:19:32\n   |\n19 |         if el != q[q.len()\
    \ - 1 - el] {\n   |                                ^ no implementation for `usize\
    \ - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for x in q {\n        sum += x;\n        if sum > max_weight\
    \ {\n            max_weight = sum;\n        }\n    }\n    if max_weight == w {\n\
    \        return true;\n    }\n    if max_weight > w {\n        return false;\n\
    \    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len()\
    \ {\n        if q[i] > q[j] {\n            i += 1;\n        } else {\n       \
    \     j += 1;\n        }\n    }\n    if i == q.len() {\n        return true;\n\
    \    }\n    if j == q.len() {\n        return false;\n    }\n    if q[i] == q[j]\
    \ {\n        i += 1;\n        j += 1;\n    }\n    while i < q.len() {\n      \
    \  if q[i] > q[j] {\n            i += 1;\n        } else {\n            j += 1;\n\
    \        }\n    }\n    if i == q.len() {\n        return true;\n    }\n    if\
    \ j == q.len() {\n        return false;\n    }\n    if q[i] == q[j] {\n      \
    \  i += 1;\n        j += 1;\n    }\n    while i < q.len() {\n        if q[i] >\
    \ q[j] {\n            i += 1;\n        } else {\n            j += 1;\n       \
    \ }\n    }\n    if i == q.len() {\n        return true;\n    }\n    if j == q.len()\
    \ {\n        return false;\n    }\n    if q[i] == q[j] {\n        i += 1;\n  \
    \      j += 1;\n    }\n    while i < q.len() {\n        if q[i] > q[j] {\n   \
    \         i += 1;\n        } else {\n            j += 1;\n        }\n    }\n \
    \   if i == q.len() {\n        return true;\n    }\n    if j == q.len() {\n  \
    \      return false;\n    }\n    if q[i] == q[j] {\n        i += 1;\n        j\
    \ += 1;\n    }\n    while i < q.len() {\n        if q[i] > q[j] {\n          \
    \  i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    if i\
    \ == q.len() {\n        return true;\n    }\n    if j == q.len() {\n        return\
    \ false;\n    }\n    if q[i] == q[j] {\n        i += 1;\n        j += 1;\n   \
    \ }\n    while i < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    if i == q.len()\
    \ {\n        return true;\n    }\n    if j == q.len() {\n        return false;\n\
    \    }\n    if q[i] == q[j] {\n        i += 1;\n        j += 1;\n    }\n    while\
    \ i < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ true;\n    }\n    if j == \n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmp283p11ed.rs:142:1\n\
    \    |\n142 | }\n    | ^ expected expression\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for el in q {\n        sum += el;\n        max_weight\
    \ = max_weight > el ? max_weight : el;\n    }\n    if sum == w {\n        true\n\
    \    } else if sum > w {\n        false\n    } else {\n        max_weight <= w\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `max_weight`\n\
    \  --> /tmp/tmpvohfvkup.rs:17:40\n   |\n17 |         max_weight = max_weight >\
    \ el ? max_weight : el;\n   |                                        ^^^^^^^^^^\
    \ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to\
    \ previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max = 0;\n    let\
    \ mut sum = 0;\n    for &i in q {\n        sum += i;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    sum == max && is_palindromic(q)\
    \ && is_balanced(q, w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpy3np5tjp.rs:21:19\n   |\n21 |     sum == max && is_palindromic(q) &&\
    \ is_balanced(q, w)\n   |                   ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpy3np5tjp.rs:21:40\n\
    \   |\n21 |     sum == max && is_palindromic(q) && is_balanced(q, w)\n   |   \
    \                                     ^^^^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpy3np5tjp.rs:15:9\n   |\n15 |   \
    \  for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ x in q {\n        sum += x;\n    }\n    if sum == w {\n        return true;\n\
    \    }\n    if sum < w {\n        return false;\n    }\n    let mut max_weight\
    \ = w;\n    for x in q {\n        max_weight = std::cmp::max(max_weight, x);\n\
    \    }\n    let mut max_weight_index = 0;\n    let mut max_weight_sum = 0;\n \
    \   for x in q.iter() {\n        max_weight_sum += x;\n        if max_weight_sum\
    \ > max_weight {\n            max_weight_index = q.iter().position(|&x| x == max_weight_sum);\n\
    \            max_weight_sum = max_weight_sum;\n        }\n    }\n    if max_weight_index\
    \ == q.len() {\n        return true;\n    }\n    let mut max_weight_index = max_weight_index;\n\
    \    let mut max_weight_sum = max_weight_sum;\n    for x in q.iter() {\n     \
    \   max_weight_sum += x;\n        if max_weight_sum > max_weight {\n         \
    \   max_weight_index = q.iter().position(|&x| x == max_weight_sum);\n        \
    \    max_weight_sum = max_weight_sum;\n        }\n    }\n    if max_weight_index\
    \ == q.len() {\n        return true;\n    }\n    if max_weight_index > q.len()\
    \ {\n        return false;\n    }\n    let mut max_weight_index = max_weight_index;\n\
    \    let mut max_weight_sum = max_weight_sum;\n    for x in q.iter() {\n     \
    \   max_weight_sum += x;\n        if max_weight_sum > max_weight {\n         \
    \   max_weight_index = q.iter().position(|&x| x == max_weight_sum);\n        \
    \    max_weight_sum = max_weight_sum;\n        }\n    }\n    if max_weight_index\
    \ == q.len() {\n        return true;\n    }\n    if max_weight_index > q.len()\
    \ {\n        return false;\n    }\n    let mut max_weight_index = max_weight_index;\n\
    \    let mut max_weight_sum = max_weight_sum;\n    for x in q.iter() {\n     \
    \   max_weight_sum += x;\n        if max_weight_sum > max_weight {\n         \
    \   max_weight_index = q.iter().position(|&x| x == max_weight_sum);\n        \
    \    max_weight_sum = max_weight_sum;\n        }\n    }\n    if max_weight_index\
    \ == q.len() {\n        return true;\n    }\n    if max_weight_index > q.len()\
    \ {\n        return false;\n    }\n    let mut max_weight_index = max_weight_index;\n\
    \    let mut max_weight_sum = max_weight_sum;\n    for x in q.iter() {\n     \
    \   max_weight_sum += x;\n        if max_weight_sum > max_weight {\n         \
    \   max_weight_index = q.iter().position(|&x| x == max_weight_sum);\n        \
    \    max_weight_sum = max_weight_sum;\n        }\n    }\n    if max_weight_index\
    \ == q.len() {\n        return true;\n    }\n    if \n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp35c9p7dn.rs:97:1\n\
    \   |\n97 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp35c9p7dn.rs:32:32\n   |\n27 |     let mut max_weight_index = 0;\n\
    \   |                                - expected due to this value\n...\n32 | \
    \            max_weight_index = q.iter().position(|&x| x == max_weight_sum);\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp35c9p7dn.rs:44:32\n   |\n39 |     let mut max_weight_index = max_weight_index;\n\
    \   |                                ---------------- expected due to this value\n\
    ...\n44 |             max_weight_index = q.iter().position(|&x| x == max_weight_sum);\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp35c9p7dn.rs:59:32\n   |\n54 |     let mut max_weight_index = max_weight_index;\n\
    \   |                                ---------------- expected due to this value\n\
    ...\n59 |             max_weight_index = q.iter().position(|&x| x == max_weight_sum);\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp35c9p7dn.rs:74:32\n   |\n69 |     let mut max_weight_index = max_weight_index;\n\
    \   |                                ---------------- expected due to this value\n\
    ...\n74 |             max_weight_index = q.iter().position(|&x| x == max_weight_sum);\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for i in q {\n        sum += i;\n        max_weight\
    \ = max_weight if i > max_weight else i;\n    }\n    sum < max_weight && is_palindromic(q)\
    \ && is_balanced(q, w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmp5b946pgp.rs:17:33\n   |\n17 |         max_weight\
    \ = max_weight if i > max_weight else i;\n   |                               \
    \  ^^ expected one of 8 possible tokens\n\nerror[E0425]: cannot find function\
    \ `is_palindromic` in this scope\n  --> /tmp/tmp5b946pgp.rs:19:25\n   |\n19 |\
    \     sum < max_weight && is_palindromic(q) && is_balanced(q, w)\n   |       \
    \                  ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_balanced` in this scope\n  --> /tmp/tmp5b946pgp.rs:19:46\n\
    \   |\n19 |     sum < max_weight && is_palindromic(q) && is_balanced(q, w)\n \
    \  |                                              ^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    for e in q {\n        if e > max_weight\
    \ {\n            max_weight = e;\n        }\n        if e != q[q.len() - 1 - e]\
    \ {\n            is_balanced = false;\n            break;\n        }\n    }\n\
    \    if is_balanced {\n        let mut sum = 0;\n        for e in q {\n      \
    \      sum += e;\n        }\n        sum < w && sum == max_weight\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeio_cq43.rs:19:33\n   |\n\
    19 |         if e != q[q.len() - 1 - e] {\n   |                              \
    \   ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize`\
    \ from `usize`\n  --> /tmp/tmpeio_cq43.rs:19:31\n   |\n19 |         if e != q[q.len()\
    \ - 1 - e] {\n   |                               ^ no implementation for `usize\
    \ - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for x in q {\n        sum += x;\n        max_weight\
    \ = if sum > max_weight { max_weight } else { sum };\n    }\n    max_weight <=\
    \ w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpen1gm4wt.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for &i in q {\n    \
    \    sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if sum == max_weight {\n            balanced = true;\n   \
    \     }\n    }\n    if balanced {\n        sum == max_weight\n    } else {\n \
    \       sum < max_weight\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi9qzwzew.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = true;\n\
    \    let mut sum = 0;\n    for &x in q {\n        sum += x;\n        balanced\
    \ = balanced && sum >= w;\n    }\n    balanced\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprnixvojn.rs:15:9\n   |\n\
    15 |     for &x in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    let mut max_weight = w;\n    let mut sum = 0;\n    while q.len() > 0 {\n\
    \        sum += q.last().unwrap();\n        q.pop();\n    }\n    if sum < max_weight\
    \ {\n        return false;\n    }\n    let mut q = q.to_vec();\n    let mut max_weight\
    \ = w;\n    let mut sum = 0;\n    while q.len() > 0 {\n        sum += q.last().unwrap();\n\
    \        q.pop();\n    }\n    if sum < max_weight {\n        return true;\n  \
    \  }\n    let mut q = q.to_vec();\n    let mut max_weight = w;\n    let mut sum\
    \ = 0;\n    while q.len() > 0 {\n        sum += q.last().unwrap();\n        q.pop();\n\
    \    }\n    if sum < max_weight {\n        return false;\n    }\n    let mut q\
    \ = q.to_vec();\n    let mut max_weight = w;\n    let mut sum = 0;\n    while\
    \ q.len() > 0 {\n        sum += q.last().unwrap();\n        q.pop();\n    }\n\
    \    if sum < max_weight {\n        return true;\n    }\n    let mut q = q.to_vec();\n\
    \    let mut max_weight = w;\n    let mut sum = 0;\n    while q.len() > 0 {\n\
    \        sum += q.last().unwrap();\n        q.pop();\n    }\n    if sum < max_weight\
    \ {\n        return false;\n    }\n    let mut q = q.to_vec();\n    let mut max_weight\
    \ = w;\n    let mut sum = 0;\n    while q.len() > 0 {\n        sum += q.last().unwrap();\n\
    \        q.pop();\n    }\n    if sum < max_weight {\n        return true;\n  \
    \  }\n    let mut q = q.to_vec();\n    let mut max_weight = w;\n    let mut sum\
    \ = 0;\n    while q.len() > 0 {\n        sum += q.last().unwrap();\n        q.pop();\n\
    \    }\n    if sum < max_weight {\n        return false;\n    }\n    let mut q\
    \ = q.to_vec();\n    let mut max_weight = w;\n    let mut sum = 0;\n    while\
    \ q.len() > 0 {\n        sum += q.last().unwrap();\n        q.pop();\n    }\n\
    \    if sum < max_weight {\n        return true;\n    }\n    let mut q = q.to_vec();\n\
    \    let mut max_weight = w;\n    let mut sum = 0;\n    while q.len() > 0 {\n\
    \        sum += q.last().unwrap();\n        q.pop();\n    }\n    if sum < max_weight\
    \ {\n        return false;\n    }\n    let mut q = q.to_vec();\n    let mut max_weight\
    \ = w;\n    let mut sum = 0;\n    while q.len() > 0 {\n        sum += q.last().unwrap();\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpe1h9njow.rs:118:3\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n106 |  \
    \   while q.len() > 0 {\n    |                       - this delimiter might not\
    \ be properly closed...\n107 |         sum += q.last().unwrap();\n108 | }\n  \
    \  | - ...as it matches this but it has different indentation\n...\n118 | }\n\
    \    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe1h9njow.rs:12:44\n\
    \   |\n12 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |    -----------\
    \                             ^^^^ expected `bool`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max = 0;\n    let\
    \ mut sum = 0;\n    for x in q {\n        sum += x;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    if w == max {\n        return true;\n\
    \    }\n    let mut balanced = false;\n    let mut sum = 0;\n    for x in q {\n\
    \        sum += x;\n        if sum > max {\n            balanced = true;\n   \
    \         break;\n        }\n    }\n    if balanced {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `q`\n   --> /tmp/tmp62ozyfov.rs:26:14\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for x in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n26  |     for x in q {\n \
    \   |              ^ value used here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `q`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n15  |     for x in &q {\n    |              +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q_rev = q.iter().rev();\n\
    \    let mut max_weight = w;\n    let mut is_balanced = true;\n    let mut sum\
    \ = 0;\n    for &x in q_rev {\n        sum += x;\n        if sum > max_weight\
    \ {\n            is_balanced = false;\n            break;\n        }\n    }\n\
    \    if is_balanced {\n        true\n    } else {\n        false\n    }\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpffaqxaux.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    for i in q {\n        sum += i;\n        if sum > w\
    \ {\n            balanced = false;\n            break;\n        }\n    }\n   \
    \ balanced && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbegj5s5i.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    let mut sum = 0;\n    for x in q {\n   \
    \     sum += x;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if sum < w {\n        is_balanced = false;\n    }\n   \
    \ is_balanced && max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2m9meili.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for &i in q {\n        sum += i;\n        max_weight\
    \ = if sum > max_weight { max_weight } else { sum };\n    }\n    sum == max_weight\
    \ && is_balanced(q, w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpkcqa2qao.rs:19:26\n\
    \   |\n19 |     sum == max_weight && is_balanced(q, w)\n   |                 \
    \         ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkcqa2qao.rs:15:9\n   |\n15 |     for &i in q {\n   |         ^^\
    \    - this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_sum = 0;\n\
    \    let mut is_balanced = true;\n    for x in q {\n        if x > w {\n     \
    \       is_balanced = false;\n            break;\n        }\n        max_sum +=\
    \ x;\n    }\n    if max_sum < w {\n        is_balanced = false;\n    }\n    is_balanced\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy2fuctdb.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_sum = 0;\n\
    \    let mut is_balanced = true;\n    for el in q {\n        if el > max_sum {\n\
    \            max_sum = el;\n        }\n        if el == max_sum {\n          \
    \  is_balanced = false;\n        }\n    }\n    if !is_balanced {\n        return\
    \ false;\n    }\n    let mut sum = 0;\n    for el in q {\n        sum += el;\n\
    \    }\n    if sum == w {\n        return true;\n    }\n    if sum > w {\n   \
    \     return false;\n    }\n    let mut max_weight = 0;\n    for el in q {\n \
    \       if el > max_weight {\n            max_weight = el;\n        }\n    }\n\
    \    if max_weight == w {\n        return true;\n    }\n    if max_weight > w\
    \ {\n        return false;\n    }\n    let mut max_weight = 0;\n    for el in\
    \ q {\n        if el > max_weight {\n            max_weight = el;\n        }\n\
    \    }\n    if max_weight == w {\n        return true;\n    }\n    if max_weight\
    \ > w {\n        return false;\n    }\n    let mut max_weight = 0;\n    for el\
    \ in q {\n        if el > max_weight {\n            max_weight = el;\n       \
    \ }\n    }\n    if max_weight == w {\n        return true;\n    }\n    if max_weight\
    \ > w {\n        return false;\n    }\n    let mut max_weight = 0;\n    for el\
    \ in q {\n        if el > max_weight {\n            max_weight = el;\n       \
    \ }\n    }\n    if max_weight == w {\n        return true;\n    }\n    if max_weight\
    \ > w {\n        return false;\n    }\n    let mut max_weight = 0;\n    for el\
    \ in q {\n        if el > max_weight {\n            max_weight = el;\n       \
    \ }\n    }\n    if max_weight == w {\n        return true;\n    }\n    if max_weight\
    \ > w {\n        return false;\n    }\n    let mut max_weight = 0;\n    for el\
    \ in q {\n        if el > max_weight {\n            max_weight = el;\n       \
    \ }\n    }\n    if max_weight == w {\n        return true;\n    }\n    if max_weight\
    \ > w {\n        return false;\n    }\n    let mut max_weight = 0;\n    for el\
    \ in q {\n        if el > max_weight {\n            max_weight = el;\n       \
    \ }\n    }\n    if max_weight == w {\n        return true;\n    }\n    if max_weight\
    \ > w {\n        return false;\n    }\n    let mut max_weight = 0;\n    for el\
    \ in q {\n        if el > max_weight {\n            max_weight = el;\n       \
    \ }\n    }\n    if max_weight == w {\n        return true;\n    }\n    if max_weight\
    \ > w {\n        return false;\n    }\n    let mut max_weight = 0;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdo5c4dot.rs:12:44\n   |\n\
    12 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |    -----------  \
    \                           ^^^^ expected `bool`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max = 0;\n    for &i in q {\n        sum += i;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    sum == max && is_balanced(q, w)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp0q6nwnl3.rs:21:19\n\
    \   |\n21 |     sum == max && is_balanced(q, w)\n   |                   ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0q6nwnl3.rs:15:9\n\
    \   |\n15 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    for x in q {\n        sum += x;\n        if sum ==\
    \ w {\n            balanced = true;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw106no8b.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_sum = 0;\n\
    \    let mut is_balanced = true;\n    for el in q.iter() {\n        if el > w\
    \ {\n            is_balanced = false;\n            break;\n        }\n       \
    \ max_sum += el;\n    }\n    if max_sum == w {\n        is_balanced\n    } else\
    \ {\n        is_balanced && max_sum <= w\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5kjod3fc.rs:16:17\n   |\n\
    16 |         if el > w {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found `isize`\n   |                 help:\
    \ consider borrowing here: `&w`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for el in q.iter() {\n        sum += el;\n        max_weight\
    \ = if sum > max_weight {\n            max_weight\n        } else {\n        \
    \    max_weight\n        };\n    }\n    if sum == max_weight {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpilbfw0zp.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for x in q.iter() {\n\
    \        sum += x;\n        if sum > w {\n            balanced = true;\n     \
    \       break;\n        }\n        if sum > max_weight {\n            max_weight\
    \ = sum;\n        }\n    }\n    balanced && max_weight <= w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkao_6fnt.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q_rev = q.iter().rev();\n\
    \    let mut q_rev_sum = q_rev.fold(0, |sum, i| sum + i);\n    let mut q_sum =\
    \ q.iter().sum();\n    let mut q_max_weight = q_sum + w;\n    \n    if q_rev_sum\
    \ < q_max_weight {\n        return false;\n    }\n    \n    let mut q_max_weight_rev\
    \ = q_max_weight - q_rev_sum;\n    \n    if q_rev.fold(0, |sum, i| sum + i) <\
    \ q_max_weight_rev {\n        return false;\n    }\n    \n    true\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpac3imhcu.rs:15:9\n\
    \   |\n15 |     let mut q_sum = q.iter().sum();\n   |         ^^^^^^^^^ consider\
    \ giving `q_sum` a type\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for v in q.iter() {\n        sum += v;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            sum\n\
    \        };\n    }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp56p51t__.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for &x in q {\n    \
    \    sum += x;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if sum == max_weight {\n            balanced = true;\n   \
    \     }\n    }\n    if balanced {\n        true\n    } else {\n        max_weight\
    \ <= w\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprviait65.rs:16:9\n   |\n\
    16 |     for &x in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max = 0;\n    for x in q {\n        sum += x;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    sum == max && q.iter().rev().all(|x|\
    \ x <= w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp07jxo_ua.rs:21:47\n   |\n\
    21 |     sum == max && q.iter().rev().all(|x| x <= w)\n   |                  \
    \                             ^\n   |                                        \
    \       |\n   |                                               expected `&isize`,\
    \ found `isize`\n   |                                               help: consider\
    \ borrowing here: `&w`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max = 0;\n    for x in q {\n        sum += x;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    sum == max && is_palindromic(q)\
    \ && w <= sum\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpciyuw91h.rs:21:19\n   |\n21 |     sum == max && is_palindromic(q) &&\
    \ w <= sum\n   |                   ^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ &i in q {\n        sum += i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpdx50_83o.rs:17:16\n\
    \   |\n17 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdx50_83o.rs:14:9\n\
    \   |\n14 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    let mut is_balanced = true;\n    for v in q.iter()\
    \ {\n        sum += v;\n        if sum > max_weight {\n            max_weight\
    \ = sum;\n        }\n        if sum < w {\n            is_balanced = false;\n\
    \            break;\n        }\n    }\n    !is_balanced\n}\n\nfn main() {\n  \
    \  let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1xu_l405.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    for el in q {\n        if el > max_weight\
    \ {\n            max_weight = el;\n        }\n        if el != q.len() - 1 {\n\
    \            if q[el] != q[el + 1] {\n                is_balanced = false;\n \
    \               break;\n            }\n        }\n    }\n    if max_weight ==\
    \ w {\n        is_balanced\n    } else {\n        is_balanced && max_weight <=\
    \ w\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7cfot2j3.rs:19:18\n   |\n\
    19 |         if el != q.len() - 1 {\n   |                  ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |         if el != (q.len()\
    \ - 1).try_into().unwrap() {\n   |                  +           +++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7cfot2j3.rs:20:16\n\
    \   |\n20 |             if q[el] != q[el + 1] {\n   |                ^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp7cfot2j3.rs:20:25\n   |\n20 |  \
    \           if q[el] != q[el + 1] {\n   |                         ^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for v in q.iter() {\n        sum += v;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n    }\n    let\
    \ mut balanced = true;\n    for v in q.iter() {\n        if v != q.len() - v {\n\
    \            balanced = false;\n            break;\n        }\n    }\n    sum\
    \ == max_weight && balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp94ojtb_i.rs:23:27\n   |\n\
    23 |         if v != q.len() - v {\n   |                           ^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot subtract `&isize` from `usize`\n\
    \  --> /tmp/tmp94ojtb_i.rs:23:25\n   |\n23 |         if v != q.len() - v {\n \
    \  |                         ^ no implementation for `usize - &isize`\n   |\n\
    \   = help: the trait `Sub<&isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n\
    \             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n      \
    \       <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp94ojtb_i.rs:23:17\n   |\n23 |         if v != q.len() -\
    \ v {\n   |                 ^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ can't compare `&isize` with `usize`\n  --> /tmp/tmp94ojtb_i.rs:23:14\n   |\n\
    23 |         if v != q.len() - v {\n   |              ^^ no implementation for\
    \ `&isize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for el in q {\n        sum += el;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            sum\n\
    \        };\n    }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbtibapa1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut balanced = true;\n    let mut sum = 0;\n    for el in q.iter() {\n\
    \        sum += el;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if sum < w {\n            balanced = false;\n        }\n \
    \   }\n    balanced && max_weight <= w\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqw5cnlcr.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for x in q {\n        sum += x;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            max_weight\
    \ + x\n        };\n    }\n    sum == w && max_weight <= w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn9haghro.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max = 0;\n    for\
    \ &i in q {\n        if i > max {\n            max = i;\n        }\n    }\n  \
    \  let mut sum = 0;\n    for &i in q {\n        sum += i;\n    }\n    if sum ==\
    \ max {\n        return true;\n    }\n    if sum < max {\n        return false;\n\
    \    }\n    let mut i = 0;\n    let mut j = q.len();\n    while i < j {\n    \
    \    if q[i] > max {\n            return false;\n        }\n        if q[j] <\
    \ max {\n            return false;\n        }\n        if q[i] != q[j] {\n   \
    \         return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn0xwnehh.rs:14:9\n   |\n\
    14 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpn0xwnehh.rs:20:9\n   |\n20 |     for &i in q {\n   |         ^^\
    \    - this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    for i in q {\n        sum += i;\n        if sum > w\
    \ {\n            balanced = true;\n            break;\n        }\n    }\n    balanced\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp70pxy1eb.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ &i in q {\n        sum += i;\n    }\n    sum < w && is_palindromic(q) && sum\
    \ >= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpxv_bu8pw.rs:17:16\n   |\n17 |     sum < w && is_palindromic(q) && sum\
    \ >= w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxv_bu8pw.rs:14:9\n   |\n14 |     for &i in q\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ &x in q {\n        sum += x;\n    }\n    if sum == w {\n        return true;\n\
    \    }\n    if sum > w {\n        return false;\n    }\n    let mut max_sum =\
    \ 0;\n    for &x in q {\n        max_sum += x;\n    }\n    if max_sum == w {\n\
    \        return true;\n    }\n    if max_sum > w {\n        return false;\n  \
    \  }\n    let mut max_weight = 0;\n    for &x in q {\n        max_weight += x;\n\
    \    }\n    if max_weight == w {\n        return true;\n    }\n    if max_weight\
    \ > w {\n        return false;\n    }\n    let mut max_weight_index = 0;\n   \
    \ for &x in q {\n        if max_weight_index == 0 {\n            max_weight_index\
    \ = x;\n        }\n        if max_weight_index > x {\n            max_weight_index\
    \ = x;\n        }\n    }\n    if max_weight_index == w {\n        return true;\n\
    \    }\n    if max_weight_index > w {\n        return false;\n    }\n    let mut\
    \ max_weight_index_index = 0;\n    for &x in q {\n        if max_weight_index_index\
    \ == 0 {\n            max_weight_index_index = x;\n        }\n        if max_weight_index_index\
    \ > x {\n            max_weight_index_index = x;\n        }\n    }\n    if max_weight_index_index\
    \ == w {\n        return true;\n    }\n    if max_weight_index_index > w {\n \
    \       return false;\n    }\n    let mut max_weight_index_index_index = 0;\n\
    \    for &x in q {\n        if max_weight_index_index_index == 0 {\n         \
    \   max_weight_index_index_index = x;\n        }\n        if max_weight_index_index_index\
    \ > x {\n            max_weight_index_index_index = x;\n        }\n    }\n   \
    \ if max_weight_index_index_index == w {\n        return true;\n    }\n    if\
    \ max_weight_index_index_index > w {\n        return false;\n    }\n    let mut\
    \ max_weight_index_index_index_index = 0;\n    for &x in q {\n        if max_weight_index_index_index_index\
    \ == 0 {\n            max_weight_index_index_index_index = x;\n        }\n   \
    \     if max_weight_index_index_index_index > x {\n            max_weight_index_index_index_index\
    \ = x;\n        }\n    }\n    if max_weight_index_index_index_index == w {\n \
    \       return true;\n    }\n    if max_weight_index_index_index_index > w {\n\
    \        return false;\n    }\n    let mut max_weight_index_index_index_index\
    \ = 0;\n    for &x in q {\n        if max_weight_index_index_index_index == 0\
    \ {\n            max_weight_index_index_index_index = x;\n        }\n        if\
    \ max_weight_index_index_index_index > x {\n            max_weight_index_index_index_index\
    \ = x;\n        }\n    }\n    if max_weight_index_index_index_index == w {\n \
    \       return true;\n\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpxm_q9ip2.rs:125:3\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n112 |  \
    \   if max_weight_index_index_index_index == w {\n    |                      \
    \                          - this delimiter might not be properly closed...\n\
    ...\n115 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n125 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxm_q9ip2.rs:14:9\n\
    \   |\n14 |     for &x in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxm_q9ip2.rs:24:9\n   |\n24 |     for &x in q {\n   |         ^^\
    \    - this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxm_q9ip2.rs:34:9\n\
    \   |\n34 |     for &x in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxm_q9ip2.rs:44:9\n   |\n44 |     for &x in q {\n   |         ^^\
    \    - this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxm_q9ip2.rs:59:9\n\
    \   |\n59 |     for &x in q {\n   |         ^^    - this expression has type `Option<isize>`"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_sum = 0;\n\
    \    let mut is_balanced = true;\n    for v in q.iter() {\n        if v > max_sum\
    \ {\n            max_sum = v;\n        }\n        if v != q.len() - 1 {\n    \
    \        if v != q.len() - 2 {\n                if v != q.len() - 3 {\n      \
    \              if v != q.len() - 4 {\n                        if v != q.len()\
    \ - 5 {\n                            if v != q.len() - 6 {\n                 \
    \               if v != q.len() - 7 {\n                                    if\
    \ v != q.len() - 8 {\n                                        if v != q.len()\
    \ - 9 {\n                                            if v != q.len() - 10 {\n\
    \                                                if v != q.len() - 11 {\n    \
    \                                                if v != q.len() - 12 {\n    \
    \                                                    if v != q.len() - 13 {\n\
    \                                                            if v != q.len() -\
    \ 14 {\n                                                                if v !=\
    \ q.len() - 15 {\n                                                    if v !=\
    \ q.len() - 16 {\n                                                        if v\
    \ != q.len() - 17 {\n                                                        \
    \    if v != q.len() - 18 {\n                                                \
    \                if v != q.len() - 19 {\n                                    \
    \                if v != q.len() - 20 {\n                                    \
    \                    if v != q.len() - 21 {\n                                \
    \                            if v != q.len() - 22 {\n                        \
    \                                        if v != q.len() - 23 {\n            \
    \                                        if v != q.len() - 24 {\n            \
    \                                            if v != q.len() - 25 {\n        \
    \                                                    if v != q.len() - 26 {\n\
    \                                                                if v != q.len()\
    \ - 27 {\n                                                    if v != q.len()\
    \ - 28 {\n                                                        if v != q.len()\
    \ - 29 {\n                                                            if v !=\
    \ q.len() - 30 {\n                                                           \
    \     if v != q.len() - 31 {\n                                               \
    \     if v != q.len() - 32 {\n                                               \
    \         if v != q.len() - 33 {\n                                           \
    \                 if v != q.len() - 34 {\n                                   \
    \                             if v != q.len() - 35 {\n                       \
    \                             if v != q.len() - 36 {\n                       \
    \                                 if v != q.len() - 37 {\n                   \
    \                                         if v != q.len() - 38 {\n           \
    \                                                     if v != q.len() - 39 {\n\
    \                                                    if v != q.len() - 40 {\n\
    \                                                        if v != q.len() - 41\
    \ {\n                                                            if v != q.len()\
    \ - 42 {\n                                                                if v\
    \ != q.len() - 43 {\n                                                    if v\
    \ != q.len() - 44 {\n                                                        if\
    \ v != q.len() - 45 {\n                                                      \
    \      if v != q.len() - 46 {\n                                              \
    \                  if v != q.len() - 47 {\n                                  \
    \                  if v != q.len() - 48 {\n                                  \
    \                      if v != q.len() - 49 {\n\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpg93dr41k.rs:79:3\n\
    \   |\n12 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n15 |     for\
    \ v in q.iter() {\n   |                       - unclosed delimiter\n...\n19 |\
    \         if v != q.len() - 1 {\n   |                             - unclosed delimiter\n\
    20 |             if v != q.len() - 2 {\n   |                                 -\
    \ unclosed delimiter\n21 |                 if v != q.len() - 3 {\n   |       \
    \                              - unclosed delimiter\n22 |                    \
    \ if v != q.len() - 4 {\n   |                                         - unclosed\
    \ delimiter\n23 |                         if v != q.len() - 5 {\n   |        \
    \                                     - unclosed delimiter\n24 |             \
    \                if v != q.len() - 6 {\n   |                                 \
    \                - unclosed delimiter\n25 |                                 if\
    \ v != q.len() - 7 {\n   |                                                   \
    \  - unclosed delimiter\n26 |                                     if v != q.len()\
    \ - 8 {\n   |                                                         - unclosed\
    \ delimiter\n27 |                                         if v != q.len() - 9\
    \ {\n   |                                                             - unclosed\
    \ delimiter\n28 |                                             if v != q.len()\
    \ - 10 {\n   |                                                               \
    \   - unclosed delimiter\n29 |                                               \
    \  if v != q.len() - 11 {\n   |                                              \
    \                        - unclosed delimiter\n30 |                          \
    \                           if v != q.len() - 12 {\n   |                     \
    \                                                     - unclosed delimiter\n31\
    \ |                                                         if v != q.len() -\
    \ 13 {\n   |                                                            "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ &i in q {\n        sum += i;\n    }\n    if sum == w {\n        return true;\n\
    \    }\n    if sum < w {\n        return false;\n    }\n    let mut max_sum =\
    \ 0;\n    for &i in q {\n        max_sum += i;\n    }\n    if max_sum == w {\n\
    \        return true;\n    }\n    if max_sum < w {\n        return false;\n  \
    \  }\n    let mut max_weight = w;\n    for &i in q {\n        max_weight -= i;\n\
    \    }\n    if max_weight == 0 {\n        return true;\n    }\n    if max_weight\
    \ < 0 {\n        return false;\n    }\n    let mut max_weight = w;\n    for &i\
    \ in q {\n        max_weight += i;\n    }\n    if max_weight == w {\n        return\
    \ true;\n    }\n    if max_weight < w {\n        return false;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp14feis50.rs:14:9\n   |\n\
    14 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp14feis50.rs:24:9\n   |\n24 |     for &i in q {\n   |         ^^\
    \    - this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp14feis50.rs:34:9\n\
    \   |\n34 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp14feis50.rs:44:9\n   |\n44 |     for &i in q {\n   |         ^^\
    \    - this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    let mut sum = 0;\n    for &i in q {\n  \
    \      sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if max_weight < w {\n        is_balanced = false;\n   \
    \ }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsa_jf0c3.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for v in q.iter() {\n        sum += v;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n    }\n    if\
    \ max_weight <= w {\n        return false;\n    }\n    let mut reversed_q = q.clone();\n\
    \    reversed_q.sort();\n    let mut sum = 0;\n    for v in reversed_q.iter()\
    \ {\n        sum += v;\n        if sum > w {\n            return false;\n    \
    \    }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpa6ecjbxi.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for &i in q {\n    \
    \    sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if sum == w {\n            balanced = true;\n        }\n \
    \   }\n    balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprgty01xk.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_sum = 0;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for v in q {\n     \
    \   sum += v;\n        if sum > w {\n            balanced = true;\n          \
    \  break;\n        }\n        max_sum = max_sum.max(sum);\n    }\n    balanced\
    \ && max_sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpypalajn6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for el in q {\n        sum += el;\n        max_weight\
    \ = if sum > max_weight {\n            max_weight\n        } else {\n        \
    \    max_weight\n        };\n    }\n    sum == w && max_weight <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7voftves.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    q.reverse();\n    let mut sum = 0;\n    for &i in q {\n        sum += i;\n\
    \    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpgvw_akzt.rs:19:16\n\
    \   |\n19 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgvw_akzt.rs:16:9\n\
    \   |\n16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max = 0;\n    let\
    \ mut sum = 0;\n    for x in q {\n        sum += x;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    if sum < w {\n        return false;\n\
    \    }\n    let mut i = 0;\n    while i < q.len() {\n        if q[i] != i {\n\
    \            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi7f4wmgs.rs:26:20\n   |\n\
    26 |         if q[i] != i {\n   |                    ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n26 |         if q[i] != i.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    for x in q {\n        sum += x;\n        if sum >=\
    \ w {\n            balanced = true;\n            break;\n        }\n    }\n  \
    \  balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1z3ya6z5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    let mut max_weight = w;\n    let mut sum = 0;\n    while q.len() > 0 {\n\
    \        sum += q.last();\n        q.pop();\n    }\n    if sum < max_weight {\n\
    \        return false;\n    }\n    let mut q = q.to_vec();\n    let mut max_weight\
    \ = w;\n    let mut sum = 0;\n    while q.len() > 0 {\n        sum += q.last();\n\
    \        q.pop();\n    }\n    if sum < max_weight {\n        return true;\n  \
    \  }\n    let mut q = q.to_vec();\n    let mut max_weight = w;\n    let mut sum\
    \ = 0;\n    while q.len() > 0 {\n        sum += q.last();\n        q.pop();\n\
    \    }\n    if sum < max_weight {\n        return false;\n    }\n    let mut q\
    \ = q.to_vec();\n    let mut max_weight = w;\n    let mut sum = 0;\n    while\
    \ q.len() > 0 {\n        sum += q.last();\n        q.pop();\n    }\n    if sum\
    \ < max_weight {\n        return true;\n    }\n    let mut q = q.to_vec();\n \
    \   let mut max_weight = w;\n    let mut sum = 0;\n    while q.len() > 0 {\n \
    \       sum += q.last();\n        q.pop();\n    }\n    if sum < max_weight {\n\
    \        return false;\n    }\n    let mut q = q.to_vec();\n    let mut max_weight\
    \ = w;\n    let mut sum = 0;\n    while q.len() > 0 {\n        sum += q.last();\n\
    \        q.pop();\n    }\n    if sum < max_weight {\n        return true;\n  \
    \  }\n    let mut q = q.to_vec();\n    let mut max_weight = w;\n    let mut sum\
    \ = 0;\n    while q.len() > 0 {\n        sum += q.last();\n        q.pop();\n\
    \    }\n    if sum < max_weight {\n        return false;\n    }\n    let mut q\
    \ = q.to_vec();\n    let mut max_weight = w;\n    let mut sum = 0;\n    while\
    \ q.len() > 0 {\n        sum += q.last();\n        q.pop();\n    }\n    if sum\
    \ < max_weight {\n        return true;\n    }\n    let mut q = q.to_vec();\n \
    \   let mut max_weight = w;\n    let mut sum = 0;\n    while q.len() > 0 {\n \
    \       sum += q.last();\n        q.pop();\n    }\n    if sum < max_weight {\n\
    \        return false;\n    }\n    let mut q = q.to_vec();\n    let mut max_weight\
    \ = w;\n    let mut sum = 0;\n    while q.len() > 0 {\n        sum += q.last();\n\
    \        q.pop();\n    }\n    if sum < \n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmpfp6uec2d.rs:111:1\n\
    \    |\n111 | }\n    | ^ expected expression\n\nerror[E0277]: cannot add-assign\
    \ `Option<&isize>` to `{integer}`\n  --> /tmp/tmpfp6uec2d.rs:17:13\n   |\n17 |\
    \         sum += q.last();\n   |             ^^ no implementation for `{integer}\
    \ += Option<&isize>`\n   |\n   = help: the trait `AddAssign<Option<&isize>>` is\
    \ not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror[E0277]: cannot add-assign `Option<&isize>`\
    \ to `{integer}`\n  --> /tmp/tmpfp6uec2d.rs:27:13\n   |\n27 |         sum += q.last();\n\
    \   |             ^^ no implementation for `{integer} += Option<&isize>`\n   |\n\
    \   = help: the trait `AddAssign<Option<&isize>>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror[E0277]: cannot add-assign `Option<&isize>` to `{integer}`\n  --> /tmp/tmpfp6uec2d.rs:37:13\n\
    \   |\n37 |         sum += q.last();\n   |             ^^ no implementation for\
    \ `{integer} += Option<&isize>`\n   |\n   = help: the trait `AddAssign<Option<&isize>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q_rev = q.iter().rev();\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    for x in q_rev {\n   \
    \     sum += x;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if max_weight == w {\n        return true;\n    }\n   \
    \ if sum < w {\n        return false;\n    }\n    let mut q_rev = q.iter().rev();\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    for x in q_rev {\n   \
    \     sum += x;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if max_weight == w {\n        return true;\n    }\n   \
    \ if sum < w {\n        return false;\n    }\n    let mut q_rev = q.iter().rev();\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    for x in q_rev {\n   \
    \     sum += x;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if max_weight == w {\n        return true;\n    }\n   \
    \ if sum < w {\n        return false;\n    }\n    let mut q_rev = q.iter().rev();\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    for x in q_rev {\n   \
    \     sum += x;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if max_weight == w {\n        return true;\n    }\n   \
    \ if sum < w {\n        return false;\n    }\n    let mut q_rev = q.iter().rev();\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    for x in q_rev {\n   \
    \     sum += x;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if max_weight == w {\n        return true;\n    }\n   \
    \ if sum < w {\n        return false;\n    }\n    let mut q_rev = q.iter().rev();\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    for x in q_rev {\n   \
    \     sum += x;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if max_weight == w {\n        return true;\n    }\n   \
    \ if sum < w {\n        return false;\n    }\n    let mut q_rev = q.iter().rev();\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    for x in q_rev {\n   \
    \     sum += x;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if max_weight == w {\n        return true;\n    }\n   \
    \ if sum < w {\n        return false;\n    }\n    let \n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n   --> /tmp/tmpdgi9itn3.rs:119:1\n\
    \    |\n119 | }\n    | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for x in q {\n        sum += x;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            sum\n\
    \        };\n    }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyusbqiky.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for el in q {\n        sum += el;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            sum\n\
    \        };\n    }\n    sum == w && max_weight <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph2nqi5_0.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    for x in q {\n        if x > max_weight\
    \ {\n            max_weight = x;\n        }\n        if x == 0 {\n           \
    \ is_balanced = false;\n        }\n    }\n    if max_weight == w {\n        is_balanced\n\
    \    } else {\n        is_balanced && max_weight <= w\n    }\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzh2a9upi.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for &i in q {\n    \
    \    sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if sum == max_weight {\n            balanced = true;\n   \
    \     }\n    }\n    balanced && sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl7kya_7i.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max = 0;\n    let\
    \ mut sum = 0;\n    for &i in q {\n        sum += i;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    sum == max && is_balanced(q) &&\
    \ is_palindromic(q) && is_less_or_equal_to_max(w, max)\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpf6et86v5.rs:21:19\n\
    \   |\n21 |     sum == max && is_balanced(q) && is_palindromic(q) && is_less_or_equal_to_max(w,\
    \ max)\n   |                   ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_palindromic` in this scope\n  --> /tmp/tmpf6et86v5.rs:21:37\n\
    \   |\n21 |     sum == max && is_balanced(q) && is_palindromic(q) && is_less_or_equal_to_max(w,\
    \ max)\n   |                                     ^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_less_or_equal_to_max` in this\
    \ scope\n  --> /tmp/tmpf6et86v5.rs:21:58\n   |\n21 |     sum == max && is_balanced(q)\
    \ && is_palindromic(q) && is_less_or_equal_to_max(w, max)\n   |              \
    \                                            ^^^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf6et86v5.rs:15:9\n\
    \   |\n15 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    let mut is_balanced = true;\n    for &i in q {\n  \
    \      sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if sum < w {\n            is_balanced = false;\n        }\n\
    \    }\n    is_balanced && max_weight <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxkkaaxip.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ &i in q {\n        sum += i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpc32lu692.rs:17:16\n\
    \   |\n17 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc32lu692.rs:14:9\n\
    \   |\n14 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut balanced = true;\n    for el in q.iter() {\n        if el > max_weight\
    \ {\n            max_weight = el;\n        }\n        if el == max_weight {\n\
    \            balanced = false;\n        }\n    }\n    if balanced {\n        let\
    \ mut sum = 0;\n        for el in q.iter() {\n            sum += el;\n       \
    \ }\n        return sum <= w;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbcbutg_2.rs:16:17\n   |\n\
    16 |         if el > max_weight {\n   |                 ^^^^^^^^^^\n   |     \
    \            |\n   |                 expected `&isize`, found integer\n   |  \
    \               help: consider borrowing here: `&max_weight`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbcbutg_2.rs:17:26\n   |\n13 |     let mut max_weight\
    \ = 0;\n   |                          - expected due to this value\n...\n17 |\
    \             max_weight = el;\n   |                          ^^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |  \
    \           max_weight = *el;\n   |                          +\n\nerror[E0277]:\
    \ can't compare `&isize` with `{integer}`\n  --> /tmp/tmpbcbutg_2.rs:19:15\n \
    \  |\n19 |         if el == max_weight {\n   |               ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q: Vec<isize> =\
    \ q.to_vec();\n    let mut w: isize = w.to_owned();\n    let mut sum = 0;\n  \
    \  let mut max_weight = 0;\n    let mut is_balanced = true;\n    loop {\n    \
    \    sum += q.iter().sum();\n        if sum > max_weight {\n            max_weight\
    \ = sum;\n        }\n        if sum == max_weight {\n            is_balanced =\
    \ true;\n        }\n        if sum < max_weight {\n            is_balanced = false;\n\
    \        }\n        if !is_balanced {\n            break;\n        }\n       \
    \ q.push(q.iter().next().unwrap());\n    }\n    w <= max_weight\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd0dz4ugb.rs:32:16\n   |\n\
    32 |         q.push(q.iter().next().unwrap());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n32 |         q.push(*q.iter().next().unwrap());\n   |                +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    let mut is_balanced = true;\n    for &i in q {\n  \
    \      sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if sum < w {\n        is_balanced = false;\n    }\n   \
    \ sum == w && is_balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdzltehyv.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    for &x in q {\n        if x > max_weight\
    \ {\n            max_weight = x;\n        }\n        if x == max_weight {\n  \
    \          is_balanced = false;\n        }\n    }\n    if is_balanced {\n    \
    \    let mut sum = 0;\n        for x in q {\n            sum += x;\n        }\n\
    \        sum < w && sum == max_weight\n    } else {\n        false\n    }\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvygx1v3m.rs:15:9\n   |\n\
    15 |     for &x in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    let mut sum = 0;\n    for x in q {\n   \
    \     sum += x;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if max_weight <= w {\n        is_balanced = false;\n  \
    \  }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpi0616ofi.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for &i in q {\n        sum += i;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            sum\n\
    \        };\n    }\n    sum == w && max_weight <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpit7wf7zk.rs:15:9\n   |\n\
    15 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for v in q.iter() {\n        sum += v;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n    }\n    if\
    \ sum == w {\n        return true;\n    }\n    if sum > w {\n        return false;\n\
    \    }\n    let mut i = 0;\n    while i < q.len() {\n        if q[i] > w {\n \
    \           break;\n        }\n        i += 1;\n    }\n    let mut j = q.len()\
    \ - 1;\n    while j > i {\n        if q[j] < w {\n            break;\n       \
    \ }\n        j -= 1;\n    }\n    if i == j {\n        return true;\n    }\n  \
    \  let mut i = q.len() - 1;\n    while i >= 0 {\n        if q[i] < w {\n     \
    \       break;\n        }\n        i -= 1;\n    }\n    let mut j = q.len() - 1;\n\
    \    while j > i {\n        if q[j] > w {\n            break;\n        }\n   \
    \     j -= 1;\n    }\n    if i == j {\n        return true;\n    }\n    if q[i]\
    \ > w {\n        return false;\n    }\n    if q[j] < w {\n        return false;\n\
    \    }\n    if q[i] < q[j] {\n        return false;\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppfyxmc7g.rs:76:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    for &i in q {\n        sum += i;\n        if sum >\
    \ w {\n            balanced = false;\n            break;\n        }\n    }\n \
    \   balanced && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgm81fnwj.rs:15:9\n   |\n\
    15 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for el in q {\n    \
    \    sum += el;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if sum == max_weight {\n            balanced = true;\n   \
    \     }\n    }\n    if balanced && sum == w {\n        return true;\n    }\n \
    \   false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm2n3xi1f.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for x in q {\n        sum += x;\n        max_weight\
    \ = if sum > w {\n            sum\n        } else {\n            max_weight\n\
    \        };\n    }\n    if sum == w {\n        true\n    } else {\n        max_weight\
    \ < w\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4lgx011w.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = w;\n\
    \    let mut is_balanced = true;\n    let mut sum = 0;\n    let mut i = 0;\n \
    \   while i < q.len() {\n        sum += q[i];\n        if sum > max_weight {\n\
    \            is_balanced = false;\n            break;\n        }\n        i +=\
    \ 1;\n    }\n    if is_balanced {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn_hges_v.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut balanced = false;\n    for v in q.iter() {\n        if v > max_weight\
    \ {\n            max_weight = v;\n        }\n        if v == max_weight {\n  \
    \          balanced = true;\n        }\n    }\n    if !balanced {\n        return\
    \ false;\n    }\n    let mut sum = 0;\n    for v in q.iter() {\n        sum +=\
    \ v;\n    }\n    if sum < w {\n        return false;\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq97neyyu.rs:16:16\n   |\n\
    16 |         if v > max_weight {\n   |                ^^^^^^^^^^\n   |       \
    \         |\n   |                expected `&isize`, found integer\n   |      \
    \          help: consider borrowing here: `&max_weight`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq97neyyu.rs:17:26\n   |\n13 |     let mut max_weight =\
    \ 0;\n   |                          - expected due to this value\n...\n17 |  \
    \           max_weight = v;\n   |                          ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |  \
    \           max_weight = *v;\n   |                          +\n\nerror[E0277]:\
    \ can't compare `&isize` with `{integer}`\n  --> /tmp/tmpq97neyyu.rs:19:14\n \
    \  |\n19 |         if v == max_weight {\n   |              ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    let mut is_balanced =\
    \ true;\n    while !q.is_empty() {\n        sum += q.iter().sum();\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n        if sum\
    \ == max_weight {\n            is_balanced = false;\n        }\n        q.iter().for_each(|x|\
    \ {\n            if x == q[0] {\n                q.shift();\n            }\n \
    \       });\n    }\n    is_balanced && sum <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `shift` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp_ktisur6.rs:27:19\n   |\n27 |             \
    \    q.shift();\n   |                   ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp_ktisur6.rs:26:18\n\
    \   |\n26 |             if x == q[0] {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    let mut balanced = true;\n    for &i in q {\n     \
    \   sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if sum == max_weight {\n            balanced = false;\n  \
    \      }\n    }\n    balanced && sum <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgeipaqhp.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for v in q.iter() {\n\
    \        sum += v;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if v == q[q.len() - 1] {\n            balanced = true;\n \
    \       }\n    }\n    !balanced && max_weight <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpnz161al6.rs:21:14\n\
    \   |\n21 |         if v == q[q.len() - 1] {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    let mut sum = 0;\n    for x in q {\n   \
    \     sum += x;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    for x in q {\n        if x == 0 {\n            is_balanced\
    \ = false;\n            break;\n        }\n    }\n    sum == max_weight && is_balanced\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `w`\n  --> /tmp/tmpaohfvc1k.rs:12:31\n   |\n\
    12 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |                 \
    \              ^ help: if this is intentional, prefix it with an underscore: `_w`\n\
    \   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0382]: use\
    \ of moved value: `q`\n   --> /tmp/tmpaohfvc1k.rs:22:14\n    |\n12  | fn will_it_fly(q:\
    \ Vec<isize>, w: isize) -> bool {\n    |                - move occurs because\
    \ `q` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n\
    16  |     for x in q {\n    |              - `q` moved due to this implicit call\
    \ to `.into_iter()`\n...\n22  |     for x in q {\n    |              ^ value used\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `q`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for x in &q {\n\
    \    |              +\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ v in q {\n        sum += v;\n    }\n    if sum < w {\n        return false;\n\
    \    }\n    let mut max = 0;\n    for v in q {\n        if v > max {\n       \
    \     max = v;\n        }\n    }\n    let mut max2 = max;\n    let mut max3 =\
    \ max;\n    let mut max4 = max;\n    let mut max5 = max;\n    let mut max6 = max;\n\
    \    let mut max7 = max;\n    let mut max8 = max;\n    let mut max9 = max;\n \
    \   let mut max10 = max;\n    let mut max11 = max;\n    let mut max12 = max;\n\
    \    let mut max13 = max;\n    let mut max14 = max;\n    let mut max15 = max;\n\
    \    let mut max16 = max;\n    let mut max17 = max;\n    let mut max18 = max;\n\
    \    let mut max19 = max;\n    let mut max20 = max;\n    let mut max21 = max;\n\
    \    let mut max22 = max;\n    let mut max23 = max;\n    let mut max24 = max;\n\
    \    let mut max25 = max;\n    let mut max26 = max;\n    let mut max27 = max;\n\
    \    let mut max28 = max;\n    let mut max29 = max;\n    let mut max30 = max;\n\
    \    let mut max31 = max;\n    let mut max32 = max;\n    let mut max33 = max;\n\
    \    let mut max34 = max;\n    let mut max35 = max;\n    let mut max36 = max;\n\
    \    let mut max37 = max;\n    let mut max38 = max;\n    let mut max39 = max;\n\
    \    let mut max40 = max;\n    let mut max41 = max;\n    let mut max42 = max;\n\
    \    let mut max43 = max;\n    let mut max44 = max;\n    let mut max45 = max;\n\
    \    let mut max46 = max;\n    let mut max47 = max;\n    let mut max48 = max;\n\
    \    let mut max49 = max;\n    let mut max50 = max;\n    let mut max51 = max;\n\
    \    let mut max52 = max;\n    let mut max53 = max;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp7kmrctlw.rs:79:1\n\
    \   |\n79 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_sum = 0;\n\
    \    let mut is_balanced = true;\n    for x in q.iter() {\n        let sum = x.to_ascii_lowercase().chars().sum();\n\
    \        if sum > max_sum {\n            max_sum = sum;\n        }\n        if\
    \ sum < w {\n            is_balanced = false;\n            break;\n        }\n\
    \    }\n    is_balanced && max_sum <= w\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_ascii_lowercase` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmpyq4p_gw8.rs:16:21\n   |\n16 | \
    \        let sum = x.to_ascii_lowercase().chars().sum();\n   |               \
    \      ^^^^^^^^^^^^^^^^^^ method not found in `&isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    for x in q {\n        if x > max_weight\
    \ {\n            max_weight = x;\n        }\n        if x == q[q.len() - 1] {\n\
    \            is_balanced = false;\n        }\n    }\n    if !is_balanced {\n \
    \       return false;\n    }\n    let mut sum = 0;\n    for x in q {\n       \
    \ sum += x;\n    }\n    if sum < w {\n        return false;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmp668ynn86.rs:19:17\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for x in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n19  |         if x == q[q.len()\
    \ - 1] {\n    |                 ^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `q`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for x in &q {\n    |              +\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for el in q {\n        sum += el;\n        max_weight\
    \ = if sum > max_weight { max_weight } else { max_weight + el };\n    }\n    sum\
    \ == w && max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1pxgr6hs.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    let mut is_balanced =\
    \ true;\n    while !q.is_empty() {\n        sum += q.iter().sum();\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n        if sum\
    \ == max_weight {\n            is_balanced = false;\n        }\n        q.pop();\n\
    \    }\n    sum == max_weight && is_balanced\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpi0vo4qpd.rs:18:13\n\
    \   |\n18 |         sum += q.iter().sum();\n   |             ^^ cannot infer type\n\
    \   |\nhelp: consider specifying the type argument in the method call\n   |\n\
    18 |         sum += q.iter().sum::<S>();\n   |                            +++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max = 0;\n    for i in q {\n        sum += i;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    sum == max && is_palindromic(q)\
    \ && is_balanced(q, w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmp8siv786n.rs:21:19\n   |\n21 |     sum == max && is_palindromic(q) &&\
    \ is_balanced(q, w)\n   |                   ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp8siv786n.rs:21:40\n\
    \   |\n21 |     sum == max && is_palindromic(q) && is_balanced(q, w)\n   |   \
    \                                     ^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for &i in q {\n        sum += i;\n        max_weight\
    \ = max_weight if i > max_weight else i;\n    }\n    sum < w && sum == max_weight\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmprees1614.rs:17:33\n   |\n17 |         max_weight\
    \ = max_weight if i > max_weight else i;\n   |                               \
    \  ^^ expected one of 8 possible tokens\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprees1614.rs:15:9\n   |\n15 |     for &i in q {\n   |         ^^    -\
    \ this expression has type `Option<isize>`\n   |         |\n   |         expected\
    \ `isize`, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `i`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for el in q {\n        sum += el;\n        if sum >\
    \ max_weight {\n            max_weight = sum;\n        }\n    }\n    if sum <\
    \ w {\n        return false;\n    }\n    let mut sum = 0;\n    let mut max_weight\
    \ = 0;\n    for el in q {\n        sum += el;\n        if sum > max_weight {\n\
    \            max_weight = sum;\n        }\n    }\n    if sum == w {\n        return\
    \ true;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut sum\
    \ = 0;\n    let mut max_weight = 0;\n    for el in q {\n        sum += el;\n \
    \       if sum > max_weight {\n            max_weight = sum;\n        }\n    }\n\
    \    if sum < w {\n        return true;\n    }\n    return false;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `q`\n   --> /tmp/tmpo7hcw9u8.rs:26:15\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for el in q {\n    |               - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n26  |     for el in q {\n\
    \    |               ^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `q`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n15  |     for el in &q {\n    |               +\n\nerror[E0382]: use of\
    \ moved value: `q`\n  --> /tmp/tmpo7hcw9u8.rs:40:15\n   |\n12 | fn will_it_fly(q:\
    \ Vec<isize>, w: isize) -> bool {\n   |                - move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n26 |\
    \     for el in q {\n   |               - `q` moved due to this implicit call\
    \ to `.into_iter()`\n...\n40 |     for el in q {\n   |               ^ value used\
    \ here after move\n   |\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n   |\n26 |     for el in &q {\n\
    \   |               +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    for i in q.iter() {\n\
    \        sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    for i in q.iter() {\n        if i != q[q.len() - 1 - i]\
    \ {\n            balanced = true;\n            break;\n        }\n    }\n    balanced\
    \ && sum == max_weight\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2sek7ofn.rs:23:33\n   |\n\
    23 |         if i != q[q.len() - 1 - i] {\n   |                              \
    \   ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `&isize`\
    \ from `usize`\n  --> /tmp/tmp2sek7ofn.rs:23:31\n   |\n23 |         if i != q[q.len()\
    \ - 1 - i] {\n   |                               ^ no implementation for `usize\
    \ - &isize`\n   |\n   = help: the trait `Sub<&isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmp2sek7ofn.rs:23:14\n   |\n\
    23 |         if i != q[q.len() - 1 - i] {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ &i in q {\n        sum += i;\n    }\n    sum < w && is_palindromic(q) && sum\
    \ == w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpifw28x2g.rs:17:16\n   |\n17 |     sum < w && is_palindromic(q) && sum\
    \ == w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpifw28x2g.rs:14:9\n   |\n14 |     for &i in q\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for x in q {\n        sum += x;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            max_weight\
    \ + x\n        };\n    }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6p65nqm1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = w;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for v in q.iter() {\n\
    \        sum += v;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if sum == max_weight {\n            balanced = true;\n   \
    \     }\n    }\n    balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpni4v2ali.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = true;\n\
    \    let mut sum = 0;\n    for i in q {\n        sum += i;\n        if sum > w\
    \ {\n            balanced = false;\n            break;\n        }\n    }\n   \
    \ balanced && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpd2jcuxk1.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    for x in q {\n        sum += x;\n        if sum ==\
    \ w {\n            balanced = true;\n            break;\n        }\n    }\n  \
    \  balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzqqpb_vo.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    for el in q {\n        if el > max_weight\
    \ {\n            max_weight = el;\n        }\n        if el != q[q.len() - 1 -\
    \ el] {\n            is_balanced = false;\n            break;\n        }\n   \
    \ }\n    if is_balanced {\n        let mut sum = 0;\n        for el in q {\n \
    \           sum += el;\n        }\n        sum < w && sum == max_weight\n    }\
    \ else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6qf0duxf.rs:19:34\n   |\n\
    19 |         if el != q[q.len() - 1 - el] {\n   |                            \
    \      ^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize`\
    \ from `usize`\n  --> /tmp/tmp6qf0duxf.rs:19:32\n   |\n19 |         if el != q[q.len()\
    \ - 1 - el] {\n   |                                ^ no implementation for `usize\
    \ - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = w;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for v in q.iter() {\n\
    \        sum += v;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if sum == max_weight {\n            balanced = true;\n   \
    \     }\n    }\n    balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdvnt09rs.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    for e in q {\n        if e > max_weight\
    \ {\n            max_weight = e;\n        }\n        if e != q.len() - 1 {\n \
    \           if e != q.len() - 2 {\n                if e != q.len() - 3 {\n   \
    \                 if e != q.len() - 4 {\n                        if e != q.len()\
    \ - 5 {\n                            if e != q.len() - 6 {\n                 \
    \               if e != q.len() - 7 {\n                                    if\
    \ e != q.len() - 8 {\n                                        if e != q.len()\
    \ - 9 {\n                                            if e != q.len() - 10 {\n\
    \                                                if e != q.len() - 11 {\n    \
    \                                                if e != q.len() - 12 {\n    \
    \                                                    if e != q.len() - 13 {\n\
    \                                                            if e != q.len() -\
    \ 14 {\n                                                                if e !=\
    \ q.len() - 15 {\n                                                    if e !=\
    \ q.len() - 16 {\n                                                        if e\
    \ != q.len() - 17 {\n                                                        \
    \    if e != q.len() - 18 {\n                                                if\
    \ e != q.len() - 19 {\n                                                    if\
    \ e != q.len() - 20 {\n                                                      \
    \  if e != q.len() - 21 {\n                                                  \
    \          if e != q.len() - 22 {\n                                          \
    \      if e != q.len() - 23 {\n                                              \
    \      if e != q.len() - 24 {\n                                              \
    \          if e != q.len() - 25 {\n                                          \
    \                  if e != q.len() - 26 {\n                                  \
    \                              if e != q.len() - 27 {\n                      \
    \                              if e != q.len() - 28 {\n                      \
    \                                  if e != q.len() - 29 {\n                  \
    \                                          if e != q.len() - 30 {\n          \
    \                                                      if e != q.len() - 31 {\n\
    \                                                    if e != q.len() - 32 {\n\
    \                                                        if e != q.len() - 33\
    \ {\n                                                            if e != q.len()\
    \ - 34 {\n                                                if e != q.len() - 35\
    \ {\n                                                    if e != q.len() - 36\
    \ {\n                                                        if e != q.len() -\
    \ 37 {\n                                                            if e != q.len()\
    \ - 38 {\n                                                if e != q.len() - 39\
    \ {\n                                                    if e != q.len() - 40\
    \ {\n                                                        if e != q.len() -\
    \ 41 {\n                                                            if e != q.len()\
    \ - 42 {\n                                                if e != q.len() - 43\
    \ {\n                                                    if e != q.len() - 44\
    \ {\n                                                        if e != q.len() -\
    \ 45 {\n                                                            if e != q.len()\
    \ - 46 {\n                                                if e != q.len() - 47\
    \ {\n                                                    if e != q.len() - 48\
    \ {\n                                                        if e != q.len() -\
    \ 49 {\n                                \n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmplnr8o5po.rs:79:3\n\
    \   |\n12 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n15 |     for\
    \ e in q {\n   |                - unclosed delimiter\n...\n19 |         if e !=\
    \ q.len() - 1 {\n   |                             - unclosed delimiter\n20 | \
    \            if e != q.len() - 2 {\n   |                                 - unclosed\
    \ delimiter\n21 |                 if e != q.len() - 3 {\n   |                \
    \                     - unclosed delimiter\n22 |                     if e != q.len()\
    \ - 4 {\n   |                                         - unclosed delimiter\n23\
    \ |                         if e != q.len() - 5 {\n   |                      \
    \                       - unclosed delimiter\n24 |                           \
    \  if e != q.len() - 6 {\n   |                                               \
    \  - unclosed delimiter\n25 |                                 if e != q.len()\
    \ - 7 {\n   |                                                     - unclosed delimiter\n\
    26 |                                     if e != q.len() - 8 {\n   |         \
    \                                                - unclosed delimiter\n27 |  \
    \                                       if e != q.len() - 9 {\n   |          \
    \                                                   - unclosed delimiter\n28 |\
    \                                             if e != q.len() - 10 {\n   |   \
    \                                                               - unclosed delimiter\n\
    29 |                                                 if e != q.len() - 11 {\n\
    \   |                                                                      - unclosed\
    \ delimiter\n30 |                                                     if e !=\
    \ q.len() - 12 {\n   |                                                       \
    \                   - unclosed delimiter\n31 |                               \
    \                          if e != q.len() - 13 {\n   |                      \
    \                                                    "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q_rev = q.iter().rev();\n\
    \    let mut w = 0;\n    let mut sum = 0;\n    let mut max_weight = 0;\n    let\
    \ mut is_balanced = true;\n    for v in q_rev {\n        sum += v;\n        if\
    \ sum > w {\n            is_balanced = false;\n            break;\n        }\n\
    \        if sum > max_weight {\n            max_weight = sum;\n        }\n   \
    \ }\n    if is_balanced {\n        true\n    } else {\n        false\n    }\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5i8lxqc1.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for &i in q {\n        sum += i;\n        max_weight\
    \ = if sum > max_weight {\n            max_weight\n        } else {\n        \
    \    max_weight\n        };\n    }\n    if sum == w {\n        true\n    } else\
    \ if sum < w {\n        false\n    } else {\n        max_weight <= w\n    }\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_uhcainc.rs:15:9\n   |\n\
    15 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    let mut is_balanced = false;\n    for &i in q {\n \
    \       sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if sum < w {\n        is_balanced = false;\n    } else\
    \ {\n        is_balanced = true;\n    }\n    is_balanced && max_weight <= w\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzfy34i3l.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max = 0;\n    let\
    \ mut sum = 0;\n    for v in q.iter() {\n        sum += v;\n        if sum > max\
    \ {\n            max = sum;\n        }\n    }\n    if sum == w {\n        return\
    \ true;\n    }\n    if sum < w {\n        return false;\n    }\n    let mut i\
    \ = 0;\n    while i < q.len() {\n        if q[i] != q[q.len() - 1 - i] {\n   \
    \         return false;\n        }\n        i += 1;\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpos43rvej.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for x in q {\n        sum += x;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            sum\n\
    \        };\n    }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7_u6nemo.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    for x in q {\n       \
    \ sum += x;\n        if sum > max_weight {\n            max_weight = sum;\n  \
    \      }\n        if sum == max_weight {\n            balanced = true;\n     \
    \   }\n    }\n    balanced && sum <= w\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfvftii3y.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    for x in q {\n        sum += x;\n        if sum ==\
    \ w {\n            balanced = true;\n            break;\n        }\n    }\n  \
    \  balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe842utx0.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for el in q {\n        sum += el;\n        if sum >\
    \ max_weight {\n            max_weight = sum;\n        }\n    }\n    if sum <\
    \ w {\n        return false;\n    }\n    let mut sum = 0;\n    let mut max_weight\
    \ = 0;\n    for el in q {\n        sum += el;\n        if sum > max_weight {\n\
    \            max_weight = sum;\n        }\n    }\n    if sum == w {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `q`\n   --> /tmp/tmp0_teiihq.rs:26:15\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for el in q {\n    |               - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n26  |     for el in q {\n\
    \    |               ^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `q`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n15  |     for el in &q {\n    |               +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for v in q.iter() {\n        sum += v;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n    }\n    if\
    \ max_weight <= w {\n        return true;\n    }\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut is_balanced = true;\n    while i < q.len() && j < q.len()\
    \ {\n        if q[j] != q[i] {\n            is_balanced = false;\n           \
    \ break;\n        }\n        i += 1;\n        j += 1;\n    }\n    if is_balanced\
    \ {\n        let mut i = 0;\n        let mut j = 0;\n        while i < q.len()\
    \ && j < q.len() {\n            if q[j] != q[i] {\n                break;\n  \
    \          }\n            i += 1;\n            j += 1;\n        }\n        if\
    \ i == q.len() {\n            return true;\n        }\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpizpa11i3.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for el in q {\n        sum += el;\n        if sum >\
    \ max_weight {\n            max_weight = sum;\n        }\n    }\n    if sum <\
    \ w {\n        return false;\n    }\n    let mut is_balanced = true;\n    for\
    \ el in q {\n        if el != q[q.len() - 1 - el] {\n            is_balanced =\
    \ false;\n            break;\n        }\n    }\n    if is_balanced {\n       \
    \ true\n    } else {\n        max_weight < w\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgt5yc71k.rs:26:34\n   |\n\
    26 |         if el != q[q.len() - 1 - el] {\n   |                            \
    \      ^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize`\
    \ from `usize`\n  --> /tmp/tmpgt5yc71k.rs:26:32\n   |\n26 |         if el != q[q.len()\
    \ - 1 - el] {\n   |                                ^ no implementation for `usize\
    \ - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for x in q {\n     \
    \   sum += x;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if sum == max_weight {\n            balanced = true;\n   \
    \     }\n    }\n    if !balanced {\n        return false;\n    }\n    if max_weight\
    \ <= w {\n        return true;\n    }\n    let mut sum = 0;\n    for x in q {\n\
    \        sum += x;\n        if sum == w {\n            return true;\n        }\n\
    \    }\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `q`\n   --> /tmp/tmpqevsbcjl.rs:32:14\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n16  |     for x in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n32  |     for x in q {\n \
    \   |              ^ value used here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `q`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n16  |     for x in &q {\n    |              +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max = 0;\n    let\
    \ mut sum = 0;\n    for i in q.iter() {\n        sum += i;\n        if sum > max\
    \ {\n            max = sum;\n        }\n    }\n    sum == w && q.iter().rev().all(|&i|\
    \ i <= max)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxmowe9mn.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    let mut sum = 0;\n    for &i in q {\n  \
    \      sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    for &i in q {\n        if i != q[q.len() - 1 - i] {\n \
    \           is_balanced = false;\n            break;\n        }\n    }\n    sum\
    \ == max_weight && is_balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp94kvdmca.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp94kvdmca.rs:22:9\n   |\n22 |     for &i in q {\n   |         ^^\
    \    - this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    q.reverse();\n    let mut sum = 0;\n    for i in q {\n        sum += i;\n\
    \    }\n    sum < w && is_palindromic(q) && sum == w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpwoc03ih6.rs:19:16\n   |\n19 |     sum < w && is_palindromic(q) && sum\
    \ == w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for x in q {\n        sum += x;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            sum\n\
    \        };\n    }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpoj30wzb9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ v in q.iter() {\n        sum += v;\n    }\n    sum < w && is_palindromic(q)\
    \ && sum >= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpcjpq2s9k.rs:17:16\n   |\n17 |     sum < w && is_palindromic(q) && sum\
    \ >= w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max = 0;\n    let\
    \ mut sum = 0;\n    for &i in q {\n        sum += i;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    sum == max && is_balanced(q) &&\
    \ is_palindromic(q) && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp_l6w67tp.rs:21:19\n\
    \   |\n21 |     sum == max && is_balanced(q) && is_palindromic(q) && sum <= w\n\
    \   |                   ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_palindromic` in this scope\n  --> /tmp/tmp_l6w67tp.rs:21:37\n\
    \   |\n21 |     sum == max && is_balanced(q) && is_palindromic(q) && sum <= w\n\
    \   |                                     ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_l6w67tp.rs:15:9\n   |\n15 | \
    \    for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    for &x in q {\n        sum += x;\n        if sum >\
    \ w {\n            balanced = true;\n            break;\n        }\n    }\n  \
    \  balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeasr_i6x.rs:15:9\n   |\n\
    15 |     for &x in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ x in q {\n        sum += x;\n    }\n    if sum < w {\n        return false;\n\
    \    }\n    let mut max_sum = 0;\n    for x in q {\n        max_sum += x;\n  \
    \  }\n    if max_sum < w {\n        return true;\n    }\n    let mut max_weight\
    \ = 0;\n    for x in q {\n        max_weight = max(max_weight, x);\n    }\n  \
    \  if max_weight < w {\n        return false;\n    }\n    let mut max_weight_index\
    \ = 0;\n    for x in q.iter().rev() {\n        max_weight_index = max(max_weight_index,\
    \ x);\n    }\n    if max_weight_index > w {\n        return true;\n    }\n   \
    \ let mut max_weight_index = 0;\n    for x in q.iter().rev() {\n        max_weight_index\
    \ = max(max_weight_index, x);\n    }\n    if max_weight_index > w {\n        return\
    \ true;\n    }\n    let mut max_weight_index = 0;\n    for x in q.iter().rev()\
    \ {\n        max_weight_index = max(max_weight_index, x);\n    }\n    if max_weight_index\
    \ > w {\n        return true;\n    }\n    let mut max_weight_index = 0;\n    for\
    \ x in q.iter().rev() {\n        max_weight_index = max(max_weight_index, x);\n\
    \    }\n    if max_weight_index > w {\n        return true;\n    }\n    let mut\
    \ max_weight_index = 0;\n    for x in q.iter().rev() {\n        max_weight_index\
    \ = max(max_weight_index, x);\n    }\n    if max_weight_index > w {\n        return\
    \ true;\n    }\n    let mut max_weight_index = 0;\n    for x in q.iter().rev()\
    \ {\n        max_weight_index = max(max_weight_index, x);\n    }\n    if max_weight_index\
    \ > w {\n        return true;\n    }\n    let mut max_weight_index = 0;\n    for\
    \ x in q.iter().rev() {\n        max_weight_index = max(max_weight_index, x);\n\
    \    }\n    if max_weight_index > w {\n        return true;\n    }\n    let mut\
    \ max_weight_index = 0;\n    for x in q.iter().rev() {\n        max_weight_index\
    \ = max(max_weight_index, x);\n    }\n    if max_weight_index > w {\n        return\
    \ true;\n    }\n    let mut max_weight_index = 0;\n    for x in q.iter().rev()\
    \ {\n        max_weight_index = max(max_weight_index, x);\n    }\n    if max_weight_index\
    \ > w {\n        return true;\n    }\n    let mut max_weight_index = 0;\n    for\
    \ x in q.iter().rev() {\n        max_weight_index = max(max_weight_index, x);\n\
    \    }\n    if max_weight_index > w {\n        return true;\n    }\n    let mut\
    \ max_weight_index = 0;\n    for x in q.iter().rev() {\n        max_weight_index\
    \ = max(max_weight_index, x);\n    }\n    if max_weight_index > w {\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpc7ccl_9c.rs:119:3\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n108 |  \
    \   if max_weight_index > w {\n    |                             - this delimiter\
    \ might not be properly closed...\n109 | }\n    | - ...as it matches this but\
    \ it has different indentation\n...\n119 | }\n    |   ^\n\nerror[E0425]: cannot\
    \ find function `max` in this scope\n  --> /tmp/tmpc7ccl_9c.rs:29:22\n   |\n29\
    \ |         max_weight = max(max_weight, x);\n   |                      ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `max` in this\
    \ scope\n  --> /tmp/tmpc7ccl_9c.rs:36:28\n   |\n36 |         max_weight_index\
    \ = max(max_weight_index, x);\n   |                            ^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpc7ccl_9c.rs:43:28\n\
    \   |\n43 |         max_weight_index = max(max_weight_index, x);\n   |       \
    \                     ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find\
    \ function `max` in this scope\n  --> /tmp/tmpc7ccl_9c.rs:50:28\n   |\n50 |  \
    \       max_weight_index = max(max_weight_index, x);\n   |                   \
    \         ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `max`\
    \ in this scope\n  --> /tmp/tmpc7ccl_9c.rs:57:28\n   |\n57 |         max_weight_index\
    \ = max(max_weight_index, x);\n   |                            ^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpc7ccl_9c.rs:64:28\n\
    \   |\n64 |         max_weight_index = max(max_weight_index, x);\n   |       \
    \                     ^^^ "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for v in q.iter() {\n        sum += v;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n    }\n    let\
    \ mut is_balanced = true;\n    let mut max_sum = 0;\n    for v in q.iter() {\n\
    \        let mut v_sum = 0;\n        for w in q.iter() {\n            v_sum +=\
    \ w;\n        }\n        if v_sum != v {\n            is_balanced = false;\n \
    \           break;\n        }\n        if v_sum > max_sum {\n            max_sum\
    \ = v_sum;\n        }\n    }\n    if max_sum == w && is_balanced {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgo1_2bdj.rs:28:21\n   |\n\
    28 |         if v_sum != v {\n   |                     ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n28 |        \
    \ if v_sum != *v {\n   |                     +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = true;\n\
    \    let mut sum = 0;\n    for v in q.iter() {\n        sum += v;\n        balanced\
    \ = balanced && (sum >= w);\n    }\n    balanced\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptojo1i_r.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for &i in q {\n        sum += i;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            sum\n\
    \        };\n    }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgvwj9rbf.rs:15:9\n   |\n\
    15 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max = 0;\n    let\
    \ mut sum = 0;\n    for x in q {\n        sum += x;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    sum == max && is_balanced(q, w)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpx1lp2ta_.rs:21:19\n\
    \   |\n21 |     sum == max && is_balanced(q, w)\n   |                   ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for v in q.iter() {\n        sum += v;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            sum\n\
    \        };\n    }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsno4qlxf.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    for &i in q {\n        sum += i;\n        if sum >\
    \ w {\n            balanced = false;\n            break;\n        }\n    }\n \
    \   balanced && sum == w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdl0ux7_k.rs:15:9\n   |\n\
    15 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for v in q {\n        sum += v;\n        if sum > max_weight\
    \ {\n            max_weight = sum;\n        }\n    }\n    if max_weight <= w {\n\
    \        return true;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < q.len() && j < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    if i == q.len()\
    \ {\n        return true;\n    }\n    if j == q.len() {\n        return false;\n\
    \    }\n    if q[i] > q[j] {\n        return false;\n    }\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < q.len() && j < q.len() {\n        if q[i] >\
    \ q[j] {\n            i += 1;\n        } else {\n            j += 1;\n       \
    \ }\n    }\n    if i == q.len() {\n        return false;\n    }\n    if j == q.len()\
    \ {\n        return true;\n    }\n    if q[i] > q[j] {\n        return true;\n\
    \    }\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpusid4vs5.rs:26:15\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for v in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n26  |     while i < q.len()\
    \ && j < q.len() {\n    |               ^^^^^^^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `q`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n15  |     for v in &q {\n    |    \
    \          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q_rev = q.iter().rev();\n\
    \    let mut sum = 0;\n    for x in q_rev {\n        sum += x;\n    }\n    sum\
    \ < w && is_balanced(q) && is_palindromic(q) && is_less_or_equal_to_max(w, sum)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmprtyek_v2.rs:18:16\n\
    \   |\n18 |     sum < w && is_balanced(q) && is_palindromic(q) && is_less_or_equal_to_max(w,\
    \ sum)\n   |                ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_palindromic` in this scope\n  --> /tmp/tmprtyek_v2.rs:18:34\n\
    \   |\n18 |     sum < w && is_balanced(q) && is_palindromic(q) && is_less_or_equal_to_max(w,\
    \ sum)\n   |                                  ^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_less_or_equal_to_max` in this\
    \ scope\n  --> /tmp/tmprtyek_v2.rs:18:55\n   |\n18 |     sum < w && is_balanced(q)\
    \ && is_palindromic(q) && is_less_or_equal_to_max(w, sum)\n   |              \
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for &x in q {\n        sum += x;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            sum\n\
    \        };\n    }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcz0tly_l.rs:15:9\n   |\n\
    15 |     for &x in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for &i in q {\n        sum += i;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            max_weight\
    \ + i\n        };\n    }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdbr3r5_n.rs:15:9\n   |\n\
    15 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q_rev = q.iter().rev();\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    for v in q_rev {\n   \
    \     sum += v;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if max_weight <= w {\n        return true;\n    }\n   \
    \ let mut q_rev_reversed = q.iter().rev();\n    let mut sum_reversed = 0;\n  \
    \  let mut max_weight_reversed = 0;\n    for v in q_rev_reversed {\n        sum_reversed\
    \ += v;\n        if sum_reversed > max_weight_reversed {\n            max_weight_reversed\
    \ = sum_reversed;\n        }\n    }\n    if max_weight_reversed <= w {\n     \
    \   return true;\n    }\n    let mut q_rev_reversed_reversed = q.iter().rev().rev();\n\
    \    let mut sum_reversed_reversed = 0;\n    let mut max_weight_reversed_reversed\
    \ = 0;\n    for v in q_rev_reversed_reversed {\n        sum_reversed_reversed\
    \ += v;\n        if sum_reversed_reversed > max_weight_reversed_reversed {\n \
    \           max_weight_reversed_reversed = sum_reversed_reversed;\n        }\n\
    \    }\n    if max_weight_reversed_reversed <= w {\n        return true;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkm4uyxsv.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_sum = 0;\n\
    \    let mut is_balanced = true;\n    let mut q_rev = q.iter().rev();\n    let\
    \ mut q_iter = q.iter();\n    for x in q_iter {\n        let mut sum = 0;\n  \
    \      for y in q_rev {\n            sum += y;\n        }\n        if sum > w\
    \ {\n            is_balanced = false;\n            break;\n        }\n       \
    \ max_sum += x;\n    }\n    is_balanced && max_sum <= w\n}\n\nfn main() {\n  \
    \  let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp8tkhuntj.rs:15:9\n\
    \   |\n15 |     let mut q_rev = q.iter().rev();\n   |         ----^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmp8tkhuntj.rs:16:9\n\
    \   |\n16 |     let mut q_iter = q.iter();\n   |         ----^^^^^^\n   |    \
    \     |\n   |         help: remove this `mut`\n\nerror[E0382]: use of moved value:\
    \ `q_rev`\n   --> /tmp/tmp8tkhuntj.rs:19:18\n    |\n15  |     let mut q_rev =\
    \ q.iter().rev();\n    |         --------- move occurs because `q_rev` has type\
    \ `Rev<std::slice::Iter<'_, isize>>`, which does not implement the `Copy` trait\n\
    ...\n19  |         for y in q_rev {\n    |                  ^^^^^ `q_rev` moved\
    \ due to this implicit call to `.into_iter()`, in previous iteration of loop\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `q_rev`\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q_rev = q.iter().rev();\n\
    \    let mut sum = 0;\n    let mut max_weight = w;\n    loop {\n        if q_rev.next().unwrap()\
    \ == q[q.len() - 1] {\n            sum += q_rev.next().unwrap();\n           \
    \ if sum < max_weight {\n                return false;\n            }\n      \
    \      sum -= q_rev.next().unwrap();\n            if sum < max_weight {\n    \
    \            return false;\n            }\n            sum -= q_rev.next().unwrap();\n\
    \            if sum < max_weight {\n                return false;\n          \
    \  }\n            sum -= q_rev.next().unwrap();\n            if sum < max_weight\
    \ {\n                return false;\n            }\n            sum -= q_rev.next().unwrap();\n\
    \            if sum < max_weight {\n                return false;\n          \
    \  }\n            sum -= q_rev.next().unwrap();\n            if sum < max_weight\
    \ {\n                return false;\n            }\n            sum -= q_rev.next().unwrap();\n\
    \            if sum < max_weight {\n                return false;\n          \
    \  }\n            sum -= q_rev.next().unwrap();\n            if sum < max_weight\
    \ {\n                return false;\n            }\n            sum -= q_rev.next().unwrap();\n\
    \            if sum < max_weight {\n                return false;\n          \
    \  }\n            sum -= q_rev.next().unwrap();\n            if sum < max_weight\
    \ {\n                return false;\n            }\n            sum -= q_rev.next().unwrap();\n\
    \            if sum < max_weight {\n                return false;\n          \
    \  }\n            sum -= q_rev.next().unwrap();\n            if sum < max_weight\
    \ {\n                return false;\n            }\n            sum -= q_rev.next().unwrap();\n\
    \            if sum < max_weight {\n                return false;\n          \
    \  }\n            sum -= q_rev.next().unwrap();\n            if sum < max_weight\
    \ {\n                return false;\n            }\n            sum -= q_rev.next().unwrap();\n\
    \            if sum < max_weight {\n                return false;\n          \
    \  }\n            sum -= q_rev.next().unwrap();\n            if sum < max_weight\
    \ {\n                return false;\n            }\n            sum -= q_rev.next().unwrap();\n\
    \            if sum < max_weight {\n                return false;\n          \
    \  }\n            sum -= q_rev.next().unwrap();\n            if sum < max_weight\
    \ {\n                return false;\n            }\n            sum -= q_rev.next().unwrap();\n\
    \            if sum < max_weight {\n                return false;\n          \
    \  }\n            sum -= q_rev.next().unwrap();\n            if sum < max_weight\
    \ {\n                return false;\n            }\n            sum -= q_rev.next().unwrap();\n\
    \            if sum < max_weight {\n                return false;\n          \
    \  }\n            sum -= q_rev.\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp3c4ni0ja.rs:113:3\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n16  |  \
    \   loop {\n    |          - unclosed delimiter\n17  |         if q_rev.next().unwrap()\
    \ == q[q.len() - 1] {\n    |                                                 \
    \   - this delimiter might not be properly closed...\n...\n103 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n113 | }\n    |   ^\n\n\
    error: unexpected token: `}`\n   --> /tmp/tmp3c4ni0ja.rs:103:1\n    |\n103 | }\n\
    \    | ^\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp3c4ni0ja.rs:17:34\n\
    \   |\n17 |         if q_rev.next().unwrap() == q[q.len() - 1] {\n   |       \
    \                           ^^ no implementation for `&isize == isize`\n   |\n\
    \   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror[E0277]: cannot subtract-assign `Rev<std::slice::Iter<'_, isize>>`\
    \ from `isize`\n   --> /tmp/tmp3c4ni0ja.rs:102:17\n    |\n102 |             sum\
    \ -= q_rev.\n    |                 ^^ no implementation for `isize -= Rev<std::slice::Iter<'_,\
    \ isize>>`\n    |\n    = help: the trait `SubAssign<Rev<std::slice::Iter<'_, isize>>>`\
    \ is not implemented for `isize`\n    = help: the following other types implement\
    \ trait `SubAssign<Rhs>`:\n              <f32 as SubAssign<&f32>>\n          \
    \    <f32 as SubAssign>\n              <f64 as SubAssign<&f64>>\n            \
    \  <f64 as SubAssign>\n              <i128 as SubAssign<&i128>>\n            \
    \  <i128 as SubAssign>\n              <i16 as SubAssign<&i16>>\n             \
    \ <i16 as SubAssign>\n            and 20 others\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    let mut sum = 0;\n    for &i in q {\n  \
    \      sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if max_weight <= w {\n        is_balanced = false;\n  \
    \  }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnapxt5x8.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for v in q {\n        sum += v;\n        if sum > max_weight\
    \ {\n            max_weight = sum;\n        }\n    }\n    if max_weight == w {\n\
    \        return true;\n    }\n    if max_weight < w {\n        return false;\n\
    \    }\n    let mut q1 = q.clone();\n    q1.reverse();\n    if will_it_fly(q1,\
    \ w) {\n        return true;\n    }\n    if will_it_fly(q1, w - max_weight) {\n\
    \        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpmvj5_3lr.rs:27:18\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for v in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n27  |     let mut q1 = q.clone();\n\
    \    |                  ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `q`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for v in &q {\n    |              +\n\n\
    error[E0382]: use of moved value: `q1`\n  --> /tmp/tmpmvj5_3lr.rs:32:20\n   |\n\
    27 |     let mut q1 = q.clone();\n   |         ------ move occurs because `q1`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n28 |     q1.reverse();\n\
    29 |     if will_it_fly(q1, w) {\n   |                    -- value moved here\n\
    ...\n32 |     if will_it_fly(q1, w - max_weight) {\n   |                    ^^\
    \ value used here after move\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    for el in q {\n        sum += el;\n        if sum >\
    \ w {\n            balanced = true;\n            break;\n        }\n    }\n  \
    \  balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9mfuz27w.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = false;\n    let mut sum = 0;\n    for x in q {\n  \
    \      sum += x;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if max_weight <= w {\n        is_balanced = true;\n   \
    \ }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuldksyhy.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for &i in q {\n    \
    \    sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    for &i in q {\n        if i != q[q.len() - 1 - i] {\n \
    \           balanced = true;\n            break;\n        }\n    }\n    !balanced\
    \ && max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp21qofj41.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp21qofj41.rs:22:9\n   |\n22 |     for &i in q {\n   |         ^^\
    \    - this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max = w;\n    for &x in q {\n        sum += x;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    sum == max\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg7afmt7t.rs:15:9\n   |\n\
    15 |     for &x in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    let mut sum = 0;\n    for v in q.iter()\
    \ {\n        sum += v;\n        if sum > max_weight {\n            max_weight\
    \ = sum;\n        }\n        if sum == max_weight {\n            is_balanced =\
    \ false;\n        }\n    }\n    sum == max_weight && is_balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptlj03zuf.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ v in q {\n        sum += v;\n    }\n    if sum < w {\n        return false;\n\
    \    }\n    let mut max_sum = 0;\n    let mut max_v = q.iter().max();\n    for\
    \ v in q.iter().rev() {\n        if v > max_v {\n            max_v = v;\n    \
    \    }\n    }\n    if sum == w {\n        return true;\n    }\n    if sum > w\
    \ {\n        return false;\n    }\n    if sum == max_sum {\n        return true;\n\
    \    }\n    if sum > max_sum {\n        return false;\n    }\n    let mut max_weight\
    \ = w;\n    for v in q.iter().rev() {\n        if v > max_weight {\n         \
    \   max_weight = v;\n        }\n    }\n    if sum == max_weight {\n        return\
    \ true;\n    }\n    if sum > max_weight {\n        return false;\n    }\n    if\
    \ sum == w {\n        return true;\n    }\n    if sum > w {\n        return false;\n\
    \    }\n    if sum == max_sum {\n        return true;\n    }\n    if sum > max_sum\
    \ {\n        return false;\n    }\n    if sum == w {\n        return true;\n \
    \   }\n    if sum > w {\n        return false;\n    }\n    if sum == max_sum {\n\
    \        return true;\n    }\n    if sum > max_sum {\n        return false;\n\
    \    }\n    if sum == w {\n        return true;\n    }\n    if sum > w {\n   \
    \     return false;\n    }\n    if sum == max_sum {\n        return true;\n  \
    \  }\n    if sum > max_sum {\n        return false;\n    }\n    if sum == w {\n\
    \        return true;\n    }\n    if sum > w {\n        return false;\n    }\n\
    \    if sum == max_sum {\n        return true;\n    }\n    if sum > max_sum {\n\
    \        return false;\n    }\n    if sum == w {\n        return true;\n    }\n\
    \    if sum > w {\n        return false;\n    }\n    if sum == max_sum {\n   \
    \     return true;\n    }\n    if sum > max_sum {\n        return false;\n   \
    \ }\n    if sum == w {\n        return true;\n    }\n    if sum > w {\n      \
    \  return false;\n    }\n    if sum == max_sum {\n        return true;\n    }\n\
    \    if sum > max_sum {\n        return false;\n    }\n    if sum == w {\n   \
    \     return true;\n    }\n    if sum > w {\n        return false;\n    }\n  \
    \  if sum == max_sum {\n        return true;\n    }\n    if sum > max_sum {\n\
    \        return false;\n    }\n    if sum == w {\n        return true;\n    }\n\
    \    if sum > w {\n        return false;\n    }\n    if sum == max_sum {\n   \
    \     return true;\n    }\n    if sum > max_sum {\n        return false;\n   \
    \ }\n    if sum == w {\n        return true;\n    }\n    if sum > \n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmpuq62p7nn.rs:151:1\n\
    \    |\n151 | }\n    | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpuq62p7nn.rs:23:16\n   |\n23 |         if v > max_v {\n   |    \
    \            ^^^^^ expected `&isize`, found enum `Option`\n   |\n   = note: expected\
    \ reference `&isize`\n                   found enum `Option<&isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuq62p7nn.rs:24:21\n   |\n21 |     let mut max_v\
    \ = q.iter().max();\n   |                     -------------- expected due to this\
    \ value\n...\n24 |             max_v = v;\n   |                     ^ expected\
    \ enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n\
    \           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n24 |             max_v = Some(v);\n   |                     +++++ +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpuq62p7nn.rs:41:16\n   |\n41 |  \
    \       if v > max_weight {\n   |                ^^^^^^^^^^\n   |            \
    \    |\n   |                expected `&isize`, found `isize`\n   |           \
    \     help: consider borrowing here: `&max_weight`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuq62p7nn.rs:42:26\n   |\n39 |     let mut max_weight =\
    \ w;\n   |                          - expected due to this value\n...\n42 |  \
    \           max_weight = v;\n   |                          ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n42 |  \
    \           max_weight = *v;\n   |                          +\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max = 0;\n    let\
    \ mut sum = 0;\n    for &i in q {\n        sum += i;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    if sum == max {\n        return\
    \ true;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut i\
    \ = 0;\n    for &i in q {\n        if i != i {\n            return false;\n  \
    \      }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5qav5jgr.rs:15:9\n   |\n\
    15 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5qav5jgr.rs:28:9\n   |\n28 |     for &i in q {\n   |         ^^\
    \    - this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for v in q.iter() {\n        sum += v;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n    }\n    sum\
    \ == max_weight && is_palindromic(q) && is_balanced(q, w)\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmp69jsh3pt.rs:21:26\n   |\n21 |     sum == max_weight && is_palindromic(q)\
    \ && is_balanced(q, w)\n   |                          ^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_balanced` in this scope\n\
    \  --> /tmp/tmp69jsh3pt.rs:21:47\n   |\n21 |     sum == max_weight && is_palindromic(q)\
    \ && is_balanced(q, w)\n   |                                               ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    for x in q {\n        if x > w {\n            balanced\
    \ = false;\n            break;\n        }\n        sum += x;\n    }\n    if sum\
    \ == w {\n        balanced = true;\n    }\n    balanced\n}\n\nfn main() {\n  \
    \  let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8z2ne_mc.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ &x in q {\n        sum += x;\n    }\n    sum < w && is_palindromic(q) && sum\
    \ == w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpxks_mkdp.rs:17:16\n   |\n17 |     sum < w && is_palindromic(q) && sum\
    \ == w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxks_mkdp.rs:14:9\n   |\n14 |     for &x in q\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max = 0;\n    for x in q {\n        sum += x;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    sum == max && is_palindromic(q)\
    \ && w <= max\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmp45d92pr9.rs:21:19\n   |\n21 |     sum == max && is_palindromic(q) &&\
    \ w <= max\n   |                   ^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = w;\n\
    \    let mut is_balanced = true;\n    let mut sum = 0;\n    for &i in q {\n  \
    \      sum += i;\n        if sum > max_weight {\n            is_balanced = false;\n\
    \            break;\n        }\n    }\n    if is_balanced {\n        true\n  \
    \  } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo71r5fgd.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max = 0;\n    let\
    \ mut sum = 0;\n    for &i in q {\n        sum += i;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    sum == max && is_balanced(q, w)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpvpcp0usd.rs:21:19\n\
    \   |\n21 |     sum == max && is_balanced(q, w)\n   |                   ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvpcp0usd.rs:15:9\n\
    \   |\n15 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    for e in q {\n        if e > max_weight\
    \ {\n            max_weight = e;\n        }\n        if e != q[q.len() - 1 - e]\
    \ {\n            is_balanced = false;\n        }\n    }\n    if max_weight ==\
    \ w && is_balanced {\n        return true;\n    }\n    return false;\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpax3nyuzr.rs:19:33\n   |\n\
    19 |         if e != q[q.len() - 1 - e] {\n   |                              \
    \   ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize`\
    \ from `usize`\n  --> /tmp/tmpax3nyuzr.rs:19:31\n   |\n19 |         if e != q[q.len()\
    \ - 1 - e] {\n   |                               ^ no implementation for `usize\
    \ - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    for x in q {\n        sum += x;\n        if sum > w\
    \ {\n            balanced = false;\n            break;\n        }\n    }\n   \
    \ balanced && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppfuy2m9o.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for i in q {\n        sum += i;\n        max_weight\
    \ = if sum > max_weight { max_weight } else { sum };\n    }\n    max_weight <=\
    \ w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwyygwgs7.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ &x in q {\n        sum += x;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp6yv54ojv.rs:17:16\n\
    \   |\n17 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6yv54ojv.rs:14:9\n\
    \   |\n14 |     for &x in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    let mut is_balanced = true;\n    for v in q.iter()\
    \ {\n        sum += v;\n        if sum > max_weight {\n            max_weight\
    \ = sum;\n        }\n        if sum == max_weight {\n            is_balanced =\
    \ false;\n        }\n    }\n    if is_balanced {\n        true\n    } else {\n\
    \        max_weight <= w\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp157nnqzy.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for v in q.iter() {\n        sum += v;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n    }\n    if\
    \ sum == max_weight {\n        return true;\n    }\n    if sum < max_weight {\n\
    \        return false;\n    }\n    let mut max_weight = 0;\n    for v in q.iter()\
    \ {\n        sum += v;\n        if sum > max_weight {\n            max_weight\
    \ = sum;\n        }\n    }\n    if sum == max_weight {\n        return true;\n\
    \    }\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpj9sbv552.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for x in q {\n        sum += x;\n        max_weight\
    \ = if sum > max_weight { max_weight } else { sum };\n    }\n    if max_weight\
    \ == w {\n        return true;\n    }\n    if max_weight > w {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ true;\n    }\n    if j == q.len() {\n        return false;\n    }\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len() {\n       \
    \ if q[i] < q[j] {\n            i += 1;\n        } else {\n            j += 1;\n\
    \        }\n    }\n    if i == q.len() {\n        return false;\n    }\n    if\
    \ j == q.len() {\n        return true;\n    }\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < q.len() && j < q.len() {\n        if q[i] > q[j] {\n \
    \           i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    if i == q.len() {\n        return true;\n    }\n    if j == q.len() {\n \
    \       return false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < q.len() && j < q.len() {\n        if q[i] < q[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    if i == q.len()\
    \ {\n        return false;\n    }\n    if j == q.len() {\n        return true;\n\
    \    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len()\
    \ {\n        if q[i] > q[j] {\n            i += 1;\n        } else {\n       \
    \     j += 1;\n        }\n    }\n    if i == q.len() {\n        return true;\n\
    \    }\n    if j == q.len() {\n        return false;\n    }\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < q.len() && j < q.len() {\n        if q[i] <\
    \ q[j] {\n            i += 1;\n        } else {\n            j += 1;\n       \
    \ }\n    }\n    if i == q.len() {\n        return false;\n    }\n    if j == q.len()\
    \ {\n        return true;\n    }\n    let mut i = 0;\n    let mut j = 0;\n   \
    \ while i < q.len() && j < q.len() {\n        if q[i] > q[j] {\n            i\
    \ += 1;\n        } else {\n            j += 1;\n        }\n    }\n    if i ==\
    \ q.len() {\n        return true;\n    }\n    if j == q.len() {\n        return\
    \ false;\n    }\n    let mut \n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n   --> /tmp/tmpy_34pegj.rs:131:1\n\
    \    |\n131 | }\n    | ^ expected identifier\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut balanced = true;\n    let mut sum = 0;\n    for &i in q {\n     \
    \   sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if sum < w {\n            balanced = false;\n        }\n \
    \   }\n    balanced && max_weight <= w\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqx6s4w5l.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = w;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for v in q.iter() {\n\
    \        sum += v;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if v == q[q.len() - 1] {\n            balanced = true;\n \
    \       }\n    }\n    balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp7yykp1qg.rs:21:14\n\
    \   |\n21 |         if v == q[q.len() - 1] {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max = 0;\n    for x in q {\n        sum += x;\n        if sum > max {\n\
    \            max = sum;\n        }\n    }\n    if sum == max {\n        return\
    \ true;\n    }\n    if sum < w {\n        return false;\n    }\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len() {\n        if\
    \ q[i] > q[j] {\n            i += 1;\n        } else {\n            j += 1;\n\
    \        }\n    }\n    if i == q.len() {\n        return true;\n    }\n    if\
    \ j == q.len() {\n        return false;\n    }\n    if q[i] > q[j] {\n       \
    \ return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpn8qyew3g.rs:29:15\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for x in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n29  |     while i < q.len()\
    \ && j < q.len() {\n    |               ^^^^^^^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `q`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n15  |     for x in &q {\n    |    \
    \          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max = 0;\n    for i in q.iter() {\n        sum += i;\n        if sum > max\
    \ {\n            max = sum;\n        }\n    }\n    sum == max && is_palindromic(q)\
    \ && w <= sum\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmp_tbp2usa.rs:21:19\n   |\n21 |     sum == max && is_palindromic(q) &&\
    \ w <= sum\n   |                   ^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for x in q {\n        sum += x;\n        max_weight\
    \ = if sum > max_weight { max_weight } else { sum };\n    }\n    if max_weight\
    \ <= w {\n        return true;\n    }\n    let mut i = 0;\n    let mut j = 0;\n\
    \    while i < q.len() && j < q.len() {\n        if q[i] > q[j] {\n          \
    \  i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    if i\
    \ == q.len() {\n        return true;\n    }\n    if j == q.len() {\n        return\
    \ false;\n    }\n    if q[i] > q[j] {\n        i += 1;\n    } else {\n       \
    \ j += 1;\n    }\n    while i < q.len() {\n        if q[i] > q[j] {\n        \
    \    i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    if\
    \ i == q.len() {\n        return true;\n    }\n    if j == q.len() {\n       \
    \ return false;\n    }\n    if q[i] > q[j] {\n        i += 1;\n    } else {\n\
    \        j += 1;\n    }\n    while i < q.len() {\n        if q[i] > q[j] {\n \
    \           i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    if i == q.len() {\n        return true;\n    }\n    if j == q.len() {\n \
    \       return false;\n    }\n    if q[i] > q[j] {\n        i += 1;\n    } else\
    \ {\n        j += 1;\n    }\n    while i < q.len() {\n        if q[i] > q[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    if i == q.len() {\n        return true;\n    }\n    if j == q.len() {\n \
    \       return false;\n    }\n    if q[i] > q[j] {\n        i += 1;\n    } else\
    \ {\n        j += 1;\n    }\n    while i < q.len() {\n        if q[i] > q[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    if i == q.len() {\n        return true;\n    }\n    if j == q.len() {\n \
    \       return false;\n    }\n    if q[i] > q[j] {\n        i += 1;\n    } else\
    \ {\n        j += 1;\n    }\n    while i < q.len() {\n        if q[i] > q[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    if i == q.len() {\n        return true;\n    }\n    if j == q.len() {\n \
    \       return false;\n    }\n    if q[i] > q[j] {\n        i += 1;\n    } else\
    \ {\n        j += 1;\n    }\n    while i < q.len() {\n        if q[i] > q[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    if i == q.len() {\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpu7mni91a.rs:150:3\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n139 |  \
    \   if i == q.len() {\n    |                     - this delimiter might not be\
    \ properly closed...\n140 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n150 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpu7mni91a.rs:12:44\n   |\n12 | fn will_it_fly(q: Vec<isize>, w: isize)\
    \ -> bool {\n   |    -----------                             ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for i in q {\n        sum += i;\n        max_weight\
    \ = if sum > w {\n            max_weight\n        } else {\n            sum\n\
    \        };\n    }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp19dgm7af.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut is_balanced = true;\n    let mut sum = 0;\n    for x in q {\n   \
    \     sum += x;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if max_weight < w {\n        is_balanced = false;\n   \
    \ }\n    sum == max_weight\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9xc1or5z.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q1 = q.clone();\n\
    \    q1.reverse();\n    let mut w1 = w;\n    let mut w2 = w;\n    let mut w3 =\
    \ w;\n    let mut w4 = w;\n    let mut w5 = w;\n    let mut w6 = w;\n    let mut\
    \ w7 = w;\n    let mut w8 = w;\n    let mut w9 = w;\n    let mut w10 = w;\n  \
    \  let mut w11 = w;\n    let mut w12 = w;\n    let mut w13 = w;\n    let mut w14\
    \ = w;\n    let mut w15 = w;\n    let mut w16 = w;\n    let mut w17 = w;\n   \
    \ let mut w18 = w;\n    let mut w19 = w;\n    let mut w20 = w;\n    let mut w21\
    \ = w;\n    let mut w22 = w;\n    let mut w23 = w;\n    let mut w24 = w;\n   \
    \ let mut w25 = w;\n    let mut w26 = w;\n    let mut w27 = w;\n    let mut w28\
    \ = w;\n    let mut w29 = w;\n    let mut w30 = w;\n    let mut w31 = w;\n   \
    \ let mut w32 = w;\n    let mut w33 = w;\n    let mut w34 = w;\n    let mut w35\
    \ = w;\n    let mut w36 = w;\n    let mut w37 = w;\n    let mut w38 = w;\n   \
    \ let mut w39 = w;\n    let mut w40 = w;\n    let mut w41 = w;\n    let mut w42\
    \ = w;\n    let mut w43 = w;\n    let mut w44 = w;\n    let mut w45 = w;\n   \
    \ let mut w46 = w;\n    let mut w47 = w;\n    let mut w48 = w;\n    let mut w49\
    \ = w;\n    let mut w50 = w;\n    let mut w51 = w;\n    let mut w52 = w;\n   \
    \ let mut w53 = w;\n    let mut w54 = w;\n    let mut w55 = w;\n    let mut w56\
    \ = w;\n    let mut w57 = w;\n\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd93pze28.rs:12:44\n   |\n\
    12 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |    -----------  \
    \                           ^^^^ expected `bool`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = w;\n\
    \    let mut is_balanced = true;\n    let mut sum = 0;\n    for i in q.iter()\
    \ {\n        sum += i;\n        if sum > max_weight {\n            is_balanced\
    \ = false;\n            break;\n        }\n    }\n    if is_balanced {\n     \
    \   for i in q.iter() {\n            if i != q[q.len() - 1 - i] {\n          \
    \      is_balanced = false;\n                break;\n            }\n        }\n\
    \    }\n    is_balanced && sum <= max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8wn5mtd4.rs:25:37\n   |\n\
    25 |             if i != q[q.len() - 1 - i] {\n   |                          \
    \           ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract\
    \ `&isize` from `usize`\n  --> /tmp/tmp8wn5mtd4.rs:25:35\n   |\n25 |         \
    \    if i != q[q.len() - 1 - i] {\n   |                                   ^ no\
    \ implementation for `usize - &isize`\n   |\n   = help: the trait `Sub<&isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmp8wn5mtd4.rs:25:18\n   |\n25 |             if i != q[q.len() - 1\
    \ - i] {\n   |                  ^^ no implementation for `&isize == isize`\n \
    \  |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = w;\n\
    \    let mut balanced = true;\n    let mut sum = 0;\n    for i in q.iter() {\n\
    \        sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n        if sum == max_weight {\n            balanced = false;\n  \
    \      }\n    }\n    balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8vfrh_5o.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ &i in q {\n        sum += i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpuvg8jne1.rs:17:16\n\
    \   |\n17 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuvg8jne1.rs:14:9\n\
    \   |\n14 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for i in q {\n        sum += i;\n        if sum > max_weight\
    \ {\n            max_weight = sum;\n        }\n    }\n    if max_weight == w {\n\
    \        return true;\n    }\n    if max_weight > w {\n        return false;\n\
    \    }\n    let mut i = 0;\n    let mut j = q.len();\n    while i < j {\n    \
    \    if q[i] != q[j] {\n            return false;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpp9t167w1.rs:28:17\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for i in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n28  |     let mut j = q.len();\n\
    \    |                 ^^^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `q`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n15  |     for i in &q {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    q.reverse();\n    let mut sum = 0;\n    for &x in q {\n        sum += x;\n\
    \    }\n    sum < w && is_palindromic(q) && sum >= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpunh28exm.rs:19:16\n   |\n19 |     sum < w && is_palindromic(q) && sum\
    \ >= w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpunh28exm.rs:16:9\n   |\n16 |     for &x in q\
    \ {\n   |         ^^    - this expression has type `Option<isize>`\n   |     \
    \    |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for v in q {\n     \
    \   sum += v;\n        if sum > w {\n            balanced = true;\n          \
    \  break;\n        }\n        if sum > max_weight {\n            max_weight =\
    \ sum;\n        }\n    }\n    balanced && sum <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmz_96ak7.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_sum = 0;\n\
    \    let mut is_balanced = true;\n    for el in q {\n        if el > w {\n   \
    \         is_balanced = false;\n            break;\n        }\n        max_sum\
    \ += el;\n    }\n    if max_sum < w {\n        is_balanced = false;\n    }\n \
    \   is_balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptjnt83nb.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    let mut max_weight = w;\n    for &i in q {\n      \
    \  sum += i;\n        if sum > max_weight {\n            max_weight = sum;\n \
    \       }\n    }\n    if max_weight == w {\n        balanced = true;\n    }\n\
    \    balanced && q.iter().rev().all(|&i| i < w)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ix7uivh.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for e in q {\n        sum += e;\n        if sum > max_weight\
    \ {\n            max_weight = sum;\n        }\n    }\n    if max_weight <= w {\n\
    \        return false;\n    }\n    let mut i = 0;\n    let mut j = q.len();\n\
    \    while i < j {\n        if q[i] != q[j] {\n            return false;\n   \
    \     }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmp9cxkb94b.rs:25:17\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for e in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n25  |     let mut j = q.len();\n\
    \    |                 ^^^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `q`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n15  |     for e in &q {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for el in q {\n        sum += el;\n        if sum >\
    \ max_weight {\n            max_weight = sum;\n        }\n    }\n    if max_weight\
    \ == w {\n        return true;\n    }\n    if max_weight > w {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ true;\n    }\n    if j == q.len() {\n        return false;\n    }\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len() {\n       \
    \ if q[i] < q[j] {\n            i += 1;\n        } else {\n            j += 1;\n\
    \        }\n    }\n    if i == q.len() {\n        return false;\n    }\n    if\
    \ j == q.len() {\n        return true;\n    }\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < q.len() && j < q.len() {\n        if q[i] > q[j] {\n \
    \           i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    if i == q.len() {\n        return true;\n    }\n    if j == q.len() {\n \
    \       return false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < q.len() && j < q.len() {\n        if q[i] < q[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    if i == q.len()\
    \ {\n        return true;\n    }\n    if j == q.len() {\n        return false;\n\
    \    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len()\
    \ {\n        if q[i] > q[j] {\n            i += 1;\n        } else {\n       \
    \     j += 1;\n        }\n    }\n    if i == q.len() {\n        return true;\n\
    \    }\n    if j == q.len() {\n        return false;\n    }\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < q.len() && j < q.len() {\n        if q[i] <\
    \ q[j] {\n            i += 1;\n        } else {\n            j += 1;\n       \
    \ }\n    }\n    if i == q.len() {\n        return true;\n    }\n    if j == q.len()\
    \ {\n        return false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n  \
    \  while i < q.len() && j < q.len() {\n        if q[i] > q[j] {\n            i\
    \ += 1;\n        } else {\n            j += 1;\n        }\n    }\n    if i ==\
    \ q.len() {\n        return true;\n    }\n    if j == q.len() {\n        return\
    \ false;\n    }\n    let mu\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n   --> /tmp/tmph6db94o2.rs:132:11\n   \
    \ |\n132 |     let mu\n    |           ^ help: add `;` here\n133 | }\n    | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph6db94o2.rs:12:44\n\
    \   |\n12 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |    -----------\
    \                             ^^^^ expected `bool`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    let mut is_balanced =\
    \ true;\n    while q.len() > 0 {\n        sum += q.iter().sum();\n        if sum\
    \ > max_weight {\n            max_weight = sum;\n        }\n        if sum ==\
    \ max_weight {\n            is_balanced = false;\n            break;\n       \
    \ }\n        q.pop();\n    }\n    q.iter().all(|&x| x <= w)\n        && is_balanced\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpaa2kznot.rs:18:13\n\
    \   |\n18 |         sum += q.iter().sum();\n   |             ^^ cannot infer type\n\
    \   |\nhelp: consider specifying the type argument in the method call\n   |\n\
    18 |         sum += q.iter().sum::<S>();\n   |                            +++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for v in q.iter() {\n        sum += v;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n    }\n    if\
    \ max_weight < w {\n        return false;\n    }\n    let mut is_balanced = true;\n\
    \    let mut max_sum = 0;\n    for v in q.iter() {\n        if v > max_sum {\n\
    \            max_sum = v;\n        }\n        if v != max_sum {\n            is_balanced\
    \ = false;\n            break;\n        }\n    }\n    if is_balanced {\n     \
    \   true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmdi269yb.rs:27:16\n   |\n\
    27 |         if v > max_sum {\n   |                ^^^^^^^\n   |             \
    \   |\n   |                expected `&isize`, found integer\n   |            \
    \    help: consider borrowing here: `&max_sum`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmdi269yb.rs:28:23\n   |\n25 |     let mut max_sum = 0;\n   |  \
    \                     - expected due to this value\n...\n28 |             max_sum\
    \ = v;\n   |                       ^ expected integer, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n28 |             max_sum = *v;\n\
    \   |                       +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmpmdi269yb.rs:30:14\n   |\n30 |         if v != max_sum {\n   | \
    \             ^^ no implementation for `&isize == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    let mut is_balanced =\
    \ true;\n\n    while !q.is_empty() {\n        sum += q.iter().sum();\n       \
    \ if sum > max_weight {\n            max_weight = sum;\n        }\n        if\
    \ sum == max_weight {\n            is_balanced = false;\n        }\n        q.pop();\n\
    \    }\n\n    !is_balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpk_r8ec_c.rs:19:13\n\
    \   |\n19 |         sum += q.iter().sum();\n   |             ^^ cannot infer type\n\
    \   |\nhelp: consider specifying the type argument in the method call\n   |\n\
    19 |         sum += q.iter().sum::<S>();\n   |                            +++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = w;\n\
    \    let mut is_balanced = true;\n    let mut sum = 0;\n    for &i in q {\n  \
    \      sum += i;\n        if sum > max_weight {\n            is_balanced = false;\n\
    \            break;\n        }\n    }\n    if is_balanced {\n        true\n  \
    \  } else {\n        max_weight == sum\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptwpp4ul7.rs:16:9\n   |\n\
    16 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
