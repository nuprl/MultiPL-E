name: HumanEval_117_select_words
language: rust
results:
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n;\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        if s.chars().all(|c| c != ' ') {\n            result.push(s.split_whitespace()[i]);\n\
    \            i += 1;\n        }\n        if i == s.len() {\n            break;\n\
    \        }\n        if s.chars().all(|c| c == ' ') {\n            i += 1;\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpz_nz3yw4.rs:19:25\n   |\n19 |             result.push(s.split_whitespace()[i]);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut index = 0;\n    let mut consonants = false;\n    let mut vowels = false;\n\
    \    let mut space = false;\n    let mut spaces = false;\n    let mut space =\
    \ false;\n    let mut spaces = false;\n    let mut space = false;\n    let mut\
    \ spaces = false;\n    let mut space = false;\n    let mut spaces = false;\n \
    \   let mut space = false;\n    let mut spaces = false;\n    let mut space = false;\n\
    \    let mut spaces = false;\n    let mut space = false;\n    let mut spaces =\
    \ false;\n    let mut space = false;\n    let mut spaces = false;\n    let mut\
    \ space = false;\n    let mut spaces = false;\n    let mut space = false;\n  \
    \  let mut spaces = false;\n    let mut space = false;\n    let mut spaces = false;\n\
    \    let mut space = false;\n    let mut spaces = false;\n    let mut space =\
    \ false;\n    let mut spaces = false;\n    let mut space = false;\n    let mut\
    \ spaces = false;\n    let mut space = false;\n    let mut spaces = false;\n \
    \   let mut space = false;\n    let mut spaces = false;\n    let mut space = false;\n\
    \    let mut spaces = false;\n    let mut space = false;\n    let mut spaces =\
    \ false;\n    let mut space = false;\n    let mut spaces = false;\n    let mut\
    \ space = false;\n    let mut spaces = false;\n    let mut space = false;\n  \
    \  let mut spaces = false;\n    let mut space = false;\n    let mut spaces = false;\n\
    \    let mut space = false;\n    let mut spaces = false;\n    let mut space =\
    \ false;\n    let mut spaces = false;\n    let mut space = false;\n    let mut\
    \ spaces = false;\n    let mut space = false;\n    let mut spaces = false;\n \
    \   let mut space = false;\n    let mut spaces = false;\n    let mut space = false;\n\
    \    let mut spaces = false;\n    let mut space = false;\n    let mut spaces =\
    \ false;\n    let mut space = false;\n    let mut spaces = false;\n    let mut\
    \ space = false;\n    let mut spaces = false;\n    let mut space = false;\n  \
    \  let mut spaces = false;\n    let mut space = false;\n    let mut spaces = false;\n\
    \    let mut space = false;\n    let mut spaces = false;\n    let mut space =\
    \ false;\n    let mut spaces = false;\n    let mut space = false;\n    let mut\
    \ spaces = false;\n    let mut space = false;\n    let mut spaces = false;\n\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt127hoas.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ index = 0;\n    while index < s.len() {\n        let mut found = false;\n  \
    \      for c in s.chars() {\n            if c == ' ' {\n                continue;\n\
    \            }\n            if c == s[index] {\n                found = true;\n\
    \                break;\n            }\n        }\n        if found {\n      \
    \      words.push(&s[index..index+n]);\n            index += n;\n        }\n \
    \   }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp18d9socc.rs:21:21\n\
    \   |\n21 |             if c == s[index] {\n   |                     ^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp18d9socc.rs:27:40\n\
    \   |\n27 |             words.push(&s[index..index+n]);\n   |                \
    \                        ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ add `isize` to `usize`\n  --> /tmp/tmp18d9socc.rs:27:39\n   |\n27 |        \
    \     words.push(&s[index..index+n]);\n   |                                  \
    \     ^ no implementation for `usize + isize`\n   |\n   = help: the trait `Add<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp18d9socc.rs:28:22\n\
    \   |\n28 |             index += n;\n   |                      ^ expected `usize`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp18d9socc.rs:31:5\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n31 |     words\n   |     ^^^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `Vec<String>`\n       "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ index = 0;\n    while index < s.len() {\n        let mut word = String::new();\n\
    \        let mut consonants = 0;\n        let mut letter = s.chars().nth(index).unwrap();\n\
    \        while letter != ' ' {\n            if letter == 'a' || letter == 'e'\
    \ || letter == 'i' || letter == 'o' || letter == 'u' {\n                consonants\
    \ += 1;\n            }\n            letter = s.chars().nth(index).unwrap();\n\
    \        }\n        if consonants == n {\n            words.push(word);\n    \
    \    }\n        index += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j = j + 1;\n        }\n        if j == s.len()\
    \ {\n            break;\n        }\n        let mut k = j;\n        while k <\
    \ s.len() && s[k] == ' ' {\n            k = k + 1;\n        }\n        if k ==\
    \ s.len() {\n            break;\n        }\n        let mut c = s[k];\n      \
    \  while k < s.len() && s[k] != c {\n            k = k + 1;\n        }\n     \
    \   if k == s.len() {\n            break;\n        }\n        let mut n = k -\
    \ j;\n        if n == n {\n            words.push(s.split_whitespace().nth(i).unwrap());\n\
    \            i = i + 1;\n        }\n    }\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv9dyckdx.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpv9dyckdx.rs:24:30\n   |\n24 |         while k < s.len() && s[k]\
    \ == ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpv9dyckdx.rs:30:21\n   |\n30 |         let mut c = s[k];\n   | \
    \                    ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n            "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut consonants = Vec::new();\n    let mut vowels = Vec::new();\n    let mut\
    \ vowel_counter = 0;\n    let mut vowel_counter2 = 0;\n    let mut vowel_counter3\
    \ = 0;\n    let mut vowel_counter4 = 0;\n    let mut vowel_counter5 = 0;\n   \
    \ let mut vowel_counter6 = 0;\n    let mut vowel_counter7 = 0;\n    let mut vowel_counter8\
    \ = 0;\n    let mut vowel_counter9 = 0;\n    let mut vowel_counter10 = 0;\n  \
    \  let mut vowel_counter11 = 0;\n    let mut vowel_counter12 = 0;\n    let mut\
    \ vowel_counter13 = 0;\n    let mut vowel_counter14 = 0;\n    let mut vowel_counter15\
    \ = 0;\n    let mut vowel_counter16 = 0;\n    let mut vowel_counter17 = 0;\n \
    \   let mut vowel_counter18 = 0;\n    let mut vowel_counter19 = 0;\n    let mut\
    \ vowel_counter20 = 0;\n    let mut vowel_counter21 = 0;\n    let mut vowel_counter22\
    \ = 0;\n    let mut vowel_counter23 = 0;\n    let mut vowel_counter24 = 0;\n \
    \   let mut vowel_counter25 = 0;\n    let mut vowel_counter26 = 0;\n    let mut\
    \ vowel_counter27 = 0;\n    let mut vowel_counter28 = 0;\n    let mut vowel_counter29\
    \ = 0;\n    let mut vowel_counter30 = 0;\n    let mut vowel_counter31 = 0;\n \
    \   let mut vowel_counter32 = 0;\n    let mut vowel_counter33 = 0;\n    let mut\
    \ vowel_counter34 = 0;\n    let mut vowel_counter35 = 0;\n    let mut vowel_counter36\
    \ = 0;\n    let mut vowel_counter37 = 0;\n    let mut vowel_counter38 = 0;\n \
    \   let mut vowel_counter39 = 0;\n    let mut vowel_counter40 = 0;\n    let mut\
    \ vowel_counter41 = 0;\n    let mut vowel_counter42 = 0;\n    let mut vowel_counter43\
    \ = 0;\n    let mut vowel_counter44 = 0;\n    let mut vowel_counter45 = 0;\n \
    \   let mut vowel_counter46 = 0;\n    let mut vowel_counter47 = 0;\n    let mut\
    \ vowel_counter48 = 0;\n    let mut vowel_counter49 = 0;\n    let mut vowel_counter50\
    \ = 0;\n    let mut vowel_counter51 = 0;\n    let mut vowel_counter52 = 0;\n \
    \   let mut vowel_counter53 = 0;\n    let mut vowel_counter54 = 0;\n\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaz6_2tno.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == s.chars().nth(j)) {\n                j += 1;\n            } else {\n  \
    \              break;\n            }\n        }\n        if j == s.len() {\n \
    \           list.push(s.to_string());\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7tt13tm8.rs:19:39\n   |\n\
    19 |             if s.chars().any(|c| c == s.chars().nth(j)) {\n   |         \
    \                              ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c| c\
    \ == s.chars().nth(j)) {\n                j = j + 1;\n            } else {\n \
    \               break;\n            }\n        }\n        words.push(s.chars().nth(i).unwrap());\n\
    \        i = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc563a3v1.rs:19:39\n   |\n\
    19 |             if s.chars().any(|c| c == s.chars().nth(j)) {\n   |         \
    \                              ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc563a3v1.rs:28:5\n   |\n12 | fn\
    \ select_words(s: String, n: isize) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n28 |     words\n   |     ^^^^^ expected struct `String`, found `char`\n \
    \  |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == ' ' || c == '\\t' || c == '\\n') {\n                break;\n          \
    \  }\n            j = j + 1;\n        }\n        let mut word = s.split_whitespace().nth(i);\n\
    \        list.push(word.clone());\n        i = j;\n    }\n    list\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm9tn13k8.rs:28:5\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n28 |     list\n   |     ^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<Option<&str>>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n;\n    while n > 0 {\n        let\
    \ mut i = s.find('a', 0); \n        if i == s.len() {\n            break;\n  \
    \      }\n        let mut j = s.find('a', i);\n        if j == s.len() {\n   \
    \         j = s.len();\n        }\n        let mut word = s.to_string();\n   \
    \     word.truncate(i);\n        word.truncate(j);\n        list.push(word);\n\
    \        s = &s[i..j];\n        n -= 1;\n    }\n    list\n}\n\nfn main() {\n \
    \   let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpqekv6djo.rs:17:23\n     |\n17   |         let mut i = s.find('a',\
    \ 0); \n     |                       ^^^^ ---  - supplied 2 arguments\n     |\
    \                       |\n     |                       expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqekv6djo.rs:18:17\n   |\n18 |         if i == s.len() {\n   | \
    \                ^^^^^^^ expected enum `Option`, found `usize`\n   |\n   = note:\
    \ expected enum `Option<usize>`\n              found type `usize`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n18 |         if i == Some(s.len()) {\n   | \
    \                +++++       +\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n    --> /tmp/tmpqekv6djo.rs:21:23\n     |\n21\
    \   |         let mut j = s.find('a', i);\n     |                       ^^^^ ---\
    \  - supplied 2 arguments\n     |                       |\n     |            \
    \           expected 1 argument\n     |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqekv6djo.rs:22:17\n   |\n22 |\
    \         if j == s.len() {\n   |                 ^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n22 |\
    \         if j == Some(s.len()) {\n   |                 +++++       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqekv6djo.rs:23:17\n   |\n21 |         let mut\
    \ j = s.find('a', i);\n   |                     -------------- expected due to\
    \ this value\n22 |         if j == s.len() {\n23 |             j = s.len();\n\
    \   |                 ^^^^^^^ expected enum `Option`, found `usize`\n   |\n  \
    \ = note: expected enum `Option<usize>`\n              found type `usize`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n23 |             j = Some(s.len());\n\
    \   |                 +++++       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqekv6djo.rs:26:23\n\
    \   |\n26 |         word.truncate(i);\n   |          "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] == ' ' {\n            j += 1\n        }\n        if j == s.len()\
    \ {\n            list.push(s.to_string());\n            i += 1;\n        } else\
    \ {\n            let mut k = j;\n            while k < s.len() && s[k] != ' '\
    \ {\n                k += 1\n            }\n            if k == s.len() {\n  \
    \              list.push(s.to_string());\n                i += 1;\n          \
    \  } else {\n                if n == s.len() - j {\n                    list.push(s.to_string());\n\
    \                    i += 1;\n                } else {\n                    let\
    \ mut count = 0;\n                    let mut j = i;\n                    while\
    \ j < s.len() && s[j] == ' ' {\n                        j += 1\n             \
    \       }\n                    if j == s.len() {\n                        list.push(s.to_string());\n\
    \                        i += 1;\n                    } else {\n             \
    \           let mut k = j;\n                        while k < s.len() && s[k]\
    \ != ' ' {\n                            k += 1\n                        }\n  \
    \                      if k == s.len() {\n                            list.push(s.to_string());\n\
    \                            i += 1;\n                        } else {\n     \
    \                       let mut count = 0;\n                            let mut\
    \ j = i;\n                            while j < s.len() && s[j] == ' ' {\n   \
    \                             j += 1\n                            }\n        \
    \                    if j == s.len() {\n                                list.push(s.to_string());\n\
    \                                i += 1;\n                            } else {\n\
    \                                let mut k = j;\n                            \
    \    while k < s.len() && s[k] != ' ' {\n                                    k\
    \ += 1\n                                }\n                                if\
    \ k == s.len() {\n                                    list.push(s.to_string());\n\
    \                                    i += 1;\n                               \
    \ } else {\n                                    let mut count = 0;\n         \
    \                           let mut j = i;\n                                 \
    \   while j < s.len() && s[j] == ' ' {\n                                     \
    \   j += 1\n                                    }\n                          \
    \          if j == s.len() {\n                                        list.push(s.to_string());\n\
    \                                        i += 1;\n                           \
    \         } else {\n                                        let mut k = j;\n \
    \                                       while k < s.len() && s[k] != ' ' {\n \
    \                                           k += 1\n                         \
    \               }\n                                        if k == s.len() {\n\
    \                                            list.push(s.to_string());\n     \
    \                                       i += 1;\n                            \
    \            } else {\n                                            let mut count\
    \ = 0;\n                                            let mut j = i;\n         \
    \                                   while j < s.len() && s[j] == ' ' {\n     \
    \                                           j += 1\n                         \
    \                   }\n                                            if j == s.len()\
    \ {\n                                                list.push(s.to_string());\n\
    \                                                i += 1;\n                   \
    \                         } else {\n                                         \
    \       let mut k = j;\n                                                while\
    \ k < s.len() && s[k] != ' ' {\n                                             \
    \       k += 1\n                                                }\n          \
    \                      \n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6naem7yk.rs:112:3\n\
    \    |\n12  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    15  |     while i < s.len() {\n    |                       - unclosed delimiter\n\
    ...\n23  |         } else {\n    |                - unclosed delimiter\n...\n\
    31  |             } else {\n    |                    - unclosed delimiter\n...\n\
    35  |                 } else {\n    |                        - unclosed delimiter\n\
    ...\n44  |                     } else {\n    |                            - unclosed\
    \ delimiter\n...\n52  |                         } else {\n    |              \
    \                  - unclosed delimiter\n...\n61  |                          \
    \   } else {\n    |                                    - unclosed delimiter\n\
    ...\n69  |                                 } else {\n    |                   \
    \                     - unclosed delimiter\n...\n78  |                       \
    \              } else {\n    |                                            - unclosed\
    \ delimiter\n...\n86  |                                         } else {\n   \
    \ |                                                - unclosed delimiter\n...\n\
    95  |                                             } else {\n    |            \
    \                                        - this delimiter might not be properly\
    \ closed...\n...\n101 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n112 | }\n    |   ^\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmp6naem7yk.rs:17:30\n   |\n17 |         while\
    \ j < s.len() && s[j] == ' ' {\n   |                              ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n        "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut consonants = Vec::new();\n    let mut vowels = Vec::new();\n    let mut\
    \ vowels_count = Vec::new();\n    let mut vowels_count_index = Vec::new();\n \
    \   let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index =\
    \ Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5lqaqr60.rs:56:11\n   |\n\
    56 |     let mu\n   |           ^ help: add `;` here\n57 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5lqaqr60.rs:12:41\n \
    \  |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as isize;\n    let mut i = 0;\n\
    \    while i < s.len() {\n        if s.chars().any(|c| c.is_consonant() == true)\
    \ {\n            list.push(s.subslice(i, i + n));\n            i += n;\n     \
    \   }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpsafwdt82.rs:18:32\n   |\n18 |         if s.chars().any(|c|\
    \ c.is_consonant() == true) {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpsafwdt82.rs:19:25\n\
    \   |\n19 |             list.push(s.subslice(i, i + n));\n   |               \
    \          ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsafwdt82.rs:19:41\n   |\n19 |             list.push(s.subslice(i,\
    \ i + n));\n   |                                         ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpsafwdt82.rs:19:39\n\
    \   |\n19 |             list.push(s.subslice(i, i + n));\n   |               \
    \                        ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsafwdt82.rs:20:18\n   |\n20 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmpsafwdt82.rs:20:15\n   |\n20 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssign>\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && count < n) {\n            words.push(s.to_string());\n \
    \           count += 1;\n        }\n        i += 1;\n    }\n    words\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpci1pdzo7.rs:17:32\n   |\n17 |         if s.chars().any(|c|\
    \ c.is_consonant() && count < n) {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ s = String::from(s);\n    while s.len() > 0 {\n        let mut word = String::from(\"\
    \");\n        let mut i = 0;\n        while i < s.len() {\n            if s.chars().nth(i).unwrap()\
    \ == ' ' {\n                i += 1;\n                continue;\n            }\n\
    \            if s.chars().nth(i).unwrap() == 'a' || s.chars().nth(i).unwrap()\
    \ == 'e' || s.chars().nth(i).unwrap() == 'i' || s.chars().nth(i).unwrap() == 'o'\
    \ || s.chars().nth(i).unwrap() == 'u' {\n                i += 1;\n           \
    \     continue;\n            }\n            if s.chars().nth(i).unwrap() == 'y'\
    \ {\n                i += 1;\n                continue;\n            }\n     \
    \       if s.chars().nth(i).unwrap() == 's' {\n                i += 1;\n     \
    \           continue;\n            }\n            if s.chars().nth(i).unwrap()\
    \ == 'd' {\n                i += 1;\n                continue;\n            }\n\
    \            if s.chars().nth(i).unwrap() == 'h' || s.chars().nth(i).unwrap()\
    \ == 'w' || s.chars().nth(i).unwrap() == 'o' || s.chars().nth(i).unwrap() == 'r'\
    \ || s.chars().nth(i).unwrap() == 'l' || s.chars().nth(i).unwrap() == 'm' || s.chars().nth(i).unwrap()\
    \ == 'a' || s.chars().nth(i).unwrap() == 'e' || s.chars().nth(i).unwrap() == 'i'\
    \ || s.chars().nth(i).unwrap() == 'o' || s.chars().nth(i).unwrap() == 'u' {\n\
    \                i += 1;\n                continue;\n            }\n         \
    \   if s.chars().nth(i).unwrap() == 'y' {\n                i += 1;\n         \
    \       continue;\n            }\n            if s.chars().nth(i).unwrap() ==\
    \ 's' {\n                i += 1;\n                continue;\n            }\n \
    \           if s.chars().nth(i).unwrap() == 'd' {\n                i += 1;\n \
    \               continue;\n            }\n            if s.chars().nth(i).unwrap()\
    \ == 'h' || s.chars().nth(i).unwrap() == 'w' || s.chars().nth(i).unwrap() == 'o'\
    \ || s.chars().nth(i).unwrap() == 'r' || s.chars().nth(i).unwrap() == 'l' || s.chars().nth(i).unwrap()\
    \ == 'm' || s.chars().nth(i).unwrap() == 'a' || s.chars().nth(i).unwrap() == 'e'\
    \ || s.chars().nth(i).unwrap() == 'i' || s.chars().nth(i).unwrap() == 'o' || s.chars().nth(i).unwrap()\
    \ == 'u' {\n                i += 1;\n                continue;\n            }\n\
    \            if s.chars().nth(i).unwrap() == 'y' \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp19out7ms.rs:71:3\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n15\
    \ |     while s.len() > 0 {\n   |                       - unclosed delimiter\n\
    ...\n18 |         while i < s.len() {\n   |                           - this delimiter\
    \ might not be properly closed...\n...\n60 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n71 | }\n   |   ^\n\nerror: expected `{`,\
    \ found `}`\n  --> /tmp/tmp19out7ms.rs:60:1\n   |\n59 |             if s.chars().nth(i).unwrap()\
    \ == 'y' \n   |             -- this `if` expression has a condition, but no block\n\
    60 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp19out7ms.rs:15:5\n\
    \   |\n12 |   fn select_words(s: String, n: isize) -> Vec<String> {\n   |    \
    \                                       ----------- expected `Vec<String>` because\
    \ of return type\n...\n15 | /     while s.len() > 0 {\n16 | |         let mut\
    \ word = String::from(\"\");\n17 | |         let mut i = 0;\n18 | |         while\
    \ i < s.len() {\n...  |\n70 | |     assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n71 | | }\n   | |__^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<String>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ index = 0;\n    while index < s.len() {\n        let mut word = String::new();\n\
    \        let mut consonants = 0;\n        for c in s.chars() {\n            if\
    \ c.is_uppercase() {\n                consonants += 1;\n            }\n      \
    \      if c.is_lowercase() {\n                consonants += 1;\n            }\n\
    \            if c.is_whitespace() {\n                continue;\n            }\n\
    \            if consonants == n {\n                word += c;\n              \
    \  consonants = 0;\n            }\n        }\n        if word.is_empty() {\n \
    \           continue;\n        }\n        words.push(word);\n        index +=\
    \ 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw8pmcnlo.rs:29:25\n   |\n\
    29 |                 word += c;\n   |                         ^ expected `&str`,\
    \ found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as usize;\n    while n > 0 {\n \
    \       let mut i = 0;\n        while i < s.len() {\n            if s[i] == '\
    \ ' {\n                i += 1;\n                continue;\n            }\n   \
    \         if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i]\
    \ == 'u' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'y' || s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i]\
    \ == 'o' || s[i] == 'u' {\n                i += 1;\n                continue;\n\
    \            }\n            if s[i] == 'b' || s[i] == 'c' || s[i] == 'd' || s[i]\
    \ == 'f' || s[i] == 'g' || s[i] == 'h' || s[i] == 'j' || s[i] == 'k' || s[i] ==\
    \ 'l' || s[i] == 'm' || s[i] == 'n' || s[i] == 'p' || s[i] == 'q' || s[i] == 'r'\
    \ || s[i] == 's' || s[i] == 't' || s[i] == 'v' || s[i] == 'w' || s[i] == 'x' ||\
    \ s[i] == 'y' {\n                i += 1;\n                continue;\n        \
    \    }\n            if s[i] == 'c' || s[i] == 'd' || s[i] == 'f' || s[i] == 'g'\
    \ || s[i] == 'h' || s[i] == 'j' || s[i] == 'k' || s[i] == 'l' || s[i] == 'm' ||\
    \ s[i] == 'n' || s[i] == 'p' || s[i] == 'q' || s[i] == 'r' || s[i] == 's' || s[i]\
    \ == 't' || s[i] == 'v' || s[i] == 'w' || s[i] == 'x' || s[i] == 'y' {\n     \
    \           i += 1;\n                continue;\n            }\n            if\
    \ s[i] == 'd' || s[i] == 'f' || s[i] == 'g' || s[i] == 'h' || s[i] == 'j' || s[i]\
    \ == 'k' || s[i] == 'l' || s[i] == 'm' || s[i] == 'n' || s[i] == 'p' || s[i] ==\
    \ 'q' || s[i] == 'r' || s[i] == 's' || s[i] == 't' || s[i] == 'v' || s[i] == 'w'\
    \ || s[i] == 'x' || s[i] == 'y' {\n                i += 1;\n                continue;\n\
    \            }\n            if s[i] == 'f' || s[i] == 'g' || s[i] == 'h' || s[i]\
    \ == 'j' || s[i] == 'k' || s[i] == 'l' || s[i] == 'm' || s[i] == 'n' || s[i] ==\
    \ 'p' || s[i] == 'q' || s[i] == 'r' || s[i] == 's' || s[i] == 't' || s[i] == 'v'\
    \ || s[i] == 'w' || s[i] == 'x' || s[i] == 'y' {\n                i += 1;\n  \
    \              continue;\n            }\n            if s[i] == 'g' || s[i] ==\
    \ 'h' || s[i] == 'j' || s[i] == 'k' || s[i] == 'l' || s[i] == 'm' || s[i] == 'n'\
    \ || s[i] == 'p' || s[i] == 'q' || s[i] == 'r' || s[i] == '\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpru8iqq9i.rs:47:174\n\
    \   |\n47 | ...i] == 'n' || s[i] == 'p' || s[i] == 'q' || s[i] == 'r' || s[i]\
    \ == '\n   |                                                                 \
    \     ^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j += 1\n        }\n        if j == i {\n     \
    \       i += 1;\n            continue;\n        }\n        let mut k = j;\n  \
    \      while k < s.len() && s[k] == ' ' {\n            k += 1\n        }\n   \
    \     if k == j {\n            i += 1;\n            continue;\n        }\n   \
    \     if n == j - i {\n            words.push(s.split_whitespace()[i]);\n    \
    \        i += 1;\n            continue;\n        }\n        if n == k - j {\n\
    \            words.push(s.split_whitespace()[j]);\n            i += 1;\n     \
    \       continue;\n        }\n        if n == k - j + 1 {\n            words.push(s.split_whitespace()[j]);\n\
    \            i += 1;\n            continue;\n        }\n        if n == k - j\
    \ + 2 {\n            words.push(s.split_whitespace()[j]);\n            i += 1;\n\
    \            continue;\n        }\n        if n == k - j + 3 {\n            words.push(s.split_whitespace()[j]);\n\
    \            i += 1;\n            continue;\n        }\n        if n == k - j\
    \ + 4 {\n            words.push(s.split_whitespace()[j]);\n            i += 1;\n\
    \            continue;\n        }\n        if n == k - j + 5 {\n            words.push(s.split_whitespace()[j]);\n\
    \            i += 1;\n            continue;\n        }\n        if n == k - j\
    \ + 6 {\n            words.push(s.split_whitespace()[j]);\n            i += 1;\n\
    \            continue;\n        }\n        if n == k - j + 7 {\n            words.push(s.split_whitespace()[j]);\n\
    \            i += 1;\n            continue;\n        }\n        if n == k - j\
    \ + 8 {\n            words.push(s.split_whitespace()[j]);\n            i += 1;\n\
    \            continue;\n        }\n        if n == k - j + 9 {\n            words.push(s.split_whitespace()[j]);\n\
    \            i += 1;\n            continue;\n        }\n        if n == k - j\
    \ + 10 {\n            words.push(s.split_whitespace()[j]);\n            i += 1;\n\
    \            continue;\n        }\n        if n == k - j + 11 {\n            words.push(s.split_whitespace()[j]);\n\
    \            i += 1;\n            continue;\n        }\n        if n == k - j\
    \ + 12 {\n            words.push(s.split_whitespace()[j]);\n            i += 1;\n\
    \            continue;\n        }\n        if n == k - j + 13 {\n            words.push(s.split_whitespace()[j]);\n\
    \            i += 1;\n            continue;\n        }\n        if n == k - j\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjiwxc0g7.rs:119:3\n\
    \    |\n12  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    15  |     while i < s.len() {\n    |                       - this delimiter might\
    \ not be properly closed...\n...\n108 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n119 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpjiwxc0g7.rs:108:1\n    |\n107 |         if n == k - j\n\
    \    |         -- this `if` expression has a condition, but no block\n108 | }\n\
    \    | ^ expected `{`\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpjiwxc0g7.rs:17:30\n   |\n17 |         while j < s.len()\
    \ && s[j] == ' ' {\n   |                              ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjiwxc0g7.rs:25:30\n   |\n25 |         while k < s.len() && s[k]\
    \ == ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatc"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = 0;\n        while j\
    \ < s.len() {\n            if s[i] == s[j] {\n                j += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ j == n {\n            list.push(&s[i..]);\n            i += 1;\n        }\n\
    \    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptelwufrb.rs:18:16\n\
    \   |\n18 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptelwufrb.rs:18:24\n   |\n18 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptelwufrb.rs:24:17\n   |\n24 |         if j ==\
    \ n {\n   |                 ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n24 |         if j == n.try_into().unwrap() {\n   |              \
    \    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptelwufrb.rs:29:5\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n29 |     list\n   |     ^^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `Vec<String>`\n              "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[i] == s[j] {\n            j += 1\n        }\n        if j - i\
    \ == n {\n            list.push(&s[i..j]);\n            i += n - 1;\n        }\n\
    \        i += 1;\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw2fc9ukc.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[i] == s[j] {\n   |                \
    \              ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpw2fc9ukc.rs:17:38\n   |\n17 |         while j < s.len() && s[i]\
    \ == s[j] {\n   |                                      ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw2fc9ukc.rs:20:21\n\
    \   |\n20 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw2fc9ukc.rs:22:18\n   |\n22 |             i += n - 1;\n\
    \   |                  ^^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add-assign `isize` to `usize`\n  --> /tmp/tmpw2fc9ukc.rs:22:15\n   |\n\
    22 |             i += n - 1;\n   |         "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    let mut\
    \ s = String::from(s);\n    while s.len() > 0 {\n        let mut pos = 0;\n  \
    \      let mut found = false;\n        while !found && pos < s.len() {\n     \
    \       let c = s[pos];\n            if c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u' {\n                found = true;\n            }\n       \
    \     pos += 1;\n        }\n        if found {\n            result.push(s.split_whitespace()[0]);\n\
    \            s = s.split_whitespace()[1];\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpci4914c0.rs:19:21\n\
    \   |\n19 |             let c = s[pos];\n   |                     ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpci4914c0.rs:26:25\n   |\n26 |             result.push(s.split_whitespace()[0]);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpci4914c0.rs:27:17\n\
    \   |\n27 |             s = s.split_whitespace()[1];\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0608.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    let mut\
    \ s = String::from(s);\n    let mut n = n as usize;\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        let mut j = i;\n        while j < s.len() && s[j] ==\
    \ ' ' {\n            j += 1\n        }\n        if j == i {\n            result.push(s.clone());\n\
    \            i += 1;\n            continue;\n        }\n        let mut count\
    \ = 0;\n        while j < s.len() && s[j] == s[i] {\n            count += 1;\n\
    \            j += 1\n        }\n        if count == n {\n            result.push(s.clone());\n\
    \            i += 1;\n            continue;\n        }\n        i += 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8jracjcf.rs:19:30\n\
    \   |\n19 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8jracjcf.rs:28:30\n   |\n28 |         while j < s.len() && s[j]\
    \ == s[i] {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8jracjcf.rs:28:38\n   |\n28 |         while j < s.len() && s[j]\
    \ == s[i] {\n   |                                      ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<s"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    if s.chars().all(|c| c.is_ascii_letter()) {\n            if s.len() > n {\n\
    \                list.push(s.subslice(i, i + n));\n                i += n;\n \
    \           } else {\n                list.push(s.subslice(i, i + 1));\n     \
    \           i += 1;\n            }\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpxgjfuqpp.rs:17:32\n   |\n17 |         if s.chars().all(|c|\
    \ c.is_ascii_letter()) {\n   |                                ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxgjfuqpp.rs:18:26\n   |\n18 |             if\
    \ s.len() > n {\n   |                          ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |             if s.len() > n.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `subslice` found for struct `String` in the current scope\n  --> /tmp/tmpxgjfuqpp.rs:19:29\n\
    \   |\n19 |                 list.push(s.subslice(i, i + n));\n   |           \
    \                  ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxgjfuqpp.rs:19:45\n   |\n19 |                 list.push(s.subslice(i,\
    \ i + n));\n   |                                             ^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpxgjfuqpp.rs:19:43\n\
    \   |\n19 |                 list.push(s.subslice(i, i + n));\n   |           \
    \                                ^ no implementation for `usize + isize`\n   |\n\
    \   = help: the trait `Add<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxgjfuqpp.rs:20:22\n   |\n20 |                 i += n;\n\
    \   |                      ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add-assign `isize` to `usize`\n  --> /tmp/tmpxgjfuqpp.rs:20:19\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut consonants =\
    \ vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n\
    \    let mut spaces = vec![\" \"];\n    let mut punctuation = vec![\".\", \"!\"\
    , \"?\"];\n    let mut letters = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut\
    \ numbers = vec![\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"\
    ];\n    let mut symbols = vec![\"!\", \"@\", \"#\", \"$\", \"%\", \"^\", \"&\"\
    , \"*\", \"(\", \")\", \"_\", \"+\", \"=\", \"-\", \"<\", \">\", \"[\", \"]\"\
    , \"{\", \"}\", \"|\", \";\", \":\", \"?\"];\n    let mut punctuation_symbols\
    \ = vec![\".\", \"!\", \"?\"];\n    let mut punctuation_symbols_count = vec![0];\n\
    \    let mut punctuation_symbols_count_max = vec![0];\n    let mut punctuation_symbols_count_min\
    \ = vec![0];\n    let mut punctuation_symbols_count_max = vec![0];\n    let mut\
    \ punctuation_symbols_count_min = vec![0];\n    let mut punctuation_symbols_count_max\
    \ = vec![0];\n    let mut punctuation_symbols_count_min = vec![0];\n    let mut\
    \ punctuation_symbols_count_max = vec![0];\n    let mut punctuation_symbols_count_min\
    \ = vec![0];\n    let mut punctuation_symbols_count_max = vec![0];\n    let mut\
    \ punctuation_symbols_count_min = vec![0];\n    let mut punctuation_symbols_count_max\
    \ = vec![0];\n    let mut punctuation_symbols_count_min = vec![0];\n    let mut\
    \ punctuation_symbols_count_max = vec![0];\n    let mut punctuation_symbols_count_min\
    \ = vec![0];\n    let mut punctuation_symbols_count_max = vec![0];\n    let mut\
    \ punctuation_symbols_count_min = vec![0];\n    let mut punctuation_symbols_count_max\
    \ = vec![0];\n    let mut punctuation_symbols_count_min = vec![0];\n    let mut\
    \ punctuation_symbols_count_max = vec![0];\n    let mut punctuation_symbols_count_\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgsytbx9m.rs:42:39\n   |\n\
    42 |     let mut punctuation_symbols_count_\n   |                            \
    \           ^ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgsytbx9m.rs:12:41\n   |\n12 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |    ------------                   \
    \      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s.chars().all(|c| c != s.chars().nth(j)) {\n            j += 1\n        }\n\
    \        words.push(&s[i .. j]);\n        i = j;\n    }\n    words\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl9xp1mrk.rs:17:53\n   |\n\
    17 |         while j < s.len() && s.chars().all(|c| c != s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl9xp1mrk.rs:23:5\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n23 |     words\n   |     ^^^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s[i] == s[j]\
    \ {\n                j += 1;\n            } else {\n                break;\n \
    \           }\n        }\n        if j == s.len() {\n            words.push(s.clone());\n\
    \            i += 1;\n        } else {\n            i += j - i;\n        }\n \
    \   }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpynbra3lt.rs:19:16\n\
    \   |\n19 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpynbra3lt.rs:19:24\n   |\n19 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    let mut\
    \ s = String::from(s);\n    let mut n = n as usize;\n    while n > 0 {\n     \
    \   let mut i = s.find('a', 0);\n        while i != s.len() {\n            if\
    \ s[i] == ' ' {\n                i += 1;\n            } else {\n             \
    \   result.push(s.subslice(i, i + 1));\n                break;\n            }\n\
    \            i += 1;\n        }\n        n -= 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpcy6mqsfp.rs:17:23\n     |\n17   |         let mut i = s.find('a',\
    \ 0);\n     |                       ^^^^ ---  - supplied 2 arguments\n     | \
    \                      |\n     |                       expected 1 argument\n \
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcy6mqsfp.rs:18:20\n   |\n18 |         while i != s.len() {\n  \
    \ |                    ^^^^^^^ expected enum `Option`, found `usize`\n   |\n \
    \  = note: expected enum `Option<usize>`\n              found type `usize`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n18 |         while i != Some(s.len())\
    \ {\n   |                    +++++       +\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `Option<usize>`\n  --> /tmp/tmpcy6mqsfp.rs:19:16\n   |\n\
    19 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot be\
    \ indexed by `Option<usize>`\n   |\n   = help: the trait `Index<Option<usize>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `Option<usize>`\n  --> /tmp/tmpcy6mqsfp.rs:20:17\n   |\n20 |       \
    \          i += 1;\n   |                 -^^^^^\n   |                 |\n   |\
    \                 cannot use `+=` on type `Option<usize>`\n\nerror[E0599]: no\
    \ method named `subslice` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpcy6mqsfp.rs:22:31\n   |\n22 |                 result.push(s.subslice(i,\
    \ i + 1));\n   |                               ^^^^^^^^ method not found in `String`\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpcy6mqsfp.rs:22:45\n\
    \   |\n22 |       "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as usize;\n    let mut i = 0;\n\
    \    while i < s.len() {\n        let mut j = i;\n        while j < s.len() &&\
    \ s.chars().all(|c| c != ' ') {\n            j += 1\n        }\n        if j ==\
    \ i {\n            list.push(s.to_string());\n            i += 1;\n        } else\
    \ {\n            if s.chars().all(|c| c == ' ') {\n                list.push(s.to_string());\n\
    \                i += 1;\n            } else {\n                while j < s.len()\
    \ && s.chars().all(|c| c != ' ') {\n                    j += 1\n             \
    \   }\n                if j == i {\n                    list.push(s.to_string());\n\
    \                    i += 1;\n                } else {\n                    let\
    \ mut count = 0;\n                    while j < s.len() {\n                  \
    \      if s.chars().all(|c| c == ' ') {\n                            count +=\
    \ 1;\n                            j += 1;\n                        } else {\n\
    \                            count += 1;\n                            break;\n\
    \                        }\n                    }\n                    if count\
    \ == n {\n                        list.push(s.to_string());\n                \
    \        i += 1;\n                    } else {\n                        i += 1;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a little\
    \ lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a\
    \ little lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary\
    \ had a little lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\"\
    , \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a little\
    \ lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a\
    \ little lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary\
    \ had a little lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\"\
    ]`,\n right: `[\"little\"]`', /tmp/tmp7279vl0l.rs:62:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    if s.chars().all(|c| c.is_ascii_letter()) {\n            if s.len() >= n\
    \ {\n                list.push(s.subslice(i, i + n));\n                i += n;\n\
    \            } else {\n                i += 1;\n            }\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    list\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpwhikoc6v.rs:17:32\n   |\n17 |         if s.chars().all(|c|\
    \ c.is_ascii_letter()) {\n   |                                ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwhikoc6v.rs:18:27\n   |\n18 |             if\
    \ s.len() >= n {\n   |                           ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |             if s.len() >= n.try_into().unwrap()\
    \ {\n   |                            ++++++++++++++++++++\n\nerror[E0599]: no\
    \ method named `subslice` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpwhikoc6v.rs:19:29\n   |\n19 |                 list.push(s.subslice(i,\
    \ i + n));\n   |                             ^^^^^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwhikoc6v.rs:19:45\n   |\n19 |\
    \                 list.push(s.subslice(i, i + n));\n   |                     \
    \                        ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ add `isize` to `usize`\n  --> /tmp/tmpwhikoc6v.rs:19:43\n   |\n19 |        \
    \         list.push(s.subslice(i, i + n));\n   |                             \
    \              ^ no implementation for `usize + isize`\n   |\n   = help: the trait\
    \ `Add<isize>` is not implemented for `usize`\n   = help: the following other\
    \ types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n    \
    \         <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n      \
    \       <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n          \
    \   <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n             <&'a\
    \ isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwhikoc6v.rs:20:22\n   |\n20 |                 i += n;\n   |   \
    \                   ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ add-assign `isize` to `usize`\n  --> /tmp/tmpwhikoc6v.rs:20:"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = 0;\n        while j\
    \ < s.len() {\n            if s[i] == s[j] {\n                j += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ j == n {\n            list.push(&s[i..]);\n        }\n        i += 1;\n    }\n\
    \    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp904jt6g4.rs:18:16\n\
    \   |\n18 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp904jt6g4.rs:18:24\n   |\n18 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp904jt6g4.rs:24:17\n   |\n24 |         if j ==\
    \ n {\n   |                 ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n24 |         if j == n.try_into().unwrap() {\n   |              \
    \    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp904jt6g4.rs:29:5\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n29 |     list\n   |     ^^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `Vec<String>`\n              "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] == ' ' {\n            j += 1\n        }\n        if j - i\
    \ == n {\n            list.push(s.split_whitespace()[i]);\n            i += n;\n\
    \        } else {\n            i += j - i;\n        }\n    }\n    list\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2tgo7580.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2tgo7580.rs:20:21\n\
    \   |\n20 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0608]: cannot index\
    \ into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmp2tgo7580.rs:21:23\n\
    \   |\n21 |             list.push(s.split_whitespace()[i]);\n   |            \
    \           ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2tgo7580.rs:22:18\n\
    \   |\n22 |             i += n;\n   |                  ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmp2tgo7580.rs:22:15\n\
    \   |\n22 |             i += n;\n   |               ^^ no implementation for `usize\
    \ += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerro"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j = j + 1;\n        }\n        if j == s.len()\
    \ {\n            break;\n        }\n        let mut k = j;\n        while k <\
    \ s.len() && s[k] == ' ' {\n            k = k + 1;\n        }\n        if k ==\
    \ s.len() {\n            break;\n        }\n        let mut count = 0;\n     \
    \   while k < s.len() {\n            if s[k] == s[i] {\n                count\
    \ = count + 1;\n                k = k + 1;\n            } else {\n           \
    \     break;\n            }\n        }\n        if count == n {\n            words.push(&s[i..j]);\n\
    \        }\n        i = j + 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp84sxtgyi.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp84sxtgyi.rs:24:30\n   |\n24 |         while k < s.len() && s[k]\
    \ == ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp84sxtgyi.rs:32:16\n   |\n32 |             if s[k] == s[i] {\n \
    \  |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ index = 0;\n    while index < s.len() {\n        let mut word = String::new();\n\
    \        let mut consonants = String::new();\n        let mut is_consonant = false;\n\
    \        for c in s.chars() {\n            if index == 0 {\n                word.push(c);\n\
    \            } else {\n                if is_consonant {\n                   \
    \ consonants.push(c);\n                } else {\n                    if c == '\
    \ ' {\n                        is_consonant = true;\n                    } else\
    \ {\n                        word.push(c);\n                    }\n          \
    \      }\n            }\n            index += 1\n        }\n        if consonants.len()\
    \ == n {\n            words.push(word);\n        }\n    }\n    words\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprl2hgwu0.rs:35:32\n   |\n\
    35 |         if consonants.len() == n {\n   |                                ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n35 |         if\
    \ consonants.len() == n.try_into().unwrap() {\n   |                          \
    \       ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] == ' ' {\n                break;\n        \
    \    }\n            if s[j].is_uppercase() {\n                break;\n       \
    \     }\n            j = j + 1;\n        }\n        if j == s.len() {\n      \
    \      break;\n        }\n        let mut k = j;\n        while k < s.len() {\n\
    \            if s[k] == ' ' {\n                break;\n            }\n       \
    \     if s[k].is_uppercase() {\n                break;\n            }\n      \
    \      k = k + 1;\n        }\n        if k == s.len() {\n            break;\n\
    \        }\n        if n == j - i {\n            list.push(s.split_whitespace()[i]);\n\
    \        }\n        i = j;\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsixxz4ue.rs:18:16\n\
    \   |\n18 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsixxz4ue.rs:21:16\n   |\n21 |             if s[j].is_uppercase()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsixxz4ue.rs:31:16\n\
    \   |\n31 |             if s[k] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    while s.len() > 0 {\n        let mut index = s.find('\
    \ ');\n        if index == s.len() {\n            result.push(s.clone());\n  \
    \          break;\n        }\n        let word = s.split_whitespace()[0];\n  \
    \      if word.chars().count(|c| c.is_consonant() == n) == n {\n            result.push(word);\n\
    \            s = &s[(index + 1)..];\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt5wet7op.rs:17:21\n   |\n\
    17 |         if index == s.len() {\n   |                     ^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n17 |         if index == Some(s.len()) {\n   |                     +++++\
    \       +\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpt5wet7op.rs:21:20\n   |\n21 |         let word = s.split_whitespace()[0];\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmpt5wet7op.rs:24:27\n   |\n24 |            \
    \ s = &s[(index + 1)..];\n   |                     ----- ^ - {integer}\n   | \
    \                    |\n   |                     Option<usize>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt5wet7op.rs:24:17\n   |\n14 |     let mut s\
    \ = String::from(s);\n   |                 --------------- expected due to this\
    \ value\n...\n24 |             s = &s[(index + 1)..];\n   |                 ^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n24 |             s = (&s[(index + 1)..]).to_string();\n   |           \
    \      +                 +++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == s.chars().nth(j)) {\n                j += 1;\n            } else {\n  \
    \              break;\n            }\n        }\n        if j == s.len() {\n \
    \           list.push(s.to_string());\n            i += 1;\n        } else {\n\
    \            i += j - i;\n        }\n    }\n    list\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppxeqgzt_.rs:19:39\n   |\n\
    19 |             if s.chars().any(|c| c == s.chars().nth(j)) {\n   |         \
    \                              ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] == ' ' {\n            j += 1\n        }\n        if j - i\
    \ == n {\n            list.push(s.split_whitespace()[i]);\n            i += n\
    \ - 1;\n        }\n        i = j;\n    }\n    list\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpf939mypt.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf939mypt.rs:20:21\n\
    \   |\n20 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0608]: cannot index\
    \ into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpf939mypt.rs:21:23\n\
    \   |\n21 |             list.push(s.split_whitespace()[i]);\n   |            \
    \           ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf939mypt.rs:22:18\n\
    \   |\n22 |             i += n - 1;\n   |                  ^^^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmpf939mypt.rs:22:15\n\
    \   |\n22 |             i += n - 1;\n   |               ^^ no implementation for\
    \ `usize += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ index = 0;\n    while index < s.len() {\n        let mut found = false;\n  \
    \      let mut i = 0;\n        while !found && i < s.len() {\n            if s[i]\
    \ == ' ' {\n                found = true;\n            } else {\n            \
    \    i += 1;\n            }\n        }\n        if found {\n            let mut\
    \ j = i;\n            while j < s.len() {\n                if s[j] == ' ' {\n\
    \                    j += 1;\n                } else {\n                    break;\n\
    \                }\n            }\n            let mut word = s.to_string();\n\
    \            word.truncate(j);\n            word.push_str(&s[index..i]);\n   \
    \         words.push(word);\n            index += 1;\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2jbajdqq.rs:19:16\n\
    \   |\n19 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2jbajdqq.rs:28:20\n   |\n28 |                 if s[j] == ' ' {\n\
    \   |                    ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() && s.chars().any(|c| c == s.chars().nth(j))\
    \ {\n            j += 1\n        }\n        if j == i {\n            list.push(s.to_string());\n\
    \            i += 1;\n        } else {\n            i += j - i;\n        }\n \
    \   }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw3dlbh7k.rs:18:53\n   |\n\
    18 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    if s.chars().all(|c| c.is_consonant() && c != ' ') {\n            list.push(s.subslice(i,\
    \ i + n));\n            i += n;\n        }\n    }\n    list\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp3m7pk8nl.rs:17:32\n   |\n17 |         if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp3m7pk8nl.rs:18:25\n\
    \   |\n18 |             list.push(s.subslice(i, i + n));\n   |               \
    \          ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3m7pk8nl.rs:18:41\n   |\n18 |             list.push(s.subslice(i,\
    \ i + n));\n   |                                         ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmp3m7pk8nl.rs:18:39\n\
    \   |\n18 |             list.push(s.subslice(i, i + n));\n   |               \
    \                        ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3m7pk8nl.rs:19:18\n   |\n19 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmp3m7pk8nl.rs:19:15\n   |\n19 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssi"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() && s.chars().all(|c| c != ' ')\
    \ {\n            j = j + 1;\n        }\n        if j == s.len() {\n          \
    \  break;\n        }\n        let mut word = String::from(&s[i .. j]);\n     \
    \   let mut count = 0;\n        while j < s.len() && s.chars().all(|c| c == '\
    \ ') {\n            j = j + 1;\n        }\n        if j == s.len() {\n       \
    \     break;\n        }\n        let mut j = i;\n        while j < s.len() &&\
    \ s.chars().all(|c| c != ' ') {\n            j = j + 1;\n        }\n        if\
    \ j == s.len() {\n            break;\n        }\n        let mut word = String::from(&s[i\
    \ .. j]);\n        if word.chars().all(|c| c != ' ') {\n            count = count\
    \ + 1;\n        }\n        if count == n {\n            words.push(word);\n  \
    \      }\n        i = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ consonants = vec![];\n    let mut vowels = vec![];\n    let mut spaces = vec![];\n\
    \    let mut caps = vec![];\n    let mut letters = vec![];\n    let mut spaces_count\
    \ = vec![];\n    let mut caps_count = vec![];\n    let mut letters_count = vec![];\n\
    \    let mut spaces_count = vec![];\n    let mut caps_count = vec![];\n    let\
    \ mut letters_count = vec![];\n    let mut spaces_count = vec![];\n    let mut\
    \ caps_count = vec![];\n    let mut letters_count = vec![];\n    let mut spaces_count\
    \ = vec![];\n    let mut caps_count = vec![];\n    let mut letters_count = vec![];\n\
    \    let mut spaces_count = vec![];\n    let mut caps_count = vec![];\n    let\
    \ mut letters_count = vec![];\n    let mut spaces_count = vec![];\n    let mut\
    \ caps_count = vec![];\n    let mut letters_count = vec![];\n    let mut spaces_count\
    \ = vec![];\n    let mut caps_count = vec![];\n    let mut letters_count = vec![];\n\
    \    let mut spaces_count = vec![];\n    let mut caps_count = vec![];\n    let\
    \ mut letters_count = vec![];\n    let mut spaces_count = vec![];\n    let mut\
    \ caps_count = vec![];\n    let mut letters_count = vec![];\n    let mut spaces_count\
    \ = vec![];\n    let mut caps_count = vec![];\n    let mut letters_count = vec![];\n\
    \    let mut spaces_count = vec![];\n    let mut caps_count = vec![];\n    let\
    \ mut letters_count = vec![];\n    let mut spaces_count = vec![];\n    let mut\
    \ caps_count = vec![];\n    let mut letters_count = vec![];\n    let mut spaces_count\
    \ = vec![];\n    let mut caps_count = vec![];\n    let mut letters_count = vec![];\n\
    \    let mut spaces_count = vec![];\n    let mut caps_count = vec![];\n    let\
    \ mut letters_count = vec![];\n    let mut spaces_count = vec![];\n    let mut\
    \ caps_count = vec![];\n    let mut letters_count = vec![];\n    let mut spaces_count\
    \ = vec\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplz7kmg6u.rs:64:31\n   |\n\
    64 |     let mut spaces_count = vec\n   |                               ^ help:\
    \ add `;` here\n65 | }\n   | - unexpected token\n\nerror[E0423]: expected value,\
    \ found macro `vec`\n  --> /tmp/tmplz7kmg6u.rs:64:28\n   |\n64 |     let mut spaces_count\
    \ = vec\n   |                            ^^^ not a value\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplz7kmg6u.rs:12:41\n   |\n12 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ index = 0;\n    while index < s.len() {\n        let mut word = String::new();\n\
    \        let mut consonants = 0;\n        let mut vowels = 0;\n        let mut\
    \ spaces = 0;\n        let mut letter = s.chars().nth(index).unwrap();\n     \
    \   while letter != ' ' {\n            if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                vowels += 1;\n \
    \           } else if letter == 'y' || letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                vowels += 2;\n \
    \           } else if letter == 'y' || letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                vowels += 3;\n \
    \           } else if letter == 'y' || letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                vowels += 4;\n \
    \           } else if letter == 'y' || letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                vowels += 5;\n \
    \           } else if letter == 'y' || letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                vowels += 6;\n \
    \           } else if letter == 'y' || letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                vowels += 7;\n \
    \           } else if letter == 'y' || letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                vowels += 8;\n \
    \           } else if letter == 'y' || letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                vowels += 9;\n \
    \           } else if letter == 'y' || letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                vowels += 10;\n\
    \            } else if letter == 'y' || letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                vowels += 11;\n\
    \            } else if letter == 'y' || letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                vowels += 12;\n\
    \            } else if letter == 'y' || letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                vowels += 13;\n\
    \            } else if letter == '\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp_v0hf7x4.rs:48:33\n\
    \   |\n48 |             } else if letter == '\n   |                          \
    \       ^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[i] == s[j] {\n                j += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ j == s.len() {\n            list.push(s.to_string());\n            i += 1;\n\
    \        } else {\n            i += j - i;\n        }\n    }\n    list\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4gldh8jx.rs:18:16\n\
    \   |\n18 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4gldh8jx.rs:18:24\n   |\n18 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] == ' ' {\n            j += 1\n        }\n        if j == i\
    \ {\n            list.push(s.to_string());\n            i += 1;\n        } else\
    \ {\n            let mut k = i;\n            while k < j {\n                if\
    \ s[k] == ' ' {\n                    k += 1;\n                } else {\n     \
    \               break;\n                }\n            }\n            if k ==\
    \ j {\n                list.push(s.to_string());\n                i += 1;\n  \
    \          } else {\n                let mut k = i;\n                while k <\
    \ j {\n                    if s[k] == ' ' {\n                        k += 1;\n\
    \                    } else {\n                        break;\n              \
    \      }\n                }\n                if k == j {\n                   \
    \ list.push(s.to_string());\n                    i += 1;\n                } else\
    \ {\n                    let mut k = i;\n                    while k < j {\n \
    \                       if s[k] == ' ' {\n                            k += 1;\n\
    \                        } else {\n                            break;\n      \
    \                  }\n                    }\n                    if k == j {\n\
    \                        list.push(s.to_string());\n                        i\
    \ += 1;\n                    } else {\n                        let mut k = i;\n\
    \                        while k < j {\n                            if s[k] ==\
    \ ' ' {\n                                k += 1;\n                           \
    \ } else {\n                                break;\n                         \
    \   }\n                        }\n                        if k == j {\n      \
    \                      list.push(s.to_string());\n                           \
    \ i += 1;\n                        } else {\n                            let mut\
    \ k = i;\n                            while k < j {\n                        \
    \        if s[k] == ' ' {\n                                    k += 1;\n     \
    \                           } else {\n                                    break;\n\
    \                                }\n                            }\n          \
    \                  if k == j {\n                                list.push(s.to_string());\n\
    \                                i += 1;\n                            } else {\n\
    \                                let mut k = i;\n                            \
    \    while k < j {\n                                    if s[k] == ' ' {\n   \
    \                                     k += 1;\n                              \
    \      } else {\n                                        break;\n            \
    \                        }\n                                }\n              \
    \                  if k == j {\n                                    list.push(s.to_string());\n\
    \                                    i += 1;\n                               \
    \ } else {\n                                    let mut k = i;\n             \
    \                       while k < j {\n                                      \
    \  if s[k] == ' ' {\n                                            k += 1;\n   \
    \                                     } else {\n                             \
    \               break;\n                                        }\n          \
    \                          }\n                                    if k == j {\n\
    \                                        list.push(s.to_string());\n         \
    \                               i += 1;\n                                    }\
    \ else {\n                                        let mut k = i;\n           \
    \                             while k < j {\n                                \
    \            if s[k] == ' ' {\n                                              \
    \  k += 1;\n                                            } else {\n           \
    \                                     break;\n                               \
    \             }\n                                        }\n                 \
    \                       if k == j {\n                                        \
    \    list.push(s.to_string());\n                                            i\
    \ += 1;\n                                        } else {\n                  \
    \                          let mut k = \n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5u6zq8en.rs:132:3\n\
    \    |\n12  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    15  |     while i < s.len() {\n    |                       - unclosed delimiter\n\
    ...\n23  |         } else {\n    |                - unclosed delimiter\n...\n\
    35  |             } else {\n    |                    - unclosed delimiter\n...\n\
    47  |                 } else {\n    |                        - unclosed delimiter\n\
    ...\n59  |                     } else {\n    |                            - unclosed\
    \ delimiter\n...\n71  |                         } else {\n    |              \
    \                  - unclosed delimiter\n...\n83  |                          \
    \   } else {\n    |                                    - unclosed delimiter\n\
    ...\n95  |                                 } else {\n    |                   \
    \                     - unclosed delimiter\n...\n107 |                       \
    \              } else {\n    |                                            - unclosed\
    \ delimiter\n...\n119 |                                         } else {\n   \
    \ |                                                - this delimiter might not\
    \ be properly closed...\n120 |                                             let\
    \ mut k = \n121 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n132 | }\n    |   ^\n\nerror: expected expression, found `}`\n   --> /tmp/tmp5u6zq8en.rs:121:1\n\
    \    |\n121 | }\n    | ^ expected expression\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp5u6zq8en.rs:17:30\n   |\n17 |  \
    \       while j < s.len() && s[j] == ' ' {\n   |                             \
    \ ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == s.chars().nth(j).unwrap()) {\n                list.push(s.subslice(i, j));\n\
    \                break;\n            }\n            j += 1\n        }\n      \
    \  i += 1;\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `subslice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp5bbl8cai.rs:20:29\n   |\n20 |                 list.push(s.subslice(i,\
    \ j));\n   |                             ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] != ' ' {\n            j += 1\n        }\n        let mut k\
    \ = j;\n        while k < s.len() && s[k] != ' ' {\n            k += 1\n     \
    \   }\n        let mut m = k;\n        while m < s.len() && s[m] != ' ' {\n  \
    \          m += 1\n        }\n        if n == j - i {\n            list.push(s.split_whitespace()[i\
    \ .. k].collect::<Vec<String>>());\n            i += k;\n        }\n    }\n  \
    \  list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpicm2u6o3.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] != ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpicm2u6o3.rs:21:30\n   |\n21 |         while k < s.len() && s[k]\
    \ != ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpicm2u6o3.rs:25:30\n   |\n25 |         while m < s.len() && s[m]\
    \ != ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::R"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[i] == s[j] {\n                j += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ j == s.len() {\n            list.push(s.to_string());\n            i += 1;\n\
    \        } else {\n            i += j - i;\n        }\n    }\n    list\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzkdrew4i.rs:18:16\n\
    \   |\n18 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzkdrew4i.rs:18:24\n   |\n18 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut consonants = Vec::new();\n    let mut vowels = Vec::new();\n    let mut\
    \ spaces = Vec::new();\n    let mut words = Vec::new();\n    let mut spaces_count\
    \ = s.chars().filter(|c| c == ' ').count();\n    let mut vowels_count = s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count();\n    let\
    \ mut consonants_count = s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' || c == 'y' || c == '\xE6' || c == '\xF8').count();\n\
    \    let mut vowels_count_in_word = 0;\n    let mut consonants_count_in_word =\
    \ 0;\n    let mut spaces_count_in_word = 0;\n    let mut words_count = s.chars().filter(|c|\
    \ c == ' ' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\v' || c == '\\\
    f').count();\n    let mut spaces_count_in_word = 0;\n    let mut vowels_count_in_word\
    \ = 0;\n    let mut consonants_count_in_word = 0;\n    let mut words_count_in_word\
    \ = 0;\n    let mut spaces_count_in_word = 0;\n    let mut vowels_count_in_word\
    \ = 0;\n    let mut consonants_count_in_word = 0;\n    let mut words_count_in_word\
    \ = 0;\n    let mut spaces_count_in_word = 0;\n    let mut vowels_count_in_word\
    \ = 0;\n    let mut consonants_count_in_word = 0;\n    let mut words_count_in_word\
    \ = 0;\n    let mut spaces_count_in_word = 0;\n    let mut vowels_count_in_word\
    \ = 0;\n    let mut consonants_count_in_word = 0;\n    let mut words_count_in_word\
    \ = 0;\n    let mut spaces_count_in_word = 0;\n    let mut vowels_count_in_word\
    \ = 0;\n    let mut consonants_count_in_word = 0;\n    let mut words_count_in_word\
    \ = 0;\n    let mut spaces_count_in_word = 0;\n    let mut vowels_count_in_word\
    \ = 0;\n    let mut consonants_count_in_word = 0;\n    let mut words_count_in_word\
    \ = 0;\n    let mut spaces_count_in_word = 0;\n    let mut vowels_count_in_word\
    \ = 0;\n    let mut consonants_count_in_word = 0;\n    let mut words_count_in_\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: unknown character escape: `v`\n  --> /tmp/tmp2y4upeta.rs:24:106\n\
    \   |\n24 |     let mut words_count = s.chars().filter(|c| c == ' ' || c == '\\\
    t' || c == '\\n' || c == '\\r' || c == '\\v' || c == '\\f').count();\n   |   \
    \                                                                            \
    \                           ^ unknown character escape\n   |\n   = help: for more\
    \ information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n24 |     let mut words_count\
    \ = s.chars().filter(|c| c == ' ' || c == '\\t' || c == '\\n' || c == '\\r' ||\
    \ c == r\"\\v\" || c == '\\f').count();\n   |                                \
    \                                                                        ~~~~~\n\
    \nerror: unknown character escape: `f`\n  --> /tmp/tmp2y4upeta.rs:24:119\n   |\n\
    24 |     let mut words_count = s.chars().filter(|c| c == ' ' || c == '\\t' ||\
    \ c == '\\n' || c == '\\r' || c == '\\v' || c == '\\f').count();\n   |       \
    \                                                                            \
    \                                    ^ unknown character escape\n   |\n   = help:\
    \ for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n24 |     let mut words_count\
    \ = s.chars().filter(|c| c == ' ' || c == '\\t' || c == '\\n' || c == '\\r' ||\
    \ c == '\\v' || c == r\"\\f\").count();\n   |                                \
    \                                                                            \
    \         ~~~~~\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp2y4upeta.rs:52:28\n\
    \   |\n52 |     let mut words_count_in_\n   |                            ^ help:\
    \ add `;` here\n53 | }\n   | - unexpected token\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp2y4upeta.rs:18:51\n   |\n18 |     let mut\
    \ spaces_count = s.chars().filter(|c| c == ' ').count();\n   | "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as usize;\n    let mut i = 0;\n\
    \    while i < s.len() {\n        let mut j = i;\n        while j < s.len() &&\
    \ s.chars().any(|c| c == s.chars().nth(j)) {\n            j += 1\n        }\n\
    \        if j == s.len() {\n            list.push(s.to_string());\n          \
    \  i += 1;\n        } else {\n            i += j - i;\n        }\n    }\n    list\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg_c099mr.rs:19:53\n   |\n\
    19 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    if s.chars().all(|c| c.is_ascii_letter() || c.is_ascii_space()) {\n     \
    \       if s.len() >= n {\n                list.push(s.to_string());\n       \
    \     }\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpknbnfi1z.rs:17:32\n   |\n17 |         if s.chars().all(|c|\
    \ c.is_ascii_letter() || c.is_ascii_space()) {\n   |                         \
    \       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii`\n\nerror[E0599]: no method named `is_ascii_space` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpknbnfi1z.rs:17:55\n   |\n17 |   \
    \      if s.chars().all(|c| c.is_ascii_letter() || c.is_ascii_space()) {\n   |\
    \                                                       ^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpknbnfi1z.rs:18:27\n   |\n18 |             if s.len() >=\
    \ n {\n   |                           ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n18 |             if s.len() >= n.try_into().unwrap() {\n\
    \   |                            ++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ consonants = vec![];\n    let mut vowels = vec![];\n    let mut spaces = vec![];\n\
    \    let mut caps = vec![];\n    let mut lower = vec![];\n    let mut upper =\
    \ vec![];\n    let mut digits = vec![];\n    let mut punctuation = vec![];\n \
    \   let mut numbers = vec![];\n    let mut symbols = vec![];\n    let mut all_chars\
    \ = vec![];\n    let mut all_chars_set = vec![];\n    let mut all_chars_set =\
    \ vec![];\n    let mut all_chars_set = vec![];\n    let mut all_chars_set = vec![];\n\
    \    let mut all_chars_set = vec![];\n    let mut all_chars_set = vec![];\n  \
    \  let mut all_chars_set = vec![];\n    let mut all_chars_set = vec![];\n    let\
    \ mut all_chars_set = vec![];\n    let mut all_chars_set = vec![];\n    let mut\
    \ all_chars_set = vec![];\n    let mut all_chars_set = vec![];\n    let mut all_chars_set\
    \ = vec![];\n    let mut all_chars_set = vec![];\n    let mut all_chars_set =\
    \ vec![];\n    let mut all_chars_set = vec![];\n    let mut all_chars_set = vec![];\n\
    \    let mut all_chars_set = vec![];\n    let mut all_chars_set = vec![];\n  \
    \  let mut all_chars_set = vec![];\n    let mut all_chars_set = vec![];\n    let\
    \ mut all_chars_set = vec![];\n    let mut all_chars_set = vec![];\n    let mut\
    \ all_chars_set = vec![];\n    let mut all_chars_set = vec![];\n    let mut all_chars_set\
    \ = vec![];\n    let mut all_chars_set = vec![];\n    let mut all_chars_set =\
    \ vec![];\n    let mut all_chars_set = vec![];\n    let mut all_chars_set = vec![];\n\
    \    let mut all_chars_set = vec![];\n    let mut all_chars_set = vec![];\n  \
    \  let mut all_chars_set = vec![];\n    let mut all_chars_set = vec![];\n    let\
    \ mut all_chars_set = vec![];\n    let mut all_chars_set = vec![];\n    let mut\
    \ all_chars_\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpubdbrdzw.rs:61:23\n   |\n\
    61 |     let mut all_chars_\n   |                       ^ help: add `;` here\n\
    62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpubdbrdzw.rs:12:41\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as usize;\n    let mut i = 0;\n\
    \    while i < s.len() {\n        let mut j = i;\n        while j < s.len() &&\
    \ s.chars().all(|c| c == s.chars().nth(j)) {\n            j += 1\n        }\n\
    \        if j == s.len() {\n            result.push(s.to_string());\n        \
    \    i += 1;\n        } else {\n            let mut j = i;\n            while\
    \ j < s.len() && s.chars().all(|c| c != s.chars().nth(j)) {\n                j\
    \ += 1\n            }\n            if j == s.len() {\n                result.push(s.to_string());\n\
    \                i += 1;\n            } else {\n                let mut j = i;\n\
    \                while j < s.len() && s.chars().all(|c| c != s.chars().nth(j))\
    \ {\n                    j += 1\n                }\n                if j == s.len()\
    \ {\n                    result.push(s.to_string());\n                    i +=\
    \ 1;\n                } else {\n                    let mut j = i;\n         \
    \           while j < s.len() && s.chars().all(|c| c != s.chars().nth(j)) {\n\
    \                        j += 1\n                    }\n                    if\
    \ j == s.len() {\n                        result.push(s.to_string());\n      \
    \                  i += 1;\n                    } else {\n                   \
    \     let mut j = i;\n                        while j < s.len() && s.chars().all(|c|\
    \ c != s.chars().nth(j)) {\n                            j += 1\n             \
    \           }\n                        if j == s.len() {\n                   \
    \         result.push(s.to_string());\n                            i += 1;\n \
    \                       } else {\n                            let mut j = i;\n\
    \                            while j < s.len() && s.chars().all(|c| c != s.chars().nth(j))\
    \ {\n                                j += 1\n                            }\n \
    \                           if j == s.len() {\n                              \
    \  result.push(s.to_string());\n                                i += 1;\n    \
    \                        } else {\n                                let mut j =\
    \ i;\n                                while j < s.len() && s.chars().all(|c| c\
    \ != s.chars().nth(j)) {\n                                    j += 1\n       \
    \                         }\n                                if j == s.len() {\n\
    \                                    result.push(s.to_string());\n           \
    \                         i += 1;\n                                } else {\n\
    \                                    let mut j = i;\n                        \
    \            while j < s.len() && s.chars().all(|c| c != s.chars().nth(j)) {\n\
    \                                        j += 1\n                            \
    \        }\n                                    if j == s.len() {\n          \
    \                              result.push(s.to_string());\n                 \
    \                       i += 1;\n                                    } else {\n\
    \                                        let mut j = i;\n                    \
    \                    while j < s.len() && s.chars().all(|c| c != s.chars().nth\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpjikq211y.rs:95:3\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n17\
    \ |     while i < s.len() {\n   |                       - unclosed delimiter\n\
    ...\n25 |         } else {\n   |                - unclosed delimiter\n...\n33\
    \ |             } else {\n   |                    - unclosed delimiter\n...\n\
    41 |                 } else {\n   |                        - unclosed delimiter\n\
    ...\n49 |                     } else {\n   |                            - unclosed\
    \ delimiter\n...\n57 |                         } else {\n   |                \
    \                - unclosed delimiter\n...\n65 |                             }\
    \ else {\n   |                                    - unclosed delimiter\n...\n\
    73 |                                 } else {\n   |                          \
    \              - unclosed delimiter\n...\n81 |                               \
    \      } else {\n   |                                            - this delimiter\
    \ might not be properly closed...\n...\n84 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n95 | }\n   |   ^\n\nerror: mismatched closing\
    \ delimiter: `}`\n  --> /tmp/tmpjikq211y.rs:83:75\n   |\n12 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \                  - closing delimiter possibly meant for this\n...\n83 |    \
    \                                     while j < s.len() && s.chars().all(|c| c\
    \ != s.chars().nth\n   |                                                     \
    \                      ^ unclosed delimiter\n84 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpjikq211y.rs:84:1\n\
    \   |\n83 |                                           while j < s.len() && s.chars().all(|c|\
    \ c != s.chars().nth\n   |  _________________________________________-----_-\n\
    \   | |                                         |\n   | |                    \
    \                     while parsing the body of this `while` expression\n84"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[i] == s[j] {\n            j += 1\n        }\n        if j ==\
    \ s.len() {\n            list.push(s.to_string());\n            i += 1;\n    \
    \    } else {\n            if j - i == n {\n                list.push(s.to_string());\n\
    \                i += 1;\n            } else {\n                i += j - i;\n\
    \            }\n        }\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp13ngxyze.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[i] == s[j] {\n   |                \
    \              ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp13ngxyze.rs:17:38\n   |\n17 |         while j < s.len() && s[i]\
    \ == s[j] {\n   |                                      ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp13ngxyze.rs:24:25\n\
    \   |\n24 |             if j - i == n {\n   |                         ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n24 |             if j -\
    \ i == n.try_into().unwrap() {\n   |                          ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ consonants = vec![];\n    let mut vowels = vec![];\n    let mut spaces = vec![];\n\
    \    let mut letters = vec![];\n    let mut spaces_count = s.chars().filter(|c|\
    \ c == ' ').count();\n    let mut letters_count = s.chars().filter(|c| c >= 'a'\
    \ && c <= 'z').count();\n    let mut vowels_count = s.chars().filter(|c| c >=\
    \ 'A' && c <= 'Z').count();\n    let mut consonants_count = s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z').count();\n    let mut vowels_count_in_string\
    \ = s.chars().filter(|c| c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z').count();\n\
    \    let mut consonants_count_in_string = s.chars().filter(|c| c >= 'a' && c <=\
    \ 'z' || c >= 'A' && c <= 'Z').count();\n    let mut vowels_count_in_string_plus_spaces\
    \ = s.chars().filter(|c| c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c ==\
    \ ' ').count();\n    let mut consonants_count_in_string_plus_spaces = s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == ' ').count();\n    let\
    \ mut vowels_count_in_string_plus_spaces_and_letters = s.chars().filter(|c| c\
    \ >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c == ' ' || c >= 'a' && c <= 'z'\
    \ || c >= 'A' && c <= 'Z' || c == ' ').count();\n    let mut consonants_count_in_string_plus_spaces_and_letters\
    \ = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c ==\
    \ ' ' || c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == ' ').count();\n\
    \    let mut vowels_count_in_string_plus_spaces_and_letters_plus_spaces = s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c == ' ' || c >= '\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp7hxecgld.rs:28:160\n\
    \   |\n28 | ... c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c == ' ' || c\
    \ >= '\n   |                                                                 \
    \     ^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as usize;\n    while n > 0 {\n \
    \       let mut i = 0;\n        while i < s.len() {\n            if s.chars().any(|c|\
    \ c == ' ' || c == '\\t' || c == '\\n') {\n                i += 1;\n         \
    \       continue;\n            }\n            if s.chars().any(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                i += 1;\n \
    \               continue;\n            }\n            if s.chars().any(|c| c ==\
    \ 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                i +=\
    \ 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == 'b' || c == 'c' || c == 'd' || c == 'f' || c == 'g' || c == 'h' || c ==\
    \ 'j' || c == 'k' || c == 'l' || c == 'm' || c == 'n' || c == 'p' || c == 'q'\
    \ || c == 'r' || c == 's' || c == 't' || c == 'v' || c == 'w' || c == 'x' || c\
    \ == 'y' || c == 'z') {\n                i += 1;\n                continue;\n\
    \            }\n            if s.chars().any(|c| c == 'B' || c == 'C' || c ==\
    \ 'D' || c == 'F' || c == 'G' || c == 'H' || c == 'J' || c == 'K' || c == 'L'\
    \ || c == 'M' || c == 'N' || c == 'P' || c == 'Q' || c == 'R' || c == 'S' || c\
    \ == 'T' || c == 'V' || c == 'W' || c == 'X' || c == 'Y' || c == 'Z') {\n    \
    \            i += 1;\n                continue;\n            }\n            if\
    \ s.chars().any(|c| c == 'c' || c == 'd' || c == 'f' || c == 'g' || c == 'h' ||\
    \ c == 'j' || c == 'k' || c == 'l' || c == 'm' || c == 'n' || c == 'p' || c ==\
    \ 'q' || c == 'r' || c == 's' || c == 't' || c == 'v' || c == 'w' || c == 'x'\
    \ || c == 'y' || c == 'z') {\n                i += 1;\n                continue;\n\
    \            }\n            if s.chars().any(|c| c == 'C' || c == 'D' || c ==\
    \ 'F' || c == 'G' || c == 'H' || c == 'J' || c == 'K' || c == 'L' || c == 'M'\
    \ || c == 'N' || c == 'P' || c == 'Q' || c == 'R' || c == 'S' || \n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvr5csw7c.rs:55:3\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n16\
    \ |     while n > 0 {\n   |                 - unclosed delimiter\n17 |       \
    \  let mut i = 0;\n18 |         while i < s.len() {\n   |                    \
    \       - this delimiter might not be properly closed...\n...\n44 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n55 | }\n   |  \
    \ ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpvr5csw7c.rs:43:29\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - closing delimiter possibly meant\
    \ for this\n...\n43 |             if s.chars().any(|c| c == 'C' || c == 'D' ||\
    \ c == 'F' || c == 'G' || c == 'H' || c == 'J' || c == 'K' || c == 'L' || c ==\
    \ 'M'...\n   |                             ^ unclosed delimiter\n44 | }\n   |\
    \ ^ mismatched closing delimiter\n\nerror: expected expression, found `)`\n  -->\
    \ /tmp/tmpvr5csw7c.rs:44:1\n   |\n44 | }\n   | ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvr5csw7c.rs:16:5\n   |\n12 |   fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \        ----------- expected `Vec<String>` because of return type\n...\n16 |\
    \ /     while n > 0 {\n17 | |         let mut i = 0;\n18 | |         while i <\
    \ s.len() {\n19 | |             if s.chars().any(|c| c == ' ' || c == '\\t' ||\
    \ c == '\\n') {\n...  |\n54 | |     assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n55 | | }\n   | |__^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<String>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        if s.chars().all(|c| c.is_consonant()\
    \ && c != ' ') {\n            words.push(s.subslice(i, i + n));\n            i\
    \ += n;\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpooxcc0me.rs:16:32\n   |\n16 |         if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpooxcc0me.rs:17:26\n\
    \   |\n17 |             words.push(s.subslice(i, i + n));\n   |              \
    \            ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpooxcc0me.rs:17:42\n   |\n17 |             words.push(s.subslice(i,\
    \ i + n));\n   |                                          ^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpooxcc0me.rs:17:40\n\
    \   |\n17 |             words.push(s.subslice(i, i + n));\n   |              \
    \                          ^ no implementation for `usize + isize`\n   |\n   =\
    \ help: the trait `Add<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `Add<Rhs>`:\n             <&'a f32 as\
    \ Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n\
    \             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n    \
    \         <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n          \
    \   <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpooxcc0me.rs:18:18\n   |\n18 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmpooxcc0me.rs:18:15\n   |\n18 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as A"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut index = 0;\n    while index < s.len() {\n        let mut word = String::new();\n\
    \        let mut consonant = false;\n        while index < s.len() {\n       \
    \     if s[index] == ' ' {\n                consonant = false;\n             \
    \   index += 1;\n                continue;\n            }\n            if s[index]\
    \ == 'a' || s[index] == 'e' || s[index] == 'i' || s[index] == 'o' || s[index]\
    \ == 'u' {\n                consonant = true;\n                index += 1;\n \
    \               continue;\n            }\n            if s[index] == 'y' {\n \
    \               consonant = false;\n                index += 1;\n            \
    \    continue;\n            }\n            if s[index] == 's' || s[index] == 't'\
    \ || s[index] == 'd' || s[index] == 'g' || s[index] == 'b' {\n               \
    \ consonant = true;\n                index += 1;\n                continue;\n\
    \            }\n            if s[index] == 'p' || s[index] == 'f' || s[index]\
    \ == 'v' || s[index] == 'k' || s[index] == 'j' {\n                consonant =\
    \ true;\n                index += 1;\n                continue;\n            }\n\
    \            if s[index] == 'w' {\n                consonant = false;\n      \
    \          index += 1;\n                continue;\n            }\n           \
    \ if s[index] == 'c' {\n                consonant = true;\n                index\
    \ += 1;\n                continue;\n            }\n            if s[index] ==\
    \ 'k' || s[index] == 'q' || s[index] == 'j' || s[index] == 'x' {\n           \
    \     consonant = true;\n                index += 1;\n                continue;\n\
    \            }\n            if s[index] == 'm' {\n                consonant =\
    \ false;\n                index += 1;\n                continue;\n           \
    \ }\n            if s[index] == 'l' || s[index] == 'z' || s[index] == 'x' || s[index]\
    \ == 'z' {\n                consonant = true;\n                index += 1;\n \
    \               continue;\n            }\n            if s[index] == 'n' {\n \
    \               consonant = false;\n                index += 1;\n            \
    \    continue;\n            }\n            if s[index] == 'r' || s[index] == 'z'\
    \ || s[index] == 'z' || s[index] == 'z' || s[index] == 'z' {\n               \
    \ consonant = true;\n                index += 1;\n                continue;\n\
    \            }\n            if s[index] == 'p' || s[index] == 'p' || s[index]\
    \ == 'p' || s[index] == 'p' || s[index] == 'p' {\n                consonant =\
    \ true;\n                index += 1;\n                continue;\n            }\n\
    \            if s[index] == 'q' || s[index] == 'q' || s[index] == 'q' || s[index]\
    \ == 'q' || s[index] == 'q' || s[index] == 'q' {\n                consonant =\
    \ true;\n                index += 1;\n                continue;\n            }\n\
    \            if s[index] == 'a' || s[index] == '\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp9a6ozx1r.rs:89:47\n\
    \   |\n89 |             if s[index] == 'a' || s[index] == '\n   |            \
    \                                   ^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ consonants = vec![];\n    let mut vowels = vec![];\n    let mut spaces = vec![];\n\
    \    let mut letters = vec![];\n    let mut spaces_count = s.chars().filter(|c|\
    \ c == ' ').count();\n    let mut letters_count = s.chars().filter(|c| c >= 'a'\
    \ && c <= 'z' || c >= 'A' && c <= 'Z').count();\n    let mut vowels_count = s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count();\n    let mut consonants_count = s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == 'b' || c == 'c' || c ==\
    \ 'd' || c == 'f' || c == 'g' || c == 'h' || c == 'j' || c == 'k' || c == 'l'\
    \ || c == 'm' || c == 'n' || c == 'p' || c == 'q' || c == 'r' || c == 's' || c\
    \ == 't' || c == 'v' || c == 'w' || c == 'x' || c == 'y' || c == 'z').count();\n\
    \    let mut vowels_count_2 = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >=\
    \ 'A' && c <= 'Z' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count();\n\
    \    let mut consonants_count_2 = s.chars().filter(|c| c >= 'a' && c <= 'z' ||\
    \ c >= 'A' && c <= 'Z' || c == 'b' || c == 'c' || c == 'd' || c == 'f' || c ==\
    \ 'g' || c == 'h' || c == 'j' || c == 'k' || c == 'l' || c == 'm' || c == 'n'\
    \ || c == 'p' || c == 'q' || c == 'r' || c == 's' || c == 't' || c == 'v' || c\
    \ == 'w' || c == 'x' || c == 'y' || c == 'z').count();\n    let mut vowels_count_3\
    \ = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y').count();\n    let mut con\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg8aeiihx.rs:25:16\n   |\n\
    25 |     let mut con\n   |                ^ help: add `;` here\n26 | }\n   | -\
    \ unexpected token\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpg8aeiihx.rs:18:51\n\
    \   |\n18 |     let mut spaces_count = s.chars().filter(|c| c == ' ').count();\n\
    \   |                                                   ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpg8aeiihx.rs:19:55\n   |\n19 |  \
    \   let mut letters_count = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >=\
    \ 'A' && c <= 'Z').count();\n   |                                            \
    \           ^^^\n   |                                                       |\n\
    \   |                                                       expected `&char`,\
    \ found `char`\n   |                                                       help:\
    \ consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg8aeiihx.rs:19:67\n\
    \   |\n19 |     let mut letters_count = s.chars().filter(|c| c >= 'a' && c <=\
    \ 'z' || c >= 'A' && c <= 'Z').count();\n   |                                \
    \                                   ^^^\n   |                                \
    \                                   |\n   |                                  \
    \                                 expected `&char`, found `char`\n   |       \
    \                                                            help: consider borrowing\
    \ here: `&'z'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg8aeiihx.rs:19:79\n\
    \   |\n19 |     let mut letters_count = s.chars().filter(|c| c >= 'a' && c <=\
    \ 'z' || c >= 'A' && c <= 'Z').count();\n   |                                \
    \                                               ^^^\n   |                    \
    \                                                           |\n   |          \
    \                                                                     expected\
    \ `&char`, found `char`\n   |     "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() && s.chars().all(|c| c != ' ')\
    \ {\n            j += 1\n        }\n        if j == i {\n            list.push(s.clone());\n\
    \            i += 1;\n        } else {\n            i += j - i;\n        }\n \
    \   }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a little\
    \ lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a\
    \ little lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary\
    \ had a little lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\"\
    , \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a little\
    \ lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a\
    \ little lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary\
    \ had a little lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\"\
    ]`,\n right: `[\"little\"]`', /tmp/tmpf61misef.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] == ' ' {\n            j += 1\n        }\n        if j == i\
    \ {\n            list.push(s.to_string());\n            i += 1;\n        } else\
    \ {\n            i += 1;\n        }\n        while j < s.len() && s[j] != ' '\
    \ {\n            j += 1\n        }\n        if j == i {\n            list.push(s.to_string());\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n     \
    \   while j < s.len() && s[j] == ' ' {\n            j += 1\n        }\n      \
    \  if j == i {\n            list.push(s.to_string());\n            i += 1;\n \
    \       } else {\n            i += 1;\n        }\n        while j < s.len() &&\
    \ s[j] != ' ' {\n            j += 1\n        }\n        if j == i {\n        \
    \    list.push(s.to_string());\n            i += 1;\n        } else {\n      \
    \      i += 1;\n        }\n        while j < s.len() && s[j] == ' ' {\n      \
    \      j += 1\n        }\n        if j == i {\n            list.push(s.to_string());\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n     \
    \   while j < s.len() && s[j] != ' ' {\n            j += 1\n        }\n      \
    \  if j == i {\n            list.push(s.to_string());\n            i += 1;\n \
    \       } else {\n            i += 1;\n        }\n        while j < s.len() &&\
    \ s[j] == ' ' {\n            j += 1\n        }\n        if j == i {\n        \
    \    list.push(s.to_string());\n            i += 1;\n        } else {\n      \
    \      i += 1;\n        }\n        while j < s.len() && s[j] != ' ' {\n      \
    \      j += 1\n        }\n        if j == i {\n            list.push(s.to_string());\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n     \
    \   while j < s.len() && s[j] == ' ' {\n            j += 1\n        }\n      \
    \  if j == i {\n            list.push(s.to_string());\n            i += 1;\n \
    \       } else {\n            i += 1;\n        }\n        while j < s.len() &&\
    \ s[j] != ' ' {\n            j += 1\n        }\n        if j == i {\n        \
    \    list.push(s.to_string());\n            i += 1;\n        } else {\n      \
    \      i += 1;\n        }\n        while j < s.len() && s[j] == ' ' {\n      \
    \      j += 1\n        }\n        if j == i {\n            list.push(s.to_string());\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n     \
    \   while j < s.len() && s[j] != ' ' {\n            j += 1\n        }\n      \
    \  if j == i {\n            \n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpuq547n_v.rs:132:3\n\
    \    |\n12  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    15  |     while i < s.len() {\n    |                       - unclosed delimiter\n\
    ...\n119 |         if j == i {\n    |                   - this delimiter might\
    \ not be properly closed...\n120 |             \n121 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n132 | }\n    |   ^\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuq547n_v.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpuq547n_v.rs:26:30\n   |\n26 |         while j < s.len() && s[j]\
    \ != ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpuq547n_v.rs:35:30\n   |\n35 |         while j < s.len("
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut index = 0;\n    while index < s.len() {\n        let mut count = 0;\n  \
    \      let mut char = s.chars().nth(index).unwrap();\n        while char == '\
    \ ' || char == '\\t' || char == '\\n' || char == '\\r' || char == '\\0' {\n  \
    \          count += 1;\n            char = s.chars().nth(index + count).unwrap();\n\
    \        }\n        if count == n {\n            list.push(s.split_whitespace().nth(index).unwrap());\n\
    \            index += 1;\n        }\n        index += 1;\n    }\n    list\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk3015wpa.rs:22:21\n   |\n\
    22 |         if count == n {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n22 |         if count == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk3015wpa.rs:28:5\n   |\n12 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n28 |     list\n   |    \
    \ ^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<&str>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    let mut\
    \ s = String::from(s);\n    let mut n = n as usize;\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        if s.chars().all(|c| c.is_consonant() && c != ' ') {\n\
    \            result.push(s.split_whitespace()[i]);\n            i += 1;\n    \
    \    }\n        if i == s.len() {\n            break;\n        }\n        if s.chars().all(|c|\
    \ c.is_consonant() && c == ' ') {\n            i += 1;\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpybqexqnk.rs:18:32\n   |\n18 |         if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmpybqexqnk.rs:19:25\n   |\n19 |         \
    \    result.push(s.split_whitespace()[i]);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0599]: no method named `is_consonant` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpybqexqnk.rs:25:32\n   |\n25 |         if s.chars().all(|c|\
    \ c.is_consonant() && c == ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0599, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut index = 0;\n    while index < s.len() {\n        let mut found = false;\n\
    \        for c in s.chars() {\n            if c == ' ' {\n                found\
    \ = true;\n                break;\n            }\n            if c.is_vowel()\
    \ {\n                found = true;\n                break;\n            }\n  \
    \      }\n        if found {\n            list.push(s.split_whitespace()[index..]);\n\
    \            index += 1;\n        }\n    }\n    list\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp_u8mtxpo.rs:22:18\n   |\n22 |             if c.is_vowel()\
    \ {\n   |                  ^^^^^^^^ method not found in `char`\n\nerror[E0608]:\
    \ cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmp_u8mtxpo.rs:28:23\n\
    \   |\n28 |             list.push(s.split_whitespace()[index..]);\n   |      \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut consonants = Vec::new();\n    let mut vowels = Vec::new();\n    let mut\
    \ spaces = Vec::new();\n    let mut letters = Vec::new();\n    let mut spaces_count\
    \ = s.chars().filter(|c| c == ' ').count();\n    let mut vowels_count = s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count();\n    let\
    \ mut consonants_count = s.chars().filter(|c| c == 'b' || c == 'c' || c == 'd'\
    \ || c == 'f' || c == 'g' || c == 'h' || c == 'j' || c == 'k' || c == 'l' || c\
    \ == 'm' || c == 'n' || c == 'p' || c == 'q' || c == 'r' || c == 's' || c == 't'\
    \ || c == 'v' || c == 'w' || c == 'x' || c == 'y').count();\n    let mut letters_count\
    \ = s.chars().filter(|c| c == 'A' || c == 'B' || c == 'C' || c == 'D' || c ==\
    \ 'E' || c == 'F' || c == 'G' || c == 'H' || c == 'I' || c == 'J' || c == 'K'\
    \ || c == 'L' || c == 'M' || c == 'N' || c == 'P' || c == 'Q' || c == 'R' || c\
    \ == 'S' || c == 'T' || c == 'V' || c == 'W' || c == 'X' || c == 'Y').count();\n\
    \    let mut spaces_count = s.chars().filter(|c| c == ' ').count();\n    let mut\
    \ vowels_count = s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count();\n    let mut consonants_count = s.chars().filter(|c|\
    \ c == 'b' || c == 'c' || c == 'd' || c == 'f' || c == 'g' || c == 'h' || c ==\
    \ 'j' || c == 'k' || c == 'l' || c == 'm' || c == 'n' || c == 'p' || c == 'q'\
    \ || c == 'r' || c == 's' || c == 't' || c == 'v' || c == 'w' || c == 'x' || c\
    \ == 'y').count();\n    let mut letters_count = s.chars().filter(|c| c == 'A'\
    \ || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' || c == 'G' || c\
    \ == 'H' || c == '\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpvcggdqg2.rs:25:151\n\
    \   |\n25 | ... c == 'D' || c == 'E' || c == 'F' || c == 'G' || c == 'H' || c\
    \ == '\n   |                                                                 \
    \     ^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    if s.chars().all(|c| c.is_consonant() && c != ' ') {\n            list.push(s.subslice(i,\
    \ i + n));\n            i += n;\n        }\n        i += 1;\n    }\n    list\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp3hnonfww.rs:17:32\n   |\n17 |         if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp3hnonfww.rs:18:25\n\
    \   |\n18 |             list.push(s.subslice(i, i + n));\n   |               \
    \          ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3hnonfww.rs:18:41\n   |\n18 |             list.push(s.subslice(i,\
    \ i + n));\n   |                                         ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmp3hnonfww.rs:18:39\n\
    \   |\n18 |             list.push(s.subslice(i, i + n));\n   |               \
    \                        ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3hnonfww.rs:19:18\n   |\n19 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmp3hnonfww.rs:19:15\n   |\n19 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssi"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n;\n    while n != 0 {\n        if\
    \ s.contains(&consonants[n % consonants.len()]) {\n            list.push(s.clone());\n\
    \        }\n        n /= consonants.len();\n    }\n    list\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `consonants` in this scope\n  --> /tmp/tmpafa9v_og.rs:17:24\n\
    \   |\n17 |         if s.contains(&consonants[n % consonants.len()]) {\n   | \
    \                       ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `consonants` in this scope\n  --> /tmp/tmpafa9v_og.rs:17:39\n   |\n\
    17 |         if s.contains(&consonants[n % consonants.len()]) {\n   |        \
    \                               ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `consonants` in this scope\n  --> /tmp/tmpafa9v_og.rs:20:14\n\
    \   |\n20 |         n /= consonants.len();\n   |              ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as usize;\n    let mut i = 0;\n\
    \    while i < s.len() {\n        if s.chars().any(|c| c.is_consonant() && c !=\
    \ ' ') {\n            result.push(s.subslice(i, i + n));\n            i += n;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpydep_9bf.rs:18:32\n   |\n18 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpydep_9bf.rs:19:27\n\
    \   |\n19 |             result.push(s.subslice(i, i + n));\n   |             \
    \              ^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    if s.chars().any(|c| c != ' ') {\n            list.push(s.to_string());\n\
    \            i += 1;\n        }\n        if i == s.len() {\n            break;\n\
    \        }\n        if s.chars().any(|c| c == ' ') {\n            i += 1;\n  \
    \      }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a little\
    \ lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a\
    \ little lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary\
    \ had a little lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\"\
    ]`,\n right: `[\"little\"]`', /tmp/tmpa3ptkkcf.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        if s.chars().all(|c| c.is_consonant()\
    \ && c != ' ') {\n            words.push(&s[i..i + n]);\n            i += n;\n\
    \        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp8icvjfxb.rs:16:32\n   |\n16 |         if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8icvjfxb.rs:17:34\n\
    \   |\n17 |             words.push(&s[i..i + n]);\n   |                      \
    \            ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add `isize`\
    \ to `usize`\n  --> /tmp/tmp8icvjfxb.rs:17:32\n   |\n17 |             words.push(&s[i..i\
    \ + n]);\n   |                                ^ no implementation for `usize +\
    \ isize`\n   |\n   = help: the trait `Add<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Add<Rhs>`:\n          \
    \   <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a\
    \ i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32\
    \ as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n\
    \             <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8icvjfxb.rs:18:18\n   |\n18 |             i\
    \ += n;\n   |                  ^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8icvjfxb.rs:21:5\n   |\n12 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \      ----------- expected `Vec<String>` because of return type\n...\n21 |  \
    \   words\n   |     ^^^^^ expected struct `String`, found `&str`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\nerror[E0277]:\
    \ cannot add-assign `isize` to `usize`\n  --> /tmp/tmp8icvjfxb.rs:18:15\n   |\n\
    18 |             i += n;\n   |               ^^ no implementation for `usize +=\
    \ isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented for\
    \ `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as A"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == s.chars().nth(j)) {\n                j += 1;\n            } else {\n  \
    \              break;\n            }\n        }\n        if j == s.len() {\n \
    \           list.push(s.to_string());\n            i += 1;\n        } else {\n\
    \            i += j - i;\n        }\n    }\n    list\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps6h4wwj0.rs:19:39\n   |\n\
    19 |             if s.chars().any(|c| c == s.chars().nth(j)) {\n   |         \
    \                              ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = 0;\n        while j < s.len()\
    \ {\n            if s[i] == s[j] {\n                j += 1;\n            } else\
    \ {\n                break;\n            }\n        }\n        if j == n {\n \
    \           words.push(s.to_string());\n            i += 1;\n        }\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmph6jxfs2g.rs:18:16\n\
    \   |\n18 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmph6jxfs2g.rs:18:24\n   |\n18 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph6jxfs2g.rs:24:17\n   |\n24 |         if j ==\
    \ n {\n   |                 ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n24 |         if j == n.try_into().unwrap() {\n   |              \
    \    ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    while s.len() > 0 {\n        let mut i = 0;\n\
    \        let mut j = s.len();\n        while i < j {\n            if s[i] == '\
    \ ' {\n                i += 1;\n                j -= 1;\n            } else {\n\
    \                i += 1;\n            }\n        }\n        let mut i = 0;\n \
    \       let mut j = s.len();\n        while i < j {\n            if s[i] == '\
    \ ' {\n                i += 1;\n                j -= 1;\n            } else {\n\
    \                i += 1;\n            }\n        }\n        if n == 0 {\n    \
    \        list.push(s.clone());\n        } else {\n            let mut i = 0;\n\
    \            let mut j = s.len();\n            while i < j {\n               \
    \ if s[i] == ' ' {\n                    i += 1;\n                    j -= 1;\n\
    \                } else {\n                    i += 1;\n                }\n  \
    \          }\n            list.push(s.clone());\n        }\n        s = String::from(&s[..i]);\n\
    \    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0bssl_px.rs:19:16\n\
    \   |\n19 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0bssl_px.rs:29:16\n   |\n29 |             if s[i] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0bssl_px.rs:42:20\n   |\n42 |                 if s[i] == ' ' {\n\
    \   |                    ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 3 previ"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n;\n    while n != 0 {\n        if\
    \ s.chars().all(|c| c.is_consonant()) {\n            result.push(s.clone());\n\
    \        }\n        n -= 1;\n        s = s.chars().filter(|c| !c.is_consonant()).collect::<String>();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpap4cd4c2.rs:17:32\n   |\n17 |         if s.chars().all(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_consonant` found for\
    \ reference `&char` in the current scope\n  --> /tmp/tmpap4cd4c2.rs:21:37\n  \
    \ |\n21 |         s = s.chars().filter(|c| !c.is_consonant()).collect::<String>();\n\
    \   |                                     ^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut consonants = Vec::new();\n    let mut vowels = Vec::new();\n    let mut\
    \ vowels_count = Vec::new();\n    let mut vowels_count_index = Vec::new();\n \
    \   let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index =\
    \ Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt_6x1coy.rs:56:11\n   |\n\
    56 |     let mu\n   |           ^ help: add `;` here\n57 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_6x1coy.rs:12:41\n \
    \  |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == s.chars().nth(j)) {\n                j += 1;\n            } else {\n  \
    \              break;\n            }\n        }\n        if j == s.len() {\n \
    \           list.push(s.to_string());\n            i += 1;\n        } else {\n\
    \            i += j - i;\n        }\n    }\n    list\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpamoo610f.rs:19:39\n   |\n\
    19 |             if s.chars().any(|c| c == s.chars().nth(j)) {\n   |         \
    \                              ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == s.chars().nth(j)) {\n                j += 1;\n            } else {\n  \
    \              break;\n            }\n        }\n        if j == s.len() {\n \
    \           list.push(s.to_string());\n            i += 1;\n        } else {\n\
    \            i += j - i;\n        }\n    }\n    list\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp181yc0oc.rs:19:39\n   |\n\
    19 |             if s.chars().any(|c| c == s.chars().nth(j)) {\n   |         \
    \                              ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    let mut\
    \ s = String::from(s);\n    let mut n = n as usize;\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        let mut j = i;\n        while j < s.len() {\n       \
    \     if s[i] == s[j] {\n                j += 1;\n            } else {\n     \
    \           break;\n            }\n        }\n        if j == s.len() {\n    \
    \        result.push(s.to_owned());\n            i += 1;\n        } else {\n \
    \           i += j - i;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpo5ze636u.rs:20:16\n\
    \   |\n20 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpo5ze636u.rs:20:24\n   |\n20 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut consonants = Vec::new();\n    let mut vowels = Vec::new();\n    let mut\
    \ vowels_count = Vec::new();\n    let mut vowels_count_index = Vec::new();\n \
    \   let mut vowels_count_index_count = Vec::new();\n    let mut vowels_count_index_count_index\
    \ = Vec::new();\n    let mut vowels_count_index_count_index_count = Vec::new();\n\
    \    let mut vowels_count_index_count_index_count_index = Vec::new();\n    let\
    \ mut vowels_count_index_count_index_count_index_count = Vec::new();\n    let\
    \ mut vowels_count_index_count_index_count_index_count_index = Vec::new();\n \
    \   let mut vowels_count_index_count_index_count_index_count_index_count = Vec::new();\n\
    \    let mut vowels_count_index_count_index_count_index_count_index_count_index\
    \ = Vec::new();\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count\
    \ = Vec::new();\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = Vec::new();\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = Vec::new();\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = Vec::new();\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = Vec::new();\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = Vec::new();\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = Vec::new();\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = Vec::new();\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = Vec::new();\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = Vec::new();\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = Vec::new();\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = Vec::new();\n    let mut vowels_count_index_count_\n}\n\nfn main() {\n   \
    \ let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgzcfv3kg.rs:38:38\n   |\n\
    38 |     let mut vowels_count_index_count_\n   |                             \
    \         ^ help: add `;` here\n39 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgzcfv3kg.rs:12:41\n   |\n12 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |    ------------                   \
    \      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ consonants = vec![];\n    let mut vowels = vec![];\n    let mut spaces = vec![];\n\
    \    let mut non_spaces = vec![];\n    let mut non_letters = vec![];\n    let\
    \ mut non_letters_spaces = vec![];\n    let mut non_letters_spaces_vowels = vec![];\n\
    \    let mut non_letters_spaces_consonants = vec![];\n    let mut non_letters_spaces_vowels_consonants\
    \ = vec![];\n    let mut non_letters_spaces_vowels_consonants_spaces = vec![];\n\
    \    let mut non_letters_spaces_consonants_spaces = vec![];\n    let mut non_letters_spaces_vowels_consonants_spaces_vowels\
    \ = vec![];\n    let mut non_letters_spaces_consonants_spaces_vowels = vec![];\n\
    \    let mut non_letters_spaces_vowels_consonants_spaces_vowels_consonants = vec![];\n\
    \    let mut non_letters_spaces_consonants_spaces_vowels_consonants = vec![];\n\
    \    let mut non_letters_spaces_vowels_consonants_spaces_vowels_consonants_spaces\
    \ = vec![];\n    let mut non_letters_spaces_consonants_spaces_vowels_consonants_spaces_vowels\
    \ = vec![];\n    let mut non_letters_spaces_consonants_spaces_vowels_consonants_spaces_vowels_consonants\
    \ = vec![];\n    let mut non_letters_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels\
    \ = vec![];\n    let mut non_letters_spaces_consonants_spaces_vowels_consonants_spaces_vowels_consonants_spaces\
    \ = vec![];\n    let mut non_letters_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels_consonants\
    \ = vec![];\n    let mut non_letters_spaces_consonants_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels\
    \ = vec![];\n    let mut non_letters_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels\
    \ = vec![];\n    let mut non_letter\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp39aq1vf6.rs:37:23\n   |\n\
    37 |     let mut non_letter\n   |                       ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp39aq1vf6.rs:12:41\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    while s.len() > 0 {\n        let mut i = 0;\n\
    \        let mut j = 0;\n        let mut c = s.chars().nth(i);\n        while\
    \ c != ' ' {\n            if c == ' ' {\n                j = 0;\n            }\n\
    \            i += 1;\n            c = s.chars().nth(i);\n        }\n        if\
    \ j == n {\n            list.push(s.clone());\n        }\n        s = s.chars().nth(i\
    \ + 1).unwrap();\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5neeupzl.rs:19:20\n   |\n\
    19 |         while c != ' ' {\n   |                    ^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<char>`\n              found\
    \ type `char`\nhelp: try wrapping the expression in `Some`\n   |\n19 |       \
    \  while c != Some(' ') {\n   |                    +++++   +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5neeupzl.rs:20:21\n   |\n20 |             if\
    \ c == ' ' {\n   |                     ^^^ expected enum `Option`, found `char`\n\
    \   |\n   = note: expected enum `Option<char>`\n              found type `char`\n\
    help: try wrapping the expression in `Some`\n   |\n20 |             if c == Some('\
    \ ') {\n   |                     +++++   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5neeupzl.rs:29:13\n   |\n14 |     let mut s = String::from(s);\n\
    \   |                 --------------- expected due to this value\n...\n29 |  \
    \       s = s.chars().nth(i + 1).unwrap();\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |             |\n  \
    \ |             expected struct `String`, found `char`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut consonants = Vec::new();\n    let mut vowels = Vec::new();\n    let mut\
    \ spaces = Vec::new();\n    let mut words = Vec::new();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut k = 0;\n    let mut l = s.len();\n    while i\
    \ < l {\n        if s[i] == ' ' {\n            spaces.push(s.chars().nth(i).unwrap());\n\
    \            i += 1;\n        } else {\n            consonants.push(s.chars().nth(i).unwrap());\n\
    \            i += 1;\n        }\n    }\n    while j < n {\n        if consonants.len()\
    \ == 0 {\n            break;\n        }\n        if consonants.len() == n {\n\
    \            list.push(consonants.clone());\n            consonants.clear();\n\
    \            i += 1;\n        } else {\n            consonants.push(s.chars().nth(i).unwrap());\n\
    \            i += 1;\n        }\n    }\n    while k < n {\n        if vowels.len()\
    \ == 0 {\n            break;\n        }\n        if vowels.len() == n {\n    \
    \        list.push(vowels.clone());\n            vowels.clear();\n           \
    \ i += 1;\n        } else {\n            vowels.push(s.chars().nth(i).unwrap());\n\
    \            i += 1;\n        }\n    }\n    while i < l {\n        if spaces.len()\
    \ == 0 {\n            break;\n        }\n        if spaces.len() == n {\n    \
    \        list.push(spaces.clone());\n            spaces.clear();\n           \
    \ i += 1;\n        } else {\n            spaces.push(s.chars().nth(i).unwrap());\n\
    \            i += 1;\n        }\n    }\n    while i < l {\n        if vowels.len()\
    \ == 0 {\n            break;\n        }\n        if vowels.len() == n {\n    \
    \        list.push(vowels.clone());\n            vowels.clear();\n           \
    \ i += 1;\n        } else {\n            vowels.push(s.chars().nth(i).unwrap());\n\
    \            i += 1;\n        }\n    }\n    while i < l {\n        if consonants.len()\
    \ == 0 {\n            break;\n        }\n        if consonants.len() == n {\n\
    \            list.push(consonants.clone());\n            consonants.clear();\n\
    \            i += 1;\n        } else {\n            consonants.push(s.chars().nth(i).unwrap());\n\
    \            i += 1;\n        }\n    }\n    while i < l {\n        if spaces.len()\
    \ == 0 {\n            break;\n        }\n        if spaces.len() == n {\n    \
    \        list.push(spaces.clone());\n            spaces.clear();\n           \
    \ i += 1;\n        } else {\n            spaces.push(s.chars().nth\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpz_4t6845.rs:117:3\n\
    \    |\n12  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    96  |     while i < l {\n    |                 - unclosed delimiter\n...\n104\
    \ |         } else {\n    |                - this delimiter might not be properly\
    \ closed...\n105 |             spaces.push(s.chars().nth\n106 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n117 | }\n    |   ^\n\n\
    error: mismatched closing delimiter: `}`\n   --> /tmp/tmpz_4t6845.rs:105:24\n\
    \    |\n12  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - closing delimiter possibly\
    \ meant for this\n...\n105 |             spaces.push(s.chars().nth\n    |    \
    \                    ^ unclosed delimiter\n106 | }\n    | ^ mismatched closing\
    \ delimiter\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpz_4t6845.rs:23:12\n   |\n23 |         if s[i] == ' ' {\n   |  \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz_4t6845.rs:35:32\n\
    \   |\n35 |         if consonants.len() == n {\n   |                         \
    \       ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n35 |      \
    \   if consonants.len() == n.try_into().unwrap() {\n   |                     \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz_4t6845.rs:48:28\n\
    \   |\n4"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == ' ') {\n                break;\n            }\n            if s.chars().any(|c|\
    \ !c.is_ascii()) {\n                break;\n            }\n            if s.chars().any(|c|\
    \ c.is_ascii() && c != ' ') {\n                j += 1;\n                continue;\n\
    \            }\n            if s.chars().any(|c| c.is_ascii() && c == ' ') {\n\
    \                j += 1;\n                continue;\n            }\n         \
    \   if s.chars().any(|c| c.is_ascii() && c != ' ') {\n                j += 1;\n\
    \                continue;\n            }\n            if s.chars().any(|c| c.is_ascii()\
    \ && c == ' ') {\n                j += 1;\n                continue;\n       \
    \     }\n            if s.chars().any(|c| c.is_ascii() && c != ' ') {\n      \
    \          j += 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c.is_ascii() && c == ' ') {\n                j += 1;\n                continue;\n\
    \            }\n            if s.chars().any(|c| c.is_ascii() && c != ' ') {\n\
    \                j += 1;\n                continue;\n            }\n         \
    \   if s.chars().any(|c| c.is_ascii() && c != ' ') {\n                j += 1;\n\
    \                continue;\n            }\n            if s.chars().any(|c| c.is_ascii()\
    \ && c != ' ') {\n                j += 1;\n                continue;\n       \
    \     }\n            if s.chars().any(|c| c.is_ascii() && c != ' ') {\n      \
    \          j += 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c.is_ascii() && c != ' ') {\n                j += 1;\n                continue;\n\
    \            }\n            if s.chars().any(|c| c.is_ascii() && c != ' ') {\n\
    \                j += 1;\n                continue;\n            }\n         \
    \   if s.chars().any(|c| c.is_ascii() && c != ' ') {\n                j += 1;\n\
    \                continue;\n            }\n            if s.chars().any(|c| c.is_ascii()\
    \ && c != ' ') {\n                j += 1;\n                continue;\n       \
    \     }\n            if s.chars().any(|c| c.is_ascii() && c != ' ') {\n      \
    \          j += 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c.is_ascii() && c != ' ') {\n                j += 1;\n                continue;\n\
    \            }\n            if s.chars().any(|c| \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpib8wgfs9.rs:101:3\n\
    \    |\n12  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    16  |     while i < s.len() {\n    |                       - unclosed delimiter\n\
    17  |         let mut j = i;\n18  |         while j < s.len() {\n    |       \
    \                    - this delimiter might not be properly closed...\n...\n90\
    \  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    101 | }\n    |   ^\n\nerror: expected expression, found `)`\n  --> /tmp/tmpib8wgfs9.rs:90:1\n\
    \   |\n90 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpib8wgfs9.rs:89:29\n   |\n12 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                           \
    \          - closing delimiter possibly meant for this\n...\n89 |            \
    \ if s.chars().any(|c| \n   |                             ^ unclosed delimiter\n\
    90 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n\
    \   --> /tmp/tmpib8wgfs9.rs:16:5\n    |\n12  |   fn select_words(s: String, n:\
    \ isize) -> Vec<String> {\n    |                                           -----------\
    \ expected `Vec<String>` because of return type\n...\n16  | /     while i < s.len()\
    \ {\n17  | |         let mut j = i;\n18  | |         while j < s.len() {\n19 \
    \ | |             if s.chars().any(|c| c == ' ') {\n...   |\n100 | |     assert_eq!(candidate(String::from(\"\
    a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n101 | | }\n    | |__^ expected struct `Vec`, found\
    \ `()`\n    |\n    = note: expected struct `Vec<String>`\n            found unit\
    \ type `()`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] == ' ' {\n            j += 1\n        }\n        if j == i\
    \ {\n            list.push(s.to_string());\n            i += 1;\n        } else\
    \ {\n            let mut count = 0;\n            while j < s.len() {\n       \
    \         if s[j] == s[i] {\n                    count += 1;\n               \
    \     j += 1;\n                } else {\n                    break;\n        \
    \        }\n            }\n            if count == n {\n                list.push(s.to_string());\n\
    \                i += 1;\n            }\n        }\n    }\n    list\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpe_0nvg3d.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpe_0nvg3d.rs:26:20\n   |\n26 |                 if s[j] == s[i] {\n\
    \   |                    ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpe_0nvg3d.rs:26:28\n\
    \   |\n26 |                 if s[j] == s[i] {\n   |                          \
    \  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <st"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s.chars().all(|c| c != s.chars().nth(j)) {\n            j += 1\n\
    \        }\n        if j == i {\n            list.push(s.to_string());\n     \
    \       i += 1;\n        } else {\n            i += j - i;\n        }\n    }\n\
    \    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpppfg6mg1.rs:17:53\n   |\n\
    17 |         while j < s.len() && s.chars().all(|c| c != s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as isize;\n    while n != 0 {\n\
    \        if s.chars().any(|c| c.is_consonant()) {\n            list.push(s.clone());\n\
    \        }\n        n -= 1;\n        s = s.chars().filter(|c| !c.is_consonant()).collect::<String>();\n\
    \    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmporfcqb93.rs:17:32\n   |\n17 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_consonant` found for\
    \ reference `&char` in the current scope\n  --> /tmp/tmporfcqb93.rs:21:37\n  \
    \ |\n21 |         s = s.chars().filter(|c| !c.is_consonant()).collect::<String>();\n\
    \   |                                     ^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] == ' ' {\n            j += 1\n        }\n        if j == i\
    \ {\n            list.push(s.to_string());\n            i += 1;\n        } else\
    \ {\n            let mut k = j;\n            while k < s.len() && s[k] != ' '\
    \ {\n                k += 1\n            }\n            if k == j {\n        \
    \        list.push(s.to_string());\n                i += 1;\n            } else\
    \ {\n                while j < s.len() && s[k] == ' ' {\n                    j\
    \ += 1\n                }\n                let mut k = j;\n                while\
    \ k < s.len() && s[k] != ' ' {\n                    k += 1\n                }\n\
    \                list.push(s.to_string());\n                i += 1;\n        \
    \    }\n        }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmstf3lqa.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmstf3lqa.rs:25:34\n   |\n25 |             while k < s.len() &&\
    \ s[k] != ' ' {\n   |                                  ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmstf3lqa.rs:32:38\n   |\n32 |                 while j < s.len()\
    \ && s[k] == ' ' {\n   |                                      ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <Str"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    if s.chars().any(|c| c.is_consonant() && c != ' ') {\n            list.push(s.subslice(i,\
    \ i + n));\n            i += n;\n        }\n    }\n    list\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp8hptexku.rs:17:32\n   |\n17 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp8hptexku.rs:18:25\n\
    \   |\n18 |             list.push(s.subslice(i, i + n));\n   |               \
    \          ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8hptexku.rs:18:41\n   |\n18 |             list.push(s.subslice(i,\
    \ i + n));\n   |                                         ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmp8hptexku.rs:18:39\n\
    \   |\n18 |             list.push(s.subslice(i, i + n));\n   |               \
    \                        ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8hptexku.rs:19:18\n   |\n19 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmp8hptexku.rs:19:15\n   |\n19 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssi"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    let mut\
    \ s = String::from(s);\n    let mut n = n as isize;\n    while n > 0 {\n     \
    \   let mut pos = 0;\n        while pos < s.len() {\n            let c = s[pos];\n\
    \            if c != ' ' {\n                result.push(s.to_owned());\n     \
    \           break;\n            }\n            pos += 1;\n        }\n        n\
    \ -= 1;\n        s = s.split_whitespace().collect();\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp65tq5n6f.rs:19:21\n\
    \   |\n19 |             let c = s[pos];\n   |                     ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s[j].is_ascii_letter() {\n            j = j + 1;\n        }\n        if j\
    \ == i {\n            break;\n        }\n        let mut word = String::new();\n\
    \        while j < s.len() && s[j].is_ascii_letter() {\n            word.push(s[j]);\n\
    \            j = j + 1;\n        }\n        if word.len() == n {\n           \
    \ words.push(word);\n        }\n        i = j;\n    }\n    words\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv_3qz_jl.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv_3qz_jl.rs:24:30\n\
    \   |\n24 |         while j < s.len() && s[j].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv_3qz_jl.rs:25:23\n\
    \   |\n25 |             word.push(s[j]);\n   |                       ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == s.chars().nth(j)) {\n                j += 1;\n            } else {\n  \
    \              break;\n            }\n        }\n        if j == s.len() {\n \
    \           list.push(s.to_string());\n            i += 1;\n        } else {\n\
    \            i += j - i;\n        }\n    }\n    list\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqytkidp8.rs:19:39\n   |\n\
    19 |             if s.chars().any(|c| c == s.chars().nth(j)) {\n   |         \
    \                              ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    let mut\
    \ s = String::from(s);\n    let mut n = n as usize;\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        if s.chars().any(|c| c != ' ' && c != '\\t' && c != '\\\
    n') {\n            if s.chars().all(|c| c != ' ' && c != '\\t' && c != '\\n')\
    \ {\n                if s.chars().count(|c| c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u') {\n                    if s.chars().count(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                       \
    \ if s.chars().count(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u') {\n                            if s.chars().count(|c| c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u') {\n                               \
    \ if s.chars().count(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u') {\n                                    if s.chars().count(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                       \
    \                 if s.chars().count(|c| c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u') {\n                                            if s.chars().count(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n              \
    \                                  if s.chars().count(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n                                   \
    \                 if s.chars().count(|c| c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u') {\n                                                    \
    \    if s.chars().count(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n                                                            if s.chars().count(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n              \
    \                                                  if s.chars().count(|c| c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                   \
    \                                                 if s.chars().count(|c| c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                   \
    \                                                     if s.chars().count(|c| c\
    \ == 'a' || c == 'e' || \n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpyug19drm.rs:46:3\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n17\
    \ |     while i < s.len() {\n   |                       - unclosed delimiter\n\
    18 |         if s.chars().any(|c| c != ' ' && c != '\\t' && c != '\\n') {\n  \
    \ |                                                                  - unclosed\
    \ delimiter\n19 |             if s.chars().all(|c| c != ' ' && c != '\\t' && c\
    \ != '\\n') {\n   |                                                          \
    \            - unclosed delimiter\n20 |                 if s.chars().count(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n   |          \
    \                                                                            \
    \            - unclosed delimiter\n21 |                     if s.chars().count(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n   |          \
    \                                                                            \
    \                - unclosed delimiter\n22 |                         if s.chars().count(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n   |          \
    \                                                                            \
    \                    - unclosed delimiter\n23 |                             if\
    \ s.chars().count(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n   |                                                                    \
    \                                          - unclosed delimiter\n24 |        \
    \                         if s.chars().count(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u') {\n   |                                       \
    \                                                                           -\
    \ unclosed delimiter\n25 |                                     if s.chars().count(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n   |          \
    \                                                           "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut consonants = Vec::new();\n    let mut vowels = Vec::new();\n    let mut\
    \ vowels_count = Vec::new();\n    let mut vowels_count_index = Vec::new();\n \
    \   let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index =\
    \ Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0g3wkodj.rs:56:11\n   |\n\
    56 |     let mu\n   |           ^ help: add `;` here\n57 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0g3wkodj.rs:12:41\n \
    \  |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == s.chars().nth(j).unwrap()) {\n                j += 1;\n            } else\
    \ {\n                break;\n            }\n        }\n        if j == s.len()\
    \ {\n            list.push(s.to_string());\n            i += 1;\n        } else\
    \ {\n            i += j - i;\n        }\n    }\n    list\n}\n\nfn main() {\n \
    \   let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a little\
    \ lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a\
    \ little lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary\
    \ had a little lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\"\
    , \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a little\
    \ lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a\
    \ little lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary\
    \ had a little lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\"\
    ]`,\n right: `[\"little\"]`', /tmp/tmpdubvpdfm.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] == ' ' {\n            j += 1\n        }\n        let mut k\
    \ = j;\n        while k < s.len() && s[k] != ' ' {\n            k += 1\n     \
    \   }\n        if k == j {\n            list.push(s.split_whitespace()[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7dk7e54k.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7dk7e54k.rs:21:30\n   |\n21 |         while k < s.len() && s[k]\
    \ != ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp7dk7e54k.rs:25:23\n   |\n25 |             list.push(s.split_whitespace()[i]);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0608.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] == ' ' {\n            j += 1\n        }\n        let mut k\
    \ = i;\n        while k < s.len() && s[k] == ' ' {\n            k += 1\n     \
    \   }\n        if j == i {\n            list.push(s.to_string());\n          \
    \  i += 1;\n            continue;\n        }\n        if k == i {\n          \
    \  list.push(s.to_string());\n            i += 1;\n            continue;\n   \
    \     }\n        if s.chars().nth(i).unwrap() == s.chars().nth(k).unwrap() {\n\
    \            i += 1;\n            continue;\n        }\n        if s.chars().nth(i).unwrap()\
    \ == s.chars().nth(j).unwrap() {\n            i += 1;\n            continue;\n\
    \        }\n        if s.chars().nth(i).unwrap() == s.chars().nth(j).unwrap()\
    \ || s.chars().nth(k).unwrap() == s.chars().nth(j).unwrap() {\n            list.push(s.to_string());\n\
    \            i += 1;\n            continue;\n        }\n        if s.chars().nth(i).unwrap()\
    \ == s.chars().nth(k).unwrap() || s.chars().nth(i).unwrap() == s.chars().nth(j).unwrap()\
    \ || s.chars().nth(k).unwrap() == s.chars().nth(j).unwrap() {\n            list.push(s.to_string());\n\
    \            i += 1;\n            continue;\n        }\n    }\n    list\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_mwy_67u.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_mwy_67u.rs:21:30\n   |\n21 |         while k < s.len() && s[k]\
    \ == ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = 0;\n        while j\
    \ < s.len() {\n            if s[i] == s[j] {\n                j += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ j == n {\n            list.push(s.subslice(i, i + n));\n            i += n;\n\
    \        }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdx96yrmz.rs:18:16\n\
    \   |\n18 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdx96yrmz.rs:18:24\n   |\n18 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdx96yrmz.rs:24:17\n   |\n24 |         if j ==\
    \ n {\n   |                 ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n24 |         if j == n.try_into().unwrap() {\n   |              \
    \    ++++++++++++++++++++\n\nerror[E0599]: no method named `subslice` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpdx96yrmz.rs:25:25\n   |\n\
    25 |             list.push(s.subslice(i, i + n));\n   |                      \
    \   ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdx96yrmz.rs:25:41\n   |\n25 |             list.push(s.subslice(i,\
    \ i + n));"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[i] == s[j] {\n                j += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ j - i == n {\n            list.push(&s[i..j]);\n            i += j - i;\n  \
    \      }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpf7e68193.rs:18:16\n\
    \   |\n18 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpf7e68193.rs:18:24\n   |\n18 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf7e68193.rs:24:21\n   |\n24 |         if j -\
    \ i == n {\n   |                     ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n24 |         if j - i == n.try_into().unwrap() {\n   |  \
    \                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf7e68193.rs:29:5\n   |\n12 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n29 |     list\n   |     ^^^^ expected\
    \ struct `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    let mut\
    \ s = String::from(s);\n    let mut n = n as usize;\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        if s.chars().any(|c| c.is_uppercase() && c.is_consonant())\
    \ {\n            if n == 0 {\n                break;\n            }\n        \
    \    i += 1;\n            n -= 1;\n        } else {\n            result.push(s.subslice(i,\
    \ i + 1));\n            i += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpsipndd32.rs:18:52\n   |\n18 |         if s.chars().any(|c|\
    \ c.is_uppercase() && c.is_consonant()) {\n   |                              \
    \                      ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `subslice` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpsipndd32.rs:25:27\n   |\n25 |             result.push(s.subslice(i,\
    \ i + 1));\n   |                           ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut consonants = Vec::new();\n    let mut vowels = Vec::new();\n    let mut\
    \ vowels_count = Vec::new();\n    let mut vowels_count_index = Vec::new();\n \
    \   let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index =\
    \ Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcf_q_7e4.rs:56:11\n   |\n\
    56 |     let mu\n   |           ^ help: add `;` here\n57 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcf_q_7e4.rs:12:41\n \
    \  |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s[i] == s[j]\
    \ {\n                j += 1;\n            } else {\n                break;\n \
    \           }\n        }\n        if j == s.len() {\n            list.push(s.clone());\n\
    \            i += 1;\n        } else {\n            i += j - i;\n        }\n \
    \   }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn5xvmydk.rs:19:16\n\
    \   |\n19 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn5xvmydk.rs:19:24\n   |\n19 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] == ' ' {\n                break;\n        \
    \    }\n            j = j + 1;\n        }\n        let mut k = i;\n        while\
    \ k < j {\n            if s[k] == ' ' {\n                break;\n            }\n\
    \            k = k + 1;\n        }\n        if k == j {\n            list.push(s.to_string());\n\
    \        }\n        i = j;\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzx9vbrnz.rs:18:16\n\
    \   |\n18 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzx9vbrnz.rs:25:16\n   |\n25 |             if s[k] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j += 1\n        }\n        if j - i > n {\n  \
    \          words.push_back(s.to_string());\n            i = j;\n        }\n  \
    \  }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp17u8lszg.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp17u8lszg.rs:20:20\n\
    \   |\n20 |         if j - i > n {\n   |                    ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         if j - i > n.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp17u8lszg.rs:21:19\n\
    \   |\n21 |             words.push_back(s.to_string());\n   |                \
    \   ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j += 1\n        }\n        let mut k = i;\n  \
    \      while k < s.len() && s[k] == ' ' {\n            k += 1\n        }\n   \
    \     if j == i {\n            words.push(s.to_string());\n            i += 1;\n\
    \            continue;\n        }\n        if k > j {\n            i += 1;\n \
    \           continue;\n        }\n        let mut count = 0;\n        while k\
    \ < j {\n            if s[k] == s[j] {\n                count += 1;\n        \
    \        k += 1;\n            } else {\n                break;\n            }\n\
    \        }\n        if count == n {\n            words.push(s.to_string());\n\
    \            i += 1;\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkv9cjjez.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkv9cjjez.rs:21:30\n   |\n21 |         while k < s.len() && s[k]\
    \ == ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkv9cjjez.rs:35:16\n   |\n35 |             if s[k] == s[j] {\n \
    \  |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ pos = 0;\n    while pos < s.len() {\n        let mut found = false;\n      \
    \  for c in s.chars() {\n            if c == ' ' {\n                found = true;\n\
    \                break;\n            }\n            if found {\n             \
    \   break;\n            }\n            if c.is_consonant() {\n               \
    \ found = true;\n            }\n        }\n        if found {\n            words.push(s.split_whitespace()[pos]);\n\
    \            pos += 1;\n        }\n    }\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp7qquqq1c.rs:25:18\n   |\n25 |             if c.is_consonant()\
    \ {\n   |                  ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0608]:\
    \ cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmp7qquqq1c.rs:30:24\n\
    \   |\n30 |             words.push(s.split_whitespace()[pos]);\n   |         \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] != ' ' {\n            j += 1\n        }\n        let mut k\
    \ = i;\n        while k < j && s[k] != ' ' {\n            k += 1\n        }\n\
    \        if k == j {\n            list.push(s.split_whitespace()[i]);\n      \
    \      i += 1;\n        } else {\n            i += 1;\n        }\n    }\n    list\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp23b8n6ju.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] != ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp23b8n6ju.rs:21:24\n   |\n21 |         while k < j && s[k] != '\
    \ ' {\n   |                        ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp23b8n6ju.rs:25:23\n   |\n25 |             list.push(s.split_whitespace()[i]);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0608.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] == ' ' {\n                break;\n        \
    \    }\n            if s[j] == ' ' && s[j + 1] == ' ' {\n                break;\n\
    \            }\n            if s[j] == ' ' && s[j + 1] != ' ' {\n            \
    \    j += 1;\n                continue;\n            }\n            if s[j] ==\
    \ ' ' && s[j + 1] == ' ' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] == ' ' && s[j + 1] != ' ' {\n            \
    \    j += 1;\n                continue;\n            }\n            if s[j] !=\
    \ ' ' && s[j + 1] == ' ' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] != ' ' && s[j + 1] != ' ' {\n            \
    \    j += 1;\n                continue;\n            }\n            if s[j] !=\
    \ ' ' && s[j + 1] != ' ' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] != ' ' && s[j + 1] != ' ' {\n            \
    \    j += 1;\n                continue;\n            }\n            if s[j] !=\
    \ ' ' && s[j + 1] != ' ' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] != ' ' && s[j + 1] != ' ' {\n            \
    \    j += 1;\n                continue;\n            }\n            if s[j] !=\
    \ ' ' && s[j + 1] != ' ' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] != ' ' && s[j + 1] != ' ' {\n            \
    \    j += 1;\n                continue;\n            }\n            if s[j] !=\
    \ ' ' && s[j + 1] != ' ' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] != ' ' && s[j + 1] != ' ' {\n            \
    \    j += 1;\n                continue;\n            }\n            if s[j] !=\
    \ ' ' && s[j + 1] != ' ' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] != ' ' && s[j + 1] != ' ' {\n            \
    \    j += 1;\n                continue;\n            }\n            if s[j] !=\
    \ ' ' && s[j + 1] != ' ' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] != ' ' && s[j + 1] != ' ' {\n            \
    \    j += 1;\n                continue;\n            }\n            if s[j] !=\
    \ ' ' && s[j + 1] != ' ' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] != ' ' && s[j + 1] != ' ' {\n            \
    \    j += 1;\n                continue;\n            }\n            if s[j] !=\
    \ ' ' && s[j + 1] != ' ' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] != ' ' && s[j + 1] != ' ' {\n            \
    \    \n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmphkle5a9g.rs:117:3\n\
    \    |\n12  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    15  |     while i < s.len() {\n    |                       - unclosed delimiter\n\
    16  |         let mut j = i;\n17  |         while j < s.len() {\n    |       \
    \                    - unclosed delimiter\n...\n104 |             if s[j] != '\
    \ ' && s[j + 1] != ' ' {\n    |                                              \
    \ - this delimiter might not be properly closed...\n105 |                 \n106\
    \ | }\n    | - ...as it matches this but it has different indentation\n...\n117\
    \ | }\n    |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphkle5a9g.rs:18:16\n   |\n18 |             if s[j] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphkle5a9g.rs:21:16\n   |\n21 |             if s[j] == ' ' && s[j\
    \ + 1] == ' ' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ consonants = vec![];\n    let mut vowels = vec![];\n    let mut spaces = vec![];\n\
    \    let mut non_spaces = vec![];\n    let mut non_letters = vec![];\n    let\
    \ mut non_spaces_index = -1;\n    let mut non_letters_index = -1;\n    let mut\
    \ vowels_index = -1;\n    let mut spaces_index = -1;\n    let mut consonants_index\
    \ = -1;\n    let mut non_spaces_len = s.len();\n    let mut non_letters_len =\
    \ s.len();\n    let mut vowels_len = s.len();\n    let mut spaces_len = s.len();\n\
    \    let mut consonants_len = s.len();\n    let mut non_spaces_index = 0;\n  \
    \  let mut non_letters_index = 0;\n    let mut vowels_index = 0;\n    let mut\
    \ spaces_index = 0;\n    let mut consonants_index = 0;\n    let mut non_spaces_len\
    \ = s.len();\n    let mut non_letters_len = s.len();\n    let mut vowels_len =\
    \ s.len();\n    let mut spaces_len = s.len();\n    let mut consonants_len = s.len();\n\
    \    let mut non_spaces_index = 0;\n    let mut non_letters_index = 0;\n    let\
    \ mut vowels_index = 0;\n    let mut spaces_index = 0;\n    let mut consonants_index\
    \ = 0;\n    let mut non_spaces_len = s.len();\n    let mut non_letters_len = s.len();\n\
    \    let mut vowels_len = s.len();\n    let mut spaces_len = s.len();\n    let\
    \ mut consonants_len = s.len();\n    let mut non_spaces_index = 0;\n    let mut\
    \ non_letters_index = 0;\n    let mut vowels_index = 0;\n    let mut spaces_index\
    \ = 0;\n    let mut consonants_index = 0;\n    let mut non_spaces_len = s.len();\n\
    \    let mut non_letters_len = s.len();\n    let mut vowels_len = s.len();\n \
    \   let mut spaces_len = s.len();\n    let mut consonants_len = s.len();\n   \
    \ let mut non_spaces_index = 0;\n    let mut non_letters_index = 0;\n    let mut\
    \ vowels_index = 0;\n    let mut spaces_index = 0;\n    let mut consonants_index\
    \ = 0;\n    let mut non_spaces_len = s.len();\n    let mut non_letters_len = s.\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpq9whl4bv.rs:66:1\n   |\n66\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpq9whl4bv.rs:65:33\n\
    \   |\n65 |     let mut non_letters_len = s.\n   |                           \
    \      ^ help: add `;` here\n66 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq9whl4bv.rs:12:41\n   |\n12 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |    ------------                   \
    \      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as usize;\n    let mut i = 0;\n\
    \    while i < s.len() {\n        if s.chars().any(|c| c != ' ' && c != '\\n')\
    \ {\n            if n == 0 {\n                break;\n            }\n        \
    \    i += 1;\n        } else {\n            result.push(s.subslice(i, i + n));\n\
    \            i += n;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `subslice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpookcf2oo.rs:24:27\n   |\n24 |             result.push(s.subslice(i,\
    \ i + n));\n   |                           ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_count\
    \ = vec![0];\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\"\
    , \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut consonant_count = vec![0];\n\
    \    let mut vowel_position = 0;\n    let mut consonant_position = 0;\n    let\
    \ mut vowel_positions = vec![0];\n    let mut consonant_positions = vec![0];\n\
    \    let mut vowel_positions_copy = vec![0];\n    let mut consonant_positions_copy\
    \ = vec![0];\n    let mut vowel_positions_copy2 = vec![0];\n    let mut consonant_positions_copy2\
    \ = vec![0];\n    let mut vowel_positions_copy3 = vec![0];\n    let mut consonant_positions_copy3\
    \ = vec![0];\n    let mut vowel_positions_copy4 = vec![0];\n    let mut consonant_positions_copy4\
    \ = vec![0];\n    let mut vowel_positions_copy5 = vec![0];\n    let mut consonant_positions_copy5\
    \ = vec![0];\n    let mut vowel_positions_copy6 = vec![0];\n    let mut consonant_positions_copy6\
    \ = vec![0];\n    let mut vowel_positions_copy7 = vec![0];\n    let mut consonant_positions_copy7\
    \ = vec![0];\n    let mut vowel_positions_copy8 = vec![0];\n    let mut consonant_positions_copy8\
    \ = vec![0];\n    let mut vowel_positions_copy9 = vec![0];\n    let mut consonant_positions_copy9\
    \ = vec![0];\n    let mut vowel_positions_copy10 = vec![0];\n    let mut consonant_positions_copy10\
    \ = vec![0];\n    let mut vowel_positions_copy11 = vec![0];\n    let mut consonant_positions_copy11\
    \ = vec![0];\n    let mut vowel_positions_copy12 = vec![0];\n    let mut consonant_positions_copy12\
    \ = vec![0];\n    let mut vowel_positions_copy13 = vec![0];\n    let mut consonant_positions_copy13\
    \ = vec![0];\n    let mut vowel_positions_copy14 = vec![0];\n    let mut consonant_positions_copy14\
    \ = vec![0];\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5dbh5224.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = 0;\n        while j\
    \ < s.len() {\n            if s[i] == s[j] {\n                j += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ j == s.len() {\n            list.push(s.to_string());\n            i += 1;\n\
    \        }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp73k3siom.rs:18:16\n\
    \   |\n18 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp73k3siom.rs:18:24\n   |\n18 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as usize;\n    while n > 0 {\n \
    \       let mut i = 0;\n        while i < s.len() {\n            if s[i] == '\
    \ ' {\n                i += 1;\n                continue;\n            }\n   \
    \         if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i]\
    \ == 'u' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'y' || s[i] == 'o' || s[i] == 'u' {\n                i\
    \ += 1;\n                continue;\n            }\n            if s[i] == 's'\
    \ || s[i] == 't' || s[i] == 'h' || s[i] == 'r' || s[i] == 'd' {\n            \
    \    i += 1;\n                continue;\n            }\n            if s[i] ==\
    \ 'n' || s[i] == 'g' || s[i] == 'l' || s[i] == 'b' || s[i] == 'p' {\n        \
    \        i += 1;\n                continue;\n            }\n            if s[i]\
    \ == 'c' || s[i] == 'f' || s[i] == 'v' || s[i] == 'm' || s[i] == 'a' {\n     \
    \           i += 1;\n                continue;\n            }\n            if\
    \ s[i] == 'k' || s[i] == 'j' || s[i] == 'q' || s[i] == 'p' || s[i] == 'b' {\n\
    \                i += 1;\n                continue;\n            }\n         \
    \   if s[i] == 'v' || s[i] == 'f' || s[i] == 'c' || s[i] == 'm' || s[i] == 'a'\
    \ {\n                i += 1;\n                continue;\n            }\n     \
    \       if s[i] == 'h' || s[i] == 'r' || s[i] == 'd' || s[i] == 'g' || s[i] ==\
    \ 'e' {\n                i += 1;\n                continue;\n            }\n \
    \           if s[i] == 'n' || s[i] == 'g' || s[i] == 'l' || s[i] == 'b' || s[i]\
    \ == 'p' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'c' || s[i] == 'f' || s[i] == 'v' || s[i] == 'm' || s[i]\
    \ == 'a' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'k' || s[i] == 'j' || s[i] == 'q' || s[i] == 'p' || s[i]\
    \ == 'b' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'v' || s[i] == 'f' || s[i] == 'c' || s[i] == 'm' || s[i]\
    \ == 'a' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'h' || s[i] == 'r' || s[i] == 'd' || s[i] == 'g' || s[i]\
    \ == 'e' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'n' || s[i] == 'g' || s[i] == 'l' || s[i] == 'b' || s[i]\
    \ == 'p' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'c' || s[i] == 'f' || s[i] == 'v' || s[i] == '\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpkatiyzpc.rs:79:69\n\
    \   |\n79 |             if s[i] == 'c' || s[i] == 'f' || s[i] == 'v' || s[i] ==\
    \ '\n   |                                                                    \
    \ ^\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    if s.chars().all(|c| c != ' ') {\n            list.push(s.subslice(i, i +\
    \ n));\n            i += n;\n        }\n    }\n    list\n}\n\nfn main() {\n  \
    \  let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `subslice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpt4cg4gui.rs:18:25\n   |\n18 |             list.push(s.subslice(i,\
    \ i + n));\n   |                         ^^^^^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpt4cg4gui.rs:18:41\n   |\n18 |\
    \             list.push(s.subslice(i, i + n));\n   |                         \
    \                ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add\
    \ `isize` to `usize`\n  --> /tmp/tmpt4cg4gui.rs:18:39\n   |\n18 |            \
    \ list.push(s.subslice(i, i + n));\n   |                                     \
    \  ^ no implementation for `usize + isize`\n   |\n   = help: the trait `Add<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt4cg4gui.rs:19:18\n\
    \   |\n19 |             i += n;\n   |                  ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmpt4cg4gui.rs:19:15\n\
    \   |\n19 |             i += n;\n   |               ^^ no implementation for `usize\
    \ += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`."
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j].is_ascii_letter() {\n            j = j + 1;\n        }\n \
    \       let mut k = i;\n        while k < j && s[k].is_ascii_letter() {\n    \
    \        k = k + 1;\n        }\n        if k == j {\n            words.push(s.to_string());\n\
    \            i = j;\n        } else {\n            i = k;\n        }\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6xu5sob2.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6xu5sob2.rs:21:24\n\
    \   |\n21 |         while k < j && s[k].is_ascii_letter() {\n   |            \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() && s.chars().any(|c| c == ' ')\
    \ {\n            j = j + 1;\n        }\n        if j - i > n {\n            list.push(s.split_whitespace().nth(i).unwrap());\n\
    \            i = j;\n        }\n        else {\n            i = j;\n        }\n\
    \    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp77nz1l9v.rs:21:20\n   |\n\
    21 |         if j - i > n {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |         if j - i > n.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp77nz1l9v.rs:29:5\n   |\n12 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n29 |     list\n   |    \
    \ ^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<&str>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    let mut\
    \ s = String::from(s);\n    while s.len() > 0 {\n        let mut i = s.len();\n\
    \        while i > 0 {\n            let c = s.chars().nth(i).unwrap();\n     \
    \       if c.is_uppercase() {\n                i = i - 1;\n            } else\
    \ {\n                break;\n            }\n        }\n        if i == 0 {\n \
    \           break;\n        }\n        let mut j = i;\n        while j > 0 {\n\
    \            let c = s.chars().nth(j).unwrap();\n            if c.is_lowercase()\
    \ {\n                j = j - 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if j == 0 {\n            break;\n        }\n\
    \        let mut k = j;\n        while k > 0 {\n            let c = s.chars().nth(k).unwrap();\n\
    \            if c.is_whitespace() {\n                k = k - 1;\n            }\
    \ else {\n                break;\n            }\n        }\n        if k == 0\
    \ {\n            break;\n        }\n        let mut l = k;\n        while l >\
    \ 0 {\n            let c = s.chars().nth(l).unwrap();\n            if c.is_whitespace()\
    \ {\n                l = l - 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if l == 0 {\n            break;\n        }\n\
    \        let mut m = l;\n        while m > 0 {\n            let c = s.chars().nth(m).unwrap();\n\
    \            if c.is_whitespace() {\n                m = m - 1;\n            }\
    \ else {\n                break;\n            }\n        }\n        if m == 0\
    \ {\n            break;\n        }\n        let mut n = m;\n        while n >\
    \ 0 {\n            let c = s.chars().nth(n).unwrap();\n            if c.is_whitespace()\
    \ {\n                n = n - 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if n == 0 {\n            break;\n        }\n\
    \        result.push(s.chars().nth(n).unwrap().to_string());\n        s = s.chars().nth(n\
    \ - 1).unwrap().to_string();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpw6u67ci4.rs:18:38\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as usize;\n    let mut i = 0;\n\
    \    while i < s.len() {\n        if s.chars().any(|c| c != ' ') {\n         \
    \   if s.chars().all(|c| c == s.chars().nth(i)) {\n                i += 1;\n \
    \           } else {\n                result.push(s.chars().nth(i).unwrap());\n\
    \                i += 1;\n            }\n        } else {\n            i += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyum58ij6.rs:19:39\n   |\n\
    19 |             if s.chars().all(|c| c == s.chars().nth(i)) {\n   |         \
    \                              ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyum58ij6.rs:29:5\n   |\n12 | fn\
    \ select_words(s: String, n: isize) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n29 |     result\n   |     ^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as usize;\n    while n > 0 {\n \
    \       if s.chars().all(|c| c.is_consonant()) {\n            result.push(s.clone());\n\
    \            n -= 1;\n        }\n        s /= ' ';\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmplitdlw5a.rs:17:32\n   |\n17 |         if s.chars().all(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0368]: binary assignment operation `/=` cannot\
    \ be applied to type `String`\n  --> /tmp/tmplitdlw5a.rs:21:9\n   |\n21 |    \
    \     s /= ' ';\n   |         -^^^^^^^\n   |         |\n   |         cannot use\
    \ `/=` on type `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0368, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    if s.chars().any(|c| c.is_consonant() && c != ' ') {\n            list.push(s.subslice(i,\
    \ i + n));\n            i += n;\n        }\n    }\n    list\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp4vuecgv3.rs:17:32\n   |\n17 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp4vuecgv3.rs:18:25\n\
    \   |\n18 |             list.push(s.subslice(i, i + n));\n   |               \
    \          ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4vuecgv3.rs:18:41\n   |\n18 |             list.push(s.subslice(i,\
    \ i + n));\n   |                                         ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmp4vuecgv3.rs:18:39\n\
    \   |\n18 |             list.push(s.subslice(i, i + n));\n   |               \
    \                        ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4vuecgv3.rs:19:18\n   |\n19 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmp4vuecgv3.rs:19:15\n   |\n19 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssi"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[i] == s[j] {\n            j += 1\n        }\n        if j ==\
    \ s.len() {\n            list.push(s.to_string());\n            i += 1;\n    \
    \    } else {\n            i += j - i;\n        }\n    }\n    list\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsht9eu16.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[i] == s[j] {\n   |                \
    \              ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsht9eu16.rs:17:38\n   |\n17 |         while j < s.len() && s[i]\
    \ == s[j] {\n   |                                      ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n;\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        if s.chars().any(|c| c.is_consonant() == true) {\n  \
    \          list.push(s.subslice(i, i + n));\n            i += n;\n        }\n\
    \    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpbh7yungn.rs:18:32\n   |\n18 |         if s.chars().any(|c|\
    \ c.is_consonant() == true) {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpbh7yungn.rs:19:25\n\
    \   |\n19 |             list.push(s.subslice(i, i + n));\n   |               \
    \          ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbh7yungn.rs:19:41\n   |\n19 |             list.push(s.subslice(i,\
    \ i + n));\n   |                                         ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpbh7yungn.rs:19:39\n\
    \   |\n19 |             list.push(s.subslice(i, i + n));\n   |               \
    \                        ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbh7yungn.rs:20:18\n   |\n20 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmpbh7yungn.rs:20:15\n   |\n20 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssign>\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as usize;\n    let mut i = 0;\n\
    \    while i < s.len() {\n        if s.chars().all(|c| c.is_consonant() && c !=\
    \ ' ') {\n            list.push(s.subslice(i, i + n));\n            i += n;\n\
    \        }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp5404v3b4.rs:18:32\n   |\n18 |         if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp5404v3b4.rs:19:25\n\
    \   |\n19 |             list.push(s.subslice(i, i + n));\n   |               \
    \          ^^^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ consonants = vec![];\n    let mut vowels = vec![];\n    let mut vowels_count\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index_count\
    \ = vec![];\n    let mut vowels_count_index_count_index = vec![];\n    let mut\
    \ vowels_count_index_count_index_count = vec![];\n    let mut vowels_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count = vec![];\n\
    \    let mut vowels_count_index_count_index_count_index_count_index = vec![];\n\
    \    let mut vowels_count_index_count_index_count_index_count_index_count = vec![];\n\
    \    let mut vowels_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut vowels_count_\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7zwuihl0.rs:39:26\n   |\n\
    39 |     let mut vowels_count_\n   |                          ^ help: add `;`\
    \ here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7zwuihl0.rs:12:41\n   |\n12 | fn select_words(s: String, n: isize) ->\
    \ Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j += 1\n        }\n        let mut word = s.split_whitespace()[j..].to_owned();\n\
    \        while i < s.len() && word.contains(&s[i..]) {\n            i += 1;\n\
    \            word = s.split_whitespace()[j..].to_owned();\n        }\n       \
    \ if word.len() == n {\n            words.push(word);\n        }\n        i +=\
    \ 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpukyamkft.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpukyamkft.rs:20:24\n   |\n20 |         let mut word = s.split_whitespace()[j..].to_owned();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpukyamkft.rs:23:20\n\
    \   |\n23 |             word = s.split_whitespace()[j..].to_owned();\n   |   \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == ' ' || c == '\\t' || c == '\\n') {\n                break;\n          \
    \  }\n            i += 1;\n            j += 1\n        }\n        if j == s.len()\
    \ {\n            break;\n        }\n        let mut word = s.split_whitespace().nth(j).unwrap();\n\
    \        if word.chars().count(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u') == n {\n            words.push(word);\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpfjs51i3s.rs:29:25\n    |\n29  |         if word.chars().count(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') == n {\n    |    \
    \                     ^^^^^ ------------------------------------------------------------\
    \ supplied 1 argument\n    |                         |\n    |                \
    \         expected 0 arguments\n    |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfjs51i3s.rs:29:96\n   |\n29 |\
    \         if word.chars().count(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u') == n {\n   |                                                  \
    \                                              ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n29 |         if word.chars().count(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u') == n.try_into().unwrap() {\n \
    \  |                                                                         \
    \                        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfjs51i3s.rs:33:5\n   |\n12 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n33 |     words\n   |     ^^^^^ expected\
    \ struct `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n;\n    while n > 0 {\n        let\
    \ mut index = s.find('a', 0); //find first letter\n        if index == s.len()\
    \ {\n            break;\n        }\n        let mut word = s.split_whitespace()[index..].to_string();\n\
    \        if word.chars().count(|c| c.is_consonant()) == n {\n            list.push(word);\n\
    \        }\n        n -= 1;\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp9_3nk8kz.rs:17:27\n     |\n17   |         let mut index = s.find('a',\
    \ 0); //find first letter\n     |                           ^^^^ ---  - supplied\
    \ 2 arguments\n     |                           |\n     |                    \
    \       expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9_3nk8kz.rs:18:21\n   |\n18 |  \
    \       if index == s.len() {\n   |                     ^^^^^^^ expected enum\
    \ `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n18 |         if index == Some(s.len()) {\n   |                     +++++\
    \       +\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp9_3nk8kz.rs:21:24\n   |\n21 |         let mut word = s.split_whitespace()[index..].to_string();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0308,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    if s.chars().all(|c| c.is_consonant() && c != ' ') {\n            list.push(s.subslice(i,\
    \ i + n));\n            i += n;\n        }\n        i += 1;\n    }\n    list\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmplik5c20q.rs:17:32\n   |\n17 |         if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmplik5c20q.rs:18:25\n\
    \   |\n18 |             list.push(s.subslice(i, i + n));\n   |               \
    \          ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplik5c20q.rs:18:41\n   |\n18 |             list.push(s.subslice(i,\
    \ i + n));\n   |                                         ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmplik5c20q.rs:18:39\n\
    \   |\n18 |             list.push(s.subslice(i, i + n));\n   |               \
    \                        ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplik5c20q.rs:19:18\n   |\n19 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmplik5c20q.rs:19:15\n   |\n19 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssi"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[i] == s[j] {\n            j += 1\n        }\n        if j - i\
    \ == n {\n            list.push(&s[i..j]);\n            i += j - i;\n        }\n\
    \    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpik2dl09v.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[i] == s[j] {\n   |                \
    \              ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpik2dl09v.rs:17:38\n   |\n17 |         while j < s.len() && s[i]\
    \ == s[j] {\n   |                                      ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpik2dl09v.rs:20:21\n\
    \   |\n20 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpik2dl09v.rs:25:5\n   |\n12 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n25 |     list\n   |    \
    \ ^^^^ expected struct `String`, f"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = 0;\n        while j\
    \ < s.len() {\n            if s[i] == s[j] {\n                j += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ j == n {\n            list.push(&s[i..j]);\n            i += j - i + 1;\n  \
    \      }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpyoazvkt3.rs:18:16\n\
    \   |\n18 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpyoazvkt3.rs:18:24\n   |\n18 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyoazvkt3.rs:24:17\n   |\n24 |         if j ==\
    \ n {\n   |                 ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n24 |         if j == n.try_into().unwrap() {\n   |              \
    \    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyoazvkt3.rs:29:5\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n29 |     list\n   |     ^^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `Vec<String>`\n              "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s[i] == s[j]\
    \ {\n                j += 1;\n            } else {\n                break;\n \
    \           }\n        }\n        if j == s.len() {\n            list.push(s.clone());\n\
    \            i += 1;\n        }\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmw8y7b44.rs:19:16\n\
    \   |\n19 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmw8y7b44.rs:19:24\n   |\n19 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n;\n    while n > 0 {\n        let\
    \ mut i = s.find(' ').unwrap();\n        let mut j = s.find(' ', i + 1).unwrap();\n\
    \        let mut word = s.split_whitespace().nth(i).unwrap();\n        if j >\
    \ i {\n            list.push(word);\n            i += 1;\n            n -= 1;\n\
    \        } else {\n            i += 1;\n            n -= 1;\n        }\n    }\n\
    \    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp2rc20ygw.rs:18:23\n     |\n18   |         let mut j = s.find('\
    \ ', i + 1).unwrap();\n     |                       ^^^^ ---  ----- supplied 2\
    \ arguments\n     |                       |\n     |                       expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2rc20ygw.rs:29:5\n   |\n12 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \      ----------- expected `Vec<String>` because of return type\n...\n29 |  \
    \   list\n   |     ^^^^ expected struct `String`, found `&str`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    let mut\
    \ s = String::from(s);\n    let mut n = n as usize;\n    while n > 0 {\n     \
    \   let mut i = 0;\n        while i < s.len() {\n            if s[i] == ' ' {\n\
    \                i += 1;\n                continue;\n            }\n         \
    \   if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\
    \ {\n                i += 1;\n                continue;\n            }\n     \
    \       if s[i] == 'y' || s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] ==\
    \ 'o' || s[i] == 'u' {\n                i += 1;\n                continue;\n \
    \           }\n            if s[i] == 'o' || s[i] == 'u' {\n                i\
    \ += 1;\n                continue;\n            }\n            if s[i] == 'e'\
    \ || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n                i += 1;\n  \
    \              continue;\n            }\n            if s[i] == 'a' || s[i] ==\
    \ 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n                i += 1;\n\
    \                continue;\n            }\n            if s[i] == 'y' || s[i]\
    \ == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n     \
    \           i += 1;\n                continue;\n            }\n            if\
    \ s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n\
    \                i += 1;\n                continue;\n            }\n         \
    \   if s[i] == 'y' || s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o'\
    \ || s[i] == 'u' {\n                i += 1;\n                continue;\n     \
    \       }\n            if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] ==\
    \ 'o' || s[i] == 'u' {\n                i += 1;\n                continue;\n \
    \           }\n            if s[i] == 'y' || s[i] == 'a' || s[i] == 'e' || s[i]\
    \ == 'i' || s[i] == 'o' || s[i] == 'u' {\n                i += 1;\n          \
    \      continue;\n            }\n            if s[i] == 'a' || s[i] == 'e' ||\
    \ s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n                i += 1;\n     \
    \           continue;\n            }\n            if s[i] == 'y' || s[i] == 'a'\
    \ || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n            \
    \    i += 1;\n                continue;\n            }\n            if s[i] ==\
    \ 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n        \
    \        i += 1;\n                continue;\n            }\n            if s[i]\
    \ == 'y' || s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] ==\
    \ 'u' {\n                i += 1;\n                continue;\n            }\n\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7hinv6m9.rs:91:3\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n16\
    \ |     while n > 0 {\n   |                 - unclosed delimiter\n17 |       \
    \  let mut i = 0;\n18 |         while i < s.len() {\n   |                    \
    \       - this delimiter might not be properly closed...\n...\n80 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n91 | }\n   |  \
    \ ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7hinv6m9.rs:19:16\n\
    \   |\n19 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7hinv6m9.rs:23:16\n   |\n23 |             if s[i] == 'a' || s[i]\
    \ == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n   |                ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7hinv6m9.rs:23:31\n   |\n23 |             if s[i] "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut consonants = Vec::new();\n    let mut vowels = Vec::new();\n    let mut\
    \ vowels_count = Vec::new();\n    let mut vowels_count_index = Vec::new();\n \
    \   let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index =\
    \ Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5e43z_oo.rs:56:11\n   |\n\
    56 |     let mu\n   |           ^ help: add `;` here\n57 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5e43z_oo.rs:12:41\n \
    \  |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] == ' ' {\n            j += 1\n        }\n        let mut k\
    \ = j;\n        while k < s.len() && s[k] != ' ' {\n            k += 1\n     \
    \   }\n        if k == i {\n            i += 1;\n            continue;\n     \
    \   }\n        let mut word = String::new();\n        while j < k {\n        \
    \    word.push(s[j]);\n            j += 1\n        }\n        if word.chars().count(|c|\
    \ c != 'a'..='z') > n {\n            i += 1;\n            continue;\n        }\n\
    \        words.push(word);\n        i += 1;\n    }\n    words\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4rw9dbi7.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4rw9dbi7.rs:21:30\n   |\n21 |         while k < s.len() && s[k]\
    \ != ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4rw9dbi7.rs:30:23\n   |\n30 |             word.push(s[j]);\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n       "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as usize;\n    let mut i = 0;\n\
    \    while i < s.len() {\n        if s.chars().any(|c| c.is_consonant() == true)\
    \ {\n            list.push(s.subslice(i, i + n));\n            i += n;\n     \
    \   }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpvgctwkqh.rs:18:32\n   |\n18 |         if s.chars().any(|c|\
    \ c.is_consonant() == true) {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpvgctwkqh.rs:19:25\n\
    \   |\n19 |             list.push(s.subslice(i, i + n));\n   |               \
    \          ^^^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    let mut\
    \ s = String::from(s);\n    let mut n = n as isize;\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        if s.chars().any(|c| c.is_consonant() == true) {\n  \
    \          result.push(s.subslice(i, i + n));\n            i += n;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpwpe09f1c.rs:18:32\n   |\n18 |         if s.chars().any(|c|\
    \ c.is_consonant() == true) {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpwpe09f1c.rs:19:27\n\
    \   |\n19 |             result.push(s.subslice(i, i + n));\n   |             \
    \              ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwpe09f1c.rs:19:43\n   |\n19 |             result.push(s.subslice(i,\
    \ i + n));\n   |                                           ^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpwpe09f1c.rs:19:41\n\
    \   |\n19 |             result.push(s.subslice(i, i + n));\n   |             \
    \                            ^ no implementation for `usize + isize`\n   |\n \
    \  = help: the trait `Add<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `Add<Rhs>`:\n             <&'a f32 as\
    \ Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n\
    \             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n    \
    \         <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n          \
    \   <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwpe09f1c.rs:20:18\n   |\n20 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmpwpe09f1c.rs:20:15\n   |\n20 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == s.chars().nth(j)) {\n                j += 1;\n            } else {\n  \
    \              break;\n            }\n        }\n        if j == s.len() {\n \
    \           list.push(s.to_string());\n            i += 1;\n        } else {\n\
    \            i += j - i;\n        }\n    }\n    list\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplksqtz3j.rs:19:39\n   |\n\
    19 |             if s.chars().any(|c| c == s.chars().nth(j)) {\n   |         \
    \                              ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as usize;\n    let mut i = 0;\n\
    \    while i < s.len() {\n        let mut j = i;\n        while j < s.len() &&\
    \ s.chars().any(|c| c == s.chars().nth(j)) {\n            j += 1\n        }\n\
    \        if j == s.len() {\n            list.push(s.to_string());\n          \
    \  i += 1;\n        } else {\n            list.push(s.to_string().split_whitespace().nth(j).unwrap());\n\
    \            i += 1;\n        }\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoarzzmsu.rs:19:53\n   |\n\
    19 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoarzzmsu.rs:26:23\n\
    \   |\n26 |             list.push(s.to_string().split_whitespace().nth(j).unwrap());\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \     |\n   |                       expected struct `String`, found `&str`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = 0;\n        while j\
    \ < s.len() {\n            if s[i] == s[j] {\n                j += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ j == n {\n            list.push(s.subslice(i, j));\n            i += j;\n  \
    \      }\n        i += 1;\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptydowft9.rs:18:16\n\
    \   |\n18 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptydowft9.rs:18:24\n   |\n18 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptydowft9.rs:24:17\n   |\n24 |         if j ==\
    \ n {\n   |                 ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n24 |         if j == n.try_into().unwrap() {\n   |              \
    \    ++++++++++++++++++++\n\nerror[E0599]: no method named `subslice` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmptydowft9.rs:25:25\n   |\n\
    25 |             list.push(s.subslice(i, j));\n   |                         ^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0599.\nFor more informati"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ index = 0;\n    while index < s.len() {\n        let mut found = false;\n  \
    \      for c in s.chars() {\n            if c == ' ' {\n                continue;\n\
    \            }\n            if c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' {\n                continue;\n            }\n            if c == 'y'\
    \ {\n                if index == 0 {\n                    continue;\n        \
    \        }\n                if index == s.len() - 1 {\n                    break;\n\
    \                }\n                found = true;\n                break;\n  \
    \          }\n            if c == n {\n                found = true;\n       \
    \         break;\n            }\n        }\n        if found {\n            words.push(s.split_whitespace()[index].to_string());\n\
    \        }\n        index += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppv144g49.rs:34:21\n   |\n\
    34 |             if c == n {\n   |                     ^ expected `char`, found\
    \ `isize`\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmppv144g49.rs:40:24\n   |\n40 |             words.push(s.split_whitespace()[index].to_string());\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0608.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    if s.chars().all(|c| c.is_consonant() && c != ' ') {\n            list.push(s.to_string());\n\
    \            i += 1;\n        }\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp5o_kd66j.rs:17:32\n   |\n17 |         if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut pos = 0;\n    while pos < s.len() {\n        let mut found = false;\n  \
    \      for c in s.chars() {\n            if c == ' ' {\n                continue;\n\
    \            }\n            if c.is_vowel() {\n                found = true;\n\
    \                break;\n            }\n        }\n        if found {\n      \
    \      words.push(s.split_whitespace()[pos]);\n        }\n        pos += 1;\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmper5wiok9.rs:21:18\n   |\n21 |             if c.is_vowel()\
    \ {\n   |                  ^^^^^^^^ method not found in `char`\n\nerror[E0608]:\
    \ cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmper5wiok9.rs:27:24\n\
    \   |\n27 |             words.push(s.split_whitespace()[pos]);\n   |         \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && count < n) {\n            words.push(s.to_string()[i..i\
    \ + 1]);\n            i += 1;\n            count += 1;\n        }\n        i +=\
    \ 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmppc5w96vr.rs:17:32\n   |\n17 |         if s.chars().any(|c|\
    \ c.is_consonant() && count < n) {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n   --> /tmp/tmppc5w96vr.rs:18:24\n    |\n\
    18  |             words.push(s.to_string()[i..i + 1]);\n    |                \
    \   ---- ^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n \
    \   |                   |\n    |                   required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n   --> /tmp/tmppc5w96vr.rs:13:21\n\
    \    |\n13  |     let mut words = vec![];\n    |                     ^^^^^^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `Vec::<T>::new`\n    = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n   --> /tmp/tmppc5w96vr.rs:13:21\n    |\n13  |  \
    \   let mut words = vec![];\n    |                     ^^^^^^ doesn't have a size\
    \ known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `Vec`\n    = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppc5w96vr.rs:24:5\n  \
    \ |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |        \
    \                                 ----------- expected `Vec<String>` because of\
    \ return type\n...\n24 |     words\n   |     ^^^^^ expected struct `String`, found\
    \ `str`\n   |\n   = note: expected struct `Vec<String>`\n              found struct\
    \ `Vec<str>`\n\nerr"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j = j + 1;\n        }\n        if j == s.len()\
    \ {\n            break;\n        }\n        let mut count = 0;\n        while\
    \ j < s.len() {\n            if s[j] == s[i] {\n                count = count\
    \ + 1;\n                j = j + 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if count == n {\n            words.push(&s[i..j]);\n\
    \        }\n        i = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjv8w9oxj.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjv8w9oxj.rs:25:16\n   |\n25 |             if s[j] == s[i] {\n \
    \  |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjv8w9oxj.rs:25:24\n   |\n25 |             if s[j] == s[i] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut consonants = Vec::new();\n    let mut vowels = Vec::new();\n    let mut\
    \ vowels_count = Vec::new();\n    let mut vowels_count_index = Vec::new();\n \
    \   let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index =\
    \ Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp12v9_rau.rs:56:11\n   |\n\
    56 |     let mu\n   |           ^ help: add `;` here\n57 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp12v9_rau.rs:12:41\n \
    \  |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n;\n    while n > 0 {\n        let\
    \ mut index = s.find(' ').unwrap();\n        let mut word = s.split_whitespace().nth(index).unwrap();\n\
    \        list.push(word);\n        s = &s[(index + 1)..];\n        n -= 1;\n \
    \   }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdjfvs9h8.rs:20:13\n   |\n\
    14 |     let mut s = String::from(s);\n   |                 --------------- expected\
    \ due to this value\n...\n20 |         s = &s[(index + 1)..];\n   |          \
    \   ^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try\
    \ using a conversion method\n   |\n20 |         s = (&s[(index + 1)..]).to_string();\n\
    \   |             +                 +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdjfvs9h8.rs:23:5\n   |\n12 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n23 |     list\n   |    \
    \ ^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<&str>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j += 1\n        }\n        if j == i {\n     \
    \       i += 1;\n            continue;\n        }\n        let mut word = String::new();\n\
    \        while j < s.len() {\n            if s[j] == ' ' {\n                break;\n\
    \            }\n            word.push(s[j]);\n            j += 1\n        }\n\
    \        if word.len() == n {\n            words.push(word.clone());\n       \
    \ }\n        i += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpa4zlbawn.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpa4zlbawn.rs:26:16\n   |\n26 |             if s[j] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpa4zlbawn.rs:29:23\n   |\n29 |             word.push(s[j]);\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerr"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] == ' ' {\n            j += 1\n        }\n        if j - i\
    \ == n {\n            list.push(&s[i..j]);\n            i = j;\n        }\n  \
    \  }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpj2ul8jdv.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj2ul8jdv.rs:20:21\n\
    \   |\n20 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj2ul8jdv.rs:25:5\n   |\n12 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n25 |     list\n   |    \
    \ ^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<&str>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == s.chars().nth(j)) {\n                j += 1;\n            } else {\n  \
    \              break;\n            }\n        }\n        if j == s.len() {\n \
    \           list.push(s.to_string());\n            i += 1;\n        } else {\n\
    \            i += j - i;\n        }\n    }\n    list\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxq081h_o.rs:19:39\n   |\n\
    19 |             if s.chars().any(|c| c == s.chars().nth(j)) {\n   |         \
    \                              ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s.chars().all(|c| c != ' ') {\n            j += 1\n        }\n\
    \        if j == i {\n            list.push(s.to_string());\n            i +=\
    \ 1;\n        } else {\n            let mut j = i;\n            while j < s.len()\
    \ && s.chars().all(|c| c != ' ') {\n                j += 1\n            }\n  \
    \          if j == i {\n                list.push(s.to_string());\n          \
    \      i += 1;\n            } else {\n                let mut j = i;\n       \
    \         while j < s.len() && s.chars().all(|c| c != ' ') {\n               \
    \     j += 1\n                }\n                if j == i {\n               \
    \     list.push(s.to_string());\n                    i += 1;\n               \
    \ } else {\n                    let mut j = i;\n                    while j <\
    \ s.len() && s.chars().all(|c| c != ' ') {\n                        j += 1\n \
    \                   }\n                    if j == i {\n                     \
    \   list.push(s.to_string());\n                        i += 1;\n             \
    \       } else {\n                        let mut j = i;\n                   \
    \     while j < s.len() && s.chars().all(|c| c != ' ') {\n                   \
    \         j += 1\n                        }\n                        if j == i\
    \ {\n                            list.push(s.to_string());\n                 \
    \           i += 1;\n                        } else {\n                      \
    \      let mut j = i;\n                            while j < s.len() && s.chars().all(|c|\
    \ c != ' ') {\n                                j += 1\n                      \
    \      }\n                            if j == i {\n                          \
    \      list.push(s.to_string());\n                                i += 1;\n  \
    \                          } else {\n                                let mut j\
    \ = i;\n                                while j < s.len() && s.chars().all(|c|\
    \ c != ' ') {\n                                    j += 1\n                  \
    \              }\n                                if j == i {\n              \
    \                      list.push(s.to_string());\n                           \
    \         i += 1;\n                                } else {\n                \
    \                    let mut j = i;\n                                    while\
    \ j < s.len() && s.chars().all(|c| c != ' ') {\n                             \
    \           j += 1\n                                    }\n                  \
    \                  if j == i {\n                                        list.push(s.to_string());\n\
    \                                        i += 1;\n                           \
    \         } else {\n                                        let mut j = i;\n \
    \                                       while j < s.len() && s.chars().all(|c|\
    \ c != ' ') {\n                                            j += 1\n          \
    \                              }\n                                        if j\
    \ == i {\n                                            list.push(s.to_string());\n\
    \                                            i += 1;\n                       \
    \                 } else {\n                                            let mut\
    \ j = i;\n                                            while j < s.len() && s.chars().all(|c|\
    \ c != ' ') {\n                                                j += 1\n      \
    \                                      }\n                                   \
    \         if j == \n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpiqyb4a99.rs:104:3\n\
    \    |\n12  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    15  |     while i < s.len() {\n    |                       - unclosed delimiter\n\
    ...\n23  |         } else {\n    |                - unclosed delimiter\n...\n\
    31  |             } else {\n    |                    - unclosed delimiter\n...\n\
    39  |                 } else {\n    |                        - unclosed delimiter\n\
    ...\n47  |                     } else {\n    |                            - unclosed\
    \ delimiter\n...\n55  |                         } else {\n    |              \
    \                  - unclosed delimiter\n...\n63  |                          \
    \   } else {\n    |                                    - unclosed delimiter\n\
    ...\n71  |                                 } else {\n    |                   \
    \                     - unclosed delimiter\n...\n79  |                       \
    \              } else {\n    |                                            - unclosed\
    \ delimiter\n...\n87  |                                         } else {\n   \
    \ |                                                - this delimiter might not\
    \ be properly closed...\n...\n93  | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n104 | }\n    |   ^\n\nerror: expected expression,\
    \ found `}`\n  --> /tmp/tmpiqyb4a99.rs:93:1\n   |\n93 | }\n   | ^ expected expression\n\
    \nerror[E0308]: mismatched types\n   --> /tmp/tmpiqyb4a99.rs:15:5\n    |\n12 \
    \ |   fn select_words(s: String, n: isize) -> Vec<String> {\n    |           \
    \                                ----------- expected `Vec<String>` because of\
    \ return type\n...\n15  | /     while i < s.len() {\n16  | |         let mut j\
    \ = i;\n17  | |         while j < s.len() && s.chars().all(|c| c != ' ') {\n18\
    \  | |             j += 1\n...   |\n103 | |     assert_eq!(candidate(String::from(\"\
    a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n104 | | }\n    | |__^ expected struct `Ve"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] == ' ' {\n            j += 1\n        }\n        let mut word\
    \ = String::new();\n        while j < s.len() && s[j] != ' ' {\n            word.push(s[j]);\n\
    \            j += 1\n        }\n        if word.len() == n {\n            words.push(word.clone());\n\
    \        }\n        i += j - i;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpghjk1us6.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpghjk1us6.rs:21:30\n   |\n21 |         while j < s.len() && s[j]\
    \ != ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpghjk1us6.rs:22:23\n   |\n22 |             word.push(s[j]);\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n       "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    if s.chars().all(|c| c.is_consonant() && c != ' ') {\n            list.push(s.subslice(i,\
    \ i + n));\n            i += n;\n        }\n    }\n    list\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp8y73f68x.rs:17:32\n   |\n17 |         if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp8y73f68x.rs:18:25\n\
    \   |\n18 |             list.push(s.subslice(i, i + n));\n   |               \
    \          ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8y73f68x.rs:18:41\n   |\n18 |             list.push(s.subslice(i,\
    \ i + n));\n   |                                         ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmp8y73f68x.rs:18:39\n\
    \   |\n18 |             list.push(s.subslice(i, i + n));\n   |               \
    \                        ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8y73f68x.rs:19:18\n   |\n19 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmp8y73f68x.rs:19:15\n   |\n19 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssi"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    if s.chars().all(|c| c.is_ascii_letter() || c.is_ascii_digit()) {\n     \
    \       if s.len() >= n {\n                list.push(s.subslice(i, i + n));\n\
    \            }\n            i += n;\n        } else {\n            i += 1;\n \
    \       }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpyj3ehe99.rs:17:32\n   |\n17 |         if s.chars().all(|c|\
    \ c.is_ascii_letter() || c.is_ascii_digit()) {\n   |                         \
    \       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyj3ehe99.rs:18:27\n\
    \   |\n18 |             if s.len() >= n {\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |             if s.len()\
    \ >= n.try_into().unwrap() {\n   |                            ++++++++++++++++++++\n\
    \nerror[E0599]: no method named `subslice` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpyj3ehe99.rs:19:29\n   |\n19 |                 list.push(s.subslice(i,\
    \ i + n));\n   |                             ^^^^^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyj3ehe99.rs:19:45\n   |\n19 |\
    \                 list.push(s.subslice(i, i + n));\n   |                     \
    \                        ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ add `isize` to `usize`\n  --> /tmp/tmpyj3ehe99.rs:19:43\n   |\n19 |        \
    \         list.push(s.subslice(i, i + n));\n   |                             \
    \              ^ no implementation for `usize + isize`\n   |\n   = help: the trait\
    \ `Add<isize>` is not implemented for `usize`\n   = help: the following other\
    \ types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n    \
    \         <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n      \
    \       <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n          \
    \   <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n             <&'a\
    \ isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyj3ehe99.rs:21:18\n   |\n21 |             i += n;\n   |       \
    \           ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmpy"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ consonants = vec![];\n    let mut vowels = vec![];\n    let mut spaces = vec![];\n\
    \    let mut non_spaces = vec![];\n    let mut non_spaces_count = vec![];\n  \
    \  let mut non_spaces_count_index = vec![];\n    let mut non_spaces_count_index2\
    \ = vec![];\n    let mut non_spaces_count_index3 = vec![];\n    let mut non_spaces_count_index4\
    \ = vec![];\n    let mut non_spaces_count_index5 = vec![];\n    let mut non_spaces_count_index6\
    \ = vec![];\n    let mut non_spaces_count_index7 = vec![];\n    let mut non_spaces_count_index8\
    \ = vec![];\n    let mut non_spaces_count_index9 = vec![];\n    let mut non_spaces_count_index10\
    \ = vec![];\n    let mut non_spaces_count_index11 = vec![];\n    let mut non_spaces_count_index12\
    \ = vec![];\n    let mut non_spaces_count_index13 = vec![];\n    let mut non_spaces_count_index14\
    \ = vec![];\n    let mut non_spaces_count_index15 = vec![];\n    let mut non_spaces_count_index16\
    \ = vec![];\n    let mut non_spaces_count_index17 = vec![];\n    let mut non_spaces_count_index18\
    \ = vec![];\n    let mut non_spaces_count_index19 = vec![];\n    let mut non_spaces_count_index20\
    \ = vec![];\n    let mut non_spaces_count_index21 = vec![];\n    let mut non_spaces_count_index22\
    \ = vec![];\n    let mut non_spaces_count_index23 = vec![];\n    let mut non_spaces_count_index24\
    \ = vec![];\n    let mut non_spaces_count_index25 = vec![];\n    let mut non_spaces_count_index26\
    \ = vec![];\n    let mut non_spaces_count_index27 = vec![];\n    let mut non_spaces_count_index28\
    \ = vec![];\n    let mut non_spaces_count_index29 = vec![];\n    let mut non_spaces_count_index30\
    \ = vec![];\n    let mut non_spaces_count_index31 = vec![];\n    let mut non_spaces_count_index32\
    \ = vec![];\n    let mut non_spaces_count_index33 = vec![];\n    let mut non_space\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnmxu6e72.rs:52:22\n   |\n\
    52 |     let mut non_space\n   |                      ^ help: add `;` here\n53\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnmxu6e72.rs:12:41\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j = j + 1;\n        }\n        if j == s.len()\
    \ {\n            break;\n        }\n        let mut k = j;\n        while k <\
    \ s.len() && s[k] == ' ' {\n            k = k + 1;\n        }\n        if k ==\
    \ s.len() {\n            break;\n        }\n        let mut c = s.chars().nth(j).unwrap();\n\
    \        if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n     \
    \       break;\n        }\n        if k == j {\n            break;\n        }\n\
    \        let mut count = 0;\n        while k < s.len() {\n            let c =\
    \ s.chars().nth(k).unwrap();\n            if c != 'a' && c != 'e' && c != 'i'\
    \ && c != 'o' && c != 'u' {\n                break;\n            }\n         \
    \   count = count + 1;\n            k = k + 1;\n        }\n        if count ==\
    \ n {\n            words.push(s.chars().nth(j).unwrap());\n        }\n       \
    \ i = j + 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxc1phlnx.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxc1phlnx.rs:24:30\n   |\n24 |         while k < s.len() && s[k]\
    \ == ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxc1phlnx.rs:51:5\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n51 |     words\n   |     ^^^^^ expected struct `String`,\
    \ found `char`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<char>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ consonants = vec![];\n    let mut vowels = vec![];\n    let mut vowels_count\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let mut vowels_count_index\
    \ = vec![];\n    let mut vowels_count_index = vec![];\n    let \n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmppmoygi2g.rs:61:1\n  \
    \ |\n61 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = 0;\n        while j\
    \ < s.len() {\n            if s[i] == s[j] {\n                j += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ j == n {\n            words.push(&s[i..i + n]);\n            i += n;\n     \
    \   }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7t45dowh.rs:18:16\n\
    \   |\n18 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7t45dowh.rs:18:24\n   |\n18 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7t45dowh.rs:24:17\n   |\n24 |         if j ==\
    \ n {\n   |                 ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n24 |         if j == n.try_into().unwrap() {\n   |              \
    \    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7t45dowh.rs:25:34\n\
    \   |\n25 |             words.push(&s[i..i + n]);\n   |                      \
    \            ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add `isize`\
    \ to `usize`\n  --> /tmp/tmp7t45dowh.rs:25:32\n   |\n25 |             words.push(&s[i..i\
    \ + n]);\n   |                                ^ no implementat"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[i] == s[j] {\n                j += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ j == s.len() {\n            list.push(&s[i .. i + n]);\n            i += n;\n\
    \        }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmrxk_5bh.rs:18:16\n\
    \   |\n18 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmrxk_5bh.rs:18:24\n   |\n18 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmrxk_5bh.rs:25:35\n   |\n25 |             list.push(&s[i\
    \ .. i + n]);\n   |                                   ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpmrxk_5bh.rs:25:33\n\
    \   |\n25 |             list.push(&s[i .. i + n]);\n   |                     \
    \            ^ no implementation for `usize + isize`\n   |\n   = help: the trait\
    \ `Add<isize>` is not implemented for `usize`\n   = help: the following other\
    \ types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n    \
    \         <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n      \
    \       <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut consonants =\
    \ vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n\
    \    let mut vowels_count = vowels.len();\n    let mut consonants_count = consonants.len();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if vowels.contains(&s[i..])\
    \ {\n            vowels_count -= 1;\n        }\n        if consonants.contains(&s[i..])\
    \ {\n            consonants_count -= 1;\n        }\n        if vowels_count ==\
    \ 0 && consonants_count == 0 {\n            words.push(&s[i..]);\n        }\n\
    \        if vowels_count == 0 && consonants_count == 1 {\n            words.push(&s[i..]);\n\
    \        }\n        if vowels_count == 1 && consonants_count == 0 {\n        \
    \    words.push(&s[i..]);\n        }\n        if vowels_count == 1 && consonants_count\
    \ == 1 {\n            words.push(&s[i..]);\n        }\n        i += 1;\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9zou28x9.rs:20:28\n   |\n\
    20 |         if vowels.contains(&s[i..]) {\n   |                            ^^^^^^^\
    \ expected `&str`, found `str`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9zou28x9.rs:23:32\n   |\n23 |         if consonants.contains(&s[i..])\
    \ {\n   |                                ^^^^^^^ expected `&str`, found `str`\n\
    \   |\n   = note: expected reference `&&str`\n              found reference `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9zou28x9.rs:40:5\n   |\n12 | fn\
    \ select_words(s: String, n: isize) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n40 |     words\n   |     ^^^^^ expected struct `String`, found `&str`\n \
    \  |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j += 1\n        }\n        if j == i {\n     \
    \       break;\n        }\n        let mut count = 0;\n        while j < s.len()\
    \ && s[j] == s[i] {\n            count += 1;\n            j += 1\n        }\n\
    \        if count == n {\n            words.push(&s[i..j]);\n        }\n     \
    \   i = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp34gkmm4r.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp34gkmm4r.rs:24:30\n   |\n24 |         while j < s.len() && s[j]\
    \ == s[i] {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp34gkmm4r.rs:24:38\n   |\n24 |         while j < s.len() && s[j]\
    \ == s[i] {\n   |                                      ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<s"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] != ' ' {\n            j += 1\n        }\n        let mut word\
    \ = s.split_whitespace().nth(i).unwrap();\n        let mut count = 0;\n      \
    \  while j < s.len() {\n            if s[j] == ' ' {\n                count +=\
    \ 1;\n                j += 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if count == n {\n            list.push(word);\n\
    \            i += 1;\n        }\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp12zgn9d6.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] != ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp12zgn9d6.rs:23:16\n   |\n23 |             if s[j] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp12zgn9d6.rs:35:5\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n35 |     list\n   |     ^^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[i] == s[j] {\n            j += 1\n        }\n        if j - i\
    \ == n {\n            list.push(&s[i..j]);\n            i += j - i;\n        }\n\
    \    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9pxdzpam.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[i] == s[j] {\n   |                \
    \              ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9pxdzpam.rs:17:38\n   |\n17 |         while j < s.len() && s[i]\
    \ == s[j] {\n   |                                      ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9pxdzpam.rs:20:21\n\
    \   |\n20 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9pxdzpam.rs:25:5\n   |\n12 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n25 |     list\n   |    \
    \ ^^^^ expected struct `String`, f"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ index = 0;\n    while index < s.len() {\n        let mut count = 0;\n      \
    \  let mut c = s.chars().nth(index).unwrap();\n        while c != ' ' && c !=\
    \ '\\t' && c != '\\n' && c != '\\r' && c != '\\0' {\n            if c == c.to_ascii_lowercase()\n\
    \                || c == c.to_ascii_uppercase()\n                || c == c.to_ascii_lowercase().to_ascii_uppercase()\n\
    \            {\n                count += 1;\n            }\n            c += 1;\n\
    \        }\n        if count == n {\n            words.push(s.split_whitespace().nth(index).unwrap());\n\
    \        }\n        index += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `char`\n  --> /tmp/tmpbnjjbkqx.rs:25:13\n   |\n25 |             c += 1;\n  \
    \ |             -^^^^^\n   |             |\n   |             cannot use `+=` on\
    \ type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbnjjbkqx.rs:32:5\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n32 |     words\n   |     ^^^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as usize;\n    while n > 0 {\n \
    \       if s.contains(&consonants[n - 1]) {\n            result.push(s.trim_end());\n\
    \        }\n        n -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `consonants` in this scope\n  --> /tmp/tmp2zh6170v.rs:17:24\n\
    \   |\n17 |         if s.contains(&consonants[n - 1]) {\n   |                \
    \        ^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2zh6170v.rs:22:5\n   |\n12 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n22 |     result\n   |     ^^^^^^\
    \ expected struct `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[i] == s[j] {\n            j = j + 1;\n        }\n        if j\
    \ - i == n {\n            list.push(&s[i..j]);\n            i = j;\n        }\n\
    \    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4ip7224o.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[i] == s[j] {\n   |                \
    \              ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4ip7224o.rs:17:38\n   |\n17 |         while j < s.len() && s[i]\
    \ == s[j] {\n   |                                      ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4ip7224o.rs:20:21\n\
    \   |\n20 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4ip7224o.rs:25:5\n   |\n12 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n25 |     list\n   |    \
    \ ^^^^ expected struct `String`, f"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() && s.chars().any(|c| c == s.chars().nth(j))\
    \ {\n            j = j + 1;\n        }\n        if j == s.len() {\n          \
    \  words.push(s.to_string());\n            i += 1;\n        } else {\n       \
    \     let mut k = j;\n            while k < s.len() && s.chars().any(|c| c ==\
    \ s.chars().nth(k)) {\n                k = k + 1;\n            }\n           \
    \ if k == s.len() {\n                words.push(s.to_string());\n            \
    \    i += 1;\n            } else {\n                let mut l = k;\n         \
    \       while l < s.len() && s.chars().any(|c| c == s.chars().nth(l)) {\n    \
    \                l = l + 1;\n                }\n                if l == s.len()\
    \ {\n                    words.push(s.to_string());\n                    i +=\
    \ 1;\n                } else {\n                    let mut m = l;\n         \
    \           while m < s.len() && s.chars().any(|c| c == s.chars().nth(m)) {\n\
    \                        m = m + 1;\n                    }\n                 \
    \   if m == s.len() {\n                        words.push(s.to_string());\n  \
    \                      i += 1;\n                    } else {\n               \
    \         let mut n = m;\n                        while n < s.len() && s.chars().any(|c|\
    \ c == s.chars().nth(n)) {\n                            n = n + 1;\n         \
    \               }\n                        if n == s.len() {\n               \
    \             words.push(s.to_string());\n                            i += 1;\n\
    \                        } else {\n                            let mut o = n;\n\
    \                            while o < s.len() && s.chars().any(|c| c == s.chars().nth(o))\
    \ {\n                                o = o + 1;\n                            }\n\
    \                            if o == s.len() {\n                             \
    \   words.push(s.to_string());\n                                i += 1;\n    \
    \                        } else {\n                                let mut p =\
    \ o;\n                                while p < s.len() && s.chars().any(|c| c\
    \ == s.chars().nth(p)) {\n                                    p = p + 1;\n   \
    \                             }\n                                if p == s.len()\
    \ {\n                                    words.push(s.to_string());\n        \
    \                            i += 1;\n                                } else {\n\
    \                                    let mut q = p;\n                        \
    \            while q < s.len() && s.chars().any(|c| c == s.chars().nth(q)) {\n\
    \                                        q = q + 1;\n                        \
    \            }\n                                    if q == s.len() {\n      \
    \                                  words.push(s.to_string());\n              \
    \                          i += 1;\n                                    } else\
    \ {\n                                        let mut r = q;\n                \
    \                        while r < s.len() && s.chars().any(|c| c == s.chars().nth(r))\
    \ {\n                                            r = r + 1;\n\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpo6mc9s8w.rs:96:3\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n16\
    \ |     while i < s.len() {\n   |                       - unclosed delimiter\n\
    ...\n24 |         } else {\n   |                - unclosed delimiter\n...\n32\
    \ |             } else {\n   |                    - unclosed delimiter\n...\n\
    40 |                 } else {\n   |                        - unclosed delimiter\n\
    ...\n48 |                     } else {\n   |                            - unclosed\
    \ delimiter\n...\n56 |                         } else {\n   |                \
    \                - unclosed delimiter\n...\n64 |                             }\
    \ else {\n   |                                    - unclosed delimiter\n...\n\
    72 |                                 } else {\n   |                          \
    \              - unclosed delimiter\n...\n80 |                               \
    \      } else {\n   |                                            - unclosed delimiter\n\
    81 |                                         let mut r = q;\n82 |            \
    \                             while r < s.len() && s.chars().any(|c| c == s.chars().nth(r))\
    \ {\n   |                                                                    \
    \                                   - this delimiter might not be properly closed...\n\
    ...\n85 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    96 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo6mc9s8w.rs:18:53\n\
    \   |\n18 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j))\
    \ {\n   |                                                     ^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpo6mc9s8w.rs:26:57\n   |\n26 |             while k < s.len() && s.chars().any(|c|\
    \ c == s.chars().nth(k)) {\n   |                                             \
    \            ^^^^^^^^^^^^^^^^ expect"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] == ' ' {\n            j += 1\n        }\n        if j == i\
    \ {\n            break;\n        }\n        let mut word = String::new();\n  \
    \      while j < s.len() {\n            if s[j] == ' ' || s[j] == '\\t' || s[j]\
    \ == '\\n' || s[j] == '\\r' {\n                break;\n            }\n       \
    \     word.push(s[j]);\n            j += 1\n        }\n        if word.len() ==\
    \ n {\n            words.push(word.clone());\n        }\n        i += j - i;\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm5wuon68.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpm5wuon68.rs:25:16\n   |\n25 |             if s[j] == ' ' || s[j]\
    \ == '\\t' || s[j] == '\\n' || s[j] == '\\r' {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpm5wuon68.rs:25:31\n   |\n25 |             if s[j] == ' ' || s[j]\
    \ == '\\t' || s[j] == '\\n' || s[j] == '\\r' {\n   |                         \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclu"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = 0;\n        while j\
    \ < s.len() {\n            if s[i] == s[j] {\n                j += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ j == n {\n            list.push(&s[i..]);\n            i += 1;\n        }\n\
    \    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpc1idewvl.rs:18:16\n\
    \   |\n18 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpc1idewvl.rs:18:24\n   |\n18 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc1idewvl.rs:24:17\n   |\n24 |         if j ==\
    \ n {\n   |                 ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n24 |         if j == n.try_into().unwrap() {\n   |              \
    \    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc1idewvl.rs:29:5\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n29 |     list\n   |     ^^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `Vec<String>`\n              "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() && s[j] == ' ' {\n            j\
    \ += 1\n        }\n        let mut k = j;\n        while k < s.len() && s[k] ==\
    \ ' ' {\n            k += 1\n        }\n        let mut l = k;\n        while\
    \ l < s.len() && s[l] == ' ' {\n            l += 1\n        }\n        let mut\
    \ m = l;\n        while m < s.len() && s[m] == ' ' {\n            m += 1\n   \
    \     }\n        let mut n = m;\n        while n < s.len() && s[n] == ' ' {\n\
    \            n += 1\n        }\n        if n == n {\n            let mut x = i;\n\
    \            while x < s.len() && s[x] == ' ' {\n                x += 1\n    \
    \        }\n            let mut y = x;\n            while y < s.len() && s[y]\
    \ == ' ' {\n                y += 1\n            }\n            let mut z = y;\n\
    \            while z < s.len() && s[z] == ' ' {\n                z += 1\n    \
    \        }\n            let mut w = z;\n            while w < s.len() && s[w]\
    \ == ' ' {\n                w += 1\n            }\n            let mut v = w;\n\
    \            while v < s.len() && s[v] == ' ' {\n                v += 1\n    \
    \        }\n            let mut u = v;\n            while u < s.len() && s[u]\
    \ == ' ' {\n                u += 1\n            }\n            let mut t = u;\n\
    \            while t < s.len() && s[t] == ' ' {\n                t += 1\n    \
    \        }\n            let mut s = t;\n            while s < s.len() && s[s]\
    \ == ' ' {\n                s += 1\n            }\n            let mut q = s;\n\
    \            while q < s.len() && s[q] == ' ' {\n                q += 1\n    \
    \        }\n            let mut p = q;\n            while p < s.len() && s[p]\
    \ == ' ' {\n                p += 1\n            }\n            let mut q = p;\n\
    \            while q < s.len() && s[q] == ' ' {\n                q += 1\n    \
    \        }\n            let mut r = q;\n            while r < s.len() && s[r]\
    \ == ' ' {\n                r += 1\n            }\n            let mut s = r;\n\
    \            while s < s.len() && s[s] == ' ' {\n                s += 1\n    \
    \        }\n            let mut q = s;\n            while q < s.len() && s[q]\
    \ == ' ' {\n                q += 1\n            }\n            let mut p = q;\n\
    \            while p < s.len(\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjpgyojnq.rs:107:3\n\
    \    |\n12  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    16  |     while i < s.len() {\n    |                       - unclosed delimiter\n\
    ...\n37  |         if n == n {\n    |                   - this delimiter might\
    \ not be properly closed...\n...\n96  | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n107 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n  --> /tmp/tmpjpgyojnq.rs:96:1\n   |\n95 |               while p < s.len(\n\
    \   |  _____________-----_-\n   | |             |\n   | |             while parsing\
    \ the body of this `while` expression\n96 | | }\n   | | ^\n   | | |\n   | |_expected\
    \ `{`\n   |   this `while` condition successfully parsed\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmpjpgyojnq.rs:95:28\n   |\n12 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \                  - closing delimiter possibly meant for this\n...\n95 |    \
    \         while p < s.len(\n   |                            ^ unclosed delimiter\n\
    96 | }\n   | ^ mismatched closing delimiter\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpjpgyojnq.rs:18:30\n   |\n18 |  \
    \       while j < s.len() && s[j] == ' ' {\n   |                             \
    \ ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjpgyojnq.rs:22:30\n   |\n22 |         while k < s.len() && s[k]\
    \ == ' ' {\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    while s.len() > 0 {\n        let mut i = 0;\n\
    \        let mut j = s.len();\n        while i < j {\n            if s[i] == '\
    \ ' {\n                i += 1;\n                j -= 1;\n            } else {\n\
    \                i += 1;\n            }\n        }\n        if n == 0 {\n    \
    \        result.push(s.clone());\n        } else {\n            let mut i = s.len();\n\
    \            while i >= 0 {\n                if s[i] == ' ' {\n              \
    \      i -= 1;\n                } else {\n                    i -= 1;\n      \
    \              break;\n                }\n            }\n            result.push(s.clone());\n\
    \        }\n        s = String::from(&s[..i]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqlvqpjpu.rs:19:16\n\
    \   |\n19 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqlvqpjpu.rs:31:20\n   |\n31 |                 if s[i] == ' ' {\n\
    \   |                    ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] == ' ' {\n            j += 1\n        }\n        if j == s.len()\
    \ {\n            list.push(s.to_string());\n            break;\n        }\n  \
    \      let mut count = 0;\n        while j < s.len() {\n            if s[j] ==\
    \ s[i] {\n                count += 1;\n                j += 1;\n            }\n\
    \            j += 1\n        }\n        if count == n {\n            list.push(s.to_string());\n\
    \        }\n        i += 1;\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpipwtf_xz.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpipwtf_xz.rs:26:16\n   |\n26 |             if s[j] == s[i] {\n \
    \  |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpipwtf_xz.rs:26:24\n   |\n26 |             if s[j] == s[i] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == s.chars().nth(j)) {\n                j += 1;\n            } else {\n  \
    \              break;\n            }\n        }\n        list.push(s.chars().nth(i).unwrap());\n\
    \        i = j;\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9o_1wkcv.rs:19:39\n   |\n\
    19 |             if s.chars().any(|c| c == s.chars().nth(j)) {\n   |         \
    \                              ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9o_1wkcv.rs:28:5\n   |\n12 | fn\
    \ select_words(s: String, n: isize) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n28 |     list\n   |     ^^^^ expected struct `String`, found `char`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as usize;\n    let mut i = 0;\n\
    \    while i < s.len() {\n        if s.chars().any(|c| c != ' ') {\n         \
    \   result.push(s.to_string());\n            i += 1;\n        }\n        if n\
    \ == 0 {\n            break;\n        }\n        n -= 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a little\
    \ lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\"]`,\n right: `[\"\
    little\"]`', /tmp/tmp58zqrcrw.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut s = String::from(s);\n    while s.len() > 0 {\n        let mut i = 0;\n\
    \        let mut j = s.len();\n        while i < j {\n            let mut c =\
    \ s[i];\n            if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u'\
    \ && c != 'y' {\n                i += 1;\n            } else {\n             \
    \   j -= 1;\n            }\n        }\n        if n == 0 {\n            break;\n\
    \        }\n        let mut i = s.len();\n        while i > 0 {\n            let\
    \ mut c = s[i];\n            if c != 'a' && c != 'e' && c != 'i' && c != 'o' &&\
    \ c != 'u' && c != 'y' {\n                i -= 1;\n            } else {\n    \
    \            break;\n            }\n        }\n        words.push(s.clone());\n\
    \        s = &s[..i];\n    }\n    words\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpyphb8nfn.rs:19:25\n\
    \   |\n19 |             let mut c = s[i];\n   |                         ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpyphb8nfn.rs:31:25\n   |\n31 |             let mut c = s[i];\n \
    \  |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyphb8nfn.rs:39:13\n   |\n14 |     let mut s\
    \ = String::from(s);\n   |                 --------------- expected due to this\
    \ value\n...\n39 |         s = &s[..i];\n   |             ^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\nhelp: try using a conversion method\n   |\n39\
    \ |         s = (&s[..i]).to_string();\n   |             +       +++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.chars().all(|c| c.is_consonant()\
    \ && c != ' ') {\n            list.push(s.subslice(i, i + n));\n            i\
    \ += n;\n        }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpeszktql8.rs:16:32\n   |\n16 |         if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpeszktql8.rs:17:25\n\
    \   |\n17 |             list.push(s.subslice(i, i + n));\n   |               \
    \          ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpeszktql8.rs:17:41\n   |\n17 |             list.push(s.subslice(i,\
    \ i + n));\n   |                                         ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpeszktql8.rs:17:39\n\
    \   |\n17 |             list.push(s.subslice(i, i + n));\n   |               \
    \                        ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeszktql8.rs:18:18\n   |\n18 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmpeszktql8.rs:18:15\n   |\n18 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssi"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ index = 0;\n    while index < s.len() {\n        let mut found = false;\n  \
    \      for c in s.chars() {\n            if c == ' ' {\n                continue;\n\
    \            }\n            if c >= 'a' && c <= 'z' {\n                continue;\n\
    \            }\n            if c >= 'A' && c <= 'Z' {\n                continue;\n\
    \            }\n            if c >= '0' && c <= '9' {\n                continue;\n\
    \            }\n            if c == ' ' {\n                continue;\n       \
    \     }\n            if c >= 'a' && c <= 'z' {\n                continue;\n  \
    \          }\n            if c >= 'A' && c <= 'Z' {\n                continue;\n\
    \            }\n            if c >= '0' && c <= '9' {\n                continue;\n\
    \            }\n            if c == ' ' {\n                continue;\n       \
    \     }\n            if c >= 'a' && c <= 'z' {\n                continue;\n  \
    \          }\n            if c >= 'A' && c <= 'Z' {\n                continue;\n\
    \            }\n            if c >= '0' && c <= '9' {\n                continue;\n\
    \            }\n            if c == ' ' {\n                continue;\n       \
    \     }\n            if c >= 'a' && c <= 'z' {\n                continue;\n  \
    \          }\n            if c >= 'A' && c <= 'Z' {\n                continue;\n\
    \            }\n            if c >= '0' && c <= '9' {\n                continue;\n\
    \            }\n            if c == ' ' {\n                continue;\n       \
    \     }\n            if c >= 'a' && c <= 'z' {\n                continue;\n  \
    \          }\n            if c >= 'A' && c <= 'Z' {\n                continue;\n\
    \            }\n            if c >= '0' && c <= '9' {\n                continue;\n\
    \            }\n            if c == ' ' {\n                continue;\n       \
    \     }\n            if c >= 'a' && c <= 'z' {\n                continue;\n  \
    \          }\n            if c >= 'A' && c <= 'Z' {\n                continue;\n\
    \            }\n            if c >= '0' && c <= '9' {\n                continue;\n\
    \            }\n            if c == ' ' {\n                continue;\n       \
    \     }\n            if c >= 'a' && c <= 'z' {\n                continue;\n  \
    \          }\n            if c >= 'A' && c <= 'Z' {\n                continue;\n\
    \            }\n            if c >= '0' && c <= '9' {\n                continue;\n\
    \            }\n            if c == ' ' {\n                continue;\n       \
    \     }\n            if c >= 'a' && c <= 'z' {\n                continue\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpsnsml9ko.rs:118:3\n\
    \    |\n12  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    15  |     while index < s.len() {\n    |                           - unclosed\
    \ delimiter\n16  |         let mut found = false;\n17  |         for c in s.chars()\
    \ {\n    |                            - unclosed delimiter\n...\n105 |       \
    \      if c >= 'a' && c <= 'z' {\n    |                                     -\
    \ this delimiter might not be properly closed...\n106 |                 continue\n\
    107 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    118 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpsnsml9ko.rs:15:5\n\
    \    |\n12  |   fn select_words(s: String, n: isize) -> Vec<String> {\n    | \
    \                                          ----------- expected `Vec<String>`\
    \ because of return type\n...\n15  | /     while index < s.len() {\n16  | |  \
    \       let mut found = false;\n17  | |         for c in s.chars() {\n18  | |\
    \             if c == ' ' {\n...   |\n117 | |     assert_eq!(candidate(String::from(\"\
    a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n118 | | }\n    | |__^ expected struct `Vec`, found\
    \ `()`\n    |\n    = note: expected struct `Vec<String>`\n            found unit\
    \ type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    if s.chars().any(|c| c.is_uppercase() && c != 'A' && c != 'E' && c != 'I'\
    \ && c != 'O' && c != 'U' && c != 'Y') {\n            i += 1;\n        } else\
    \ {\n            if s.chars().any(|c| c.is_lowercase() && c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u' && c != 'y') {\n                i += 1;\n\
    \            } else {\n                if s.chars().any(|c| c.is_whitespace()\
    \ && c != '\\n' && c != '\\r' && c != '\\t') {\n                    i += 1;\n\
    \                } else {\n                    if s.chars().any(|c| c.is_digit())\
    \ {\n                        i += 1;\n                    } else {\n         \
    \               if s.chars().any(|c| c.is_punct()) {\n                       \
    \     i += 1;\n                        } else {\n                            if\
    \ s.chars().any(|c| c.is_symbol()) {\n                                i += 1;\n\
    \                            } else {\n                                if s.chars().any(|c|\
    \ c.is_control()) {\n                                    i += 1;\n           \
    \                     } else {\n                                    if s.chars().any(|c|\
    \ c.is_digit()) {\n                                        i += 1;\n         \
    \                           } else {\n                                       \
    \ if s.chars().any(|c| c.is_upper()) {\n                                     \
    \       i += 1;\n                                        } else {\n          \
    \                                  if s.chars().any(|c| c.is_lower()) {\n    \
    \                                            i += 1;\n                       \
    \                     } else {\n                                             \
    \   if s.chars().any(|c| c.is_space()) {\n                                   \
    \                 i += 1;\n                                                } else\
    \ {\n                                                    if s.chars().any(|c|\
    \ c.is_digit()) {\n                                                        i +=\
    \ 1;\n                                                    } else {\n         \
    \                                               i += 1;\n                    \
    \                                }\n                                         \
    \       }\n                                            }\n                   \
    \                     }\n                                    }\n             \
    \                   }\n                            }\n                       \
    \ }\n                    }\n                }\n            }\n        }\n    }\n\
    \    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpgav0zvul.rs:26:44\n    |\n26  |                     if s.chars().any(|c|\
    \ c.is_digit()) {\n    |                                            ^^^^^^^^-\
    \ supplied 0 arguments\n    |                                            |\n \
    \   |                                            expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror[E0599]: no method named `is_punct`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpgav0zvul.rs:29:48\n\
    \   |\n29 |                         if s.chars().any(|c| c.is_punct()) {\n   |\
    \                                                ^^^^^^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `is_symbol` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpgav0zvul.rs:32:52\n   |\n32 | ...         \
    \          if s.chars().any(|c| c.is_symbol()) {\n   |                       \
    \                       ^^^^^^^^^ method not found in `char`\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpgav0zvul.rs:38:60\n\
    \    |\n38  | ...                   if s.chars().any(|c| c.is_digit()) {\n   \
    \ |                                              ^^^^^^^^- supplied 0 arguments\n\
    \    |                                              |\n    |                 \
    \                             expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `is_upper` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpgav0zvul.rs:41:64\n   |\n41 | ...      \
    \             if s.chars().any(|c| c.is_upper()) {\n   |                     \
    \                         ^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_uppercase`\n\nerror[E0599]: no method named `is_lower` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpgav0zvul.rs:44:68\n   |\n\
    44 | ...                   if s.chars().any(|c| c.is_lower()) {\n   |        \
    \                                      ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_lowercase`\n\nerror"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == s.chars().nth(j)) {\n                j += 1;\n            } else {\n  \
    \              break;\n            }\n        }\n        if j == s.len() {\n \
    \           list.push(s.to_string());\n            i += 1;\n        } else {\n\
    \            i += j - i;\n        }\n    }\n    list\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmmeknno_.rs:19:39\n   |\n\
    19 |             if s.chars().any(|c| c == s.chars().nth(j)) {\n   |         \
    \                              ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s.chars().all(|c| c != ' ') {\n            j += 1\n        }\n        if\
    \ j == i {\n            i += 1;\n            continue;\n        }\n        let\
    \ mut word = String::new();\n        while j < s.len() && s.chars().all(|c| c\
    \ != ' ') {\n            word.push(s.chars().nth(j).unwrap());\n            j\
    \ += 1\n        }\n        if word.chars().count() == n {\n            words.push(word);\n\
    \        }\n        i += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq15ddwl3.rs:29:36\n   |\n\
    29 |         if word.chars().count() == n {\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n29 |      \
    \   if word.chars().count() == n.try_into().unwrap() {\n   |                 \
    \                    ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j += 1\n        }\n        if j == i {\n     \
    \       i += 1;\n            continue;\n        }\n        let mut count = 0;\n\
    \        while j < s.len() {\n            if s[j] == s[i] {\n                count\
    \ += 1;\n                j += 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if count == n {\n            words.push(&s[i..j]);\n\
    \        }\n        i = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfu_l57so.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfu_l57so.rs:26:16\n   |\n26 |             if s[j] == s[i] {\n \
    \  |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfu_l57so.rs:26:24\n   |\n26 |             if s[j] == s[i] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j += 1\n        }\n        if j == i {\n     \
    \       i += 1;\n            continue;\n        }\n        let mut found = false;\n\
    \        let mut j = 0;\n        while j < s.len() && s[j] == s[i] {\n       \
    \     j += 1\n        }\n        if j == i {\n            i += 1;\n          \
    \  continue;\n        }\n        let mut j = 0;\n        while j < s.len() &&\
    \ s[j] != s[i] {\n            j += 1\n        }\n        if j == i {\n       \
    \     i += 1;\n            continue;\n        }\n        if j > i {\n        \
    \    words.push_back(s.to_string());\n            i += j - i;\n        }\n   \
    \ }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2o5832_u.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2o5832_u.rs:26:30\n   |\n26 |         while j < s.len() && s[j]\
    \ == s[i] {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2o5832_u.rs:26:38\n   |\n26 |         while j < s.len() && s[j]\
    \ == s[i] {\n   |                                      ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<s"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut index = 0;\n    while index < s.len() {\n        let mut word = String::new();\n\
    \        let mut consonants = String::new();\n        let mut i = 0;\n       \
    \ while i < n {\n            if s[index].is_ascii_letter() {\n               \
    \ consonants += s[index];\n                i += 1;\n            } else {\n   \
    \             break;\n            }\n        }\n        words.push(consonants);\n\
    \        index += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwans1x6z.rs:20:16\n\
    \   |\n20 |             if s[index].is_ascii_letter() {\n   |                ^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwans1x6z.rs:21:31\n   |\n21 |                 consonants += s[index];\n\
    \   |                               ^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    while s.len() > 0 {\n        let mut i = 0;\n\
    \        let mut j = 0;\n        let mut found = false;\n        while !found\
    \ && i < s.len() {\n            if s[i] == ' ' {\n                i += 1;\n  \
    \              continue;\n            }\n            if s[i] == 'a' || s[i] ==\
    \ 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n                i += 1;\n\
    \                continue;\n            }\n            if s[i] == 'y' {\n    \
    \            i += 1;\n                continue;\n            }\n            if\
    \ s[i] == 's' || s[i] == 't' || s[i] == 'h' || s[i] == 'r' || s[i] == 'd' {\n\
    \                i += 1;\n                continue;\n            }\n         \
    \   if s[i] == 'n' {\n                i += 1;\n                continue;\n   \
    \         }\n            if s[i] == 'd' {\n                i += 1;\n         \
    \       found = true;\n                continue;\n            }\n            if\
    \ s[i] == 'l' || s[i] == 'm' || s[i] == 'p' || s[i] == 'f' || s[i] == 'v' {\n\
    \                i += 1;\n                found = true;\n                continue;\n\
    \            }\n            if s[i] == 'b' || s[i] == 'c' || s[i] == 'm' || s[i]\
    \ == 'a' || s[i] == 'g' {\n                i += 1;\n                found = true;\n\
    \                continue;\n            }\n            if s[i] == 'k' || s[i]\
    \ == 'h' || s[i] == 'j' || s[i] == 'r' || s[i] == 'n' {\n                i +=\
    \ 1;\n                found = true;\n                continue;\n            }\n\
    \            if s[i] == 'p' || s[i] == 't' || s[i] == 's' || s[i] == 'd' || s[i]\
    \ == 'f' || s[i] == 'v' {\n                i += 1;\n                found = true;\n\
    \                continue;\n            }\n            if s[i] == 'a' || s[i]\
    \ == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n                i +=\
    \ 1;\n                found = true;\n                continue;\n            }\n\
    \            if s[i] == 'y' {\n                i += 1;\n                found\
    \ = true;\n                continue;\n            }\n            if s[i] == 's'\
    \ || s[i] == 't' || s[i] == 'h' || s[i] == 'r' || s[i] == 'd' {\n            \
    \    i += 1;\n                found = true;\n                continue;\n     \
    \       }\n            if s[i] == 'n' {\n                i += 1;\n           \
    \     found = true;\n                continue;\n            }\n            if\
    \ s[i] == 'd' {\n                i += 1;\n                found = true;\n    \
    \            continue;\n            }\n            if s[i] == 'l' || s[i] == 'm'\
    \ || s[i] == 'p' || s[i] == 'f' || s[i] == 'v' {\n                i += 1;\n  \
    \              found = true;\n                continue;\n            }\n     \
    \       if s[i] == 'b' || s[i] == 'c' || s[i] == 'm' || s[i]\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpbk04fi02.rs:107:3\n\
    \    |\n12  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    15  |     while s.len() > 0 {\n    |                       - unclosed delimiter\n\
    ...\n19  |         while !found && i < s.len() {\n    |                      \
    \               - this delimiter might not be properly closed...\n...\n96  | }\n\
    \    | - ...as it matches this but it has different indentation\n...\n107 | }\n\
    \    |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpbk04fi02.rs:96:1\n\
    \   |\n95 |             if s[i] == 'b' || s[i] == 'c' || s[i] == 'm' || s[i]\n\
    \   |             -- this `if` expression has a condition, but no block\n96 |\
    \ }\n   | ^ expected `{`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpbk04fi02.rs:20:16\n   |\n20 |             if s[i]\
    \ == ' ' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpbk04fi02.rs:24:16\n   |\n24 |             if s[i] == 'a' || s[i]\
    \ == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n   |                ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n         "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    let mut\
    \ s = String::from(s);\n    let mut n = n as usize;\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        if s.chars().any(|c| c != ' ') {\n            result.push(s.subslice(i,\
    \ i + n));\n            i += n;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `subslice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpvjzvsl__.rs:19:27\n   |\n19 |             result.push(s.subslice(i,\
    \ i + n));\n   |                           ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.chars().all(|c| c != ' ')\
    \ {\n            list.push(s.to_string());\n            i += 1;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    list\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp726p7a31.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] != ' ' {\n            j += 1\n        }\n        if j == i\
    \ {\n            list.push(s.to_string());\n            i += 1;\n        } else\
    \ {\n            if j > i {\n                let mut k = j;\n                while\
    \ k < i && s[k] != ' ' {\n                    k += 1\n                }\n    \
    \            if k == i {\n                    list.push(s.to_string());\n    \
    \                i += 1;\n                } else {\n                    if k >\
    \ i {\n                        let mut l = k;\n                        while l\
    \ < i && s[l] != ' ' {\n                            l += 1\n                 \
    \       }\n                        if l == i {\n                            list.push(s.to_string());\n\
    \                            i += 1;\n                        } else {\n     \
    \                       if l > i {\n                                let mut m\
    \ = l;\n                                while m < i && s[m] != ' ' {\n       \
    \                             m += 1\n                                }\n    \
    \                            if m == i {\n                                   \
    \ list.push(s.to_string());\n                                    i += 1;\n   \
    \                             } else {\n                                    if\
    \ m > i {\n                                        let mut n = m;\n          \
    \                              while n < i && s[n] != ' ' {\n                \
    \                            n += 1\n                                        }\n\
    \                                        if n == i {\n                       \
    \                     list.push(s.to_string());\n                            \
    \                i += 1;\n                                        } else {\n \
    \                                           if n > i {\n                     \
    \                           let mut o = n;\n                                 \
    \               while o < i && s[o] != ' ' {\n                               \
    \                     o += 1\n                                               \
    \ }\n                                                if o == i {\n           \
    \                                         list.push(s.to_string());\n        \
    \                                            i += 1;\n                       \
    \                         } else {\n                                         \
    \           if o > i {\n                                                     \
    \   let mut p = o;\n                                                        while\
    \ p < i && s[p] != ' ' {\n                                                   \
    \         p += 1\n                                                        }\n\
    \                                                        if p == i {\n       \
    \                                                     list.push(s.to_string());\n\
    \                                                            i += 1;\n       \
    \                                                 } else {\n                 \
    \                                           if p > i {\n                     \
    \                                           let mut q = p;\n                 \
    \                                               while q < i && s[q] != ' ' {\n\
    \                                                                    q += 1\n\
    \                                                                }\n         \
    \                                                       if q == i {\n        \
    \                                                            list.push(s.to_string());\n\
    \                                                                    i += 1;\n\
    \                                                                } else {\n  \
    \                                                                  if q > i {\n\
    \                                                                        let mut\
    \ r = q;\n                                                                   \
    \     while r < i && s[r] != ' ' {\n                                         \
    \                                   r += 1\n                                 \
    \                                       }\n                                  \
    \                                                      if r == i {\n         \
    \                                                                   list.push(s.to_string());\n\
    \                                                                            i\
    \ += 1;\n                                                                    \
    \    } else {\n                                                              \
    \              if r > i {\n                                                  \
    \                              let mut s = r;\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp3xw7t9ux.rs:109:3\n\
    \    |\n12  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    15  |     while i < s.len() {\n    |                       - unclosed delimiter\n\
    ...\n23  |         } else {\n    |                - unclosed delimiter\n24  |\
    \             if j > i {\n    |                      - unclosed delimiter\n...\n\
    32  |                 } else {\n    |                        - unclosed delimiter\n\
    33  |                     if k > i {\n    |                              - unclosed\
    \ delimiter\n...\n41  |                         } else {\n    |              \
    \                  - unclosed delimiter\n42  |                             if\
    \ l > i {\n    |                                      - unclosed delimiter\n...\n\
    50  |                                 } else {\n    |                        \
    \                - unclosed delimiter\n51  |                                 \
    \    if m > i {\n    |                                              - unclosed\
    \ delimiter\n...\n59  |                                         } else {\n   \
    \ |                                                - unclosed delimiter\n60  |\
    \                                             if n > i {\n    |              \
    \                                        - unclosed delimiter\n...\n68  |    \
    \                                             } else {\n    |                \
    \                                        - unclosed delimiter\n69  |         \
    \                                            if o > i {\n    |               \
    \                                               - unclosed delimiter\n...\n77\
    \  |                                                         } else {\n    | \
    \                                                               - unclosed delimiter\n\
    78  |                                                             if p > i {\n\
    \    |                                                                      -\
    \ unclosed delimiter\n...\n86  |                                    "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n;\n    while n > 0 {\n        let\
    \ mut i = 0;\n        while i < s.len() {\n            if s.chars().any(|c| c.is_consonant()\
    \ && c != ' ') {\n                i += 1;\n            } else {\n            \
    \    break;\n            }\n        }\n        if i == s.len() {\n           \
    \ list.push(s.clone());\n            n -= 1;\n        } else {\n            s\
    \ = s.to_string().split_whitespace().collect::<Vec<_>>();\n            i += 1;\n\
    \        }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp_f9zcj88.rs:19:36\n   |\n19 |             if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                    ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_f9zcj88.rs:29:17\n\
    \   |\n14 |     let mut s = String::from(s);\n   |                 ---------------\
    \ expected due to this value\n...\n29 |             s = s.to_string().split_whitespace().collect::<Vec<_>>();\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found struct `Vec`\n   |\n   = note: expected struct `String`\n\
    \              found struct `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[i] == s[j] {\n                j += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ j == s.len() {\n            list.push(s.to_string());\n            i += 1;\n\
    \        }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpui3u62gh.rs:18:16\n\
    \   |\n18 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpui3u62gh.rs:18:24\n   |\n18 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j += 1\n        }\n        if j == i {\n     \
    \       break;\n        }\n        let mut word = String::new();\n        while\
    \ j < s.len() && s[j] == s[i] {\n            word.push(s[j]);\n            j +=\
    \ 1\n        }\n        if word.len() == n {\n            words.push(word);\n\
    \        }\n        i = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzmrtr6hf.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzmrtr6hf.rs:24:30\n   |\n24 |         while j < s.len() && s[j]\
    \ == s[i] {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzmrtr6hf.rs:24:38\n   |\n24 |         while j < s.len() && s[j]\
    \ == s[i] {\n   |                                      ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<s"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ consonants = vec![];\n    let mut vowels = vec![];\n    let mut spaces = vec![];\n\
    \    let mut letters = vec![];\n    let mut spaces_count = s.chars().filter(|c|\
    \ c == ' ').count();\n    let mut letters_count = s.chars().filter(|c| c >= 'a'\
    \ && c <= 'z').count();\n    let mut vowels_count = s.chars().filter(|c| c >=\
    \ 'A' && c <= 'Z').count();\n    let mut consonants_count = s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z').count();\n    let mut vowels_count_2\
    \ = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c ==\
    \ '_').count();\n    let mut consonants_count_2 = s.chars().filter(|c| c >= 'a'\
    \ && c <= 'z' || c >= 'A' && c <= 'Z' || c == '_' || c == '-').count();\n    let\
    \ mut vowels_count_3 = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' &&\
    \ c <= 'Z' || c == '_' || c == '-' || c == '.' || c == '-' || c == '!' || c ==\
    \ '?').count();\n    let mut consonants_count_3 = s.chars().filter(|c| c >= 'a'\
    \ && c <= 'z' || c >= 'A' && c <= 'Z' || c == '_' || c == '-' || c == '.' || c\
    \ == '-' || c == '!' || c == '?' || c == '.' || c == '-' || c == '?').count();\n\
    \    let mut vowels_count_4 = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >=\
    \ 'A' && c <= 'Z' || c == '_' || c == '-' || c == '.' || c == '-' || c == '!'\
    \ || c == '?' || c == '.' || c == '-' || c == '?' || c == '!' || c == '?' || c\
    \ == '!' || c == '?' || c == '!' || c == '?' || c == '!' || c == '?' || c == '!'\
    \ || c == '?' || c == '!' || c == '?' || c == '!' || c == '?' || c == '!' || c\
    \ == '?\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp9idj2qxf.rs:26:392\n\
    \   |\n26 | ... c == '!' || c == '?' || c == '!' || c == '?' || c == '!' || c\
    \ == '?\n   |                                                                \
    \      ^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ index = 0;\n    while index < s.len() {\n        let mut word = String::new();\n\
    \        let mut found = false;\n        for c in s.chars() {\n            if\
    \ c.is_consonant() && found == false {\n                word.push(c);\n      \
    \          found = true;\n            }\n            if found == true {\n    \
    \            if c == ' ' {\n                    word.push(c);\n              \
    \      found = false;\n                } else {\n                    found = false;\n\
    \                }\n            }\n        }\n        if found == true {\n   \
    \         if word.len() == n {\n                words.push(word);\n          \
    \  }\n        }\n        index += 1;\n    }\n    words\n}\n\nfn main() {\n   \
    \ let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpdbx0py4c.rs:19:18\n   |\n19 |             if c.is_consonant()\
    \ && found == false {\n   |                  ^^^^^^^^^^^^ method not found in\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdbx0py4c.rs:33:30\n\
    \   |\n33 |             if word.len() == n {\n   |                           \
    \   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n33 |      \
    \       if word.len() == n.try_into().unwrap() {\n   |                       \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j += 1\n        }\n        let mut word = s.split_whitespace()[j..].to_owned();\n\
    \        while j < s.len() && s[j] == ' ' {\n            j += 1\n        }\n \
    \       if j == s.len() {\n            words.push(word);\n            i += 1;\n\
    \        } else {\n            let mut count = 0;\n            while j < s.len()\
    \ && s[j] == word[0] {\n                count += 1;\n                j += 1\n\
    \            }\n            if count == n {\n                words.push(word);\n\
    \                i += 1;\n            } else {\n                i += 1;\n    \
    \        }\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcaf4pxse.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpcaf4pxse.rs:20:24\n   |\n20 |         let mut word = s.split_whitespace()[j..].to_owned();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpcaf4pxse.rs:21:30\n   |\n\
    21 |         while j < s.len() && s[j] == ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpcaf4pxse.rs:29:34\n   |\n29 |             while j < s.len() &&\
    \ s[j] == word[0] {\n   |                                  ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] != ' ' {\n            j += 1\n        }\n        let mut k\
    \ = i;\n        while k < j && s[k] != ' ' {\n            k += 1\n        }\n\
    \        if k == j {\n            list.push(s.split_whitespace()[i]);\n      \
    \      i += 1;\n        } else {\n            i += 1;\n        }\n    }\n    list\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpka82ruis.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] != ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpka82ruis.rs:21:24\n   |\n21 |         while k < j && s[k] != '\
    \ ' {\n   |                        ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpka82ruis.rs:25:23\n   |\n25 |             list.push(s.split_whitespace()[i]);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0608.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c != ' ' && c != '\\t' && c != '\\n' && c != '\\r') {\n                if s.chars().all(|c|\
    \ c != ' ' && c != '\\t' && c != '\\n' && c != '\\r') {\n                    if\
    \ s.chars().all(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\
    \ {\n                        if s.chars().all(|c| c != 'A' && c != 'E' && c !=\
    \ 'I' && c != 'O' && c != 'U') {\n                            if s.chars().all(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n              \
    \                  if s.chars().all(|c| c != 'A' && c != 'E' && c != 'I' && c\
    \ != 'O' && c != 'U') {\n                                    if s.chars().all(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n              \
    \                          if s.chars().all(|c| c != 'A' && c != 'E' && c != 'I'\
    \ && c != 'O' && c != 'U') {\n                                            if s.chars().all(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n              \
    \                                  if s.chars().all(|c| c != 'A' && c != 'E' &&\
    \ c != 'I' && c != 'O' && c != 'U') {\n                                      \
    \              if s.chars().all(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o'\
    \ && c != 'u') {\n                                                        if s.chars().all(|c|\
    \ c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n              \
    \                                              if s.chars().all(|c| c != 'a' &&\
    \ c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n                          \
    \                                      if s.chars().all(|c| c != 'A' && c != 'E'\
    \ && c != 'I' && c != 'O' && c != 'U') {\n                                   \
    \                                 if s.chars().all(|c| c != 'a' && c != 'e' &&\
    \ c != 'i' && c != 'o' && c != 'u') {\n                                      \
    \                                  if s.chars().all(|c| c != 'A' && c != 'E' &&\
    \ c != 'I' && c != 'O' && c != 'U') {\n                                      \
    \                          \n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7i49rbir.rs:47:3\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n16\
    \ |     while i < s.len() {\n   |                       - unclosed delimiter\n\
    17 |         let mut j = i;\n18 |         while j < s.len() {\n   |          \
    \                 - unclosed delimiter\n19 |             if s.chars().any(|c|\
    \ c != ' ' && c != '\\t' && c != '\\n' && c != '\\r') {\n   |                \
    \                                                                   - unclosed\
    \ delimiter\n20 |                 if s.chars().all(|c| c != ' ' && c != '\\t'\
    \ && c != '\\n' && c != '\\r') {\n   |                                       \
    \                                                - unclosed delimiter\n21 |  \
    \                   if s.chars().all(|c| c != 'a' && c != 'e' && c != 'i' && c\
    \ != 'o' && c != 'u') {\n   |                                                \
    \                                                    - unclosed delimiter\n22\
    \ |                         if s.chars().all(|c| c != 'A' && c != 'E' && c !=\
    \ 'I' && c != 'O' && c != 'U') {\n   |                                       \
    \                                                                 - unclosed delimiter\n\
    23 |                             if s.chars().all(|c| c != 'a' && c != 'e' &&\
    \ c != 'i' && c != 'o' && c != 'u') {\n   |                                  \
    \                                                                          - unclosed\
    \ delimiter\n24 |                                 if s.chars().all(|c| c != 'A'\
    \ && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n   |                   \
    \                                                                            \
    \                 - unclosed delimiter\n25 |                                 \
    \    if s.chars().all(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c !=\
    \ 'u') {\n   |                                                               \
    \                                                     - unclosed delimi"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c| c != ' ' &&\
    \ c != '\\n' && c != '\\t' && c != '\\r' && c != '\\b') {\n            list.push(s.to_string());\n\
    \            i += 1;\n        }\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: unknown character escape: `b`\n  --> /tmp/tmpnlpe9xif.rs:16:88\n\
    \   |\n16 |         if s.chars().any(|c| c != ' ' && c != '\\n' && c != '\\t'\
    \ && c != '\\r' && c != '\\b') {\n   |                                       \
    \                                                 ^ unknown character escape\n\
    \   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n16 |         if s.chars().any(|c|\
    \ c != ' ' && c != '\\n' && c != '\\t' && c != '\\r' && c != r\"\\b\") {\n   |\
    \                                                                            \
    \          ~~~~~\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() && s[j] == ' ' {\n            j\
    \ += 1\n        }\n        if j == i {\n            break;\n        }\n      \
    \  let mut k = i;\n        while k < j && s[k] == ' ' {\n            k += 1\n\
    \        }\n        if k == j {\n            break;\n        }\n        if n ==\
    \ j - k + 1 {\n            result.push(s.split_whitespace()[k..j].collect::<Vec<_>>());\n\
    \        }\n        i = k + 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm9tao0k8.rs:18:30\n\
    \   |\n18 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpm9tao0k8.rs:25:24\n   |\n25 |         while k < j && s[k] == '\
    \ ' {\n   |                        ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm9tao0k8.rs:31:17\n\
    \   |\n31 |         if n == j - k + 1 {\n   |                 ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n31 |         if n == (j\
    \ - k + 1).try_into().unwrap() {\n   |                 +         +++++++++++++++++++++\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpm9tao0k8.rs:32:25\n   |\n32 |             result.push(s.split_whitespace()[k..j].collect::<Vec<_>>());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome e"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() && s[j] == ' ' {\n            j\
    \ = j + 1;\n        }\n        let mut k = i;\n        while k < s.len() && s[k]\
    \ != ' ' {\n            k = k + 1;\n        }\n        if k == i {\n         \
    \   list.push(s.subslice(i, j));\n            i = j;\n        } else {\n     \
    \       i = k;\n        }\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwrcuj3r6.rs:18:30\n\
    \   |\n18 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwrcuj3r6.rs:22:30\n   |\n22 |         while k < s.len() && s[k]\
    \ != ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `subslice` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpwrcuj3r6.rs:26:25\n   |\n26 |          \
    \   list.push(s.subslice(i, j));\n   |                         ^^^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as usize;\n    while n != 0 {\n\
    \        if s.contains(&consonants[n % consonants.len()]) {\n            result.push(s.clone());\n\
    \        }\n        n /= consonants.len();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `consonants` in this scope\n  --> /tmp/tmp7y617s3z.rs:17:24\n\
    \   |\n17 |         if s.contains(&consonants[n % consonants.len()]) {\n   | \
    \                       ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `consonants` in this scope\n  --> /tmp/tmp7y617s3z.rs:17:39\n   |\n\
    17 |         if s.contains(&consonants[n % consonants.len()]) {\n   |        \
    \                               ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `consonants` in this scope\n  --> /tmp/tmp7y617s3z.rs:20:14\n\
    \   |\n20 |         n /= consonants.len();\n   |              ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ count = 0;\n    let mut last = 0;\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        if s.chars().nth(i).unwrap().is_consonant() {\n            count\
    \ += 1;\n            if count == n {\n                last = i;\n            }\n\
    \        }\n        i += 1;\n    }\n    if count > n {\n        words.extend_from_slice(&s[last..]);\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpvtv2dq2y.rs:18:38\n   |\n18 |         if s.chars().nth(i).unwrap().is_consonant()\
    \ {\n   |                                      ^^^^^^^^^^^^ method not found in\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvtv2dq2y.rs:27:33\n\
    \   |\n27 |         words.extend_from_slice(&s[last..]);\n   |               \
    \                  ^^^^^^^^^^ expected slice, found `str`\n   |\n   = note: expected\
    \ reference `&[_]`\n              found reference `&str`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() && s[j] == ' ' {\n            j += 1\n        }\n        let mut word\
    \ = s.split_whitespace()[j..].to_owned();\n        if word.len() == n {\n    \
    \        words.push(word);\n        }\n        i = j;\n    }\n    words\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy50tm441.rs:17:30\n\
    \   |\n17 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpy50tm441.rs:20:24\n   |\n20 |         let mut word = s.split_whitespace()[j..].to_owned();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0608.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
