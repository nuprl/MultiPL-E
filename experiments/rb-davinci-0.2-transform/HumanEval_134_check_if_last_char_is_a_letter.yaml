name: HumanEval_134_check_if_last_char_is_a_letter
language: rb
prompt: "# Create a function that returns True if the last character\n# of a given\
  \ string is an alphabetical character and is not\n# a part of a word, and False\
  \ otherwise.\n# Note: \"word\" is a group of characters separated by space.\n# Examples:\n\
  # >>> check_if_last_char_is_a_letter.call(\"apple pie\")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"\
  apple pi e\")\n# true\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e \"\
  )\n# false\n# >>> check_if_last_char_is_a_letter.call(\"\")\n# false\ndef check_if_last_char_is_a_letter(txt)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_if_last_char_is_a_letter\n\
  \    candidate = method(:check_if_last_char_is_a_letter)\n    assert_equal(false,\
  \ candidate.call(\"apple\"))\n    assert_equal(true, candidate.call(\"apple pi e\"\
  ))\n    assert_equal(false, candidate.call(\"eeeee\"))\n    assert_equal(true, candidate.call(\"\
  A\"))\n    assert_equal(false, candidate.call(\"Pumpkin pie \"))\n    assert_equal(false,\
  \ candidate.call(\"Pumpkin pie 1\"))\n    assert_equal(false, candidate.call(\"\"\
  ))\n    assert_equal(false, candidate.call(\"eeeee e \"))\n    assert_equal(false,\
  \ candidate.call(\"apple pie\"))\n    assert_equal(false, candidate.call(\"apple\
  \ pi e \"))\n  end\nend\n"
completions: ["  if txt.length == 0\n    return false\n  end\n  if txt[-1] =~ /[a-zA-Z]/\
    \ && txt[-2] =~ /\\s/\n    return true\n  else\n    return false\n  end\nend",
  "  if txt.empty?\n    return false\n  end\n  if txt[-1] =~ /[a-zA-Z]/\n    if txt[-2]\
    \ =~ /[a-zA-Z]/\n      return false\n    else\n      return true\n    end\n  else\n\
    \    return false\n  end\nend", "  txt.strip.split(\" \").last.match(/[a-zA-Z]/)\
    \ ? true : false\nend", "  txt.split(\" \").last.match(/[a-zA-Z]/) ? true : false\n\
    end", "  return false if txt.empty?\n  return false if txt[-1] == \" \"\n  return\
    \ true if txt[-1] =~ /[a-zA-Z]/\n  false\nend", "  return false if txt.empty?\n\
    \  txt.split(\" \").last.match(/[a-zA-Z]/) ? true : false\nend", "  if txt.empty?\n\
    \    false\n  elsif txt[-1] =~ /[a-zA-Z]/\n    true\n  else\n    false\n  end\n\
    end", "  txt.split(\" \").last.match(/[a-zA-Z]/) ? true : false\nend", "  if txt.empty?\n\
    \    return false\n  end\n  if txt[-1] =~ /[[:alpha:]]/\n    if txt[-2] =~ /[[:space:]]/\n\
    \      return true\n    end\n  end\n  return false\nend", "  # TODO: implement\
    \ this function\nend", "  return false if txt.empty?\n  return false if txt.split(\"\
    \ \").last.length > 1\n  txt.split(\" \").last.match(/[a-zA-Z]/) ? true : false\n\
    end", "  if txt.empty?\n    return false\n  end\n  if txt[-1] =~ /[[:alpha:]]/\n\
    \    return true\n  end\n  return false\nend", "  # TODO: implement this function\n\
    end", "  if txt.length == 0\n    return false\n  end\n  if txt[-1] =~ /[a-zA-Z]/\n\
    \    if txt[-2] =~ /[a-zA-Z]/\n      return false\n    else\n      return true\n\
    \    end\n  else\n    return false\n  end\nend", "  txt.split(\" \").last.match(/[a-zA-Z]$/)\
    \ ? true : false\nend", "  # TODO: implement this function\nend", "  txt.split(\"\
    \ \").last.match(/[a-zA-Z]/).nil? ? false : true\nend", "  return false if txt.empty?\n\
    \  last_char = txt[-1]\n  last_char =~ /[a-zA-Z]/ && !(txt =~ /\\s#{last_char}$/)\n\
    end", "  # TODO: Implement this function\nend", "  txt.split(\" \").last.match(/[a-zA-Z]/).nil?\
    \ ? false : true\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
