name: HumanEval_129_minPath
language: rb
prompt: "# Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n# each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n# inclusive appears exactly once on the cells of the grid.\n# You have\
  \ to find the minimum path of length k in the grid. You can start\n# from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n# in other words,\
  \ you can go to cells which share an edge with you current\n# cell.\n# Please note\
  \ that a path of length k means visiting exactly k cells (not\n# necessarily distinct).\n\
  # You CANNOT go off the grid.\n# A path A (of length k) is considered less than\
  \ a path B (of length k) if\n# after making the ordered lists of the values on the\
  \ cells that A and B go\n# through (let's call them lst_A and lst_B), lst_A is lexicographically\
  \ less\n# than lst_B, in other words, there exist an integer index i (1 <= i <=\
  \ k)\n# such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n# lst_A[j]\
  \ = lst_B[j].\n# It is guaranteed that the answer is unique.\n# Return an ordered\
  \ list of the values on the cells that the minimum path go through.\n# Examples:\
  \    \n# >>> minPath.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\n# [1, 2, 1]\n#\
  \ >>> minPath.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n# [1]\ndef minPath(grid,\
  \ k)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minPath\n\
  \    candidate = method(:minPath)\n    assert_equal([1, 2, 1], candidate.call([[1,\
  \ 2, 3], [4, 5, 6], [7, 8, 9]], 3))\n    assert_equal([1], candidate.call([[5, 9,\
  \ 3], [4, 1, 6], [7, 8, 2]], 1))\n    assert_equal([1, 2, 1, 2], candidate.call([[1,\
  \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4))\n    assert_equal([1,\
  \ 10, 1, 10, 1, 10, 1], candidate.call([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11,\
  \ 15], [8, 14, 9, 2]], 7))\n    assert_equal([1, 7, 1, 7, 1], candidate.call([[8,\
  \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5))\n    assert_equal([1,\
  \ 6, 1, 6, 1, 6, 1, 6, 1], candidate.call([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3,\
  \ 15, 6], [12, 13, 10, 1]], 9))\n    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1, 6,\
  \ 1, 6], candidate.call([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8,\
  \ 7, 2]], 12))\n    assert_equal([1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[2, 7,\
  \ 4], [3, 1, 5], [6, 8, 9]], 8))\n    assert_equal([1, 5, 1, 5, 1, 5, 1, 5], candidate.call([[6,\
  \ 1, 5], [3, 8, 9], [2, 7, 4]], 8))\n    assert_equal([1, 2, 1, 2, 1, 2, 1, 2, 1,\
  \ 2], candidate.call([[1, 2], [3, 4]], 10))\n    assert_equal([1, 3, 1, 3, 1, 3,\
  \ 1, 3, 1, 3], candidate.call([[1, 3], [3, 2]], 10))\n  end\nend\n"
completions: ["  # Write your code here\nend", "  # Write your code here\nend", " \
    \ # Write your code here\nend", "  # Write your code here\nend", "  # Write your\
    \ code here\nend", "  # Write your code here\nend", "  # Write your code here\n\
    end", "  # Write your code here\nend", "  # Write your code here\nend", "  # Write\
    \ your code here\nend", "  # Write your code here\nend", "  # Write your code\
    \ here\nend", "  # Write your code here\nend", "  # Write your code here\nend",
  "  # Write your code here\nend", "  # Write your code here\nend", "  # Your code\
    \ here\nend", "  # Write your code here\nend", "  # Write your code here\nend",
  "  # Write your code here\nend", "  # Write your code here\nend", "  # Write your\
    \ code here\nend", "  # Write your code here\nend", "  # Write your code here\n\
    end", "    # Write your code here\nend", "  # Write your code here\nend", "  #\
    \ Write your code here\nend", "  n = grid.length\n  m = grid[0].length\n  min_path\
    \ = []\n  min_sum = n * m * n * m\n  for i in 0...n\n    for j in 0...m\n    \
    \  path = []\n      sum = 0\n      dfs(grid, i, j, k, path, sum)\n      if sum\
    \ < min_sum\n        min_sum = sum\n        min_path = path\n      end\n    end\n\
    \  end\n  min_path\nend", "  # Write your code here\nend", "  n = grid.length\n\
    \  return [] if n == 0\n  return [] if k == 0\n  return [grid[0][0]] if k == 1\n\
    \  return [] if k > n * n\n  # dp[i][j][k] = min path of length k starting from\
    \ grid[i][j]\n  dp = Array.new(n) { Array.new(n) { Array.new(k + 1) } }\n  # dp[i][j][1]\
    \ = grid[i][j]\n  (0...n).each do |i|\n    (0...n).each do |j|\n      dp[i][j][1]\
    \ = grid[i][j]\n    end\n  end\n  # dp[i][j][k] = min(dp[i - 1][j][k - 1], dp[i\
    \ + 1][j][k - 1], dp[i][j - 1][k - 1], dp[i][j + 1][k - 1])\n  (2..k).each do\
    \ |l|\n    (0...n).each do |i|\n      (0...n).each do |j|\n        dp[i][j][l]\
    \ = [dp[i - 1][j][l - 1], dp[i + 1][j][l - 1], dp[i][j - 1][l - 1], dp[i][j +\
    \ 1][l - 1]].min\n      end\n    end\n  end\n  # find the minimum path of length\
    \ k\n  min_path = []\n  min_value = Float::INFINITY\n  (0...n).each do |i|\n \
    \   (0...n).each do |j|\n      if dp[i][j][k] < min_value\n        min_path =\
    \ [i, j]\n        min_value = dp[i][j][k]\n      end\n    end\n  end\n  # backtrack\
    \ to find the path\n  path = []\n  (k - 1).downto(1) do |l|\n    path << min_path\n\
    \    min_path = next_step(dp, min_path, l)\n  end\n  path <<", "  # Write your\
    \ code here\nend", "  # Write your code here\nend", "  # Write your code here\n\
    end", "  # Write your code here\nend", "  # Write your code here\nend", "  # Write\
    \ your code here\nend", "  # Write your code here\nend", "  n = grid.length\n\
    \  m = grid[0].length\n  # dp[i][j][l] is the minimum path of length l starting\
    \ from cell (i, j).\n  dp = Array.new(n) { Array.new(m) { Array.new(k + 1) } }\n\
    \  # Initialize the dp table.\n  (0...n).each do |i|\n    (0...m).each do |j|\n\
    \      dp[i][j][1] = [grid[i][j]]\n    end\n  end\n  # Fill the dp table.\n  (2..k).each\
    \ do |l|\n    (0...n).each do |i|\n      (0...m).each do |j|\n        dp[i][j][l]\
    \ = []\n        # Try all the neighbors.\n        [[i - 1, j], [i + 1, j], [i,\
    \ j - 1], [i, j + 1]].each do |x, y|\n          if x >= 0 && x < n && y >= 0 &&\
    \ y < m\n            # If the neighbor is smaller, update the minimum path.\n\
    \            if dp[x][y][l - 1] && (dp[i][j][l].empty? || dp[x][y][l - 1] < dp[i][j][l])\n\
    \              dp[i][j][l] = dp[x][y][l - 1]\n            end\n          end\n\
    \        end\n        # Add the current cell to the path.\n        dp[i][j][l]\
    \ << grid[i][j] if dp[i][j][l]\n      end\n    end\n  end\n  # Find the minimum\
    \ path.\n  min_path = []\n  (0...n).each do |i|\n    (0...m).each do |j|\n   \
    \   if min_path.empty? || dp[i][j][k] < min_path\n        min_path = dp[i][j][k]\n\
    \      end\n    end\n  end\n  min_path\nend", "  # write your code in Ruby 2.2\n\
    end", "  # Write your code here\nend", "  # Write your code here\nend", "  # Write\
    \ your code here\nend", "  # Write your code here\nend", "    # Write your code\
    \ here\nend", "  # Write your code here\nend", "  # Write your code here\nend",
  "  # Write your code here\nend", "  # Write your code here\nend", "  # Write your\
    \ code here\nend", "  # Write your code here\nend", "  n = grid.length\n  # Initialize\
    \ the minimum path to be the first cell.\n  min_path = [grid[0][0]]\n  # Initialize\
    \ the minimum path sum to be the first cell.\n  min_path_sum = grid[0][0]\n  #\
    \ Initialize the current path to be the first cell.\n  curr_path = [grid[0][0]]\n\
    \  # Initialize the current path sum to be the first cell.\n  curr_path_sum =\
    \ grid[0][0]\n  # Initialize the current cell to be the first cell.\n  curr_cell\
    \ = [0, 0]\n  # Initialize the current path length to be 1.\n  curr_path_length\
    \ = 1\n  # Initialize the stack to be empty.\n  stack = []\n  # Push the current\
    \ cell to the stack.\n  stack.push(curr_cell)\n  # While the stack is not empty.\n\
    \  while !stack.empty?\n    # Pop the top cell from the stack.\n    curr_cell\
    \ = stack.pop\n    # If the current path length is greater than k, then continue.\n\
    \    if curr_path_length > k\n      next\n    end\n    # If the current path length\
    \ is equal to k, then check if the current\n    # path is less than the minimum\
    \ path.\n    if curr_path_length == k\n      if curr_path < min_path\n       \
    \ min_path = curr_path.dup\n      end\n      next\n    end\n    # For each of\
    \ the 4 neighbor cells of the current cell.\n    for i in 0..3\n      # Initialize\
    \ the neighbor cell.\n      neighbor_cell = []\n      # If the neighbor cell is\
    \ the top cell.\n      if i == 0\n        # If the current cell is the top row,\
    \ then continue.\n        if curr_cell[0] == 0\n          next\n        end\n\
    \        # Set the neighbor cell to be the top cell.\n        neighbor_cell =\
    \ [curr_cell[0] - 1, curr_cell[1]]\n      # If the neighbor cell is the bottom\
    \ cell.\n      elsif i == 1\n        # If the current cell is the bottom row,",
  "  # Write your code here\nend", "  # Write your code here\nend", "  # Write your\
    \ code here\nend", "  # Write your code here\nend", "  # Write your code here\n\
    end", "  # Write your code here\nend", "  # Write your code here\nend", "  n =\
    \ grid.length\n  # The following is a very naive solution.\n  # It is O(n^2 *\
    \ k) in time and O(n^2 * k) in space.\n  # It is not hard to see that the time\
    \ complexity can be improved to O(n^2 * k * log(k)).\n  # However, it is not clear\
    \ how to improve the space complexity.\n  # The following solution is O(n^2 *\
    \ k) in time and O(n^2 * k) in space.\n  # It is not hard to see that the time\
    \ complexity can be improved to O(n^2 * k * log(k)).\n  # However, it is not clear\
    \ how to improve the space complexity.\n  # The following solution is O(n^2 *\
    \ k) in time and O(n^2 * k) in space.\n  # It is not hard to see that the time\
    \ complexity can be improved to O(n^2 * k * log(k)).\n  # However, it is not clear\
    \ how to improve the space complexity.\n  # The following solution is O(n^2 *\
    \ k) in time and O(n^2 * k) in space.\n  # It is not hard to see that the time\
    \ complexity can be improved to O(n^2 * k * log(k)).\n  # However, it is not clear\
    \ how to improve the space complexity.\n  # The following solution is O(n^2 *\
    \ k) in time and O(n^2 * k) in space.\n  # It is not hard to see that the time\
    \ complexity can be improved to O(n^2 * k * log(k)).\n  # However, it is not clear\
    \ how to improve the space complexity.\n  # The following solution is O(n^2 *\
    \ k) in time and O(n^2 * k) in space.\n  # It is not hard to see that the time\
    \ complexity can be improved to O(n^2 * k * log(k)).\n  # However, it is not clear\
    \ how to improve the space complexity.\n  # The following solution is O(n^2 *\
    \ k) in time and O(n^2 * k) in space.\n  # It is not hard to see that the time\
    \ complexity can be improved to O(n^2 *", "  # Your code here\nend", "  # Write\
    \ your code here\nend", "  # Write your code here\nend", "  # Write your code\
    \ here\nend", "  # Write your code here\nend", "  # Write your code here\nend",
  "  # Write your code here\nend", "  # Write your code here\nend", "  # Write your\
    \ code here\nend", "  # Write your code here\nend", "  n = grid.length\n  m =\
    \ grid[0].length\n  # dp[i][j][k] is the minimum path of length k starting from\
    \ cell (i, j)\n  dp = Array.new(n) { Array.new(m) { Array.new(k + 1) } }\n  #\
    \ Initialize the base case\n  (0...n).each do |i|\n    (0...m).each do |j|\n \
    \     dp[i][j][1] = [grid[i][j]]\n    end\n  end\n  # Fill the table\n  (2..k).each\
    \ do |l|\n    (0...n).each do |i|\n      (0...m).each do |j|\n        # Initialize\
    \ the minimum path\n        dp[i][j][l] = []\n        # Check the neighbors\n\
    \        [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]].each do |x, y|\n   \
    \       # Check if the neighbor is inside the grid\n          if x >= 0 && x <\
    \ n && y >= 0 && y < m\n            # Check if the neighbor has a path of length\
    \ l - 1\n            if dp[x][y][l - 1].length > 0\n              # Check if the\
    \ current path is less than the minimum path\n              if dp[i][j][l].length\
    \ == 0 ||\n                 dp[i][j][l] > dp[x][y][l - 1] + [grid[i][j]]\n   \
    \             # Update the minimum path\n                dp[i][j][l] = dp[x][y][l\
    \ - 1] + [grid[i][j]]\n              end\n            end\n          end\n   \
    \     end\n      end\n    end\n  end\n  # Find the minimum path\n  min_path =\
    \ []\n  (0...n).each do |i|\n    (0...m).each do |j|\n      if min_path.length\
    \ == 0 || min_path > dp[i][j][k]\n        min_path = dp[i][j][k]\n      end\n\
    \    end\n  end\n  min_path\nend", "  # Write your code here\nend", "  # Write\
    \ your code here\nend", "  # Write your code here\nend", "  # Your code here\n\
    end", "  # Write your code here\nend", "  # Write your code here\nend", "  # Write\
    \ your code here\nend", "  # Write your code here\nend", "  # Write your code\
    \ here\nend", "  # Write your code here\nend", "  # Write your code here\nend",
  "  # Write your code here\nend", "  # Write your code here\nend", "  # Write your\
    \ code here\nend", "  # Write your code here\nend", "  # Write your code here\n\
    end", "  # Write your code here\nend", "  # Write your code here\nend", "  # your\
    \ code here\nend", "  # Write your code here\nend", "  # Write your code here\n\
    end", "  # Write your code here\nend", "  # Write your code here\nend", "  # Write\
    \ your code here\nend", "  # Write your code here\nend", "  # Write your code\
    \ here\nend", "  # Write your code here\nend", "  # Write your code here\nend",
  "  # Write your code here\nend", "  # Write your code here\nend", "  # Write your\
    \ code here\nend", "  # Write your code here\nend", "  # Write your code here\n\
    end", "  # Write your code here\nend", "  # Write your code here\nend", "  # Write\
    \ your code here\nend", "    # Write your code here\n    # To print results to\
    \ the standard output you can use puts\n    # Example: puts \"Hello world!\"\n\
    end", "    n = grid.length\n    return [] if n == 0\n    return [] if k == 0\n\
    \    return [] if k > n * n\n    return grid[0] if k == 1\n    return grid[0]\
    \ if k == n\n    return grid[0] if k == n * n\n    # dp[i][j][l] means the minimum\
    \ path of length l starting from cell (i, j)\n    dp = Array.new(n) { Array.new(n)\
    \ { Array.new(k + 1) { [] } } }\n    # initialize dp[i][j][1]\n    for i in 0...n\n\
    \        for j in 0...n\n            dp[i][j][1] = [grid[i][j]]\n        end\n\
    \    end\n    # initialize dp[i][j][2]\n    for i in 0...n\n        for j in 0...n\n\
    \            dp[i][j][2] = [grid[i][j]]\n            dp[i][j][2] += [grid[i][j\
    \ + 1]] if j + 1 < n\n            dp[i][j][2] += [grid[i][j - 1]] if j - 1 >=\
    \ 0\n            dp[i][j][2] += [grid[i + 1][j]] if i + 1 < n\n            dp[i][j][2]\
    \ += [grid[i - 1][j]] if i - 1 >= 0\n            dp[i][j][2].sort!\n        end\n\
    \    end\n    # dp\n    for l in 3..k\n        for i in 0...n\n            for\
    \ j in 0...n\n                dp[i][j][l] = [grid[i][j]]\n                dp[i][j][l]\
    \ += dp[i][j + 1][l - 1] if j + 1 < n\n                dp[i][j][l] += dp[i][j\
    \ - 1][l - 1] if j - 1 >= 0\n                dp[i][j][l] += dp[i + 1][j][l - 1]\
    \ if i + 1 < n\n                dp[i][j][l] += dp[", "  # Write your code here\n\
    end", "  # Write your code here\nend", "  # your code here\nend", "  # Write your\
    \ code here\nend", "  # Write your code here\nend", "  # Write your code here\n\
    end", "  # Write your code here\nend", "  # Write your code here\nend", "  # Write\
    \ your code here\nend", "  # Write your code here\nend", "  # Write your code\
    \ here\nend", "  # Write your code here\nend", "  # Write your code here\nend",
  "  # your code here\nend", "  # Write your code here\nend", "  # Write your code\
    \ here\nend", "  n = grid.length\n  m = grid[0].length\n  min_path = []\n  min_sum\
    \ = n * m * n * m\n  (0...n).each do |i|\n    (0...m).each do |j|\n      path\
    \ = []\n      sum = 0\n      k.times do |l|\n        path << grid[i][j]\n    \
    \    sum += grid[i][j]\n        if i > 0 && grid[i - 1][j] < grid[i][j]\n    \
    \      i -= 1\n        elsif i < n - 1 && grid[i + 1][j] < grid[i][j]\n      \
    \    i += 1\n        elsif j > 0 && grid[i][j - 1] < grid[i][j]\n          j -=\
    \ 1\n        elsif j < m - 1 && grid[i][j + 1] < grid[i][j]\n          j += 1\n\
    \        end\n      end\n      if sum < min_sum\n        min_path = path\n   \
    \     min_sum = sum\n      end\n    end\n  end\n  min_path\nend", "  # Write your\
    \ code here\nend", "  # Write your code here\nend", "  # Write your code here\n\
    end", "  n = grid.length\n  return [] if n < 2 || k < 1\n  return [grid[0][0]]\
    \ if k == 1\n  return [grid[0][0], grid[0][1]] if k == 2\n  return [grid[0][0],\
    \ grid[1][0]] if k == 2\n  return [grid[0][0], grid[0][1], grid[0][2]] if k ==\
    \ 3\n  return [grid[0][0], grid[1][0], grid[2][0]] if k == 3\n  return [grid[0][0],\
    \ grid[0][1], grid[1][1]] if k == 3\n  return [grid[0][0], grid[1][0], grid[1][1]]\
    \ if k == 3\n  return [grid[0][0], grid[0][1], grid[1][0]] if k == 3\n  return\
    \ [grid[0][0], grid[1][0], grid[1][1], grid[1][2]] if k == 4\n  return [grid[0][0],\
    \ grid[0][1], grid[1][1], grid[2][1]] if k == 4\n  return [grid[0][0], grid[1][0],\
    \ grid[1][1], grid[1][2]] if k == 4\n  return [grid[0][0], grid[1][0], grid[1][1],\
    \ grid[2][1]] if k == 4\n  return [grid[0][0], grid[0][1], grid[1][1], grid[1][2]]\
    \ if k == 4\n  return [grid[0][0], grid[1][0], grid[1][1], grid[2][1], grid[2][2]]\
    \ if k == 5\n  return [grid[0][0], grid[0][1], grid[1][1], grid[1][2], grid[2][2]]\
    \ if k == 5\n  return [grid[0][0], grid[1][0], grid[1][1], grid[1][2], grid[2][2]]\
    \ if k == 5\n  return [grid[0][0], grid[1][0], grid[1][1], grid[2][1], grid[2][2]]\
    \ if", "  # Write your code here\nend", "  # Write your code here\nend", "  #\
    \ Write your code here\nend", "  # Write your code here\nend", "  # Write your\
    \ code here\nend", "  # Write your code here\nend", "  # Write your code here\n\
    end", "  # Write your code here\nend", "  # Write your code here\nend", "  # Write\
    \ your code here\nend", "  # Write your code here\nend", "  # Write your code\
    \ here\nend", "  # Write your code here\nend", "  # Write your code here\nend",
  "  # Write your code here\nend", "  # Write your code here\nend", "  # Write your\
    \ code here\nend", "  # Write your code here\nend", "  # Write your code here\n\
    end", "  # Write your code here\nend", "  # Write your code here\nend", "  # Write\
    \ your code here\nend", "  # Write your code here\nend", "  # Write your code\
    \ here\nend", "  # Write your code here\nend", "  # TODO: Implement\nend", " \
    \ # Write your code here\nend", "  # Write your code here\nend", "  # Write your\
    \ code here\nend", "  # Write your code here\nend", "  # Write your code here\n\
    end", "  # Write your code here\nend", "  # Your code here\nend", "  # Write your\
    \ code here\nend", "  # Write your code here\nend", "  # Write your code here\n\
    end", "  # Write your code here\nend", "  # Write your code here\nend", "  # Write\
    \ your code here\nend", "  # Implement your solution here\nend", "  # Write your\
    \ code here\nend", "  # Write your code here\nend", "  # Write your code here\n\
    end", "  # Write your code here\nend", "  # Write your code here\nend", "  # Write\
    \ your code here\nend", "  # Write your code here\nend", "  # Write your code\
    \ here\nend", "  # Write your code here\nend", "  # Write your code here\nend",
  "  n = grid.length\n  return [] if n == 0\n  m = grid[0].length\n  return [] if\
    \ m == 0\n  return [] if k == 0\n  return [] if k > n * m\n  return [grid[0][0]]\
    \ if k == 1\n  # Find the minimum path of length k - 1.\n  min_path = minPath(grid,\
    \ k - 1)\n  # Find the cell that the last element of min_path is on.\n  last_cell\
    \ = nil\n  grid.each_with_index do |row, i|\n    row.each_with_index do |elem,\
    \ j|\n      if elem == min_path[-1]\n        last_cell = [i, j]\n        break\n\
    \      end\n    end\n    break if last_cell\n  end\n  # Find the minimum neighbor\
    \ of last_cell.\n  min_neighbor = nil\n  min_neighbor_value = nil\n  [[-1, 0],\
    \ [1, 0], [0, -1], [0, 1]].each do |delta|\n    i = last_cell[0] + delta[0]\n\
    \    j = last_cell[1] + delta[1]\n    if i >= 0 && i < n && j >= 0 && j < m\n\
    \      if !min_neighbor || grid[i][j] < min_neighbor_value\n        min_neighbor\
    \ = [i, j]\n        min_neighbor_value = grid[i][j]\n      end\n    end\n  end\n\
    \  # Add the value of min_neighbor to min_path.\n  min_path << min_neighbor_value\n\
    \  min_path\nend", "  # Write your code here\nend", "  # Write your code here\n\
    end", "  # Write your code here\nend", "  # Write your code here\nend", "  # Write\
    \ your code here\nend", "  # Write your code here\nend", "  # Write your code\
    \ here\nend", "  # Write your code here\nend", "  # Write your code here\nend",
  "  # Write your code here\nend", "  # Write your code here\nend", "  # Write your\
    \ code here\nend", "  # Write your code here\nend", "  # Write your code here\n\
    end", "  # Write your code here\nend", "  # Write your code here\nend", "  # Write\
    \ your code here\nend", "  # Write your code here\nend", "  # Write your code\
    \ here\nend", "  # Write your code here\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
