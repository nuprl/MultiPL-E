name: HumanEval_111_histogram
language: rb
prompt: "# Given a string representing a space separated lowercase letters, return\
  \ a dictionary\n# of the letter with the most repetition and containing the corresponding\
  \ count.\n# If several letters have the same occurrence, return all of them.\n#\
  \ Example:\n# >>> histogram.call(\"a b c\")\n# {\"a\" => 1, \"b\" => 1, \"c\" =>\
  \ 1}\n# >>> histogram.call(\"a b b a\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"\
  a b c a b\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"b b b b a\")\n\
  # {\"b\" => 4}\n# >>> histogram.call(\"\")\n# {}\ndef histogram(test)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_histogram\n\
  \    candidate = method(:histogram)\n    assert_equal({\"a\" => 2, \"b\" => 2},\
  \ candidate.call(\"a b b a\"))\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"\
  a b c a b\"))\n    assert_equal({\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1,\
  \ \"g\" => 1}, candidate.call(\"a b c d g\"))\n    assert_equal({\"r\" => 1, \"\
  t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({\"b\" => 4},\
  \ candidate.call(\"b b b b a\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\"\
  \ => 1}, candidate.call(\"r t g\"))\n    assert_equal({}, candidate.call(\"\"))\n\
  \    assert_equal({\"a\" => 1}, candidate.call(\"a\"))\n  end\nend\n"
completions: ["  test.split(\" \").inject(Hash.new(0)) { |h,v| h[v] += 1; h }.select\
    \ { |k,v| v == test.split(\" \").inject(Hash.new(0)) { |h,v| h[v] += 1; h }.values.max\
    \ }\nend", "  test.split(\" \").group_by{|x| x}.map{|k,v| [k, v.size]}.to_h\n\
    end", "  test.split(\" \").group_by{|x| x}.map{|k,v| [k, v.size]}.to_h\nend",
  "  histogram = Hash.new(0)\n  test.split.each { |word| histogram[word] += 1 }\n\
    \  histogram\nend", "  # your code here\nend", "  test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.select { |k, v| v == test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.values.max }\nend", "  letters = test.split(\" \")\n\
    \  letter_count = Hash.new(0)\n  letters.each do |letter|\n    letter_count[letter]\
    \ += 1\n  end\n  letter_count\nend", "  test.split(\" \").group_by{|x| x}.map{|k,v|\
    \ [k, v.size]}.to_h\nend", "  letters = test.split(\" \")\n  counts = Hash.new(0)\n\
    \  letters.each { |letter| counts[letter] += 1 }\n  counts\nend", "  test.split(\"\
    \ \").group_by{|x| x}.map{|k,v| [k, v.size]}.to_h\nend", "  test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.max_by { |k, v| v }\nend", "  histogram = Hash.new(0)\n\
    \  test.split(\" \").each { |word| histogram[word] += 1 }\n  histogram\nend",
  "  test.split(\" \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.select { |k, v|\
    \ v == test.split(\" \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.values.max\
    \ }\nend", "  test.split(\" \").group_by{|i| i}.map{|k,v| [k, v.size]}.to_h\n\
    end", "  test.split(\" \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.select\
    \ { |k, v| v == test.split(\" \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.values.max\
    \ }\nend", "  test.split(\" \").group_by { |x| x }.map { |k, v| [k, v.size] }.to_h\n\
    end", "  test.split(\" \").group_by { |x| x }.map { |k, v| [k, v.size] }.to_h\n\
    end", "  test.split.each_with_object(Hash.new(0)) { |word, counts| counts[word]\
    \ += 1 }\nend", "  test.split(\" \").group_by{|x| x}.map{|k,v| [k, v.size]}.to_h\n\
    end", "  if test.empty?\n    return {}\n  else\n    test = test.split(\" \")\n\
    \    test = test.group_by{|x| x}\n    test = test.map{|k,v| [k,v.length]}\n  \
    \  test = test.to_h\n    test = test.sort_by{|k,v| v}.reverse.to_h\n    test =\
    \ test.select{|k,v| v == test.values[0]}\n    return test\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
