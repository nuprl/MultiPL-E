name: HumanEval_98_count_upper
language: rb
prompt: "# Given a string s, count the number of uppercase vowels in even indices.\n\
  # For example:\n# >>> count_upper.call(\"aBCdEf\")\n# 1\n# >>> count_upper.call(\"\
  abcdefg\")\n# 0\n# >>> count_upper.call(\"dBBE\")\n# 0\ndef count_upper(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_upper\n\
  \    candidate = method(:count_upper)\n    assert_equal(1, candidate.call(\"aBCdEf\"\
  ))\n    assert_equal(0, candidate.call(\"abcdefg\"))\n    assert_equal(0, candidate.call(\"\
  dBBE\"))\n    assert_equal(0, candidate.call(\"B\"))\n    assert_equal(1, candidate.call(\"\
  U\"))\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(2, candidate.call(\"\
  EEEE\"))\n  end\nend\n"
completions: ["  s.chars.select.with_index { |c, i| c =~ /[AEIOU]/ && i.even? }.count\n\
    end", "  s.split(\"\").each_with_index.count { |char, index| char =~ /[AEIOU]/\
    \ && index.even? }\nend", "  s.split(\"\").select.with_index { |x, i| x =~ /[AEIOU]/\
    \ && i.even? }.size\nend", "  s.chars.select.with_index { |c, i| c =~ /[AEIOU]/\
    \ && i.even? }.count\nend", "  count = 0\n  s.each_char.with_index do |char, index|\n\
    \    if index.even? && char =~ /[AEIOU]/\n      count += 1\n    end\n  end\n \
    \ count\nend", "  s.split(\"\").map.with_index { |x, i| x if i.even? && x =~ /[AEIOU]/\
    \ }.compact.count\nend", "  s.split(\"\").each_with_index.count { |x, i| x =~\
    \ /[AEIOU]/ && i.even? }\nend", "  s.split(\"\").map.with_index { |char, i| char\
    \ if i.even? && char =~ /[AEIOU]/ }.compact.count\nend", "  s.split(\"\").select.with_index\
    \ { |x, i| x =~ /[AEIOU]/ && i.even? }.size\nend", "  s.split(\"\").select.with_index\
    \ { |letter, index| letter.upcase == letter && index.even? }.count\nend", "  s.chars.each_with_index.reduce(0)\
    \ do |acc, (char, index)|\n    acc += 1 if char =~ /[AEIOU]/ && index.even?\n\
    \    acc\n  end\nend", "  s.split(\"\").select.with_index { |x, i| x =~ /[AEIOU]/\
    \ && i.even? }.count\nend", "  count = 0\n  s.split(\"\").each_with_index do |char,\
    \ i|\n    if i.even? && char =~ /[AEIOU]/\n      count += 1\n    end\n  end\n\
    \  count\nend", "  s.split(\"\").select.with_index { |x, i| x =~ /[AEIOU]/ &&\
    \ i.even? }.count\nend", "  s.split(\"\").each_with_index.count { |char, i| char.upcase\
    \ == char && i.even? }\nend", "  s.split(\"\").each_with_index.map { |x, i| x\
    \ if i.even? && x =~ /[AEIOU]/ }.compact.count\nend", "  s.chars.each_with_index.count\
    \ { |char, index| char =~ /[AEIOU]/ && index.even? }\nend", "  s.split(\"\").each_with_index.count\
    \ { |c, i| c =~ /[AEIOU]/ && i.even? }\nend", "  s.chars.map.with_index { |c,\
    \ i| c if i.even? && c =~ /[AEIOU]/ }.compact.count\nend", "  s.split(\"\").each_with_index.count\
    \ { |char, index| char =~ /[AEIOU]/ && index.even? }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
