name: HumanEval_93_encode
language: rb
prompt: "# Write a function that takes a message, and encodes in such a \n# way that\
  \ it swaps case of all letters, replaces all vowels in \n# the message with the\
  \ letter that appears 2 places ahead of that \n# vowel in the english alphabet.\
  \ \n# Assume only letters. \n# Examples:\n# >>> encode.call(\"test\")\n# \"TGST\"\
  \n# >>> encode.call(\"This is a message\")\n# \"tHKS KS C MGSSCGG\"\ndef encode(message)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encode\n\
  \    candidate = method(:encode)\n    assert_equal(\"tgst\", candidate.call(\"TEST\"\
  ))\n    assert_equal(\"mWDCSKR\", candidate.call(\"Mudasir\"))\n    assert_equal(\"\
  ygs\", candidate.call(\"YES\"))\n    assert_equal(\"tHKS KS C MGSSCGG\", candidate.call(\"\
  This is a message\"))\n    assert_equal(\"k dQnT kNqW wHcT Tq wRkTg\", candidate.call(\"\
  I DoNt KnOw WhAt tO WrItE\"))\n  end\nend\n"
completions: ["  message.downcase.tr('aeiou', 'eioua')\nend", "  vowels = ['a', 'e',\
    \ 'i', 'o', 'u']\n  encoded_message = \"\"\n  message.each_char do |char|\n  \
    \  if vowels.include?(char.downcase)\n      encoded_message += (char.ord + 2).chr\n\
    \    else\n      encoded_message += char.swapcase\n    end\n  end\n  encoded_message\n\
    end", "  # TODO: Implement this method\nend", "  message.downcase.tr('aeiou',\
    \ 'eioua')\nend", "  # TODO: implement this function\nend", "  message.downcase.tr('aeiou',\
    \ 'eioua')\nend", "  message.downcase.tr(\"a-z\", \"c-za-b\")\nend", "  message.chars.map\
    \ do |char|\n    if char.match(/[a-z]/i)\n      if char.match(/[aeiou]/i)\n  \
    \      char = char.next.next\n      else\n        char = char.next\n      end\n\
    \    end\n    char.upcase\n  end.join\nend", "  message.downcase.tr('aeiou', 'eioua')\n\
    end", "\tmessage.downcase.tr(\"aeiou\", \"eioau\")\nend", "  message.downcase.tr('aeiou',\
    \ 'eioau')\nend", "  message.split(\"\").map do |letter|\n    if letter.match(/[aeiou]/i)\n\
    \      letter.next.next\n    else\n      letter.swapcase\n    end\n  end.join\n\
    end", "  message.chars.map do |char|\n    if char.match(/[aeiou]/i)\n      char\
    \ = char.next.next\n    else\n      char = char.swapcase\n    end\n  end.join\n\
    end", "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  encoded_message = \"\"\
    \n  message.each_char do |char|\n    if vowels.include?(char.downcase)\n     \
    \ encoded_message += vowels[(vowels.index(char.downcase) + 2) % 5]\n    elsif\
    \ char == char.upcase\n      encoded_message += char.downcase\n    else\n    \
    \  encoded_message += char.upcase\n    end\n  end\n  encoded_message\nend", " \
    \ message.chars.map do |char|\n    if char.match(/[aeiou]/i)\n      char.next.next\n\
    \    else\n      char.swapcase\n    end\n  end.join\nend", "  vowels = \"aeiou\"\
    \n  message.downcase.chars.map do |char|\n    if vowels.include?(char)\n     \
    \ vowels[(vowels.index(char) + 2) % 5]\n    else\n      char\n    end\n  end.join.upcase\n\
    end", "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  encoded_message = \"\"\
    \n  message.each_char do |char|\n    if vowels.include?(char.downcase)\n     \
    \ encoded_message += next_vowel(char)\n    else\n      encoded_message += char.swapcase\n\
    \    end\n  end\n  encoded_message\nend", "  vowels = %w(a e i o u)\n  letters\
    \ = message.split('')\n  letters.map! do |letter|\n    if vowels.include?(letter.downcase)\n\
    \      letter = letter.next.next\n    else\n      letter.swapcase\n    end\n \
    \ end\n  letters.join\nend", "  message.downcase.tr('aeiou', 'cdfghjklmnpqrstvwxyzab')\n\
    end", "  # your code here\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
