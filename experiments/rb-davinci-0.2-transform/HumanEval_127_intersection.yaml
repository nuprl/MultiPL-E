name: HumanEval_127_intersection
language: rb
prompt: "# You are given two intervals,\n# where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n# The given intervals are closed\
  \ which means that the interval (start, end)\n# includes both start and end.\n#\
  \ For each given interval, it is assumed that its start is less or equal its end.\n\
  # Your task is to determine whether the length of intersection of these two \n#\
  \ intervals is a prime number.\n# Example, the intersection of the intervals (1,\
  \ 3), (2, 4) is (2, 3)\n# which its length is 1, which not a prime number.\n# If\
  \ the length of the intersection is a prime number, return \"YES\",\n# otherwise,\
  \ return \"NO\".\n# If the two intervals don't intersect, return \"NO\".\n# [input/output]\
  \ samples:\n# >>> intersection.call([1, 2], [2, 3])\n# \"NO\"\n# >>> intersection.call([-1,\
  \ 1], [0, 4])\n# \"NO\"\n# >>> intersection.call([-3, -1], [-5, 5])\n# \"YES\"\n\
  def intersection(interval1, interval2)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersection\n\
  \    candidate = method(:intersection)\n    assert_equal(\"NO\", candidate.call([1,\
  \ 2], [2, 3]))\n    assert_equal(\"NO\", candidate.call([-1, 1], [0, 4]))\n    assert_equal(\"\
  YES\", candidate.call([-3, -1], [-5, 5]))\n    assert_equal(\"YES\", candidate.call([-2,\
  \ 2], [-4, 0]))\n    assert_equal(\"NO\", candidate.call([-11, 2], [-1, -1]))\n\
  \    assert_equal(\"NO\", candidate.call([1, 2], [3, 5]))\n    assert_equal(\"NO\"\
  , candidate.call([1, 2], [1, 2]))\n    assert_equal(\"NO\", candidate.call([-2,\
  \ -2], [-3, -2]))\n  end\nend\n"
completions: ["  if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n \
    \   return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n  finish\
    \ = [interval1[1], interval2[1]].min\n  if start == finish\n    return \"NO\"\n\
    \  end\n  if is_prime(finish - start)\n    return \"YES\"\n  else\n    return\
    \ \"NO\"\n  end\nend", "  start = [interval1[0], interval2[0]].max\n  finish =\
    \ [interval1[1], interval2[1]].min\n  return \"NO\" if start > finish\n  return\
    \ \"YES\" if (start..finish).count.prime?\n  \"NO\"\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n  return \"\
    NO\" if start > ending\n  return \"YES\" if (start..ending).size.prime?\n  \"\
    NO\"\nend", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  return \"NO\" if start > finish\n  return \"YES\" if start\
    \ == finish\n  (start..finish).count.prime? ? \"YES\" : \"NO\"\nend", "  start\
    \ = [interval1[0], interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n\
    \  return \"NO\" if start > ending\n  return \"YES\" if (start..ending).count.prime?\n\
    \  \"NO\"\nend", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  return \"NO\" if start > finish\n  return \"YES\" if (start..finish).count.prime?\n\
    \  \"NO\"\nend", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  return \"NO\" if start > finish\n  return \"YES\" if prime?(finish\
    \ - start + 1)\n  \"NO\"\nend", "  intersection = [interval1[0], interval2[0]].max..[interval1[1],\
    \ interval2[1]].min\n  intersection.size == 1 ? \"NO\" : prime?(intersection.size)\
    \ ? \"YES\" : \"NO\"\nend", "  start = [interval1[0], interval2[0]].max\n  finish\
    \ = [interval1[1], interval2[1]].min\n  return \"NO\" if start > finish\n  return\
    \ \"YES\" if start == finish\n  return \"NO\" if (start..finish).to_a.size.prime?\n\
    \  \"YES\"\nend", "  if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n\
    \    return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n  finish\
    \ = [interval1[1], interval2[1]].min\n  if start == finish\n    return \"NO\"\n\
    \  end\n  if (start..finish).to_a.length.prime?\n    return \"YES\"\n  else\n\
    \    return \"NO\"\n  end\nend", "  # your code here\nend", "  start1, end1 =\
    \ interval1\n  start2, end2 = interval2\n  if start1 > end2 || start2 > end1\n\
    \    return \"NO\"\n  end\n  start = [start1, start2].max\n  finish = [end1, end2].min\n\
    \  if start > finish\n    return \"NO\"\n  end\n  if prime?(finish - start + 1)\n\
    \    return \"YES\"\n  else\n    return \"NO\"\n  end\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  return \"\
    NO\" if start > finish\n  return \"YES\" if start == finish\n  return \"NO\" if\
    \ finish - start == 1\n  (2..Math.sqrt(finish - start)).each do |i|\n    return\
    \ \"NO\" if (finish - start) % i == 0\n  end\n  \"YES\"\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  return \"\
    NO\" if start > finish\n  return \"YES\" if start == finish\n  return \"NO\" if\
    \ (start..finish).count.prime?\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  ending = [interval1[1], interval2[1]].min\n  return \"NO\" if ending < start\n\
    \  return \"YES\" if (ending - start + 1).prime?\n  \"NO\"\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  return \"\
    NO\" if start > finish\n  return \"YES\" if (start..finish).size.prime?\n  \"\
    NO\"\nend", "  start = [interval1[0], interval2[0]].max\n  ending = [interval1[1],\
    \ interval2[1]].min\n  return \"NO\" if start > ending\n  return \"YES\" if (start..ending).to_a.length.prime?\n\
    \  \"NO\"\nend", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  return \"NO\" if start > finish\n  return \"YES\" if (start..finish).count.prime?\n\
    \  \"NO\"\nend", "  # your code here\nend", "  # your code here\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
