name: HumanEval_6_parse_nested_parens
language: rb
prompt: "# Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n# For each of the group, output the deepest\
  \ level of nesting of parentheses.\n# E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n# >>> parse_nested_parens.call(\"(()()) ((())) () ((())()())\"\
  )\n# [2, 3, 1, 3]\ndef parse_nested_parens(paren_string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_nested_parens\n\
  \    candidate = method(:parse_nested_parens)\n    assert_equal([2, 3, 1, 3], candidate.call(\"\
  (()()) ((())) () ((())()())\"))\n    assert_equal([1, 2, 3, 4], candidate.call(\"\
  () (()) ((())) (((())))\"))\n    assert_equal([4], candidate.call(\"(()(())((())))\"\
  ))\n  end\nend\n"
completions: ["  paren_string.split(\" \").map do |paren_group|\n    paren_group.chars.reduce(0)\
    \ do |max_level, char|\n      if char == \"(\"\n        max_level += 1\n     \
    \ elsif char == \")\"\n        max_level -= 1\n      end\n      max_level\n  \
    \  end\n  end\nend", "  # TODO: Implement this function\nend", "  paren_string.split(\"\
    \ \").map { |paren_group| paren_group.scan(/\\(/).count }\nend", "  paren_string.split(\"\
    \ \").map do |paren_group|\n    paren_group.chars.reduce(0) do |max_nesting, char|\n\
    \      if char == \"(\"\n        max_nesting + 1\n      elsif char == \")\"\n\
    \        max_nesting - 1\n      else\n        max_nesting\n      end\n    end\n\
    \  end\nend", "  paren_string.split.map do |paren_group|\n    paren_group.chars.reduce(0)\
    \ do |max_nesting, char|\n      case char\n      when '('\n        max_nesting\
    \ + 1\n      when ')'\n        max_nesting - 1\n      else\n        max_nesting\n\
    \      end\n    end\n  end\nend", "  paren_string.split(' ').map do |paren_group|\n\
    \    paren_group.chars.reduce(0) do |max_depth, char|\n      if char == '('\n\
    \        max_depth += 1\n      elsif char == ')'\n        max_depth -= 1\n   \
    \   end\n      max_depth\n    end\n  end\nend", "  paren_string.split(\" \").map\
    \ do |paren_group|\n    paren_group.chars.reduce(0) do |max_depth, char|\n   \
    \   if char == \"(\"\n        max_depth += 1\n      elsif char == \")\"\n    \
    \    max_depth -= 1\n      end\n      max_depth\n    end\n  end\nend", "  paren_string.split(\"\
    \ \").map { |paren_group|\n    paren_group.chars.reduce(0) { |max_depth, char|\n\
    \      if char == \"(\"\n        max_depth + 1\n      elsif char == \")\"\n  \
    \      max_depth - 1\n      else\n        max_depth\n      end\n    }\n  }\nend",
  "  paren_string.split(\" \").map do |paren_group|\n    paren_group.chars.reduce(0)\
    \ do |acc, char|\n      if char == \"(\"\n        acc += 1\n      elsif char ==\
    \ \")\"\n        acc -= 1\n      end\n      acc\n    end\n  end\nend", "  paren_string.split.map\
    \ { |paren_group| paren_group.count('(') }\nend", "  paren_string.split(\" \"\
    ).map { |paren_group|\n    paren_group.chars.reduce(0) { |max_level, char|\n \
    \     if char == \"(\"\n        max_level + 1\n      elsif char == \")\"\n   \
    \     max_level - 1\n      else\n        max_level\n      end\n    }\n  }\nend",
  "  paren_string.split(\" \").map { |group|\n    group.chars.reduce(0) { |max_level,\
    \ char|\n      if char == \"(\"\n        max_level + 1\n      elsif char == \"\
    )\"\n        max_level - 1\n      else\n        max_level\n      end\n    }\n\
    \  }\nend", "  paren_string.split.map do |paren_group|\n    paren_group.chars.reduce(0)\
    \ do |max_nesting, char|\n      if char == '('\n        max_nesting + 1\n    \
    \  elsif char == ')'\n        max_nesting - 1\n      else\n        max_nesting\n\
    \      end\n    end\n  end\nend", "  paren_string.split(\" \").map { |paren_group|\n\
    \    paren_group.chars.reduce(0) { |max_nesting, char|\n      if char == \"(\"\
    \n        max_nesting + 1\n      elsif char == \")\"\n        max_nesting - 1\n\
    \      else\n        max_nesting\n      end\n    }\n  }\nend", "  paren_string.split.map\
    \ { |paren_group| paren_group.count('(') }\nend", "  paren_string.split(' ').map\
    \ do |paren_group|\n    paren_group.chars.reduce(0) do |max_nesting, char|\n \
    \     if char == '('\n        max_nesting + 1\n      elsif char == ')'\n     \
    \   max_nesting - 1\n      else\n        max_nesting\n      end\n    end\n  end\n\
    end", "  paren_string.split(\" \").map { |paren_group|\n    paren_group.chars.reduce(0)\
    \ { |max_level, char|\n      char == \"(\" ? max_level + 1 : max_level - 1\n \
    \   }\n  }\nend", "  paren_string.split(\" \").map { |paren_group|\n    max_depth\
    \ = 0\n    current_depth = 0\n    paren_group.each_char do |char|\n      if char\
    \ == \"(\"\n        current_depth += 1\n        max_depth = current_depth if current_depth\
    \ > max_depth\n      elsif char == \")\"\n        current_depth -= 1\n      end\n\
    \    end\n    max_depth\n  }\nend", "  paren_string.split.map do |paren_group|\n\
    \    paren_group.chars.reduce(0) do |max_depth, char|\n      if char == '('\n\
    \        max_depth + 1\n      elsif char == ')'\n        max_depth - 1\n     \
    \ else\n        max_depth\n      end\n    end\n  end\nend", "  paren_string.split.map\
    \ do |paren_group|\n    paren_group.chars.reduce(0) do |max_depth, char|\n   \
    \   if char == '('\n        max_depth + 1\n      elsif char == ')'\n        max_depth\
    \ - 1\n      else\n        max_depth\n      end\n    end\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
