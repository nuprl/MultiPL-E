{
  "language": "rb",
  "name": "HumanEval_20_find_closest_elements",
  "results": [
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_diff = numbers[1] - numbers[0]\n  closest_pair = [numbers[0], numbers[1]]\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    diff = number - numbers[index - 1]\n    if diff < closest_diff\n      closest_diff = diff\n      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpnauw2mwv\nStarted\n.\nFinished in 0.000469382 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2130.46 tests/s, 10652.30 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_distance\n      closest_pair = [numbers[index - 1], number]\n      closest_distance = (number - numbers[index - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp1m9cxi1h\nStarted\n.\nFinished in 0.00045887 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2179.27 tests/s, 10896.33 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  # TODO: implement this method\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    difference = (number - numbers[index - 1]).abs\n    if difference < closest_difference\n      closest_difference = difference\n      closest_elements = [numbers[index - 1], number]\n    end\n  end\n  closest_elements\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpainsenh_\nStarted\n.\nFinished in 0.000472429 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2116.72 tests/s, 10583.60 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).to_a.min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpigr3g6os\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpigr3g6os.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007820749 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n127.86 tests/s, 255.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    distance = (number - numbers[index - 1]).abs\n    if distance < closest_distance\n      closest_distance = distance\n      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpzvn5k7xo\nStarted\n.\nFinished in 0.000460729 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2170.47 tests/s, 10852.37 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    if (num - numbers[i - 1]).abs < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = (num - numbers[i - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp2hk12q4y\nStarted\n.\nFinished in 0.000440772 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2268.75 tests/s, 11343.73 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_distance\n      closest_pair = [numbers[index - 1], number]\n      closest_distance = (number - numbers[index - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp1m9cxi1h\nStarted\n.\nFinished in 0.00045887 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2179.27 tests/s, 10896.33 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  (numbers.length - 1).times do |i|\n    diff = (numbers[i + 1] - numbers[i]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i], numbers[i + 1]]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpymtre51p\nStarted\n.\nFinished in 0.000446899 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2237.64 tests/s, 11188.21 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    distance = (num - numbers[index - 1]).abs\n    if distance < closest_distance\n      closest_distance = distance\n      closest_pair = [numbers[index - 1], num]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpc8a1jrig\nStarted\n.\nFinished in 0.00046163 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2166.24 tests/s, 10831.19 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |n, i|\n    next if i == 0\n    diff = (numbers[i] - numbers[i-1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i-1], numbers[i]]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp81e_blzx\nStarted\n.\nFinished in 0.000474104 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2109.24 tests/s, 10546.21 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  # TODO: implement this method\n  numbers.sort!\n  closest_elements = []\n  closest_difference = numbers[1] - numbers[0]\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    difference = number - numbers[index - 1]\n    if difference < closest_difference\n      closest_difference = difference\n      closest_elements = [numbers[index - 1], number]\n    end\n  end\n  closest_elements\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpvwnboh_p\nStarted\n.\nFinished in 0.000455981 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2193.07 tests/s, 10965.37 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    if (num - numbers[i - 1]).abs < closest_distance\n      closest_pair = [numbers[i - 1], num]\n      closest_distance = (num - numbers[i - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpw4328hc2\nStarted\n.\nFinished in 0.00047369 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2111.09 tests/s, 10555.43 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    distance = (number - numbers[index - 1]).abs\n    if distance < closest_distance\n      closest_distance = distance\n      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpzvn5k7xo\nStarted\n.\nFinished in 0.000460729 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2170.47 tests/s, 10852.37 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  min_diff = Float::INFINITY\n  closest_elements = []\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = num - numbers[index - 1]\n    if diff < min_diff\n      min_diff = diff\n      closest_elements = [numbers[index - 1], num]\n    end\n  end\n  closest_elements\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpc_2axtl9\nStarted\n.\nFinished in 0.000444744 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2248.48 tests/s, 11242.42 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    diff = (number - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], number]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpdwg4f9et\nStarted\n.\nFinished in 0.000472081 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2118.28 tests/s, 10591.40 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_distance\n      closest_distance = (number - numbers[index - 1]).abs\n      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp03pufh23\nStarted\n.\nFinished in 0.000461655 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2166.12 tests/s, 10830.60 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_cons(2) do |pair|\n    diff = (pair[1] - pair[0]).abs\n    if diff < closest_diff\n      closest_pair = pair\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp1osx5iay\nStarted\n.\nFinished in 0.000448655 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2228.88 tests/s, 11144.42 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = (numbers[1] - numbers[0]).abs\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuvqscdq2.rb:12: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpuvqscdq2.rb:21: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_distance\n      closest_distance = (number - numbers[index - 1]).abs\n      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp03pufh23\nStarted\n.\nFinished in 0.000461655 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2166.12 tests/s, 10830.60 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_diff = numbers[1] - numbers[0]\n  closest_pair = [numbers[0], numbers[1]]\n  numbers.each_with_index do |number, index|\n    if index < numbers.length - 1\n      diff = numbers[index + 1] - number\n      if diff < closest_diff\n        closest_diff = diff\n        closest_pair = [number, numbers[index + 1]]\n      end\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp0ho191g6\nStarted\n.\nFinished in 0.000455745 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2194.21 tests/s, 10971.05 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_diff = (numbers[1] - numbers[0]).abs\n  closest_pair = [numbers[0], numbers[1]]\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_diff = diff\n      closest_pair = [numbers[i - 1], num]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpsjx1vsap\nStarted\n.\nFinished in 0.000523061 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1911.82 tests/s, 9559.11 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    if (num - numbers[i - 1]).abs < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = (num - numbers[i - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp2hk12q4y\nStarted\n.\nFinished in 0.000440772 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2268.75 tests/s, 11343.73 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    if (num - numbers[index - 1]).abs < closest_distance\n      closest_distance = (num - numbers[index - 1]).abs\n      closest_pair = [numbers[index - 1], num]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpa83a0kt4\nStarted\n.\nFinished in 0.000486467 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2055.64 tests/s, 10278.19 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    if (num - numbers[i - 1]).abs < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = (num - numbers[i - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp2hk12q4y\nStarted\n.\nFinished in 0.000440772 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2268.75 tests/s, 11343.73 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = (numbers[1] - numbers[0]).abs\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuvqscdq2.rb:12: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpuvqscdq2.rb:21: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    distance = (number - numbers[index - 1]).abs\n    if distance < closest_distance\n      closest_distance = distance\n      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpzvn5k7xo\nStarted\n.\nFinished in 0.000460729 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2170.47 tests/s, 10852.37 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = []\n  closest_difference = numbers[1] - numbers[0]\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    difference = number - numbers[index - 1]\n    if difference < closest_difference\n      closest_difference = difference\n      closest_elements = [numbers[index - 1], number]\n    end\n  end\n  closest_elements\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp1xx36i9j\nStarted\n.\nFinished in 0.000460976 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2169.31 tests/s, 10846.55 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = []\n  closest_diff = numbers[1] - numbers[0]\n  numbers.each_with_index do |number, index|\n    if index < numbers.length - 1\n      diff = numbers[index + 1] - number\n      if diff < closest_diff\n        closest_diff = diff\n        closest_pair = [number, numbers[index + 1]]\n      end\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpcallc1xi\nStarted\n.\nFinished in 0.000515703 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1939.10 tests/s, 9695.50 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_diff = numbers[1] - numbers[0]\n  closest_pair = [numbers[0], numbers[1]]\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    if (num - numbers[index - 1]) < closest_diff\n      closest_diff = num - numbers[index - 1]\n      closest_pair = [numbers[index - 1], num]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmptclnk9xa\nStarted\n.\nFinished in 0.000491542 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2034.41 tests/s, 10172.07 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  # TODO: implement this method\n  numbers.sort!\n  min_diff = (numbers[1] - numbers[0]).abs\n  min_pair = [numbers[0], numbers[1]]\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    diff = (number - numbers[index - 1]).abs\n    if diff < min_diff\n      min_diff = diff\n      min_pair = [numbers[index - 1], number]\n    end\n  end\n  min_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpl9uy69kd\nStarted\n.\nFinished in 0.000529203 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1889.63 tests/s, 9448.17 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = numbers[1] - numbers[0]\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    diff = number - numbers[index - 1]\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], number]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpt1vbr5rg\nStarted\n.\nFinished in 0.000475514 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2102.99 tests/s, 10514.94 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).map { |a, b| [a, b, (a - b).abs] }.min_by { |a, b, c| c }[0..1]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp3b_uc4so\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmp3b_uc4so.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.009385956 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n106.54 tests/s, 213.08 assertions/s\n",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).map { |a, b| [a, b, (a - b).abs] }.min_by { |a, b, diff| diff }[0..1]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpv54l9etl\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpv54l9etl.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.008320197 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n120.19 tests/s, 240.38 assertions/s\n",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_distance\n      closest_pair = [numbers[index - 1], number]\n      closest_distance = (number - numbers[index - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp1m9cxi1h\nStarted\n.\nFinished in 0.00045887 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2179.27 tests/s, 10896.33 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_diff = numbers[1] - numbers[0]\n  closest_pair = [numbers[0], numbers[1]]\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    diff = number - numbers[index - 1]\n    if diff < closest_diff\n      closest_diff = diff\n      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpnauw2mwv\nStarted\n.\nFinished in 0.000469382 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2130.46 tests/s, 10652.30 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    diff = (number - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], number]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpdwg4f9et\nStarted\n.\nFinished in 0.000472081 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2118.28 tests/s, 10591.40 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_distance\n      closest_pair = [numbers[index - 1], number]\n      closest_distance = (number - numbers[index - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp1m9cxi1h\nStarted\n.\nFinished in 0.00045887 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2179.27 tests/s, 10896.33 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_difference = numbers[1] - numbers[0]\n  closest_elements = [numbers[0], numbers[1]]\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    difference = number - numbers[index - 1]\n    if difference < closest_difference\n      closest_difference = difference\n      closest_elements = [numbers[index - 1], number]\n    end\n  end\n  closest_elements\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp4tsdagjb\nStarted\n.\nFinished in 0.000460366 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2172.18 tests/s, 10860.92 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  (numbers.length - 1).times do |i|\n    diff = (numbers[i + 1] - numbers[i]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i], numbers[i + 1]]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpymtre51p\nStarted\n.\nFinished in 0.000446899 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2237.64 tests/s, 11188.21 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).to_a.min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpigr3g6os\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpigr3g6os.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007820749 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n127.86 tests/s, 255.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).map { |a, b| [a, b, (a - b).abs] }.sort_by { |a, b, c| c }.first[0..1]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp_s0e79fj\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmp_s0e79fj.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.010415106 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n96.01 tests/s, 192.03 assertions/s\n",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).map { |a, b| [a, b, (a - b).abs] }.sort_by { |a, b, c| c }.first[0..1]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp_s0e79fj\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmp_s0e79fj.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.010415106 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n96.01 tests/s, 192.03 assertions/s\n",
      "timestamp": 1659799041
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    if (num - numbers[i - 1]).abs < closest_distance\n      closest_pair = [numbers[i - 1], num]\n      closest_distance = (num - numbers[i - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpw4328hc2\nStarted\n.\nFinished in 0.00047369 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2111.09 tests/s, 10555.43 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = (numbers[1] - numbers[0]).abs\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuvqscdq2.rb:12: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpuvqscdq2.rb:21: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_distance\n      closest_distance = (number - numbers[index - 1]).abs\n      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp03pufh23\nStarted\n.\nFinished in 0.000461655 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2166.12 tests/s, 10830.60 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = (numbers[1] - numbers[0]).abs\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuvqscdq2.rb:12: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpuvqscdq2.rb:21: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = (numbers[1] - numbers[0]).abs\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuvqscdq2.rb:12: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpuvqscdq2.rb:21: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = (numbers[1] - numbers[0]).abs\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuvqscdq2.rb:12: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpuvqscdq2.rb:21: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = closest_elements[1] - closest_elements[0]\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    difference = number - numbers[index - 1]\n    if difference < closest_difference\n      closest_elements = [numbers[index - 1], number]\n      closest_difference = difference\n    end\n  end\n  closest_elements\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpebgph00f\nStarted\n.\nFinished in 0.000536558 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1863.73 tests/s, 9318.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = numbers[1] - numbers[0]\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    difference = number - numbers[index - 1]\n    if difference < closest_difference\n      closest_difference = difference\n      closest_elements = [numbers[index - 1], number]\n    end\n  end\n  closest_elements\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp4yltq89g\nStarted\n.\nFinished in 0.000478476 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2089.97 tests/s, 10449.84 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_distance\n      closest_distance = (number - numbers[index - 1]).abs\n      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp03pufh23\nStarted\n.\nFinished in 0.000461655 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2166.12 tests/s, 10830.60 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  (0..numbers.length-2).each do |i|\n    diff = (numbers[i+1] - numbers[i]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i], numbers[i+1]]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpsb30rjo1\nStarted\n.\nFinished in 0.000500376 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1998.50 tests/s, 9992.49 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).map { |a, b| [a, b, (a - b).abs] }.min_by { |a, b, diff| diff }[0..1]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpv54l9etl\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpv54l9etl.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.008320197 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n120.19 tests/s, 240.38 assertions/s\n",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).to_a.min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpigr3g6os\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpigr3g6os.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007820749 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n127.86 tests/s, 255.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == numbers.length - 1\n    diff = (numbers[i + 1] - num).abs\n    if diff < closest_diff\n      closest_pair = [num, numbers[i + 1]]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp0lwcuczw\nStarted\n.\nFinished in 0.000457895 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2183.91 tests/s, 10919.53 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |x, y| (x - y).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmphimx6snn\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmphimx6snn.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.008668104 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n115.37 tests/s, 230.73 assertions/s\n",
      "timestamp": 1659799041
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).map { |a, b| [a, b, (a - b).abs] }.sort_by(&:last).first(2)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp5yvma93y\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmp5yvma93y.rb:14:in `test_find_closest_elements'\n     11: class TestHumanEval < Test::Unit::TestCase\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n  => 14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n     15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n<[3.9, 4.0]> expected but was\n<[[3.9, 4.0, 0.10000000000000009], [2.0, 2.2, 0.20000000000000018]]>\n\ndiff:\n? [[3.9, 4.0, 0.10000000000000009], [2.0, 2.2, 0.20000000000000018]]\n===============================================================================\n\nFinished in 0.009483212 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n105.45 tests/s, 105.45 assertions/s\n",
      "timestamp": 1659799041
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_distance\n      closest_pair = [numbers[index - 1], number]\n      closest_distance = (number - numbers[index - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp1m9cxi1h\nStarted\n.\nFinished in 0.00045887 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2179.27 tests/s, 10896.33 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_distance\n      closest_pair = [numbers[index - 1], number]\n      closest_distance = (number - numbers[index - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp1m9cxi1h\nStarted\n.\nFinished in 0.00045887 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2179.27 tests/s, 10896.33 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  (numbers.length - 1).times do |i|\n    diff = (numbers[i + 1] - numbers[i]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i], numbers[i + 1]]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpymtre51p\nStarted\n.\nFinished in 0.000446899 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2237.64 tests/s, 11188.21 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  (0..numbers.length-2).each do |i|\n    diff = (numbers[i+1] - numbers[i]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i], numbers[i+1]]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpsb30rjo1\nStarted\n.\nFinished in 0.000500376 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1998.50 tests/s, 9992.49 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_distance\n      closest_pair = [numbers[index - 1], number]\n      closest_distance = (number - numbers[index - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp1m9cxi1h\nStarted\n.\nFinished in 0.00045887 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2179.27 tests/s, 10896.33 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    distance = (number - numbers[index - 1]).abs\n    if distance < closest_distance\n      closest_distance = distance\n      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpzvn5k7xo\nStarted\n.\nFinished in 0.000460729 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2170.47 tests/s, 10852.37 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_distance = numbers[1] - numbers[0]\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    distance = number - numbers[index - 1]\n    if distance < closest_distance\n      closest_distance = distance\n      closest_elements = [numbers[index - 1], number]\n    end\n  end\n  closest_elements\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpr76d4p_z\nStarted\n.\nFinished in 0.000430441 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2323.20 tests/s, 11615.99 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = (numbers[1] - numbers[0]).abs\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuvqscdq2.rb:12: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpuvqscdq2.rb:21: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    distance = (number - numbers[index - 1]).abs\n    if distance < closest_distance\n      closest_distance = distance\n      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpzvn5k7xo\nStarted\n.\nFinished in 0.000460729 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2170.47 tests/s, 10852.37 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    distance = (number - numbers[index - 1]).abs\n    if distance < closest_distance\n      closest_distance = distance\n      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpzvn5k7xo\nStarted\n.\nFinished in 0.000460729 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2170.47 tests/s, 10852.37 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    diff = (number - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], number]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpdwg4f9et\nStarted\n.\nFinished in 0.000472081 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2118.28 tests/s, 10591.40 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).to_a.min_by { |x, y| (x - y).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpbq_wldht\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpbq_wldht.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007597499 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.62 tests/s, 263.24 assertions/s\n",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    if (num - numbers[i - 1]).abs < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = (num - numbers[i - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp2hk12q4y\nStarted\n.\nFinished in 0.000440772 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2268.75 tests/s, 11343.73 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).map { |a, b| [a, b, (a - b).abs] }.sort_by { |a, b, c| c }.first[0..1]\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmp_s0e79fj\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmp_s0e79fj.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.010415106 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n96.01 tests/s, 192.03 assertions/s\n",
      "timestamp": 1659799041
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_diff\n      closest_pair = [numbers[index - 1], number]\n      closest_diff = (number - numbers[index - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpp1nblqdo\nStarted\n.\nFinished in 0.00051563 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1939.38 tests/s, 9696.88 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = (numbers[1] - numbers[0]).abs\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuvqscdq2.rb:12: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpuvqscdq2.rb:21: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_distance\n      closest_pair = [numbers[index - 1], number]\n      closest_distance = (number - numbers[index - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp1m9cxi1h\nStarted\n.\nFinished in 0.00045887 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2179.27 tests/s, 10896.33 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    distance = (number - numbers[index - 1]).abs\n    if distance < closest_distance\n      closest_distance = distance\n      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpzvn5k7xo\nStarted\n.\nFinished in 0.000460729 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2170.47 tests/s, 10852.37 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = numbers[1] - numbers[0]\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    difference = numbers[index] - numbers[index - 1]\n    if difference < closest_difference\n      closest_difference = difference\n      closest_elements = [numbers[index - 1], numbers[index]]\n    end\n  end\n  closest_elements\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp8xzp9g7j\nStarted\n.\nFinished in 0.000498575 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2005.72 tests/s, 10028.58 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    distance = (number - numbers[index - 1]).abs\n    if distance < closest_distance\n      closest_distance = distance\n      closest_elements = [numbers[index - 1], number]\n    end\n  end\n  closest_elements\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpp438r43l\nStarted\n.\nFinished in 0.000510891 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1957.36 tests/s, 9786.82 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = (numbers[1] - numbers[0]).abs\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuvqscdq2.rb:12: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpuvqscdq2.rb:21: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_difference = numbers[1] - numbers[0]\n  closest_numbers = [numbers[0], numbers[1]]\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    difference = number - numbers[index - 1]\n    if difference < closest_difference\n      closest_difference = difference\n      closest_numbers = [numbers[index - 1], number]\n    end\n  end\n  closest_numbers\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpu481vs5v\nStarted\n.\nFinished in 0.000537704 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1859.76 tests/s, 9298.80 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |n, i|\n    next if i == 0\n    diff = (numbers[i] - numbers[i-1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i-1], numbers[i]]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp81e_blzx\nStarted\n.\nFinished in 0.000474104 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2109.24 tests/s, 10546.21 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = numbers[1] - numbers[0]\n  numbers.each_with_index do |n, i|\n    next if i == 0\n    if (n - numbers[i - 1]) < closest_difference\n      closest_elements = [numbers[i - 1], n]\n      closest_difference = n - numbers[i - 1]\n    end\n  end\n  closest_elements\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpom9ej_db\nStarted\n.\nFinished in 0.000489721 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2041.98 tests/s, 10209.90 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    diff = (number - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], number]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpdwg4f9et\nStarted\n.\nFinished in 0.000472081 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2118.28 tests/s, 10591.40 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    distance = (number - numbers[index - 1]).abs\n    if distance < closest_distance\n      closest_distance = distance\n      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpzvn5k7xo\nStarted\n.\nFinished in 0.000460729 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2170.47 tests/s, 10852.37 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpw_ttuuzt\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpw_ttuuzt.rb:14:in `test_find_closest_elements'\n     11: class TestHumanEval < Test::Unit::TestCase\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n  => 14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n     15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n<[3.9, 4.0]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.007149768 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n139.86 tests/s, 139.86 assertions/s\n",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = (numbers[1] - numbers[0]).abs\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuvqscdq2.rb:12: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpuvqscdq2.rb:21: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_diff = numbers[1] - numbers[0]\n  closest_pair = [numbers[0], numbers[1]]\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    if (num - numbers[index - 1]) < closest_diff\n      closest_diff = num - numbers[index - 1]\n      closest_pair = [numbers[index - 1], num]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmptclnk9xa\nStarted\n.\nFinished in 0.000491542 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2034.41 tests/s, 10172.07 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = numbers[1] - numbers[0]\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    difference = number - numbers[index - 1]\n    if difference < closest_difference\n      closest_difference = difference\n      closest_elements = [numbers[index - 1], number]\n    end\n  end\n  closest_elements\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp4yltq89g\nStarted\n.\nFinished in 0.000478476 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2089.97 tests/s, 10449.84 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_difference = numbers[1] - numbers[0]\n  closest_elements = [numbers[0], numbers[1]]\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    difference = number - numbers[index - 1]\n    if difference < closest_difference\n      closest_difference = difference\n      closest_elements = [numbers[index - 1], number]\n    end\n  end\n  closest_elements\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp4tsdagjb\nStarted\n.\nFinished in 0.000460366 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2172.18 tests/s, 10860.92 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_distance\n      closest_distance = (number - numbers[index - 1]).abs\n      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp03pufh23\nStarted\n.\nFinished in 0.000461655 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2166.12 tests/s, 10830.60 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  # TODO: implement this method\n  numbers.combination(2).to_a.min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpx54b8x3e\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpx54b8x3e.rb:16:in `test_find_closest_elements'\n     13:   def test_find_closest_elements\n     14:     candidate = method(:find_closest_elements)\n     15:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 16:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     17:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     18:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     19:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007939763 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n125.95 tests/s, 251.90 assertions/s\n",
      "timestamp": 1659799041
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    diff = (number - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], number]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpdwg4f9et\nStarted\n.\nFinished in 0.000472081 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2118.28 tests/s, 10591.40 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    diff = (number - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], number]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpdwg4f9et\nStarted\n.\nFinished in 0.000472081 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2118.28 tests/s, 10591.40 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = numbers[1] - numbers[0]\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    difference = number - numbers[index - 1]\n    if difference < closest_difference\n      closest_difference = difference\n      closest_elements = [numbers[index - 1], number]\n    end\n  end\n  closest_elements\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp4yltq89g\nStarted\n.\nFinished in 0.000478476 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2089.97 tests/s, 10449.84 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_distance\n      closest_pair = [numbers[index - 1], number]\n      closest_distance = (number - numbers[index - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp1m9cxi1h\nStarted\n.\nFinished in 0.00045887 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2179.27 tests/s, 10896.33 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_distance\n      closest_pair = [numbers[index - 1], number]\n      closest_distance = (number - numbers[index - 1]).abs\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp1m9cxi1h\nStarted\n.\nFinished in 0.00045887 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2179.27 tests/s, 10896.33 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = (numbers[1] - numbers[0]).abs\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuvqscdq2.rb:12: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpuvqscdq2.rb:21: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).to_a.min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpigr3g6os\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpigr3g6os.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007820749 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n127.86 tests/s, 255.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = (numbers[1] - numbers[0]).abs\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuvqscdq2.rb:12: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpuvqscdq2.rb:21: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_diff = Float::INFINITY\n  closest_pair = []\n  numbers.each_with_index do |num, i|\n    if i < numbers.length - 1\n      diff = (num - numbers[i + 1]).abs\n      if diff < closest_diff\n        closest_diff = diff\n        closest_pair = [num, numbers[i + 1]]\n      end\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmpvkynibn7\nStarted\n.\nFinished in 0.00062906 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1589.67 tests/s, 7948.37 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpzqafz062\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpzqafz062.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007612479 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.36 tests/s, 262.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = (numbers[1] - numbers[0]).abs\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuvqscdq2.rb:12: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpuvqscdq2.rb:21: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |number, index|\n    next if index == 0\n    if (number - numbers[index - 1]).abs < closest_distance\n      closest_distance = (number - numbers[index - 1]).abs\n      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp03pufh23\nStarted\n.\nFinished in 0.000461655 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2166.12 tests/s, 10830.60 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_elements = [numbers[0], numbers[1]]\n  closest_difference = (numbers[1] - numbers[0]).abs\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuvqscdq2.rb:12: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpuvqscdq2.rb:21: syntax error, unexpected end-of-input, expecting `end'\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  # TODO: implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpr4w4qy_2\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpr4w4qy_2.rb:14:in `test_find_closest_elements'\n     11: class TestHumanEval < Test::Unit::TestCase\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n  => 14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n     15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n<[3.9, 4.0]> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.008853086 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n112.95 tests/s, 112.95 assertions/s\n",
      "timestamp": 1659799041
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).to_a.min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpigr3g6os\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpigr3g6os.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007820749 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n127.86 tests/s, 255.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmprtxht1si\nStarted\n.\nFinished in 0.000444972 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2247.33 tests/s, 11236.66 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_diff = numbers[1] - numbers[0]\n  closest_pair = [numbers[0], numbers[1]]\n  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff = num - numbers[index - 1]\n    if diff < closest_diff\n      closest_diff = diff\n      closest_pair = [numbers[index - 1], num]\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmppsg30wl8\nStarted\n.\nFinished in 0.000403568 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2477.90 tests/s, 12389.49 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).to_a.sort_by { |a, b| (a - b).abs }.first\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpha8morxh\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpha8morxh.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007062968 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n141.58 tests/s, 283.17 assertions/s\n",
      "timestamp": 1659799041
    },
    {
      "exit_code": 1,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.combination(2).to_a.min_by { |a, b| (a - b).abs }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "Loaded suite /tmp/tmpigr3g6os\nStarted\nF\n===============================================================================\nFailure: test_find_closest_elements(TestHumanEval)\n/tmp/tmpigr3g6os.rb:15:in `test_find_closest_elements'\n     12:   def test_find_closest_elements\n     13:     candidate = method(:find_closest_elements)\n     14:     assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n  => 15:     assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n     16:     assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n     17:     assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n     18:     assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n<[5.0, 5.9]> expected but was\n<[5.9, 5.0]>\n\ndiff:\n? [5.0, 5.9]\n?    9    0 \n?    ?    ? \n===============================================================================\n\nFinished in 0.007820749 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n127.86 tests/s, 255.73 assertions/s\n",
      "timestamp": 1659799040
    },
    {
      "exit_code": 0,
      "program": "# From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n# other and return them in order (smaller number, larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n",
      "status": "OK",
      "stderr": "Loaded suite /tmp/tmp28hezgrn\nStarted\n.\nFinished in 0.000439809 seconds.\n-------------------------------------------------------------------------------\n1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n2273.71 tests/s, 11368.57 assertions/s\n",
      "stdout": "",
      "timestamp": 1659799040
    }
  ]
}