name: HumanEval_20_find_closest_elements
language: rb
prompt: "# From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n# other and return them in order (smaller number,\
  \ larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
  # [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\
  # [2.0, 2.0]\ndef find_closest_elements(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n\
  \    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0,\
  \ 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2,\
  \ 3.1, 4.1, 5.1]))\n  end\nend\n"
completions: ["  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend", "  numbers.sort!\n\
    \  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n\
    \  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num -\
    \ numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i\
    \ - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend",
  "  numbers.sort!\n  closest_diff = numbers[1] - numbers[0]\n  closest_pair = [numbers[0],\
    \ numbers[1]]\n  numbers.each_with_index do |number, index|\n    next if index\
    \ == 0\n    diff = number - numbers[index - 1]\n    if diff < closest_diff\n \
    \     closest_diff = diff\n      closest_pair = [numbers[index - 1], number]\n\
    \    end\n  end\n  closest_pair\nend", "  numbers.sort!\n  closest_pair = [numbers[0],\
    \ numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index\
    \ do |number, index|\n    next if index == 0\n    if (number - numbers[index -\
    \ 1]).abs < closest_distance\n      closest_pair = [numbers[index - 1], number]\n\
    \      closest_distance = (number - numbers[index - 1]).abs\n    end\n  end\n\
    \  closest_pair\nend", "  # TODO: implement this method\n  numbers.sort!\n  closest_elements\
    \ = [numbers[0], numbers[1]]\n  closest_difference = (numbers[1] - numbers[0]).abs\n\
    \  numbers.each_with_index do |number, index|\n    next if index == 0\n    difference\
    \ = (number - numbers[index - 1]).abs\n    if difference < closest_difference\n\
    \      closest_difference = difference\n      closest_elements = [numbers[index\
    \ - 1], number]\n    end\n  end\n  closest_elements\nend", "  numbers.combination(2).to_a.min_by\
    \ { |a, b| (a - b).abs }\nend", "  numbers.sort!\n  closest_pair = [numbers[0],\
    \ numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index\
    \ do |number, index|\n    next if index == 0\n    distance = (number - numbers[index\
    \ - 1]).abs\n    if distance < closest_distance\n      closest_distance = distance\n\
    \      closest_pair = [numbers[index - 1], number]\n    end\n  end\n  closest_pair\n\
    end", "  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff\
    \ = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, i|\n   \
    \ next if i == 0\n    if (num - numbers[i - 1]).abs < closest_diff\n      closest_pair\
    \ = [numbers[i - 1], num]\n      closest_diff = (num - numbers[i - 1]).abs\n \
    \   end\n  end\n  closest_pair\nend", "  numbers.sort!\n  closest_pair = [numbers[0],\
    \ numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index\
    \ do |number, index|\n    next if index == 0\n    if (number - numbers[index -\
    \ 1]).abs < closest_distance\n      closest_pair = [numbers[index - 1], number]\n\
    \      closest_distance = (number - numbers[index - 1]).abs\n    end\n  end\n\
    \  closest_pair\nend", "  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n\
    \  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do\
    \ |num, i|\n    next if i == 0\n    diff = (num - numbers[i - 1]).abs\n    if\
    \ diff < closest_diff\n      closest_pair = [numbers[i - 1], num]\n      closest_diff\
    \ = diff\n    end\n  end\n  closest_pair\nend", "  numbers.combination(2).min_by\
    \ { |a, b| (a - b).abs }\nend", "  numbers.sort!\n  closest_pair = [numbers[0],\
    \ numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  (numbers.length\
    \ - 1).times do |i|\n    diff = (numbers[i + 1] - numbers[i]).abs\n    if diff\
    \ < closest_diff\n      closest_pair = [numbers[i], numbers[i + 1]]\n      closest_diff\
    \ = diff\n    end\n  end\n  closest_pair\nend", "  numbers.sort!\n  closest_pair\
    \ = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n\
    \  numbers.each_with_index do |num, index|\n    next if index == 0\n    diff =\
    \ (num - numbers[index - 1]).abs\n    if diff < closest_diff\n      closest_pair\
    \ = [numbers[index - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\n\
    end", "  numbers.sort!\n  closest_pair = [numbers[0], numbers[1]]\n  closest_diff\
    \ = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index do |num, index|\n\
    \    next if index == 0\n    diff = (num - numbers[index - 1]).abs\n    if diff\
    \ < closest_diff\n      closest_pair = [numbers[index - 1], num]\n      closest_diff\
    \ = diff\n    end\n  end\n  closest_pair\nend", "  numbers.sort!\n  closest_pair\
    \ = [numbers[0], numbers[1]]\n  closest_distance = (numbers[1] - numbers[0]).abs\n\
    \  numbers.each_with_index do |num, index|\n    next if index == 0\n    distance\
    \ = (num - numbers[index - 1]).abs\n    if distance < closest_distance\n     \
    \ closest_distance = distance\n      closest_pair = [numbers[index - 1], num]\n\
    \    end\n  end\n  closest_pair\nend", "  numbers.sort!\n  closest_pair = [numbers[0],\
    \ numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n  numbers.each_with_index\
    \ do |n, i|\n    next if i == 0\n    diff = (numbers[i] - numbers[i-1]).abs\n\
    \    if diff < closest_diff\n      closest_pair = [numbers[i-1], numbers[i]]\n\
    \      closest_diff = diff\n    end\n  end\n  closest_pair\nend", "  numbers.sort!\n\
    \  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n\
    \  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num -\
    \ numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i\
    \ - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend",
  "  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend", "  numbers.sort!\n\
    \  closest_pair = [numbers[0], numbers[1]]\n  closest_diff = (numbers[1] - numbers[0]).abs\n\
    \  numbers.each_with_index do |num, i|\n    next if i == 0\n    diff = (num -\
    \ numbers[i - 1]).abs\n    if diff < closest_diff\n      closest_pair = [numbers[i\
    \ - 1], num]\n      closest_diff = diff\n    end\n  end\n  closest_pair\nend",
  "  # TODO: implement this method\n  numbers.sort!\n  closest_elements = []\n  closest_difference\
    \ = numbers[1] - numbers[0]\n  numbers.each_with_index do |number, index|\n  \
    \  next if index == 0\n    difference = number - numbers[index - 1]\n    if difference\
    \ < closest_difference\n      closest_difference = difference\n      closest_elements\
    \ = [numbers[index - 1], number]\n    end\n  end\n  closest_elements\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
