name: HumanEval_11_string_xor
language: rb
prompt: "# Input are two strings a and b consisting only of 1s and 0s.\n# Perform\
  \ binary XOR on these inputs and return result also as a string.\n# >>> string_xor.call(\"\
  010\", \"110\")\n# \"100\"\ndef string_xor(a, b)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n\
  \    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"\
  111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n\
  \    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"
completions: ["  a.to_i(2) ^ b.to_i(2)\nend", "  a.chars.zip(b.chars).map { |x, y|\
    \ (x.to_i ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i\
    \ ^ y.to_i).to_s }.join\nend", "  a.to_i(2) ^ b.to_i(2)\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x,\
    \ y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i\
    \ ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^\
    \ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0'\
    \ : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1'\
    \ }.join\nend", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\n\
    end", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\nend", " \
    \ a.chars.zip(b.chars).map { |x, y| x == y ? \"0\" : \"1\" }.join\nend", "  #\
    \ TODO: implement me\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s\
    \ }.join\nend", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\n\
    end", "  raise ArgumentError, \"a and b must be strings\" unless a.is_a?(String)\
    \ && b.is_a?(String)\n  raise ArgumentError, \"a and b must be the same length\"\
    \ unless a.length == b.length\n  raise ArgumentError, \"a and b must only contain\
    \ 1s and 0s\" unless a.match(/^[01]+$/) && b.match(/^[01]+$/)", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x,\
    \ y| x == y ? \"0\" : \"1\" }.join\nend", "  a.chars.zip(b.chars).map { |x, y|\
    \ (x.to_i ^ y.to_i).to_s }.join\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
