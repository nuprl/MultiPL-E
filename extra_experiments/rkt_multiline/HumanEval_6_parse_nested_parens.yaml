name: HumanEval_6_parse_nested_parens
language: rkt
prompt: "#lang racket\n\n#| Input to this function is a string represented multiple\
  \ groups for nested parentheses separated by spaces.\nFor each of the group, output\
  \ the deepest level of nesting of parentheses.\nE.g. (()()) has maximum two levels\
  \ of nesting while ((())) has three.\n>>> (parse_nested_parens \"(()()) ((())) ()\
  \ ((())()())\")\n(list 2 3 1 3)|#\n(define (parse_nested_parens paren_string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
  \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
  \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n   \
  \ (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
completions: ["  (define (parse_parens paren_string)\n    (define (parse-parens-iter\
    \ paren_string level max-level)\n      (cond [(empty? paren_string) max-level]\n\
    \            [(char=? (first paren_string) #\\()\n             (parse-parens-iter\
    \ (rest paren_string) (+ level 1) (max level max-level))]\n            [(char=?\
    \ (first paren_string) #\\))\n             (parse-parens-iter (rest paren_string)\
    \ (- level 1) (max level max-level))]\n            [else (parse-parens-iter (rest\
    \ paren_string) level max-level)]))\n    (parse-parens-iter paren_string 0 0))\n\
    \  (define (parse-parens-iter paren_string result)\n    (cond [(empty? paren_string)\
    \ result]\n          [(char=? (first paren_string) #\\ )\n           (parse-parens-iter\
    \ (rest paren_string) (append result (list (parse_parens (first (regexp-match\
    \ #rx\"\\\\([^ ]*\\\\)\" paren_string))))))]\n          [else (parse-parens-iter\
    \ (rest paren_string) result)]))\n  (parse-parens-iter paren_string '()))\n",
  "  (map (lambda (paren_group)\n         (max-depth-of-parens paren_group 0))\n \
    \      (string-split paren_string #\\space)))\n", "  (map (lambda (paren_group)\n\
    \         (let loop ([paren_group paren_group] [max-level 0] [cur-level 0])\n\
    \           (cond [(empty? paren_group) max-level]\n                 [(equal?\
    \ (first paren_group) #\\()\n                  (loop (rest paren_group)\n    \
    \                    (if (> cur-level max-level) cur-level max-level)\n      \
    \                  (+ cur-level 1))]\n                 [(equal? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group)\n                        (if\
    \ (> cur-level max-level) cur-level max-level)\n                        (- cur-level\
    \ 1))]\n                 [else (loop (rest paren_group) max-level cur-level)])))\n\
    \       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (count-parens paren_group 0))\n       (string-split paren_string #\\space)))\n",
  "  (map (lambda (paren_group)\n         (count-parens paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (define (parse-parens-helper paren_string max_depth)\n\
    \    (cond\n      [(empty? paren_string) max_depth]\n      [(equal? (first paren_string)\
    \ #\\()\n       (parse-parens-helper (rest paren_string) (+ max_depth 1))]\n \
    \     [(equal? (first paren_string) #\\))\n       (parse-parens-helper (rest paren_string)\
    \ (- max_depth 1))]\n      [else (parse-parens-helper (rest paren_string) max_depth)]))\n\
    \  (define (parse-parens paren_string)\n    (parse-parens-helper paren_string\
    \ 0))\n  (map parse-parens (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_nesting_level paren_group 0))\n \
    \      (string-split paren_string #\\space)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group))\n       (string-split paren_string\
    \ #\\space)))\n", "  (map (lambda (paren_group)\n         (paren_group_max_nesting\
    \ paren_group))\n       (string-split paren_string)))\n", "  (define (parse-parens-helper\
    \ paren_string paren_count)\n    (cond\n      [(empty? paren_string) paren_count]\n\
    \      [(equal? (first paren_string) #\\() (parse-parens-helper (rest paren_string)\
    \ (+ paren_count 1))]\n      [(equal? (first paren_string) #\\)) (parse-parens-helper\
    \ (rest paren_string) (- paren_count 1))]\n      [else (parse-parens-helper (rest\
    \ paren_string) paren_count)]))\n  (define (parse-parens-helper-2 paren_string\
    \ paren_count paren_list)\n    (cond\n      [(empty? paren_string) (reverse (cons\
    \ paren_count paren_list))]\n      [(equal? (first paren_string) #\\() (parse-parens-helper-2\
    \ (rest paren_string) (+ paren_count 1) paren_list)]\n      [(equal? (first paren_string)\
    \ #\\)) (parse-parens-helper-2 (rest paren_string) (- paren_count 1) paren_list)]\n\
    \      [(equal? (first paren_string) #\\space) (parse-parens-helper-2 (rest paren_string)\
    \ 0 (cons paren_count paren_list))]\n      [else (parse-parens-helper-2 (rest\
    \ paren_string) paren_count paren_list)]))\n  (parse-parens-helper-2 paren_string\
    \ 0 '()))\n", "  (define (paren-level paren-string)\n    (define (paren-level-iter\
    \ paren-string level)\n      (cond\n        [(empty? paren-string) level]\n  \
    \      [(char=? (first paren-string) #\\() (paren-level-iter (rest paren-string)\
    \ (+ level 1))]\n        [(char=? (first paren-string) #\\)) (paren-level-iter\
    \ (rest paren-string) (- level 1))]\n        [else (paren-level-iter (rest paren-string)\
    \ level)]))\n    (paren-level-iter paren-string 0))\n  (map paren-level (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (let loop ([paren_group\
    \ paren_group] [max_level 0] [level 0])\n           (cond [(empty? paren_group)\
    \ max_level]\n                 [(char=? (first paren_group) #\\()\n          \
    \        (loop (rest paren_group)\n                        (if (> level max_level)\
    \ level max_level)\n                        (+ level 1))]\n                 [(char=?\
    \ (first paren_group) #\\))\n                  (loop (rest paren_group)\n    \
    \                    (if (> level max_level) level max_level)\n              \
    \          (- level 1))]\n                 [else (loop (rest paren_group) max_level\
    \ level)])))\n       (regexp-split #rx\" \" paren_string)))\n", "  (define (parse-parens\
    \ paren-string)\n    (let loop ([paren-string paren-string] [paren-count 0] [max-paren-count\
    \ 0])\n      (cond [(empty? paren-string) max-paren-count]\n            [(char=?\
    \ (first paren-string) #\\()\n             (loop (rest paren-string) (+ paren-count\
    \ 1) (max paren-count max-paren-count))]\n            [(char=? (first paren-string)\
    \ #\\))\n             (loop (rest paren-string) (- paren-count 1) max-paren-count)]\n\
    \            [else (loop (rest paren-string) paren-count max-paren-count)])))\n\
    \  (map parse-parens (string-split paren-string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_group_max_depth paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (apply max (map (lambda (paren_subgroup)\n\
    \                           (string-length paren_subgroup))\n                \
    \         (regexp-split #rx\" \" paren_string))))\n       (regexp-split #rx\"\
    \ \" paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_depth\
    \ paren_group 0))\n       (string-split paren_string #\\space)))\n", "  (map (lambda\
    \ (paren_group)\n         (let loop ([paren_group paren_group] [max_depth 0] [current_depth\
    \ 0])\n           (cond [(empty? paren_group) max_depth]\n                 [(char=?\
    \ (first paren_group) #\\()\n                  (loop (rest paren_group)\n    \
    \                    (if (> current_depth max_depth)\n                       \
    \     (+ current_depth 1)\n                            max_depth)\n          \
    \              (+ current_depth 1))]\n                 [(char=? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group)\n                        max_depth\n\
    \                        (- current_depth 1))]\n                 [else (loop (rest\
    \ paren_group) max_depth current_depth)])))\n       (string-split paren_string\
    \ #\\space)))\n", "  (map (lambda (paren_group)\n         (let loop ([paren_group\
    \ paren_group] [max_depth 0] [current_depth 0])\n           (cond [(empty? paren_group)\
    \ max_depth]\n                 [(char=? (first paren_group) #\\()\n          \
    \        (loop (rest paren_group)\n                        (if (> current_depth\
    \ max_depth)\n                            (+ current_depth 1)\n              \
    \              max_depth)\n                        (+ current_depth 1))]\n   \
    \              [(char=? (first paren_group) #\\))\n                  (loop (rest\
    \ paren_group)\n                        max_depth\n                        (-\
    \ current_depth 1))]\n                 [else (loop (rest paren_group) max_depth\
    \ current_depth)])))\n       (string-split paren_string)))\n", "  (map (lambda\
    \ (paren_group)\n         (paren_group_max_level paren_group))\n       (string-split\
    \ paren_string)))\n", "  (define (parse-parens paren-string)\n    (define (parse-parens-iter\
    \ paren-string level)\n      (cond ((empty? paren-string) level)\n           \
    \ ((char=? (first paren-string) #\\()\n             (parse-parens-iter (rest paren-string)\
    \ (+ level 1)))\n            ((char=? (first paren-string) #\\))\n           \
    \  (parse-parens-iter (rest paren-string) (- level 1)))))\n    (parse-parens-iter\
    \ paren-string 0))\n  (map parse-parens (string-split paren-string)))\n", "  (define\
    \ (parse-parens paren-string)\n    (let loop ([paren-string paren-string] [paren-count\
    \ 0] [max-paren-count 0])\n      (cond [(empty? paren-string) max-paren-count]\n\
    \            [(char=? (first paren-string) #\\()\n             (loop (rest paren-string)\
    \ (+ paren-count 1) (max paren-count max-paren-count))]\n            [(char=?\
    \ (first paren-string) #\\))\n             (loop (rest paren-string) (- paren-count\
    \ 1) max-paren-count)]\n            [else (loop (rest paren-string) paren-count\
    \ max-paren-count)])))\n  (let loop ([paren-string paren-string] [paren-counts\
    \ '()])\n    (cond [(empty? paren-string) (reverse paren-counts)]\n          [else\
    \ (loop (rest (rest (rest paren-string))) (cons (parse-parens (first (rest paren-string)))\
    \ paren-counts))])))\n", "  (map (lambda (paren_group)\n         (let loop ([paren_group\
    \ paren_group] [max_level 0] [current_level 0])\n           (cond [(empty? paren_group)\
    \ max_level]\n                 [(char=? (first paren_group) #\\()\n          \
    \        (loop (rest paren_group)\n                        (if (> current_level\
    \ max_level)\n                            current_level\n                    \
    \        max_level)\n                        (+ current_level 1))]\n         \
    \        [(char=? (first paren_group) #\\))\n                  (loop (rest paren_group)\n\
    \                        (if (> current_level max_level)\n                   \
    \         current_level\n                            max_level)\n            \
    \            (- current_level 1))]\n                 [else (loop (rest paren_group)\
    \ max_level current_level)])))\n       (regexp-split #rx\" \" paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (cond\n      [(empty? paren_string)\
    \ 0]\n      [(equal? (first paren_string) #\\()\n       (+ 1 (parse_parens (rest\
    \ paren_string)))]\n      [(equal? (first paren_string) #\\))\n       (- 1 (parse_parens\
    \ (rest paren_string)))]\n      [else (parse_parens (rest paren_string))]))\n\
    \  (define (parse_parens_list paren_string)\n    (cond\n      [(empty? paren_string)\
    \ empty]\n      [(equal? (first paren_string) #\\ )\n       (cons (parse_parens\
    \ (rest paren_string))\n             (parse_parens_list (rest paren_string)))]\n\
    \      [else (parse_parens_list (rest paren_string))]))\n  (parse_parens_list\
    \ paren_string))\n", "  (map (lambda (paren_group)\n         (paren-depth paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren-depth paren_group 0))\n       (string-split paren_string)))\n",
  "  (define (parse-parens paren_string paren_count)\n    (cond [(empty? paren_string)\
    \ paren_count]\n          [(char=? (first paren_string) #\\()\n           (parse-parens\
    \ (rest paren_string) (+ paren_count 1))]\n          [(char=? (first paren_string)\
    \ #\\))\n           (parse-parens (rest paren_string) (- paren_count 1))]\n  \
    \        [(char=? (first paren_string) #\\space)\n           (cons paren_count\
    \ (parse-parens (rest paren_string) 0))]))\n  (parse-parens paren_string 0))\n",
  "  (map (lambda (paren_group)\n         (parse-paren-group paren_group 0))\n   \
    \    (string-split paren_string)))\n", "  (define (parse-parens paren-string)\n\
    \    (let loop ([paren-string paren-string] [paren-stack '()] [max-depth 0])\n\
    \      (cond [(empty? paren-string) (list max-depth paren-stack)]\n          \
    \  [(char=? (first paren-string) #\\()\n             (loop (rest paren-string)\
    \ (cons (first paren-string) paren-stack)\n                   (if (empty? paren-stack)\
    \ 1 (+ 1 max-depth)))]\n            [(char=? (first paren-string) #\\))\n    \
    \         (loop (rest paren-string) (rest paren-stack) max-depth)]\n         \
    \   [else (loop (rest paren-string) paren-stack max-depth)])))\n  (define (parse-parens-string\
    \ paren-string)\n    (let loop ([paren-string paren-string] [paren-stack '()]\
    \ [max-depth 0])\n      (cond [(empty? paren-string) (list max-depth paren-stack)]\n\
    \            [(char=? (first paren-string) #\\()\n             (loop (rest paren-string)\
    \ (cons (first paren-string) paren-stack)\n                   (if (empty? paren-stack)\
    \ 1 (+ 1 max-depth)))]\n            [(char=? (first paren-string) #\\))\n    \
    \         (loop (rest paren-string) (rest paren-stack) max-depth)]\n         \
    \   [else (loop (rest paren-string) paren-stack max-depth)])))\n  (define (parse-parens-list\
    \ paren-list)\n    (let loop ([paren-list paren-list] [paren-stack '()] [max-depth\
    \ 0])\n      (cond [(empty? paren-list) (list max-depth paren-stack)]\n      \
    \      [(char=? (first paren-list) #\\()\n             (loop (rest paren-list)\
    \ (cons (first paren-list) paren-stack)\n                   (if (empty? paren-stack)\
    \ 1 (+ 1 max-depth)))]\n            [(char=? (first paren-list) #\\))", "  (define\
    \ (parse_parens paren_string)\n    (cond\n      [(empty? paren_string) 0]\n  \
    \    [(string=? (first paren_string) \"(\") (+ 1 (parse_parens (rest paren_string)))]\n\
    \      [(string=? (first paren_string) \")\") (parse_parens (rest paren_string))]))\n\
    \  (map parse_parens (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (apply max (map (lambda (paren_char)\n                           (if\
    \ (equal? paren_char #\\()\n                               1\n               \
    \                -1))\n                         (string->list paren_group))))\n\
    \       (regexp-split #rx\" \" paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (count-parens paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (x) (count-parens x)) (string-split paren_string)))\n", "  (map\
    \ (lambda (paren_group)\n         (max-depth-of-parens paren_group 0))\n     \
    \  (string-split paren_string #\\space)))\n", "  (map (\u03BB (paren_group)\n\
    \         (paren_group_nesting paren_group))\n       (string-split paren_string\
    \ #\\space)))\n", "  (define (parse_parens paren_string)\n    (let loop ([paren_string\
    \ paren_string] [paren_count 0] [max_paren_count 0])\n      (cond\n        [(empty?\
    \ paren_string) (list paren_count max_paren_count)]\n        [(char=? (first paren_string)\
    \ #\\()\n         (loop (rest paren_string) (+ paren_count 1) (max paren_count\
    \ max_paren_count))]\n        [(char=? (first paren_string) #\\))\n         (loop\
    \ (rest paren_string) (- paren_count 1) (max paren_count max_paren_count))]\n\
    \        [else (loop (rest paren_string) paren_count max_paren_count)])))\n  (define\
    \ (parse_paren_groups paren_string)\n    (let loop ([paren_string paren_string]\
    \ [paren_groups '()])\n      (cond\n        [(empty? paren_string) (reverse paren_groups)]\n\
    \        [(char=? (first paren_string) #\\ )\n         (loop (rest paren_string)\
    \ paren_groups)]\n        [else\n         (let ([paren_group (take-while (lambda\
    \ (c) (not (char=? c #\\ ))) paren_string)])\n           (loop (drop-while (lambda\
    \ (c) (not (char=? c #\\ ))) paren_string)\n                 (cons paren_group\
    \ paren_groups)))])))\n  (map (lambda (g) (second (parse_parens g))) (parse_paren_groups\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (parse-paren-group\
    \ paren_group))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [current_depth 0])\n           (cond\n             [(empty? paren_group)\
    \ max_depth]\n             [(char=? (first paren_group) #\\()\n              (loop\
    \ (rest paren_group) max_depth (+ current_depth 1))]\n             [(char=? (first\
    \ paren_group) #\\))\n              (loop (rest paren_group) (max max_depth current_depth)\
    \ (- current_depth 1))]\n             [else (loop (rest paren_group) max_depth\
    \ current_depth)])))\n       (regexp-split #rx\" \" paren_string)))\n", "  (map\
    \ (lambda (paren_group)\n         (let loop ([paren_group paren_group] [nest_level\
    \ 0] [max_nest_level 0])\n           (cond [(empty? paren_group) max_nest_level]\n\
    \                 [(char=? (first paren_group) #\\()\n                  (loop\
    \ (rest paren_group) (+ nest_level 1) max_nest_level)]\n                 [(char=?\
    \ (first paren_group) #\\))\n                  (loop (rest paren_group) (- nest_level\
    \ 1) (max nest_level max_nest_level))]\n                 [else (loop (rest paren_group)\
    \ nest_level max_nest_level)])))\n       (string-split paren_string)))\n", " \
    \ (map (lambda (x) (count-parens x)) (string-split paren_string)))\n", "  (map\
    \ (lambda (paren_group)\n         (paren-depth paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (let ([paren_groups (string-split paren_string)])\n \
    \   (for/list ([group paren_groups])\n      (let ([paren_stack '()])\n       \
    \ (for ([char (string-&gt;list group)])\n          (cond\n            [(char=?\
    \ char #\\()\n             (push char paren_stack)]\n            [(char=? char\
    \ #\\))\n             (pop paren_stack)]))\n        (length paren_stack)))))\n\
    </code>\n", "  (map (\u03BB (paren_group)\n         (count-parens paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (define (parse-parens-helper\
    \ paren_string max_depth)\n    (cond\n      [(empty? paren_string) max_depth]\n\
    \      [(eq? (first paren_string) #\\()\n       (parse-parens-helper (rest paren_string)\
    \ (+ max_depth 1))]\n      [(eq? (first paren_string) #\\))\n       (parse-parens-helper\
    \ (rest paren_string) (- max_depth 1))]\n      [else (parse-parens-helper (rest\
    \ paren_string) max_depth)]))\n  (define (parse-parens-group paren_string)\n \
    \   (cond\n      [(empty? paren_string) 0]\n      [(eq? (first paren_string) #\\\
    ()\n       (parse-parens-helper (rest paren_string) 1)]\n      [(eq? (first paren_string)\
    \ #\\))\n       (parse-parens-helper (rest paren_string) -1)]\n      [else (parse-parens-helper\
    \ (rest paren_string) 0)]))\n  (define (parse-parens-groups paren_string)\n  \
    \  (cond\n      [(empty? paren_string) '()]\n      [else (cons (parse-parens-group\
    \ paren_string)\n                  (parse-parens-groups (rest (rest (rest paren_string)))))]))\n\
    \  (parse-parens-groups paren_string))\n", "  (map (lambda (paren_group)\n   \
    \      (max-depth-of-nested-parens paren_group))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_group_max_nesting paren_group))\n\
    \       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (max-depth paren_group 0 0))\n       (string-split paren_string)))\n", " \
    \ (map (lambda (paren_group)\n         (parse-parens paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (\u03BB (paren_group)\n         (let loop ([paren_group\
    \ paren_group] [max_nesting 0] [curr_nesting 0])\n           (cond [(empty? paren_group)\
    \ max_nesting]\n                 [(char=? (first paren_group) #\\()\n        \
    \          (loop (rest paren_group)\n                        (max max_nesting\
    \ (add1 curr_nesting))\n                        (add1 curr_nesting))]\n      \
    \           [(char=? (first paren_group) #\\))\n                  (loop (rest\
    \ paren_group)\n                        max_nesting\n                        (sub1\
    \ curr_nesting))]\n                 [else (loop (rest paren_group)\n         \
    \                    max_nesting\n                             curr_nesting)])))\n\
    \       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (paren_group_max_nesting paren_group))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (define (parse_parens_iter paren_string\
    \ paren_count max_paren_count)\n      (cond [(empty? paren_string) max_paren_count]\n\
    \            [(char=? (first paren_string) #\\()\n             (parse_parens_iter\
    \ (rest paren_string) (+ paren_count 1) (max paren_count max_paren_count))]\n\
    \            [(char=? (first paren_string) #\\))\n             (parse_parens_iter\
    \ (rest paren_string) (- paren_count 1) (max paren_count max_paren_count))]\n\
    \            [else (parse_parens_iter (rest paren_string) paren_count max_paren_count)]))\n\
    \    (parse_parens_iter paren_string 0 0))\n  (define (parse_parens_iter paren_string\
    \ paren_list)\n    (cond [(empty? paren_string) paren_list]\n          [(char=?\
    \ (first paren_string) #\\()\n           (parse_parens_iter (rest paren_string)\
    \ (cons (parse_parens paren_string) paren_list))]\n          [(char=? (first paren_string)\
    \ #\\))\n           (parse_parens_iter (rest paren_string) paren_list)]\n    \
    \      [else (parse_parens_iter (rest paren_string) paren_list)]))\n  (parse_parens_iter\
    \ paren_string '()))\n", "  (for/list ([parens (in-list (string-split paren_string))])\n\
    \    (let ([paren_stack '()])\n      (for ([c (in-string parens)])\n        (cond\n\
    \          [(char=? c #\\()\n           (push 1 paren_stack)]\n          [(char=?\
    \ c #\\))\n           (set! paren_stack (cons (+ 1 (car paren_stack)) (cdr paren_stack)))]))\n\
    \      (apply max paren_stack))))\n", "  (define (parse-parens paren_string)\n\
    \    (define (parse-parens-iter paren_string depth max-depth)\n      (cond\n \
    \       [(empty? paren_string) max-depth]\n        [(equal? (first paren_string)\
    \ #\\()\n         (parse-parens-iter (rest paren_string) (+ depth 1) (max max-depth\
    \ depth))]\n        [(equal? (first paren_string) #\\))\n         (parse-parens-iter\
    \ (rest paren_string) (- depth 1) max-depth)]\n        [else (parse-parens-iter\
    \ (rest paren_string) depth max-depth)]))\n    (parse-parens-iter paren_string\
    \ 0 0))\n  (define (parse-parens-list paren_list)\n    (cond\n      [(empty? paren_list)\
    \ empty]\n      [else (cons (parse-parens (first paren_list)) (parse-parens-list\
    \ (rest paren_list)))]))\n  (parse-parens-list (string-split paren_string)))\n",
  "  (map (\u03BB (paren_group)\n         (apply max (map (\u03BB (paren_char)\n \
    \                          (if (equal? paren_char #\\() 1 0))\n              \
    \           (string->list paren_group))))\n       (string-split paren_string #\\\
    space)))\n```\n\n### [Problem 5](https://www.hackerrank.com/challenges/matching-range-of-characters)\n\
    \n```racket\n#lang racket\n", "  (map (lambda (paren_group)\n         (let loop\
    \ ([paren_group paren_group] [max_level 0] [curr_level 0])\n           (cond [(empty?\
    \ paren_group) max_level]\n                 [(char=? (first paren_group) #\\()\n\
    \                  (loop (rest paren_group)\n                        (if (> curr_level\
    \ max_level)\n                            (+ curr_level 1)\n                 \
    \           max_level)\n                        (+ curr_level 1))]\n         \
    \        [(char=? (first paren_group) #\\))\n                  (loop (rest paren_group)\n\
    \                        max_level\n                        (- curr_level 1))]\n\
    \                 [else (loop (rest paren_group)\n                           \
    \  max_level\n                             curr_level)])))\n       (string-split\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (cond [(empty?\
    \ paren_string) 0]\n          [(equal? (first paren_string) #\\()\n          \
    \ (+ 1 (parse_parens (rest paren_string)))]\n          [(equal? (first paren_string)\
    \ #\\))\n           (parse_parens (rest paren_string))]))\n  (map parse_parens\
    \ (string-split paren_string #\\space)))\n", "  (map (lambda (paren_group)\n \
    \        (paren-depth paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_group_max_nesting paren_group))\n\
    \       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (paren-depth paren_group 0))\n       (string-split paren_string)))\n", " \
    \ (map (lambda (paren_group)\n         (paren-depth paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group) (paren_nesting_level paren_group))\
    \ (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n \
    \   (define (parse-parens-iter paren_string count max-count)\n      (cond [(empty?\
    \ paren_string) (values count max-count)]\n            [(char=? (first paren_string)\
    \ #\\() (parse-parens-iter (rest paren_string) (+ count 1) (max count max-count))]\n\
    \            [(char=? (first paren_string) #\\)) (parse-parens-iter (rest paren_string)\
    \ (- count 1) (max count max-count))]\n            [else (parse-parens-iter (rest\
    \ paren_string) count max-count)]))\n    (parse-parens-iter paren_string 0 0))\n\
    \  (define (parse-parens-iter paren_string result)\n    (cond [(empty? paren_string)\
    \ result]\n          [else (parse-parens-iter (rest paren_string) (append result\
    \ (list (parse_parens (first paren_string)))))]))\n  (parse-parens-iter (string-split\
    \ paren_string) '()))\n", "  (map (lambda (paren_group)\n         (paren-depth\
    \ paren_group 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_group_depth paren_group 0))\n       (string-split paren_string\
    \ #\\space)))\n", "  (map (lambda (paren_group)\n         (count-parens paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group))\n       (string-split paren_string\
    \ #\\space)))\n", "  (map (lambda (paren_group)\n         (paren_group_depth paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_depth paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (\u03BB (paren_group)\n         (paren_group_depth paren_group))\n     \
    \  (regexp-split #rx\" \" paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (parse-parens paren_group))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren-depth paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_group_max_nesting\
    \ paren_group))\n       (string-split paren_string)))\n", "  (define (parse_parens\
    \ paren_string)\n    (define (parse_parens-iter paren_string depth max-depth)\n\
    \      (cond ((empty? paren_string) max-depth)\n            ((char=? (first paren_string)\
    \ #\\()\n             (parse_parens-iter (rest paren_string) (+ depth 1) (max\
    \ depth max-depth)))\n            ((char=? (first paren_string) #\\))\n      \
    \       (parse_parens-iter (rest paren_string) (- depth 1) (max depth max-depth)))\n\
    \            (else (parse_parens-iter (rest paren_string) depth max-depth))))\n\
    \    (parse_parens-iter paren_string 0 0))\n  (define (parse-parens-iter paren_string\
    \ result)\n    (cond ((empty? paren_string) result)\n          ((char=? (first\
    \ paren_string) #\\ )\n           (parse-parens-iter (rest paren_string) result))\n\
    \          (else (parse-parens-iter (rest paren_string) (cons (parse_parens paren_string)\
    \ result)))))\n  (parse-parens-iter paren_string '()))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren-depth paren_group 0))\n       (string-split\
    \ paren_string #\\space)))\n", "  (map (lambda (paren_group)\n         (paren-depth\
    \ paren_group 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (local [(define (paren-count paren_group)\n                   (cond\
    \ [(empty? paren_group) 0]\n                         [(eq? (first paren_group)\
    \ #\\()\n                          (add1 (paren-count (rest paren_group)))]\n\
    \                         [(eq? (first paren_group) #\\))\n                  \
    \        (sub1 (paren-count (rest paren_group)))]\n                         [else\
    \ (paren-count (rest paren_group))]))]\n           (paren-count paren_group)))\n\
    \       (string-split paren_string)))\n```\n\n### [Problem 2](https://www.hackerrank.com/challenges/fp-filter-array)\n\
    \n```racket\n#lang racket\n", "  (map (lambda (paren_group)\n         (let loop\
    \ ([paren_group paren_group] [max_depth 0] [depth 0])\n           (cond [(empty?\
    \ paren_group) max_depth]\n                 [(char=? (first paren_group) #\\()\n\
    \                  (loop (rest paren_group)\n                        (if (&gt;\
    \ depth max_depth) depth max_depth)\n                        (+ depth 1))]\n \
    \                [(char=? (first paren_group) #\\))\n                  (loop (rest\
    \ paren_group)\n                        (if (&gt; depth max_depth) depth max_depth)\n\
    \                        (- depth 1))]\n                 [else (loop (rest paren_group)\
    \ max_depth depth)])))\n       (string-&gt;list/c (string-trim paren_string))))\n\
    </code>\n", "  (map (lambda (paren_group)\n         (paren-group-max-depth paren_group))\n\
    \       (string-split paren_string)))\n", "  (map (\u03BB (paren_group)\n    \
    \     (let loop ([paren_group paren_group] [max_level 0] [level 0])\n        \
    \   (cond [(empty? paren_group) max_level]\n                 [(char=? (first paren_group)\
    \ #\\()\n                  (loop (rest paren_group)\n                        (max\
    \ max_level (add1 level))\n                        (add1 level))]\n          \
    \       [(char=? (first paren_group) #\\))\n                  (loop (rest paren_group)\n\
    \                        max_level\n                        (sub1 level))]\n \
    \                [else (loop (rest paren_group)\n                            \
    \ max_level\n                             level)])))\n       (regexp-match* #rx\"\
    ([()]*)\" paren_string)))\n", "  (map (lambda (paren_group)\n         (let loop\
    \ ([paren_group paren_group] [max_level 0] [current_level 0])\n           (cond\
    \ [(empty? paren_group) max_level]\n                 [(char=? (first paren_group)\
    \ #\\()\n                  (loop (rest paren_group)\n                        (if\
    \ (> current_level max_level)\n                            current_level\n   \
    \                         max_level)\n                        (+ current_level\
    \ 1))]\n                 [(char=? (first paren_group) #\\))\n                \
    \  (loop (rest paren_group)\n                        (if (> current_level max_level)\n\
    \                            current_level\n                            max_level)\n\
    \                        (- current_level 1))]\n                 [else (loop (rest\
    \ paren_group) max_level current_level)])))\n       (regexp-split #rx\" \" paren_string)))\n",
  "  (map (\u03BB (paren_group)\n         (count-parens paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (apply max (map\
    \ (lambda (paren_group_char)\n                           (if (char=? paren_group_char\
    \ #\\()\n                               1\n                               -1))\n\
    \                         (string->list paren_group))))\n       (string-split\
    \ paren_string #\\space)))\n", "  (map (lambda (paren_group)\n         (paren-depth\
    \ paren_group 0))\n       (string-split paren_string #\\space)))\n", "  (map (lambda\
    \ (paren_group)\n         (paren_nesting_depth paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (cond [(empty?\
    \ paren_string) 0]\n          [(eq? (first paren_string) #\\()\n           (+\
    \ 1 (parse_parens (rest paren_string)))]\n          [(eq? (first paren_string)\
    \ #\\))\n           (- 1 (parse_parens (rest paren_string)))]\n          [else\
    \ (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split paren_string\
    \ #\\space)))\n", "  (map (lambda (paren_group)\n         (paren-depth paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (let loop ([paren_group paren_group] [max_level 0] [curr_level 0])\n\
    \           (cond [(empty? paren_group) max_level]\n                 [(char=?\
    \ (first paren_group) #\\()\n                  (loop (rest paren_group)\n    \
    \                    (if (> curr_level max_level)\n                          \
    \  (+ curr_level 1)\n                            max_level)\n                \
    \        (+ curr_level 1))]\n                 [(char=? (first paren_group) #\\\
    ))\n                  (loop (rest paren_group)\n                        max_level\n\
    \                        (- curr_level 1))]\n                 [else (loop (rest\
    \ paren_group)\n                             max_level\n                     \
    \        curr_level)])))\n       (string-split paren_string)))\n", "  (define\
    \ (parse_parens paren_string)\n    (let loop ([paren_string paren_string] [level\
    \ 0] [max_level 0])\n      (cond\n        [(empty? paren_string) max_level]\n\
    \        [(char=? (first paren_string) #\\()\n         (loop (rest paren_string)\
    \ (+ level 1) (max level max_level))]\n        [(char=? (first paren_string) #\\\
    ))\n         (loop (rest paren_string) (- level 1) max_level)]\n        [else\
    \ (loop (rest paren_string) level max_level)])))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n", "  (define (parse_parens paren_string)\n    (define\
    \ (parse_parens-iter paren_string level)\n      (cond\n        [(empty? paren_string)\
    \ level]\n        [(char=? (first paren_string) #\\()\n         (parse_parens-iter\
    \ (rest paren_string) (+ level 1))]\n        [(char=? (first paren_string) #\\\
    ))\n         (parse_parens-iter (rest paren_string) (- level 1))]\n        [else\
    \ (parse_parens-iter (rest paren_string) level)]))\n    (parse_parens-iter paren_string\
    \ 0))\n  (map parse_parens (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (count-parens paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren-level paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (define (parse-parens paren-string)\n    (define (parse-parens-iter\
    \ paren-string paren-count max-paren-count)\n      (cond ((empty? paren-string)\
    \ (list paren-count max-paren-count))\n            ((char=? (first paren-string)\
    \ #\\()\n             (parse-parens-iter (rest paren-string) (+ paren-count 1)\
    \ (max paren-count max-paren-count)))\n            ((char=? (first paren-string)\
    \ #\\))\n             (parse-parens-iter (rest paren-string) (- paren-count 1)\
    \ (max paren-count max-paren-count)))\n            (else (parse-parens-iter (rest\
    \ paren-string) paren-count max-paren-count))))\n    (parse-parens-iter paren-string\
    \ 0 0))\n  (define (parse-parens-string paren-string)\n    (cond ((empty? paren-string)\
    \ '())\n          ((char=? (first paren-string) #\\ )\n           (cons (parse-parens\
    \ (first (regexp-match #rx\"^[^ ]+\" paren-string)))\n                 (parse-parens-string\
    \ (regexp-replace #rx\"^[^ ]+ \" \"\" paren-string))))\n          (else (cons\
    \ (parse-parens paren-string) '()))))\n  (map second (parse-parens-string paren-string)))\n",
  "  (map (lambda (paren_group)\n         (paren-nesting-level paren_group))\n   \
    \    (string-split paren_string)))\n", "  (map (lambda (paren_group)\n       \
    \  (paren-depth paren_group 0))\n       (string-split paren_string)))\n", "  (map\
    \ (\u03BB (paren_group)\n         (paren-depth paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren-depth paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (for/list ([paren-group (in-list\
    \ (string-split paren_string))])\n    (let ([paren-stack '()])\n      (for ([paren\
    \ (in-string paren-group)])\n        (cond\n          [(char=? paren #\\()\n \
    \          (push paren paren-stack)]\n          [(char=? paren #\\))\n       \
    \    (pop paren-stack)]))\n      (length paren-stack))))\n", "  (map (lambda (paren_group)\n\
    \         (paren_group_max_nesting paren_group))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (max-depth-of-parens paren_group 0 0))\n\
    \       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (paren_nesting_level paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [current_depth 0])\n           (cond [(empty? paren_group) max_depth]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group)\n                        (if (> current_depth max_depth)\n    \
    \                        (+ current_depth 1)\n                            max_depth)\n\
    \                        (+ current_depth 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group)\n           \
    \             max_depth\n                        (- current_depth 1))]\n     \
    \            [else (loop (rest paren_group) max_depth current_depth)])))\n   \
    \    (regexp-split #rx\" \" paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (parse-parens paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_group_nesting_level paren_group))\n\
    \       (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (define (parse-parens-helper paren_string current-level max-level)\n    \
    \  (cond\n        [(empty? paren_string) max-level]\n        [(equal? (first paren_string)\
    \ #\\()\n         (parse-parens-helper (rest paren_string) (+ current-level 1)\
    \ (max current-level max-level))]\n        [(equal? (first paren_string) #\\))\n\
    \         (parse-parens-helper (rest paren_string) (- current-level 1) max-level)]\n\
    \        [else (parse-parens-helper (rest paren_string) current-level max-level)]))\n\
    \    (parse-parens-helper paren_string 0 0))\n  (map parse_parens (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren-depth paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (define (parse-parens paren-string)\n\
    \    (define (parse-parens-iter paren-string paren-count max-paren-count)\n  \
    \    (cond\n        [(empty? paren-string)\n         (list paren-count max-paren-count)]\n\
    \        [(char=? (first paren-string) #\\()\n         (parse-parens-iter (rest\
    \ paren-string) (+ paren-count 1) (max paren-count max-paren-count))]\n      \
    \  [(char=? (first paren-string) #\\))\n         (parse-parens-iter (rest paren-string)\
    \ (- paren-count 1) (max paren-count max-paren-count))]\n        [else\n     \
    \    (parse-parens-iter (rest paren-string) paren-count max-paren-count)]))\n\
    \    (parse-parens-iter paren-string 0 0))\n  (define (parse-parens-group paren-string)\n\
    \    (cond\n      [(empty? paren-string)\n       (list)]\n      [(char=? (first\
    \ paren-string) #\\()\n       (cons (parse-parens paren-string) (parse-parens-group\
    \ (rest paren-string)))]\n      [else\n       (parse-parens-group (rest paren-string))]))\n\
    \  (map second (parse-parens-group paren-string)))\n", "  (define (paren-level\
    \ paren_string)\n    (let loop ([paren_string paren_string] [level 0])\n     \
    \ (cond [(empty? paren_string) level]\n            [(char=? (first paren_string)\
    \ #\\()\n             (loop (rest paren_string) (+ level 1))]\n            [(char=?\
    \ (first paren_string) #\\))\n             (loop (rest paren_string) (- level\
    \ 1))]\n            [else (loop (rest paren_string) level)])))\n  (map paren-level\
    \ (string-split paren_string)))\n", "  (map (\u03BB (paren_group)\n         (let\
    \ loop ([paren_group paren_group] [max_depth 0] [current_depth 0])\n         \
    \  (cond [(empty? paren_group) max_depth]\n                 [(char=? (first paren_group)\
    \ #\\()\n                  (loop (rest paren_group)\n                        (if\
    \ (> current_depth max_depth)\n                            current_depth\n   \
    \                         max_depth)\n                        (+ current_depth\
    \ 1))]\n                 [(char=? (first paren_group) #\\))\n                \
    \  (loop (rest paren_group)\n                        max_depth\n             \
    \           (- current_depth 1))]\n                 [else (loop (rest paren_group)\n\
    \                             max_depth\n                             current_depth)])))\n\
    \       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (count-paren-levels paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_nesting\
    \ 0] [current_nesting 0])\n           (cond [(empty? paren_group) max_nesting]\n\
    \                 [(char=? (first paren_group) #\\()\n                  (loop\
    \ (rest paren_group)\n                        (if (> current_nesting max_nesting)\n\
    \                            (+ current_nesting 1)\n                         \
    \   max_nesting)\n                        (+ current_nesting 1))]\n          \
    \       [(char=? (first paren_group) #\\))\n                  (loop (rest paren_group)\n\
    \                        max_nesting\n                        (- current_nesting\
    \ 1))]\n                 [else (loop (rest paren_group)\n                    \
    \         max_nesting\n                             current_nesting)])))\n   \
    \    (regexp-split #rx\" \" paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren-depth paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_level\
    \ 0] [current_level 0])\n           (cond [(empty? paren_group) max_level]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group)\n                        (if (> current_level max_level)\n    \
    \                        current_level\n                            max_level)\n\
    \                        (+ current_level 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group)\n           \
    \             (if (> current_level max_level)\n                            current_level\n\
    \                            max_level)\n                        (- current_level\
    \ 1))]\n                 [else (loop (rest paren_group) max_level current_level)])))\n\
    \       (regexp-split #rx\" \" paren_string)))\n", "  (map (\u03BB (paren_group)\n\
    \         (foldl (\u03BB (paren_char acc)\n                  (if (eq? paren_char\
    \ #\\()\n                      (+ acc 1)\n                      (- acc 1)))\n\
    \                0\n                paren_group))\n       (string-split paren_string\
    \ #\\space)))\n", "  (map (lambda (paren_group)\n         (paren-depth paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren-depth paren_group))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_nesting_level paren_group 0))\n \
    \      (string-split paren_string)))\n", "  (map (lambda (paren_group)\n     \
    \    (parse-parens paren_group 0))\n       (string-split paren_string)))\n", " \
    \ (map (lambda (paren_group)\n         (count-parens paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (\u03BB (paren_group)\n         (let loop ([paren_group\
    \ paren_group] [max_nesting 0] [current_nesting 0])\n           (cond [(empty?\
    \ paren_group) max_nesting]\n                 [(char=? (first paren_group) #\\\
    ()\n                  (loop (rest paren_group)\n                        (if (&gt;\
    \ current_nesting max_nesting)\n                            current_nesting\n\
    \                            max_nesting)\n                        (+ current_nesting\
    \ 1))]\n                 [(char=? (first paren_group) #\\))\n                \
    \  (loop (rest paren_group)\n                        (if (&gt; current_nesting\
    \ max_nesting)\n                            current_nesting\n                \
    \            max_nesting)\n                        (- current_nesting 1))]\n \
    \                [else (loop (rest paren_group) max_nesting current_nesting)])))\n\
    \       (string-&gt;list/c (string-split paren_string #\\space))))\n</code>\n",
  "  (map (lambda (paren_group)\n         (paren-depth paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group) (count-parens paren_group\
    \ 0)) (string-split paren_string)))\n", "  (map (lambda (paren_group)\n      \
    \   (count_parens paren_group 0))\n       (string-split paren_string)))\n", " \
    \ (map (lambda (paren_group)\n         (paren-depth paren_group))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (let loop ([paren_group\
    \ paren_group] [max_level 0] [curr_level 0])\n           (cond [(empty? paren_group)\
    \ max_level]\n                 [(char=? (first paren_group) #\\()\n          \
    \        (loop (rest paren_group)\n                        (if (> curr_level max_level)\n\
    \                            (+ curr_level 1)\n                            max_level)\n\
    \                        (+ curr_level 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group)\n           \
    \             max_level\n                        (- curr_level 1))]\n        \
    \         [else (loop (rest paren_group)\n                             max_level\n\
    \                             curr_level)])))\n       (string-split paren_string)))\n",
  "  (let ([paren_list (string-&gt;list paren_string)])\n    (let loop ([paren_list\
    \ paren_list] [paren_count 0] [max_paren_count 0])\n      (cond\n        [(empty?\
    \ paren_list) (list max_paren_count)]\n        [(char=? (first paren_list) #\\\
    ()\n         (loop (rest paren_list) (+ paren_count 1) (max paren_count max_paren_count))]\n\
    \        [(char=? (first paren_list) #\\))\n         (loop (rest paren_list) (-\
    \ paren_count 1) max_paren_count)]\n        [else (loop (rest paren_list) paren_count\
    \ max_paren_count)]))))\n</code>\n", "  (define (parse_parens paren_string)\n\
    \    (define (parse_parens_iter paren_string acc)\n      (cond\n        [(empty?\
    \ paren_string) acc]\n        [(char=? (first paren_string) #\\()\n         (parse_parens_iter\
    \ (rest paren_string) (add1 acc))]\n        [(char=? (first paren_string) #\\\
    ))\n         (parse_parens_iter (rest paren_string) (sub1 acc))]\n        [else\
    \ (parse_parens_iter (rest paren_string) acc)]))\n    (parse_parens_iter paren_string\
    \ 0))\n  (define (parse_parens_iter paren_string acc)\n    (cond\n      [(empty?\
    \ paren_string) acc]\n      [(char=? (first paren_string) #\\ )\n       (parse_parens_iter\
    \ (rest paren_string) acc)]\n      [else (parse_parens_iter (rest paren_string)\
    \ (cons (parse_parens paren_string) acc))]))\n  (parse_parens_iter paren_string\
    \ '()))\n", "  (define (parse-parens paren-string)\n    (define (parse-parens-iter\
    \ paren-string max-nesting)\n      (cond\n        [(empty? paren-string) max-nesting]\n\
    \        [(string=? (first paren-string) \"(\")\n         (parse-parens-iter (rest\
    \ paren-string) (+ max-nesting 1))]\n        [(string=? (first paren-string) \"\
    )\")\n         (parse-parens-iter (rest paren-string) (- max-nesting 1))]\n  \
    \      [else (parse-parens-iter (rest paren-string) max-nesting)]))\n    (parse-parens-iter\
    \ paren-string 0))\n  (define (parse-parens-iter paren-string max-nesting)\n \
    \   (cond\n      [(empty? paren-string) (list max-nesting)]\n      [(string=?\
    \ (first paren-string) \" \")\n       (cons max-nesting (parse-parens-iter (rest\
    \ paren-string) 0))]\n      [else (parse-parens-iter (rest paren-string) (parse-parens\
    \ (first paren-string)))]))\n  (parse-parens-iter paren-string 0))\n", "  (map\
    \ (lambda (paren_group)\n         (paren-depth paren_group))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren-depth paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (let loop ([paren_string paren_string] [depth 0] [max-depth 0])\n      (cond\n\
    \        [(empty? paren_string) max-depth]\n        [(char=? (first paren_string)\
    \ #\\()\n         (loop (rest paren_string) (+ depth 1) (max depth max-depth))]\n\
    \        [(char=? (first paren_string) #\\))\n         (loop (rest paren_string)\
    \ (- depth 1) max-depth)]\n        [else (loop (rest paren_string) depth max-depth)])))\n\
    \  (map parse_parens (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (let loop ([paren_group paren_group] [max_level 0] [curr_level 0])\n\
    \           (cond [(empty? paren_group) max_level]\n                 [(char=?\
    \ (first paren_group) #\\()\n                  (loop (rest paren_group)\n    \
    \                    (if (> (+ curr_level 1) max_level)\n                    \
    \        (+ curr_level 1)\n                            max_level)\n          \
    \              (+ curr_level 1))]\n                 [(char=? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group)\n                        max_level\n\
    \                        (- curr_level 1))]\n                 [else (loop (rest\
    \ paren_group) max_level curr_level)])))\n       (regexp-split #rx\" \" paren_string)))\n",
  "  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_nesting\
    \ 0] [current_nesting 0])\n           (cond [(empty? paren_group) max_nesting]\n\
    \                 [(char=? (first paren_group) #\\()\n                  (loop\
    \ (rest paren_group)\n                        (max max_nesting (add1 current_nesting))\n\
    \                        (add1 current_nesting))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group)\n           \
    \             max_nesting\n                        (sub1 current_nesting))]\n\
    \                 [else (loop (rest paren_group)\n                           \
    \  max_nesting\n                             current_nesting)])))\n       (string-split\
    \ paren_string #\\space)))\n", "  (define (parse_parens paren_string)\n    (define\
    \ (parse-parens-iter paren_string max-level level)\n      (cond\n        [(empty?\
    \ paren_string) (list max-level level)]\n        [(equal? (first paren_string)\
    \ #\\() (parse-parens-iter (rest paren_string) (max max-level (add1 level)) (add1\
    \ level))]\n        [(equal? (first paren_string) #\\)) (parse-parens-iter (rest\
    \ paren_string) max-level (sub1 level))]\n        [else (parse-parens-iter (rest\
    \ paren_string) max-level level)]))\n    (parse-parens-iter paren_string 0 0))\n\
    \  (define (parse-parens-string-iter paren_string max-levels)\n    (cond\n   \
    \   [(empty? paren_string) max-levels]\n      [else (parse-parens-string-iter\
    \ (rest paren_string) (append max-levels (list (first (parse_parens (first paren_string))))))]))\n\
    \  (parse-parens-string-iter (string-split paren_string #\\space) '()))\n", " \
    \ (map (lambda (paren_group)\n         (paren_group_max_nesting paren_group))\n\
    \       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (parse-parens paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (\u03BB (paren_group) (parse_nested_parens_helper paren_group 0)) (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_group_max_nesting\
    \ paren_group))\n       (string-split paren_string)))\n", "  (define (parse_parens\
    \ paren_string)\n    (define (parse-parens-helper paren_string count)\n      (cond\n\
    \        [(empty? paren_string) count]\n        [(char=? (first paren_string)\
    \ #\\()\n         (parse-parens-helper (rest paren_string) (+ count 1))]\n   \
    \     [(char=? (first paren_string) #\\))\n         (parse-parens-helper (rest\
    \ paren_string) (- count 1))]\n        [else (parse-parens-helper (rest paren_string)\
    \ count)]))\n    (parse-parens-helper paren_string 0))\n  (define (parse-parens-list\
    \ paren_string)\n    (cond\n      [(empty? paren_string) empty]\n      [(char=?\
    \ (first paren_string) #\\ )\n       (cons (parse_parens (rest paren_string))\n\
    \             (parse-parens-list (rest paren_string)))]\n      [else (cons (parse_parens\
    \ paren_string)\n                  (parse-parens-list paren_string))]))\n  (parse-parens-list\
    \ paren_string))\n", "  (define (parse-parens-helper paren_string max-level)\n\
    \    (cond ((null? paren_string) max-level)\n          ((eq? (car paren_string)\
    \ #\\()\n           (parse-parens-helper (cdr paren_string) (+ max-level 1)))\n\
    \          ((eq? (car paren_string) #\\))\n           (parse-parens-helper (cdr\
    \ paren_string) (- max-level 1)))\n          ((eq? (car paren_string) #\\space)\n\
    \           (parse-parens-helper (cdr paren_string) max-level))\n          (else\
    \ (error \"Invalid input\"))))\n  (define (parse-parens-helper-2 paren_string\
    \ max-level)\n    (cond ((null? paren_string) (list max-level))\n          ((eq?\
    \ (car paren_string) #\\()\n           (parse-parens-helper-2 (cdr paren_string)\
    \ (+ max-level 1)))\n          ((eq? (car paren_string) #\\))\n           (parse-parens-helper-2\
    \ (cdr paren_string) (- max-level 1)))\n          ((eq? (car paren_string) #\\\
    space)\n           (cons max-level (parse-parens-helper-2 (cdr paren_string) 0)))))\n\
    \  (parse-parens-helper-2 paren_string 0))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group))\n       (string-split paren_string)))\n",
  "  (map (\u03BB (paren_group)\n         (paren_group_max_depth paren_group 0))\n\
    \       (string-split paren_string #\\space)))\n", "  (define (parse-parens paren-string)\n\
    \    (define (parse-parens-iter paren-string paren-count max-paren-count)\n  \
    \    (cond [(empty? paren-string) max-paren-count]\n            [(char=? (first\
    \ paren-string) #\\()\n             (parse-parens-iter (rest paren-string) (+\
    \ paren-count 1)\n                                (if (> paren-count max-paren-count)\n\
    \                                    paren-count\n                           \
    \         max-paren-count))]\n            [(char=? (first paren-string) #\\))\n\
    \             (parse-parens-iter (rest paren-string) (- paren-count 1)\n     \
    \                           (if (> paren-count max-paren-count)\n            \
    \                        paren-count\n                                    max-paren-count))]\n\
    \            [else (parse-parens-iter (rest paren-string) paren-count max-paren-count)]))\n\
    \    (parse-parens-iter paren-string 0 0))\n  (define (parse-parens-iter paren-string\
    \ paren-count max-paren-count)\n    (cond [(empty? paren-string) (list max-paren-count)]\n\
    \          [(char=? (first paren-string) #\\ )\n           (parse-parens-iter\
    \ (rest paren-string) paren-count max-paren-count)]\n          [else (cons (parse-parens\
    \ (first paren-string))\n                      (parse-parens-iter (rest paren-string)\
    \ paren-count max-paren-count))]))\n  (parse-parens-iter paren_string 0 0))\n",
  "  (map (lambda (paren_group)\n         (count-parens paren_group 0))\n       (string-tokenize\
    \ paren_string)))\n", "  (map (lambda (paren_group) (parse_paren_group paren_group))\
    \ (string-split paren_string)))\n", "  (map (lambda (paren_group)\n         (paren-depth\
    \ paren_group 0))\n       (string-split paren_string #\\space)))\n", "  (map (lambda\
    \ (paren_group)\n         (max-depth-of-parens paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (count-parens paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (define (parse-parens paren-string)\n\
    \    (define (parse-parens-iter paren-string max-level level)\n      (cond\n \
    \       [(empty? paren-string) max-level]\n        [(char=? (first paren-string)\
    \ #\\()\n         (parse-parens-iter (rest paren-string)\n                   \
    \         (if (> level max-level) level max-level)\n                         \
    \   (+ level 1))]\n        [(char=? (first paren-string) #\\))\n         (parse-parens-iter\
    \ (rest paren-string)\n                            (if (> level max-level) level\
    \ max-level)\n                            (- level 1))]\n        [else (parse-parens-iter\
    \ (rest paren-string) max-level level)]))\n    (parse-parens-iter paren-string\
    \ 0 0))\n  (define (parse-parens-list paren-string)\n    (cond\n      [(empty?\
    \ paren-string) empty]\n      [(char=? (first paren-string) #\\ )\n       (cons\
    \ (parse-parens (rest paren-string))\n             (parse-parens-list (rest paren-string)))]\n\
    \      [else (cons (parse-parens paren-string)\n                  (parse-parens-list\
    \ paren-string))]))\n  (parse-parens-list paren-string))\n", "  (map (lambda (paren_group)\n\
    \         (paren_group_max_depth paren_group))\n       (paren_group_list paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren-depth paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (\u03BB (paren_group)\n         (apply max (map\
    \ (\u03BB (paren_level)\n                           (string-length paren_level))\n\
    \                         (regexp-split #rx\" \" paren_group))))\n       (regexp-split\
    \ #rx\" \" paren_string)))\n", "  (map (lambda (paren_group)\n         (let loop\
    \ ([paren_group paren_group] [max_nesting 0] [curr_nesting 0])\n           (cond\
    \ [(empty? paren_group) max_nesting]\n                 [(char=? (first paren_group)\
    \ #\\()\n                  (loop (rest paren_group)\n                        (if\
    \ (> curr_nesting max_nesting)\n                            curr_nesting\n   \
    \                         max_nesting)\n                        (+ curr_nesting\
    \ 1))]\n                 [(char=? (first paren_group) #\\))\n                \
    \  (loop (rest paren_group)\n                        max_nesting\n           \
    \             (- curr_nesting 1))]\n                 [else (loop (rest paren_group)\n\
    \                             max_nesting\n                             curr_nesting)])))\n\
    \       (regexp-split #rx\" \" paren_string)))\n", "  (define (parse-parens paren_string)\n\
    \    (define (parse-parens-iter paren_string max-nesting)\n      (cond [(empty?\
    \ paren_string) max-nesting]\n            [(char=? (first paren_string) #\\()\n\
    \             (parse-parens-iter (rest paren_string) (+ max-nesting 1))]\n   \
    \         [(char=? (first paren_string) #\\))\n             (parse-parens-iter\
    \ (rest paren_string) (- max-nesting 1))]\n            [else (parse-parens-iter\
    \ (rest paren_string) max-nesting)]))\n    (parse-parens-iter paren_string 0))\n\
    \  (define (parse-parens-groups paren_string)\n    (cond [(empty? paren_string)\
    \ empty]\n          [(char=? (first paren_string) #\\ )\n           (cons (parse-parens\
    \ (rest paren_string))\n                 (parse-parens-groups (rest paren_string)))]\n\
    \          [else (parse-parens-groups (rest paren_string))]))\n  (parse-parens-groups\
    \ paren_string))\n", "  (map (lambda (paren_group)\n         (paren-depth paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (define (parse-parens paren_string\
    \ acc)\n    (cond [(empty? paren_string) (reverse acc)]\n          [(char=? (first\
    \ paren_string) #\\()\n           (parse-parens (rest paren_string) (cons 1 acc))]\n\
    \          [(char=? (first paren_string) #\\))\n           (parse-parens (rest\
    \ paren_string) (cons (+ 1 (first acc)) (rest acc)))]\n          [(char=? (first\
    \ paren_string) #\\space)\n           (parse-parens (rest paren_string) (cons\
    \ 0 acc))]))\n  (parse-parens paren_string (list 0)))\n", "  (map (lambda (paren_group)\n\
    \         (parse-parens paren_group))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (define (parse_parens-iter paren_string\
    \ count max_count)\n      (cond ((null? paren_string) max_count)\n           \
    \ ((equal? (car paren_string) \"(\")\n             (parse_parens-iter (cdr paren_string)\
    \ (+ count 1) (max count max_count)))\n            ((equal? (car paren_string)\
    \ \")\")\n             (parse_parens-iter (cdr paren_string) (- count 1) (max\
    \ count max_count)))\n            (else (parse_parens-iter (cdr paren_string)\
    \ count max_count))))\n    (parse_parens-iter paren_string 0 0))\n  (map parse_parens\
    \ (string-split paren_string)))\n", "  (map (lambda (paren_group)\n         (paren-depth\
    \ paren_group 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (parse-parens paren_group))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (count-parens paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_depth paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (let loop ([paren_group paren_group] [max_depth 0] [depth 0])\n    \
    \       (cond [(empty? paren_group) max_depth]\n                 [(char=? (first\
    \ paren_group) #\\()\n                  (loop (rest paren_group) (max max_depth\
    \ (add1 depth)) (add1 depth))]\n                 [(char=? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group) (max max_depth depth) (sub1\
    \ depth))]\n                 [else (loop (rest paren_group) max_depth depth)])))\n\
    \       (split-string paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (let loop ([paren_group paren_group] [max_depth 0] [current_depth 0])\n\
    \           (cond [(empty? paren_group) max_depth]\n                 [(char=?\
    \ (first paren_group) #\\()\n                  (loop (rest paren_group)\n    \
    \                    (if (> current_depth max_depth)\n                       \
    \     current_depth\n                            max_depth)\n                \
    \        (+ current_depth 1))]\n                 [(char=? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group)\n                        max_depth\n\
    \                        (- current_depth 1))]\n                 [else (loop (rest\
    \ paren_group) max_depth current_depth)])))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [paren_count 0] [max_paren_count 0])\n      (cond\n        [(empty? paren_string)\
    \ max_paren_count]\n        [(char=? (first paren_string) #\\()\n         (loop\
    \ (rest paren_string) (+ paren_count 1) (max paren_count max_paren_count))]\n\
    \        [(char=? (first paren_string) #\\))\n         (loop (rest paren_string)\
    \ (- paren_count 1) max_paren_count)]\n        [else (loop (rest paren_string)\
    \ paren_count max_paren_count)])))\n  (map parse_parens (string-split paren_string\
    \ #\\space)))\n", "  (map (lambda (paren_group)\n         (paren_depth paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (map (\u03BB (paren_group)\n\
    \         (paren-depth paren_group))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren-depth paren_group))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (count-parens paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren-depth paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (\u03BB (paren_group) (parse_paren_group paren_group)) (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren-depth paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (let loop ([paren_group\
    \ paren_group] [paren_count 0] [max_paren_count 0])\n           (cond [(empty?\
    \ paren_group) max_paren_count]\n                 [(char=? (first paren_group)\
    \ #\\()\n                  (loop (rest paren_group) (+ paren_count 1) (max paren_count\
    \ max_paren_count))]\n                 [(char=? (first paren_group) #\\))\n  \
    \                (loop (rest paren_group) (- paren_count 1) (max paren_count max_paren_count))]\n\
    \                 [else (loop (rest paren_group) paren_count max_paren_count)])))\n\
    \       (string-split paren_string #\\space)))\n", "  (define (parse_parens paren_string)\n\
    \    (define (parse-parens-helper paren_string paren_count)\n      (cond\n   \
    \     [(empty? paren_string) paren_count]\n        [(char=? (first paren_string)\
    \ #\\()\n         (parse-parens-helper (rest paren_string) (+ paren_count 1))]\n\
    \        [(char=? (first paren_string) #\\))\n         (parse-parens-helper (rest\
    \ paren_string) (- paren_count 1))]\n        [else (parse-parens-helper (rest\
    \ paren_string) paren_count)]))\n    (parse-parens-helper paren_string 0))\n \
    \ (define (parse-parens-list paren_string)\n    (cond\n      [(empty? paren_string)\
    \ empty]\n      [(char=? (first paren_string) #\\ )\n       (cons (parse_parens\
    \ (rest paren_string))\n             (parse-parens-list (rest paren_string)))]\n\
    \      [else (cons (parse_parens paren_string) empty)]))\n  (parse-parens-list\
    \ paren_string))\n", "  (map (lambda (paren_group)\n         (max-depth paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (\u03BB (paren_group) (parse_nested_parens_helper paren_group 0))\n    \
    \   (string-split paren_string)))\n", "  (map (lambda (paren_group)\n        \
    \ (count-paren-nesting paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_group_max_depth paren_group))\n \
    \      (string-split paren_string)))\n", "  (map (lambda (paren_group)\n     \
    \    (count-paren-nesting paren_group 0))\n       (string-split paren_string)))\n",
  "  (define (parse-parens-helper paren_string)\n    (define (parse-parens-helper-inner\
    \ paren_string current_level max_level)\n      (cond\n        [(empty? paren_string)\
    \ (list current_level max_level)]\n        [(char=? (first paren_string) #\\()\n\
    \         (parse-parens-helper-inner (rest paren_string) (+ current_level 1)\n\
    \                                    (if (> current_level max_level) current_level\
    \ max_level))]\n        [(char=? (first paren_string) #\\))\n         (parse-parens-helper-inner\
    \ (rest paren_string) (- current_level 1) max_level)]\n        [else (parse-parens-helper-inner\
    \ (rest paren_string) current_level max_level)]))\n    (parse-parens-helper-inner\
    \ paren_string 0 0))\n  (define (parse-parens-helper-outer paren_string)\n   \
    \ (cond\n      [(empty? paren_string) '()]\n      [else (cons (parse-parens-helper\
    \ (first (string-split paren_string #\\space)))\n                  (parse-parens-helper-outer\
    \ (rest (string-split paren_string #\\space))))]))\n  (parse-parens-helper-outer\
    \ paren_string))\n", "  (for/list ([paren_group (in-list (string-split paren_string))])\n\
    \    (let ([paren_group_len (string-length paren_group)])\n      (define (paren-level-helper\
    \ paren-group-len paren-group-index paren-level)\n        (cond\n          [(=\
    \ paren-group-index paren-group-len) paren-level]\n          [(char=? (string-ref\
    \ paren-group paren-group-index) #\\()\n           (paren-level-helper paren-group-len\
    \ (+ paren-group-index 1) (+ paren-level 1))]\n          [(char=? (string-ref\
    \ paren-group paren-group-index) #\\))\n           (paren-level-helper paren-group-len\
    \ (+ paren-group-index 1) (- paren-level 1))]\n          [else (paren-level-helper\
    \ paren-group-len (+ paren-group-index 1) paren-level)]))\n      (paren-level-helper\
    \ paren-group-len 0 0))))\n", "  (map (\u03BB (paren_group)\n         (apply max\
    \ (map length (regexp-match #rx\"\\(([^()]*)\\)\" paren_group))))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_depth paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (define (parse-parens-helper paren_string count max-count)\n      (cond [(empty?\
    \ paren_string) (values count max-count)]\n            [(char=? (first paren_string)\
    \ #\\()\n             (parse-parens-helper (rest paren_string) (+ count 1) (max\
    \ count max-count))]\n            [(char=? (first paren_string) #\\))\n      \
    \       (parse-parens-helper (rest paren_string) (- count 1) (max count max-count))]\n\
    \            [else (parse-parens-helper (rest paren_string) count max-count)]))\n\
    \    (parse-parens-helper paren_string 0 0))\n  (define (parse-parens-list paren_string)\n\
    \    (cond [(empty? paren_string) empty]\n          [(char=? (first paren_string)\
    \ #\\ )\n           (cons (parse_parens (rest paren_string)) (parse-parens-list\
    \ (rest paren_string)))]\n          [else (parse-parens-list (rest paren_string))]))\n\
    \  (parse-parens-list paren_string))\n", "  (map (lambda (paren_group)\n     \
    \    (paren_depth paren_group 0))\n       (string-split paren_string)))\n", " \
    \ (map (lambda (paren_group)\n         (paren_group_max_nesting paren_group))\n\
    \       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (let loop ([paren_group paren_group] [max_depth 0] [current_depth 0])\n\
    \           (cond [(empty? paren_group) max_depth]\n                 [(char=?\
    \ (first paren_group) #\\()\n                  (loop (rest paren_group)\n    \
    \                    (if (> (+ current_depth 1) max_depth)\n                 \
    \           (+ current_depth 1)\n                            max_depth)\n    \
    \                    (+ current_depth 1))]\n                 [(char=? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group)\n                        max_depth\n\
    \                        (- current_depth 1))]\n                 [else (loop (rest\
    \ paren_group)\n                             max_depth\n                     \
    \        current_depth)])))\n       (string-split paren_string)))\n", "  (map\
    \ (\u03BB (paren_group)\n         (apply max (map (\u03BB (paren)\n          \
    \                 (if (equal? paren \")\")\n                               (-\
    \ 0)\n                               1))\n                         (string-&gt;list\
    \ paren_group))))\n       (regexp-split #rx\" \" paren_string)))\n</code>\n",
  "  (map (\u03BB (paren_group)\n         (paren-depth paren_group 0))\n       (string-split\
    \ paren_string #\\space)))\n", "  (map (lambda (paren_group)\n         (paren_nesting_level\
    \ paren_group 0))\n       (string-split paren_string)))\n", "  (define (parse-parens-helper\
    \ paren_string max_depth)\n    (cond\n      [(empty? paren_string) max_depth]\n\
    \      [(char=? (first paren_string) #\\()\n       (parse-parens-helper (rest\
    \ paren_string) (add1 max_depth))]\n      [(char=? (first paren_string) #\\))\n\
    \       (parse-parens-helper (rest paren_string) (sub1 max_depth))]\n      [else\
    \ (parse-parens-helper (rest paren_string) max_depth)]))\n  (define (parse-parens-group\
    \ paren_string)\n    (cond\n      [(empty? paren_string) empty]\n      [(char=?\
    \ (first paren_string) #\\ )\n       (cons (parse-parens-helper (rest paren_string)\
    \ 0)\n             (parse-parens-group (rest paren_string)))]\n      [else (parse-parens-group\
    \ (rest paren_string))]))\n  (parse-parens-group paren_string))\n", "  (for/list\
    \ ([paren_group (in-list (string-split paren_string))])\n    (let loop ([paren_group\
    \ paren_group] [level 0] [max_level 0])\n      (cond\n        [(empty? paren_group)\
    \ max_level]\n        [(char=? (first paren_group) #\\()\n         (loop (rest\
    \ paren_group) (+ level 1) (max level max_level))]\n        [(char=? (first paren_group)\
    \ #\\))\n         (loop (rest paren_group) (- level 1) max_level)]\n        [else\
    \ (loop (rest paren_group) level max_level)]))))\n", "  (map (lambda (paren_group)\n\
    \         (parse-paren-group paren_group))\n       (string-split paren_string)))\n",
  "  (define (parse_paren_group paren_group)\n    (define (parse_paren_group_helper\
    \ paren_group max_depth current_depth)\n      (cond\n        [(empty? paren_group)\
    \ max_depth]\n        [(char=? (first paren_group) #\\()\n         (parse_paren_group_helper\
    \ (rest paren_group)\n                                   (if (> current_depth\
    \ max_depth)\n                                       current_depth\n         \
    \                              max_depth)\n                                  \
    \ (+ current_depth 1))]\n        [(char=? (first paren_group) #\\))\n        \
    \ (parse_paren_group_helper (rest paren_group)\n                             \
    \      max_depth\n                                   (- current_depth 1))]\n \
    \       [else (parse_paren_group_helper (rest paren_group)\n                 \
    \                       max_depth\n                                        current_depth)]))\n\
    \    (parse_paren_group_helper paren_group 0 0))\n  (map parse_paren_group (string-split\
    \ paren_string #\\space)))\n```\n\n## Problem 3\n\n```racket\n#lang racket\n",
  "  (map (\u03BB (paren_group)\n         (apply max (map (\u03BB (paren_level)\n\
    \                           (length paren_level))\n                         (regexp-match\
    \ #rx\"(\\(+)\" paren_group))))\n       (regexp-match #rx\"([^ ]+)\" paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_group_max_nesting paren_group))\n\
    \       (string-split paren_string)))\n", "  (define (parse-parens-helper paren_string\
    \ paren_count)\n    (cond\n      [(empty? paren_string) (list paren_count)]\n\
    \      [(char=? (first paren_string) #\\()\n       (parse-parens-helper (rest\
    \ paren_string) (+ paren_count 1))]\n      [(char=? (first paren_string) #\\))\n\
    \       (parse-parens-helper (rest paren_string) (- paren_count 1))]\n      [(char=?\
    \ (first paren_string) #\\space)\n       (cons paren_count (parse-parens-helper\
    \ (rest paren_string) 0))]))\n  (parse-parens-helper paren_string 0))\n", "  (define\
    \ (parse-parens paren-string)\n    (define (parse-parens-iter paren-string depth\
    \ max-depth)\n      (cond [(empty? paren-string) max-depth]\n            [(char=?\
    \ (first paren-string) #\\()\n             (parse-parens-iter (rest paren-string)\
    \ (+ depth 1) (max depth max-depth))]\n            [(char=? (first paren-string)\
    \ #\\))\n             (parse-parens-iter (rest paren-string) (- depth 1) max-depth)]\n\
    \            [else (parse-parens-iter (rest paren-string) depth max-depth)]))\n\
    \    (parse-parens-iter paren-string 0 0))\n  (map parse-parens (string-split\
    \ paren-string)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
