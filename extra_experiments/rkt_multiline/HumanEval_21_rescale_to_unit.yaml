name: HumanEval_21_rescale_to_unit
language: rkt
prompt: "#lang racket\n\n#| Given list of numbers (of at least two elements), apply\
  \ a linear transform to that list,\nsuch that the smallest number will become 0\
  \ and the largest will become 1\n>>> (rescale_to_unit (list 1.0 2.0 3.0 4.0 5.0))\n\
  (list 0.0 0.25 0.5 0.75 1.0)|#\n(define (rescale_to_unit numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rescale_to_unit))\n\
  \    (check-equal? (candidate (list 2.0 49.9)) (list 0.0 1.0))\n    (check-equal?\
  \ (candidate (list 100.0 49.9)) (list 1.0 0.0))\n    (check-equal? (candidate (list\
  \ 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0))\n    (check-equal? (candidate\
  \ (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75))\n    (check-equal? (candidate\
  \ (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75))\n))\n\n(test-humaneval)"
completions: ["  (define (rescale_to_unit_iter numbers min max)\n    (if (null? numbers)\n\
    \        '()\n        (cons (/ (- (car numbers) min) (- max min))\n          \
    \    (rescale_to_unit_iter (cdr numbers) min max))))\n  (rescale_to_unit_iter\
    \ numbers (apply min numbers) (apply max numbers)))\n", "  (define (rescale_to_unit_helper\
    \ numbers min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (-\
    \ (car numbers) min) (- max min))\n              (rescale_to_unit_helper (cdr\
    \ numbers) min max))))\n  (rescale_to_unit_helper numbers (apply min numbers)\
    \ (apply max numbers)))\n", "  (define (rescale_to_unit_helper numbers min max)\n\
    \    (cond\n      [(empty? numbers) empty]\n      [else (cons (/ (- (first numbers)\
    \ min) (- max min))\n                  (rescale_to_unit_helper (rest numbers)\
    \ min max))]))\n  (rescale_to_unit_helper numbers (apply min numbers) (apply max\
    \ numbers)))\n", "  (define (rescale_to_unit_helper numbers min max)\n    (if\
    \ (null? numbers)\n        '()\n        (cons (/ (- (car numbers) min) (- max\
    \ min))\n              (rescale_to_unit_helper (cdr numbers) min max))))\n  (rescale_to_unit_helper\
    \ numbers (apply min numbers) (apply max numbers)))\n", "  (define (rescale_to_unit_helper\
    \ numbers min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (-\
    \ (car numbers) min) (- max min))\n              (rescale_to_unit_helper (cdr\
    \ numbers) min max))))\n  (rescale_to_unit_helper numbers (apply min numbers)\
    \ (apply max numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max\
    \ (apply max numbers)]\n         [delta (- max min)])\n    (map (lambda (x) (/\
    \ (- x min) delta)) numbers)))\n", "  (define min (apply min numbers))\n  (define\
    \ max (apply max numbers))\n  (define range (- max min))\n  (map (lambda (x) (/\
    \ (- x min) range)) numbers))\n", "  (let* ([min (apply min numbers)]\n      \
    \   [max (apply max numbers)]\n         [range (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) range)) numbers)))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [range (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) range)) numbers)))\n", "  (define (rescale_to_unit_helper numbers\
    \ min max)\n    (cond\n      [(empty? numbers) empty]\n      [else (cons (/ (-\
    \ (first numbers) min) (- max min))\n                  (rescale_to_unit_helper\
    \ (rest numbers) min max))]))\n  (rescale_to_unit_helper numbers (apply min numbers)\
    \ (apply max numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max\
    \ (apply max numbers)]\n         [range (- max min)])\n    (map (lambda (x) (/\
    \ (- x min) range)) numbers)))\n", "  (let* ([min (apply min numbers)]\n     \
    \    [max (apply max numbers)]\n         [diff (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) diff)) numbers)))\n", "  (let ([min (apply min numbers)]\n\
    \        [max (apply max numbers)])\n    (map (\u03BB (x) (/ (- x min) (- max\
    \ min))) numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [diff (- max min)])\n    (map (lambda (x) (/ (- x min)\
    \ diff)) numbers)))\n", "  (define (rescale-helper numbers min max)\n    (if (null?\
    \ numbers)\n        '()\n        (cons (/ (- (car numbers) min) (- max min)) (rescale-helper\
    \ (cdr numbers) min max))))\n  (rescale-helper numbers (apply min numbers) (apply\
    \ max numbers)))\n", "  (define (rescale_to_unit_iter numbers min max)\n    (if\
    \ (null? numbers)\n        '()\n        (cons (/ (- (car numbers) min) (- max\
    \ min))\n              (rescale_to_unit_iter (cdr numbers) min max))))\n  (rescale_to_unit_iter\
    \ numbers (apply min numbers) (apply max numbers)))\n", "  (let* ([min (apply\
    \ min numbers)]\n         [max (apply max numbers)]\n         [diff (- max min)])\n\
    \    (map (lambda (x) (/ (- x min) diff)) numbers)))\n", "  (define (rescale-helper\
    \ numbers min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (-\
    \ (car numbers) min) (- max min))\n              (rescale-helper (cdr numbers)\
    \ min max))))\n  (rescale-helper numbers (apply min numbers) (apply max numbers)))\n",
  "  (define (rescale_to_unit_iter numbers min max result)\n    (if (null? numbers)\n\
    \        result\n        (let ([number (car numbers)])\n          (rescale_to_unit_iter\
    \ (cdr numbers)\n                                (if (< number min) number min)\n\
    \                                (if (> number max) number max)\n            \
    \                    (cons (/ (- number min) (- max min)) result)))))\n  (reverse\
    \ (rescale_to_unit_iter numbers (car numbers) (car numbers) '())))\n", "  (define\
    \ (rescale_to_unit_helper numbers min max)\n    (cond\n      [(empty? numbers)\
    \ empty]\n      [else (cons (/ (- (first numbers) min) (- max min))\n        \
    \          (rescale_to_unit_helper (rest numbers) min max))]))\n  (rescale_to_unit_helper\
    \ numbers (apply min numbers) (apply max numbers)))\n", "  (let* ([min (apply\
    \ min numbers)]\n         [max (apply max numbers)]\n         [range (- max min)])\n\
    \    (map (lambda (n) (/ (- n min) range)) numbers)))\n", "  (let* ([min (apply\
    \ min numbers)]\n         [max (apply max numbers)]\n         [diff (- max min)])\n\
    \    (map (lambda (x) (/ (- x min) diff)) numbers)))\n", "  (define (rescale_to_unit_helper\
    \ numbers min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (-\
    \ (car numbers) min) (- max min))\n              (rescale_to_unit_helper (cdr\
    \ numbers) min max))))\n  (rescale_to_unit_helper numbers (apply min numbers)\
    \ (apply max numbers)))\n", "  (define (rescale_to_unit_helper numbers min max)\n\
    \    (if (null? numbers)\n        '()\n        (cons (/ (- (car numbers) min)\
    \ (- max min))\n              (rescale_to_unit_helper (cdr numbers) min max))))\n\
    \  (rescale_to_unit_helper numbers (apply min numbers) (apply max numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [range (- max min)])\n    (map (lambda (x) (/ (- x min) range)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [range (- max min)])\n    (map (lambda (x) (/ (- x min) range)) numbers)))\n",
  "  (define (rescale_to_unit_helper numbers min max)\n    (if (null? numbers)\n \
    \       '()\n        (cons (/ (- (car numbers) min) (- max min))\n           \
    \   (rescale_to_unit_helper (cdr numbers) min max))))\n  (rescale_to_unit_helper\
    \ numbers (apply min numbers) (apply max numbers)))\n", "  (define (rescale-helper\
    \ numbers min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (-\
    \ (car numbers) min) (- max min))\n              (rescale-helper (cdr numbers)\
    \ min max))))\n  (rescale-helper numbers (apply min numbers) (apply max numbers)))\n",
  "  (define (rescale_to_unit_helper numbers min max)\n    (if (null? numbers)\n \
    \       '()\n        (cons (/ (- (car numbers) min) (- max min))\n           \
    \   (rescale_to_unit_helper (cdr numbers) min max))))\n  (rescale_to_unit_helper\
    \ numbers (apply min numbers) (apply max numbers)))\n", "  (define (rescale-helper\
    \ numbers min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (-\
    \ (car numbers) min) (- max min))\n              (rescale-helper (cdr numbers)\
    \ min max))))\n  (rescale-helper numbers (apply min numbers) (apply max numbers)))\n",
  "  (define (rescale-helper numbers min max)\n    (if (null? numbers)\n        '()\n\
    \        (cons (/ (- (car numbers) min) (- max min))\n              (rescale-helper\
    \ (cdr numbers) min max))))\n  (rescale-helper numbers (apply min numbers) (apply\
    \ max numbers)))\n", "  (define min (apply min numbers))\n  (define max (apply\
    \ max numbers))\n  (define range (- max min))\n  (map (lambda (x) (/ (- x min)\
    \ range)) numbers))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [delta (- max min)])\n    (map (lambda (x) (/ (- x min)\
    \ delta)) numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [range (- max min)])\n    (map (lambda (n) (/ (- n min)\
    \ range)) numbers)))\n", "  (define (rescale_to_unit_helper numbers min max)\n\
    \    (if (null? numbers)\n        '()\n        (cons (/ (- (car numbers) min)\
    \ (- max min))\n              (rescale_to_unit_helper (cdr numbers) min max))))\n\
    \  (rescale_to_unit_helper numbers (apply min numbers) (apply max numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [diff (- max min)])\n    (map (lambda (n) (/ (- n min) diff)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [diff (- max min)])\n    (map (lambda (x) (/ (- x min) diff)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [delta (- max min)])\n    (map (lambda (x) (/ (- x min) delta)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [range (- max min)])\n    (map (lambda (x) (/ (- x min) range)) numbers)))\n",
  "  (define (rescale_to_unit_helper numbers min max)\n    (if (null? numbers)\n \
    \       '()\n        (cons (/ (- (car numbers) min) (- max min))\n           \
    \   (rescale_to_unit_helper (cdr numbers) min max))))\n  (rescale_to_unit_helper\
    \ numbers (apply min numbers) (apply max numbers)))\n", "  (let ([min (apply min\
    \ numbers)]\n        [max (apply max numbers)])\n    (map (lambda (x) (/ (- x\
    \ min) (- max min))) numbers)))\n", "  (let* ([min (apply min numbers)]\n    \
    \     [max (apply max numbers)]\n         [diff (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) diff)) numbers)))\n", "  (define (rescale_to_unit_helper numbers\
    \ min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (- (car numbers)\
    \ min) (- max min))\n              (rescale_to_unit_helper (cdr numbers) min max))))\n\
    \  (rescale_to_unit_helper numbers (apply min numbers) (apply max numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [diff (- max min)])\n    (map (lambda (x) (/ (- x min) diff)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [diff (- max min)])\n    (map (lambda (n) (/ (- n min) diff)) numbers)))\n",
  "  (define (rescale_to_unit_helper numbers min max)\n    (if (null? numbers)\n \
    \       '()\n        (cons (/ (- (car numbers) min) (- max min))\n           \
    \   (rescale_to_unit_helper (cdr numbers) min max))))\n  (rescale_to_unit_helper\
    \ numbers (apply min numbers) (apply max numbers)))\n", "  (let* ([min (apply\
    \ min numbers)]\n         [max (apply max numbers)]\n         [range (- max min)])\n\
    \    (map (lambda (n) (/ (- n min) range)) numbers)))\n", "  (define (rescale_to_unit_helper\
    \ numbers min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (-\
    \ (car numbers) min) (- max min))\n              (rescale_to_unit_helper (cdr\
    \ numbers) min max))))\n  (rescale_to_unit_helper numbers (apply min numbers)\
    \ (apply max numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max\
    \ (apply max numbers)]\n         [range (- max min)])\n    (map (lambda (x) (/\
    \ (- x min) range)) numbers)))\n", "  (let* ([min (apply min numbers)]\n     \
    \    [max (apply max numbers)]\n         [diff (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) diff)) numbers)))\n", "  (define (rescale_to_unit-helper numbers\
    \ min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (- (car numbers)\
    \ min) (- max min))\n              (rescale_to_unit-helper (cdr numbers) min max))))\n\
    \  (rescale_to_unit-helper numbers (apply min numbers) (apply max numbers)))\n",
  "  (let ((min (apply min numbers))\n        (max (apply max numbers)))\n    (map\
    \ (lambda (x) (/ (- x min) (- max min))) numbers)))\n", "  (define (rescale_to_unit_helper\
    \ numbers min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (-\
    \ (car numbers) min) (- max min))\n              (rescale_to_unit_helper (cdr\
    \ numbers) min max))))\n  (rescale_to_unit_helper numbers (apply min numbers)\
    \ (apply max numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max\
    \ (apply max numbers)]\n         [range (- max min)])\n    (map (lambda (x) (/\
    \ (- x min) range)) numbers)))\n", "  (let* ([min (apply min numbers)]\n     \
    \    [max (apply max numbers)]\n         [diff (- max min)])\n    (map (\u03BB\
    \ (x) (/ (- x min) diff)) numbers)))\n", "  (define (rescale-helper numbers min\
    \ max)\n    (if (null? numbers)\n        '()\n        (cons (/ (- (car numbers)\
    \ min) (- max min)) (rescale-helper (cdr numbers) min max))))\n  (rescale-helper\
    \ numbers (apply min numbers) (apply max numbers)))\n", "  (let ([min (apply min\
    \ numbers)]\n        [max (apply max numbers)])\n    (map (lambda (x) (/ (- x\
    \ min) (- max min))) numbers)))\n", "  (let* ([min (apply min numbers)]\n    \
    \     [max (apply max numbers)]\n         [scale (/ 1.0 (- max min))])\n    (map\
    \ (lambda (x) (* scale (- x min))) numbers)))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [diff (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) diff)) numbers)))\n", "  (define (rescale-helper numbers min\
    \ max)\n    (if (null? numbers)\n        '()\n        (cons (/ (- (car numbers)\
    \ min) (- max min))\n              (rescale-helper (cdr numbers) min max))))\n\
    \  (rescale-helper numbers (apply min numbers) (apply max numbers)))\n", "  (let*\
    \ ([min (apply min numbers)]\n         [max (apply max numbers)]\n         [diff\
    \ (- max min)])\n    (map (lambda (x) (/ (- x min) diff)) numbers)))\n", "  (let*\
    \ ([min (apply min numbers)]\n         [max (apply max numbers)]\n         [diff\
    \ (- max min)])\n    (map (lambda (x) (/ (- x min) diff)) numbers)))\n", "  (let\
    \ ([min (apply min numbers)]\n        [max (apply max numbers)])\n    (map (lambda\
    \ (x) (/ (- x min) (- max min))) numbers)))\n", "  (define (rescale_to_unit_helper\
    \ numbers min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (-\
    \ (car numbers) min) (- max min))\n              (rescale_to_unit_helper (cdr\
    \ numbers) min max))))\n  (rescale_to_unit_helper numbers (apply min numbers)\
    \ (apply max numbers)))\n", "  (let ([min (apply min numbers)]\n        [max (apply\
    \ max numbers)])\n    (map (lambda (x) (/ (- x min) (- max min))) numbers)))\n",
  "  (let* ([min-number (apply min numbers)]\n         [max-number (apply max numbers)]\n\
    \         [range (- max-number min-number)])\n    (map (lambda (x) (/ (- x min-number)\
    \ range)) numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [delta (- max min)])\n    (map (lambda (x) (/ (- x min)\
    \ delta)) numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [scale (/ (- 1.0) (- max min))])\n    (map (lambda (x)\
    \ (* scale (- x min))) numbers)))\n", "  (define (rescale-helper numbers min max)\n\
    \    (if (null? numbers)\n        '()\n        (cons (/ (- (car numbers) min)\
    \ (- max min))\n              (rescale-helper (cdr numbers) min max))))\n  (rescale-helper\
    \ numbers (apply min numbers) (apply max numbers)))\n", "  (let* ([min (apply\
    \ min numbers)]\n         [max (apply max numbers)]\n         [range (- max min)])\n\
    \    (map (lambda (x) (/ (- x min) range)) numbers)))\n", "  (let* ([min (apply\
    \ min numbers)]\n         [max (apply max numbers)]\n         [scale (/ 1.0 (-\
    \ max min))])\n    (map (lambda (x) (* scale (- x min))) numbers)))\n", "  (let*\
    \ ([min (apply min numbers)]\n         [max (apply max numbers)]\n         [scale\
    \ (/ 1.0 (- max min))])\n    (map (lambda (x) (* scale (- x min))) numbers)))\n",
  "  (define (rescale-helper numbers min max)\n    (if (null? numbers)\n        '()\n\
    \        (cons (/ (- (car numbers) min) (- max min))\n              (rescale-helper\
    \ (cdr numbers) min max))))\n  (rescale-helper numbers (apply min numbers) (apply\
    \ max numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [diff (- max min)])\n    (map (lambda (x) (/ (- x min)\
    \ diff)) numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [delta (- max min)])\n    (map (lambda (x) (/ (- x min)\
    \ delta)) numbers)))\n", "  (let ([min (apply min numbers)]\n        [max (apply\
    \ max numbers)])\n    (map (lambda (x) (/ (- x min) (- max min))) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [diff (- max min)])\n    (map (lambda (x) (/ (- x min) diff)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [delta (- max min)])\n    (map (lambda (n)\n           (/ (- n min) delta))\n\
    \         numbers)))\n", "  (define (rescale-helper numbers min max)\n    (if\
    \ (null? numbers)\n        '()\n        (cons (/ (- (car numbers) min) (- max\
    \ min))\n              (rescale-helper (cdr numbers) min max))))\n  (rescale-helper\
    \ numbers (apply min numbers) (apply max numbers)))\n", "  (let* ([min (apply\
    \ min numbers)]\n         [max (apply max numbers)]\n         [diff (- max min)])\n\
    \    (map (lambda (x) (/ (- x min) diff)) numbers)))\n", "  (let* ([min (apply\
    \ min numbers)]\n         [max (apply max numbers)]\n         [delta (- max min)])\n\
    \    (map (lambda (x) (/ (- x min) delta)) numbers)))\n", "  (let* ([min (apply\
    \ min numbers)]\n         [max (apply max numbers)]\n         [range (- max min)])\n\
    \    (map (lambda (x) (/ (- x min) range)) numbers)))\n", "  (let ([min (apply\
    \ min numbers)]\n        [max (apply max numbers)])\n    (map (lambda (x) (/ (-\
    \ x min) (- max min))) numbers)))\n", "  (let* ([min (apply min numbers)]\n  \
    \       [max (apply max numbers)]\n         [diff (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) diff)) numbers)))\n", "  (define (rescale_to_unit_helper numbers\
    \ min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (- (car numbers)\
    \ min) (- max min))\n              (rescale_to_unit_helper (cdr numbers) min max))))\n\
    \  (rescale_to_unit_helper numbers (apply min numbers) (apply max numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [diff (- max min)])\n    (map (lambda (x) (/ (- x min) diff)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [diff (- max min)])\n    (map (lambda (n) (/ (- n min) diff)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [scale (/ (- 1.0) (- max min))])\n    (map (lambda (x) (* scale (- x min)))\
    \ numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply max\
    \ numbers)]\n         [diff (- max min)])\n    (map (lambda (x) (/ (- x min) diff))\
    \ numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply max\
    \ numbers)]\n         [range (- max min)])\n    (map (lambda (x) (/ (- x min)\
    \ range)) numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [diff (- max min)])\n    (map (lambda (x) (/ (- x min)\
    \ diff)) numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [diff (- max min)])\n    (map (lambda (n) (/ (- n min)\
    \ diff)) numbers)))\n", "  (define (rescale_to_unit_iter numbers min max scaled)\n\
    \    (if (null? numbers)\n        scaled\n        (rescale_to_unit_iter (cdr numbers)\n\
    \                              (min min (car numbers))\n                     \
    \         (max max (car numbers))\n                              (append scaled\
    \ (list (/ (- (car numbers) min) (- max min)))))))\n  (rescale_to_unit_iter numbers\
    \ (car numbers) (car numbers) '()))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [range (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) range)) numbers)))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [diff (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) diff)) numbers)))\n", "  (define (rescale_to_unit_iter numbers\
    \ min max result)\n    (if (null? numbers)\n        result\n        (let* ([n\
    \ (car numbers)]\n               [r (/ (- n min) (- max min))])\n          (rescale_to_unit_iter\
    \ (cdr numbers) min max (cons r result)))))\n  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)])\n    (reverse (rescale_to_unit_iter numbers\
    \ min max '()))))\n", "  (define (rescale_to_unit_helper numbers min max)\n  \
    \  (if (null? numbers)\n        '()\n        (cons (/ (- (car numbers) min) (-\
    \ max min))\n              (rescale_to_unit_helper (cdr numbers) min max))))\n\
    \  (rescale_to_unit_helper numbers (apply min numbers) (apply max numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [diff (- max min)])\n    (map (lambda (x) (/ (- x min) diff)) numbers)))\n",
  "  (define (rescale_to_unit_helper numbers min max)\n    (if (null? numbers)\n \
    \       '()\n        (cons (/ (- (car numbers) min) (- max min))\n           \
    \   (rescale_to_unit_helper (cdr numbers) min max))))\n  (rescale_to_unit_helper\
    \ numbers (apply min numbers) (apply max numbers)))\n", "  (let* ([min (apply\
    \ min numbers)]\n         [max (apply max numbers)]\n         [range (- max min)])\n\
    \    (map (lambda (x) (/ (- x min) range)) numbers)))\n", "  (let* ([min (apply\
    \ min numbers)]\n         [max (apply max numbers)]\n         [scale (/ 1.0 (-\
    \ max min))])\n    (map (lambda (x) (* scale (- x min))) numbers)))\n", "  (let*\
    \ ([min (apply min numbers)]\n         [max (apply max numbers)]\n         [range\
    \ (- max min)])\n    (map (lambda (x) (/ (- x min) range)) numbers)))\n", "  (define\
    \ min (apply min numbers))\n  (define max (apply max numbers))\n  (define range\
    \ (- max min))\n  (map (lambda (x) (/ (- x min) range)) numbers))\n", "  (let*\
    \ ([min (apply min numbers)]\n         [max (apply max numbers)]\n         [diff\
    \ (- max min)])\n    (map (lambda (x) (/ (- x min) diff)) numbers)))\n", "  (let*\
    \ ([min (apply min numbers)]\n         [max (apply max numbers)]\n         [delta\
    \ (- max min)])\n    (map (lambda (x) (/ (- x min) delta)) numbers)))\n", "  (let*\
    \ ([min (apply min numbers)]\n         [max (apply max numbers)]\n         [diff\
    \ (- max min)])\n    (map (lambda (x) (/ (- x min) diff)) numbers)))\n", "  (let\
    \ ([min (apply min numbers)]\n        [max (apply max numbers)])\n    (map (lambda\
    \ (x) (/ (- x min) (- max min))) numbers)))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [range (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) range)) numbers)))\n", "  (define (rescale-to-unit-helper numbers\
    \ min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (- (car numbers)\
    \ min) (- max min))\n              (rescale-to-unit-helper (cdr numbers) min max))))\n\
    \  (rescale-to-unit-helper numbers (apply min numbers) (apply max numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [delta (- max min)])\n    (map (lambda (x) (/ (- x min) delta)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [scale (/ (- 1.0) (- max min))])\n    (map (lambda (n) (* scale (- n min)))\
    \ numbers)))\n", "  (define (rescale_to_unit_iter numbers min max result)\n  \
    \  (if (null? numbers)\n        result\n        (let* ([current (car numbers)]\n\
    \               [new-min (if (< current min) current min)]\n               [new-max\
    \ (if (> current max) current max)])\n          (rescale_to_unit_iter (cdr numbers)\
    \ new-min new-max (cons (/ (- current min) (- max min)) result)))))\n  (reverse\
    \ (rescale_to_unit_iter numbers (car numbers) (car numbers) '())))\n", "  (define\
    \ (rescale_to_unit_helper numbers min max)\n    (if (null? numbers)\n        '()\n\
    \        (cons (/ (- (car numbers) min) (- max min))\n              (rescale_to_unit_helper\
    \ (cdr numbers) min max))))\n  (rescale_to_unit_helper numbers (apply min numbers)\
    \ (apply max numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max\
    \ (apply max numbers)]\n         [scale (/ 1.0 (- max min))])\n    (map (lambda\
    \ (x) (* scale (- x min))) numbers)))\n", "  (define (rescale_to_unit_helper numbers\
    \ min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (- (car numbers)\
    \ min) (- max min))\n              (rescale_to_unit_helper (cdr numbers) min max))))\n\
    \  (rescale_to_unit_helper numbers (apply min numbers) (apply max numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [range (- max min)])\n    (map (lambda (x) (/ (- x min) range)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [delta (- max min)])\n    (map (lambda (x) (/ (- x min) delta)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [diff (- max min)])\n    (map (lambda (n) (/ (- n min) diff)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [diff (- max min)])\n    (map (lambda (x) (/ (- x min) diff)) numbers)))\n",
  "  (define (rescale-helper numbers min max)\n    (if (null? numbers)\n        '()\n\
    \        (cons (/ (- (car numbers) min) (- max min))\n              (rescale-helper\
    \ (cdr numbers) min max))))\n  (rescale-helper numbers (apply min numbers) (apply\
    \ max numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [range (- max min)])\n    (map (lambda (x) (/ (- x min)\
    \ range)) numbers)))\n", "  (define (rescale_to_unit_iter numbers min max)\n \
    \   (if (null? numbers)\n        '()\n        (cons (/ (- (car numbers) min) (-\
    \ max min))\n              (rescale_to_unit_iter (cdr numbers) min max))))\n \
    \ (rescale_to_unit_iter numbers (apply min numbers) (apply max numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [delta (- max min)])\n    (map (lambda (n) (/ (- n min) delta)) numbers)))\n",
  "  (define (rescale_to_unit_helper numbers min max)\n    (if (null? numbers)\n \
    \       '()\n        (cons (/ (- (car numbers) min) (- max min))\n           \
    \   (rescale_to_unit_helper (cdr numbers) min max))))\n  (rescale_to_unit_helper\
    \ numbers (apply min numbers) (apply max numbers)))\n", "  (define (rescale_to_unit_iter\
    \ numbers min max result)\n    (cond [(empty? numbers) result]\n          [else\
    \ (rescale_to_unit_iter (rest numbers)\n                                     \
    \ (min (first numbers) min)\n                                      (max (first\
    \ numbers) max)\n                                      (append result (list (/\
    \ (- (first numbers) min) (- max min)))))]))\n  (rescale_to_unit_iter numbers\
    \ (first numbers) (first numbers) '()))\n", "  (define (rescale_to_unit-helper\
    \ numbers min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (-\
    \ (car numbers) min) (- max min))\n              (rescale_to_unit-helper (cdr\
    \ numbers) min max))))\n  (rescale_to_unit-helper numbers (apply min numbers)\
    \ (apply max numbers)))\n", "  (define min (apply min numbers))\n  (define max\
    \ (apply max numbers))\n  (map (lambda (x) (/ (- x min) (- max min))) numbers))\n",
  "  (define (rescale_to_unit_helper numbers min max)\n    (if (null? numbers)\n \
    \       '()\n        (cons (/ (- (car numbers) min) (- max min))\n           \
    \   (rescale_to_unit_helper (cdr numbers) min max))))\n  (rescale_to_unit_helper\
    \ numbers (apply min numbers) (apply max numbers)))\n", "  (define (rescale_to_unit_helper\
    \ numbers min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (-\
    \ (car numbers) min) (- max min))\n              (rescale_to_unit_helper (cdr\
    \ numbers) min max))))\n  (rescale_to_unit_helper numbers (apply min numbers)\
    \ (apply max numbers)))\n", "  (define (rescale-helper numbers min max)\n    (if\
    \ (null? numbers)\n        '()\n        (cons (/ (- (car numbers) min) (- max\
    \ min))\n              (rescale-helper (cdr numbers) min max))))\n  (rescale-helper\
    \ numbers (apply min numbers) (apply max numbers)))\n", "  (let* ([min (apply\
    \ min numbers)]\n         [max (apply max numbers)]\n         [scale (/ (- 1.0)\
    \ (- max min))])\n    (map (lambda (x) (* scale (- x min))) numbers)))\n", " \
    \ (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n     \
    \    [diff (- max min)])\n    (map (lambda (n) (/ (- n min) diff)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [diff (- max min)])\n    (map (lambda (x) (/ (- x min) diff)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [diff (- max min)])\n    (map (lambda (x) (/ (- x min) diff)) numbers)))\n",
  "  (define (rescale_to_unit_helper numbers min max)\n    (if (null? numbers)\n \
    \       '()\n        (cons (/ (- (car numbers) min) (- max min))\n           \
    \   (rescale_to_unit_helper (cdr numbers) min max))))\n  (rescale_to_unit_helper\
    \ numbers (apply min numbers) (apply max numbers)))\n", "  (define (rescale-helper\
    \ numbers min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (-\
    \ (car numbers) min) (- max min))\n              (rescale-helper (cdr numbers)\
    \ min max))))\n  (rescale-helper numbers (apply min numbers) (apply max numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [delta (- max min)])\n    (map (lambda (x) (/ (- x min) delta)) numbers)))\n",
  "  (define (rescale_to_unit_iter numbers min max result)\n    (if (null? numbers)\n\
    \        result\n        (let ([number (car numbers)])\n          (rescale_to_unit_iter\
    \ (cdr numbers)\n                                (if (< number min) number min)\n\
    \                                (if (> number max) number max)\n            \
    \                    (cons (/ (- number min) (- max min)) result)))))\n  (reverse\
    \ (rescale_to_unit_iter numbers (car numbers) (car numbers) '())))\n", "  (define\
    \ (rescale_to_unit_helper numbers min max)\n    (if (null? numbers)\n        '()\n\
    \        (cons (/ (- (car numbers) min) (- max min))\n              (rescale_to_unit_helper\
    \ (cdr numbers) min max))))\n  (rescale_to_unit_helper numbers (apply min numbers)\
    \ (apply max numbers)))\n", "  (define (rescale-helper numbers min max)\n    (if\
    \ (null? numbers)\n        '()\n        (cons (/ (- (car numbers) min) (- max\
    \ min)) (rescale-helper (cdr numbers) min max))))\n  (rescale-helper numbers (apply\
    \ min numbers) (apply max numbers)))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [delta (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) delta)) numbers)))\n", "  (define (rescale_to_unit-helper numbers\
    \ min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (- (car numbers)\
    \ min) (- max min))\n              (rescale_to_unit-helper (cdr numbers) min max))))\n\
    \  (rescale_to_unit-helper numbers (apply min numbers) (apply max numbers)))\n",
  "  (define (rescale_to_unit_iter numbers min max result)\n    (if (null? numbers)\n\
    \        result\n        (rescale_to_unit_iter (cdr numbers)\n               \
    \               (min min (car numbers))\n                              (max max\
    \ (car numbers))\n                              (append result (list (/ (- (car\
    \ numbers) min) (- max min)))))))\n  (rescale_to_unit_iter numbers (car numbers)\
    \ (car numbers) '()))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [range (- max min)])\n    (map (lambda (x) (/ (- x min)\
    \ range)) numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [delta (- max min)])\n    (map (lambda (n) (/ (- n min)\
    \ delta)) numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [range (- max min)])\n    (map (lambda (x) (/ (- x min)\
    \ range)) numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [range (- max min)])\n    (map (lambda (x) (/ (- x min)\
    \ range)) numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [delta (- max min)])\n    (map (lambda (n) (/ (- n min)\
    \ delta)) numbers)))\n", "  (define (rescale_to_unit_helper numbers min max)\n\
    \    (cond\n      [(empty? numbers) empty]\n      [else (cons (/ (- (first numbers)\
    \ min) (- max min))\n                  (rescale_to_unit_helper (rest numbers)\
    \ min max))]))\n  (rescale_to_unit_helper numbers (apply min numbers) (apply max\
    \ numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply max\
    \ numbers)]\n         [delta (- max min)])\n    (map (lambda (x) (/ (- x min)\
    \ delta)) numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [delta (- max min)])\n    (map (lambda (x) (/ (- x min)\
    \ delta)) numbers)))\n", "  (define (rescale_to_unit_helper numbers min max)\n\
    \    (cond\n      [(empty? numbers) empty]\n      [else (cons (/ (- (first numbers)\
    \ min) (- max min))\n                  (rescale_to_unit_helper (rest numbers)\
    \ min max))]))\n  (rescale_to_unit_helper numbers (apply min numbers) (apply max\
    \ numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply max\
    \ numbers)]\n         [range (- max min)])\n    (map (lambda (x) (/ (- x min)\
    \ range)) numbers)))\n", "  (let ([min (apply min numbers)]\n        [max (apply\
    \ max numbers)])\n    (map (lambda (n) (/ (- n min) (- max min))) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [delta (- max min)])\n    (map (lambda (x) (/ (- x min) delta)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [range (- max min)])\n    (map (lambda (x) (/ (- x min) range)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [range (- max min)])\n    (map (lambda (x) (/ (- x min) range)) numbers)))\n",
  "  (define (rescale-helper numbers min max)\n    (if (null? numbers)\n        '()\n\
    \        (cons (/ (- (car numbers) min) (- max min))\n              (rescale-helper\
    \ (cdr numbers) min max))))\n  (rescale-helper numbers (apply min numbers) (apply\
    \ max numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [diff (- max min)])\n    (map (lambda (x) (/ (- x min)\
    \ diff)) numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [range (- max min)])\n    (map (lambda (n) (/ (- n min)\
    \ range)) numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [scale (/ (- 1.0) (- max min))])\n    (map (lambda (x)\
    \ (* scale (- x min))) numbers)))\n", "  (define (rescale_to_unit_iter numbers\
    \ min max result)\n    (if (null? numbers)\n        result\n        (let ([number\
    \ (car numbers)])\n          (rescale_to_unit_iter (cdr numbers)\n           \
    \                     (if (< number min) number min)\n                       \
    \         (if (> number max) number max)\n                                (cons\
    \ (/ (- number min) (- max min)) result)))))\n  (reverse (rescale_to_unit_iter\
    \ numbers (car numbers) (car numbers) '())))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [scale (/ (- 1.0) (- max min))])\n\
    \    (map (lambda (x) (* scale (- x min))) numbers)))\n", "  (let* ([min (apply\
    \ min numbers)]\n         [max (apply max numbers)]\n         [delta (- max min)])\n\
    \    (map (lambda (x) (/ (- x min) delta)) numbers)))\n", "  (define (rescale_to_unit_iter\
    \ numbers min max result)\n    (if (null? numbers)\n        result\n        (rescale_to_unit_iter\
    \ (cdr numbers)\n                              (min min (car numbers))\n     \
    \                         (max max (car numbers))\n                          \
    \    (append result (list (/ (- (car numbers) min) (- max min)))))))\n  (rescale_to_unit_iter\
    \ numbers (car numbers) (car numbers) '()))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [range (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) range)) numbers)))\n", "  (let ([min (apply min numbers)]\n\
    \        [max (apply max numbers)])\n    (map (lambda (x) (/ (- x min) (- max\
    \ min))) numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [diff (- max min)])\n    (map (lambda (n) (/ (- n min)\
    \ diff)) numbers)))\n", "  (define (rescale_to_unit-helper numbers min max)\n\
    \    (if (null? numbers)\n        '()\n        (cons (/ (- (car numbers) min)\
    \ (- max min))\n              (rescale_to_unit-helper (cdr numbers) min max))))\n\
    \  (rescale_to_unit-helper numbers (apply min numbers) (apply max numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [range (- max min)])\n    (map (lambda (x) (/ (- x min) range)) numbers)))\n",
  "  (define min (apply min numbers))\n  (define max (apply max numbers))\n  (define\
    \ range (- max min))\n  (map (lambda (x) (/ (- x min) range)) numbers))\n", " \
    \ (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n     \
    \    [delta (- max min)])\n    (map (lambda (x) (/ (- x min) delta)) numbers)))\n",
  "  (define (rescale_to_unit_iter numbers min max result)\n    (if (null? numbers)\n\
    \        result\n        (let ([n (car numbers)])\n          (rescale_to_unit_iter\
    \ (cdr numbers)\n                                (if (< n min) n min)\n      \
    \                          (if (> n max) n max)\n                            \
    \    (cons (/ (- n min) (- max min)) result)))))\n  (reverse (rescale_to_unit_iter\
    \ numbers (car numbers) (car numbers) '())))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [range (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) range)) numbers)))\n", "  (define (rescale_to_unit_helper numbers\
    \ min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (- (car numbers)\
    \ min) (- max min))\n              (rescale_to_unit_helper (cdr numbers) min max))))\n\
    \  (rescale_to_unit_helper numbers (apply min numbers) (apply max numbers)))\n",
  "  (let ([min (apply min numbers)]\n        [max (apply max numbers)])\n    (map\
    \ (lambda (x) (/ (- x min) (- max min))) numbers)))\n", "  (define (rescale_to_unit_iter\
    \ numbers min max result)\n    (cond\n      [(empty? numbers) result]\n      [else\n\
    \       (define first (first numbers))\n       (define rest (rest numbers))\n\
    \       (define scaled-first (/ (- first min) (- max min)))\n       (rescale_to_unit_iter\
    \ rest min max (append result (list scaled-first)))]))\n  (rescale_to_unit_iter\
    \ numbers (min numbers) (max numbers) (list)))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [delta (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) delta)) numbers)))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [diff (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) diff)) numbers)))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [diff (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) diff)) numbers)))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [range (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) range)) numbers)))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [diff (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) diff)) numbers)))\n", "  (define (rescale-helper numbers min\
    \ max)\n    (if (null? numbers)\n        '()\n        (cons (/ (- (car numbers)\
    \ min) (- max min))\n              (rescale-helper (cdr numbers) min max))))\n\
    \  (rescale-helper numbers (apply min numbers) (apply max numbers)))\n", "  (let*\
    \ ([min (apply min numbers)]\n         [max (apply max numbers)]\n         [delta\
    \ (- max min)])\n    (map (lambda (x) (/ (- x min) delta)) numbers)))\n", "  (let*\
    \ ([min (apply min numbers)]\n         [max (apply max numbers)]\n         [range\
    \ (- max min)])\n    (map (lambda (n) (/ (- n min) range)) numbers)))\n", "  (let*\
    \ ([min (apply min numbers)]\n         [max (apply max numbers)]\n         [diff\
    \ (- max min)])\n    (map (lambda (x) (/ (- x min) diff)) numbers)))\n", "  (let*\
    \ ([min (apply min numbers)]\n         [max (apply max numbers)]\n         [range\
    \ (- max min)])\n    (map (lambda (x) (/ (- x min) range)) numbers)))\n", "  (let*\
    \ ([min (apply min numbers)]\n         [max (apply max numbers)]\n         [range\
    \ (- max min)])\n    (map (lambda (x) (/ (- x min) range)) numbers)))\n", "  (define\
    \ (rescale_to_unit-helper numbers min max)\n    (if (null? numbers)\n        '()\n\
    \        (cons (/ (- (car numbers) min) (- max min))\n              (rescale_to_unit-helper\
    \ (cdr numbers) min max))))\n  (rescale_to_unit-helper numbers (apply min numbers)\
    \ (apply max numbers)))\n", "  (define (rescale_to_unit_iter numbers min max result)\n\
    \    (if (null? numbers)\n        result\n        (let* ([n (car numbers)]\n \
    \              [new-n (/ (- n min) (- max min))])\n          (rescale_to_unit_iter\
    \ (cdr numbers) min max (append result (list new-n))))))\n  (rescale_to_unit_iter\
    \ numbers (apply min numbers) (apply max numbers) '()))\n", "  (let* ([min (apply\
    \ min numbers)]\n         [max (apply max numbers)]\n         [delta (- max min)])\n\
    \    (map (lambda (x) (/ (- x min) delta)) numbers)))\n", "  (define (rescale_to_unit-helper\
    \ numbers min max)\n    (if (null? numbers)\n        '()\n        (cons (/ (-\
    \ (car numbers) min) (- max min))\n              (rescale_to_unit-helper (cdr\
    \ numbers) min max))))\n  (rescale_to_unit-helper numbers (apply min numbers)\
    \ (apply max numbers)))\n", "  (define (rescale_to_unit_iter numbers min max result)\n\
    \    (cond [(empty? numbers) (reverse result)]\n          [else (rescale_to_unit_iter\
    \ (rest numbers)\n                                      (min (first numbers) min)\n\
    \                                      (max (first numbers) max)\n           \
    \                           (cons (/ (- (first numbers) min) (- max min)) result))]))\n\
    \  (rescale_to_unit_iter numbers (first numbers) (first numbers) (list)))\n",
  "  (define min (apply min numbers))\n  (define max (apply max numbers))\n  (define\
    \ range (- max min))\n  (map (lambda (x) (/ (- x min) range)) numbers))\n", " \
    \ (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n     \
    \    [diff (- max min)])\n    (map (lambda (n) (/ (- n min) diff)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [diff (- max min)])\n    (map (lambda (x) (/ (- x min) diff)) numbers)))\n",
  "  (define (rescale_to_unit_iter numbers min max)\n    (if (null? numbers)\n   \
    \     '()\n        (cons (/ (- (car numbers) min) (- max min))\n             \
    \ (rescale_to_unit_iter (cdr numbers) min max))))\n  (rescale_to_unit_iter numbers\
    \ (apply min numbers) (apply max numbers)))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [diff (- max min)])\n    (map (lambda\
    \ (x) (/ (- x min) diff)) numbers)))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [scale (/ (- 1.0) (- max min))])\n\
    \    (map (lambda (x) (* scale (- x min))) numbers)))\n", "  (let* ([min (apply\
    \ min numbers)]\n         [max (apply max numbers)]\n         [delta (- max min)])\n\
    \    (map (lambda (x) (/ (- x min) delta)) numbers)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
