name: HumanEval_120_maximum
language: rkt
prompt: "#lang racket\n\n#| Given a list arr of integers and a positive integer k,\
  \ return a sorted list \nof length k with the maximum k numbers in arr.\nExample\
  \ 1:\n>>> (maximum (list -3 -4 5) 3)\n(list -4 -3 5)\nExample 2:\n>>> (maximum (list\
  \ 4 -4 4) 2)\n(list 4 4)\nExample 3:\n>>> (maximum (list -3 2 1 2 -1 -2 1) 1)\n\
  (list 2)\nNote:\n1. The length of the list will be in the range of [1, 1000].\n\
  2. The elements in the list will be in the range of [-1000, 1000].\n3. 0 <= k <=\
  \ len(arr)|#\n(define (maximum arr k)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maximum))\n\
  \    (check-equal? (candidate (list -3 -4 5) 3) (list -4 -3 5))\n    (check-equal?\
  \ (candidate (list 4 -4 4) 2) (list 4 4))\n    (check-equal? (candidate (list -3\
  \ 2 1 2 -1 -2 1) 1) (list 2))\n    (check-equal? (candidate (list 123 -123 20 0\
  \ 1 2 -3) 3) (list 2 20 123))\n    (check-equal? (candidate (list -123 20 0 1 2\
  \ -3) 4) (list 0 1 2 20))\n    (check-equal? (candidate (list 5 15 0 3 -13 -8 0)\
  \ 7) (list -13 -8 0 0 3 5 15))\n    (check-equal? (candidate (list -1 0 2 5 3 -10)\
  \ 2) (list 3 5))\n    (check-equal? (candidate (list 1 0 5 -7) 1) (list 5))\n  \
  \  (check-equal? (candidate (list 4 -4) 2) (list -4 4))\n    (check-equal? (candidate\
  \ (list -10 10) 2) (list -10 10))\n    (check-equal? (candidate (list 1 2 3 -23\
  \ 243 -400 0) 0) (list ))\n))\n\n(test-humaneval)"
completions: ["  (sort arr > (take arr k)))\n", "  (sort arr <))\n", "  (sort arr\
    \ (lambda (x y) (< x y))))\n", "  (sort arr >))\n", "  (sort arr (lambda (a b)\
    \ (< a b))))\n", "  (define (max-helper arr k)\n    (if (null? arr)\n        (list)\n\
    \        (let ([max (apply max arr)])\n          (cons max (max-helper (remove\
    \ max arr) (- k 1))))))\n  (if (null? arr)\n      (list)\n      (max-helper arr\
    \ k)))\n", "  (sort arr (lambda (x y) (< x y))))\n", "  (sort arr <))\n", "  (sort\
    \ arr (lambda (x y) (< x y)))\n  (take arr k))\n", "  (define (max-heapify arr\
    \ i)\n    (define (left i) (+ (* 2 i) 1))\n    (define (right i) (+ (* 2 i) 2))\n\
    \    (define (swap i j)\n      (define temp (list-ref arr i))\n      (set-car!\
    \ (list-ref arr i) (list-ref arr j))\n      (set-car! (list-ref arr j) temp))\n\
    \    (define (max-heapify-helper arr i)\n      (define l (left i))\n      (define\
    \ r (right i))\n      (define largest\n        (cond [(> l (length arr)) i]\n\
    \              [(> r (length arr))\n               (if (> (list-ref arr l) (list-ref\
    \ arr i))\n                   l\n                   i)]\n              [else\n\
    \               (if (> (list-ref arr l) (list-ref arr r))\n                  \
    \ (if (> (list-ref arr l) (list-ref arr i))\n                       l\n      \
    \                 i)\n                   (if (> (list-ref arr r) (list-ref arr\
    \ i))\n                       r\n                       i))]))\n      (when (/=\
    \ largest i)\n        (swap i largest)\n        (max-heapify-helper arr largest)))\n\
    \    (max-heapify-helper arr i))\n  (define (build-max-heap arr)\n    (for ([i\
    \ (in-range (quotient (length arr) 2) -1 -1)])\n      (max-heapify arr i)))\n\
    \  (define (heap-sort arr)\n    (build-max-heap arr)\n    (for ([i (in-range (length\
    \ arr) 1 -1)])\n      (swap 0 i)\n      (max-heapify (sublist arr 0 i) 0)))\n\
    \  (heap-sort arr))\n", "  (sort arr >))\n", "  (sort arr (lambda (x y) (< x y)))\n\
    \  (take arr k))\n```\n\n## Problem 3\n\n```racket\n#lang racket\n", "  (define\
    \ (helper arr k)\n    (if (empty? arr)\n        '()\n        (let ([max (apply\
    \ max arr)])\n          (cons max (helper (remove max arr) (- k 1))))))\n  (helper\
    \ arr k))\n", "  (sort arr (lambda (x y) (< x y))))\n", "  (sort arr < k))\n",
  "  (define (max-helper arr k)\n    (cond [(empty? arr) empty]\n          [(= k 0)\
    \ empty]\n          [else (define (max-helper2 arr k)\n                  (cond\
    \ [(empty? arr) empty]\n                        [(= k 0) empty]\n            \
    \            [else (cons (max (first arr) (first (max-helper2 (rest arr) (- k\
    \ 1))))\n                                    (max-helper2 (rest arr) (- k 1)))]))\n\
    \                (max-helper2 arr k)]))\n  (max-helper arr k))\n", "  (sort arr\
    \ (lambda (x y) (< x y))))\n", "  (sort arr <))\n", "  (sort arr (lambda (a b)\
    \ (< a b))))\n", "  (sort arr <))\n", "  (define (helper arr k acc)\n    (cond\
    \ [(empty? arr) acc]\n          [(>= k (length acc)) (helper (rest arr) k (insert\
    \ (first arr) acc))]\n          [(< (first arr) (last acc)) (helper (rest arr)\
    \ k acc)]\n          [else (helper (rest arr) k (insert (first arr) (butlast acc)))]))\n\
    \  (helper arr k (list (first arr))))\n", "  (sort arr > (sublist arr 0 k)))\n",
  "  (define (max-list lst)\n    (if (null? (cdr lst))\n        (car lst)\n      \
    \  (if (> (car lst) (max-list (cdr lst)))\n            (car lst)\n           \
    \ (max-list (cdr lst)))))\n  (define (remove-max lst)\n    (if (null? (cdr lst))\n\
    \        (list)\n        (if (= (car lst) (max-list lst))\n            (cdr lst)\n\
    \            (cons (car lst) (remove-max (cdr lst))))))\n  (define (helper lst\
    \ k)\n    (if (= k 0)\n        (list)\n        (cons (max-list lst) (helper (remove-max\
    \ lst) (- k 1)))))\n  (helper arr k))\n", "  (define (max-helper arr k)\n    (cond\
    \ [(empty? arr) empty]\n          [(= k 0) empty]\n          [else\n         \
    \  (define max (apply max arr))\n           (define rest (filter (lambda (x) (not\
    \ (= x max))) arr))\n           (cons max (max-helper rest (- k 1)))]))\n  (max-helper\
    \ arr k))\n", "  (sort arr > (take arr k)))\n", "  (sort arr < (sublist arr 0\
    \ k)))\n", "  (sort arr (lambda (x y) (< x y))))\n", "  (sort arr <))\n", "  (sort\
    \ arr > (take arr k)))\n", "  (sort arr (lambda (x y) (< x y))))\n", "  (define\
    \ (max-helper arr k)\n    (cond [(empty? arr) empty]\n          [(= k 0) empty]\n\
    \          [else (cons (max (first arr) (max-helper (rest arr) (- k 1)))\n   \
    \                   (max-helper (rest arr) (- k 1)))]))\n  (sort (max-helper arr\
    \ k) >))\n", "  (sort arr >))\n", "  (define (insert-sort lst)\n    (define (insert-sort-helper\
    \ lst sorted)\n      (cond [(empty? lst) sorted]\n            [(empty? sorted)\
    \ (insert-sort-helper (rest lst) (list (first lst))) ]\n            [else (insert-sort-helper\
    \ (rest lst) (insert-helper (first lst) sorted))]))\n    (define (insert-helper\
    \ x lst)\n      (cond [(empty? lst) (list x)]\n            [(>= x (first lst))\
    \ (cons x lst)]\n            [else (cons (first lst) (insert-helper x (rest lst)))]))\n\
    \    (insert-sort-helper lst empty))\n  (define (maximum-helper arr k)\n    (cond\
    \ [(empty? arr) empty]\n          [(= k 0) empty]\n          [else (cons (first\
    \ arr) (maximum-helper (rest arr) (- k 1)))]))\n  (insert-sort (maximum-helper\
    \ arr k)))\n", "  (define (insert-sort lst)\n    (define (insert-item item lst)\n\
    \      (cond [(empty? lst) (list item)]\n            [(> item (first lst)) (cons\
    \ item lst)]\n            [else (cons (first lst) (insert-item item (rest lst)))]))\n\
    \    (define (insert-sort-helper lst)\n      (cond [(empty? lst) empty]\n    \
    \        [else (insert-item (first lst) (insert-sort-helper (rest lst)))]))\n\
    \    (insert-sort-helper lst))\n  (define (maximum-helper arr k)\n    (cond [(empty?\
    \ arr) empty]\n          [(= k 0) empty]\n          [else (insert-sort (cons (first\
    \ arr) (maximum-helper (rest arr) (- k 1))))]))\n  (maximum-helper arr k))\n",
  "  (define (max-helper arr k)\n    (cond\n      [(empty? arr) empty]\n      [(=\
    \ k 0) empty]\n      [else\n       (define (max-helper-helper arr max)\n     \
    \    (cond\n           [(empty? arr) max]\n           [(> (first arr) max) (max-helper-helper\
    \ (rest arr) (first arr))]\n           [else (max-helper-helper (rest arr) max)]))\n\
    \       (cons (max-helper-helper arr (first arr))\n             (max-helper (remove\
    \ (max-helper-helper arr (first arr)) arr) (- k 1)))]))\n  (max-helper arr k))\n",
  "  (sort arr (lambda (a b) (< a b))))\n", "  (sort arr (lambda (x y) (< x y))))\n",
  "  (define (max-k lst k)\n    (if (or (empty? lst) (= k 0))\n        '()\n     \
    \   (cons (apply max lst)\n              (max-k (remove (apply max lst) lst) (-\
    \ k 1)))))\n  (max-k arr k))\n", "  (define (max-heapify arr i)\n    (define (left\
    \ i) (+ (* 2 i) 1))\n    (define (right i) (+ (* 2 i) 2))\n    (define (swap arr\
    \ i j)\n      (define (swap-helper arr i j)\n        (define (swap-helper-helper\
    \ arr i j)\n          (set! arr (vector-set arr i (vector-ref arr j)))\n     \
    \     (set! arr (vector-set arr j (vector-ref arr i)))\n          arr)\n     \
    \   (if (and (vector? arr) (vector? (vector-ref arr i)) (vector? (vector-ref arr\
    \ j)))\n            (swap-helper-helper arr i j)\n            (swap-helper-helper\
    \ (vector->list arr) i j)))\n      (swap-helper arr i j))\n    (define (max-heapify-helper\
    \ arr i)\n      (define (max-heapify-helper-helper arr i)\n        (define (max-heapify-helper-helper-helper\
    \ arr i)\n          (define (max-heapify-helper-helper-helper-helper arr i)\n\
    \            (define (max-heapify-helper-helper-helper-helper-helper arr i)\n\
    \              (define (max-heapify-helper-helper-helper-helper-helper-helper\
    \ arr i)\n                (define (max-heapify-helper-helper-helper-helper-helper-helper-helper\
    \ arr i)\n                  (define (max-heapify-helper-helper-helper-helper-helper-helper-helper-helper\
    \ arr i)\n                    (define (max-heapify-helper-helper-helper-helper-helper-helper-helper-helper-helper\
    \ arr i)\n                      (define (max-heapify-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper\
    \ arr i)\n                        (define (max-heapify-hel", "  (define (max-helper\
    \ arr k)\n    (cond [(empty? arr) empty]\n          [(= k 0) empty]\n        \
    \  [else (cons (max (first arr) (max-helper (rest arr) (- k 1)))\n           \
    \           (max-helper (rest arr) (- k 1)))]))\n  (max-helper arr k))\n", " \
    \ (sort arr (lambda (x y) (< x y))))\n", "  (define (max-helper arr k acc)\n \
    \   (cond\n      [(empty? arr) acc]\n      [(empty? acc) (max-helper (rest arr)\
    \ k (list (first arr)))]\n      [(> (first arr) (first acc)) (max-helper (rest\
    \ arr) k (cons (first arr) (rest acc)))]\n      [else (max-helper (rest arr) k\
    \ acc)]))\n  (max-helper arr k '()))\n", "  (sort arr < (take arr k)))\n", " \
    \ (sort arr (lambda (x y) (< x y))))\n", "  (sort arr >))\n", "  (sort arr >))\n",
  "  (define (max-k-helper arr k)\n    (cond [(empty? arr) empty]\n          [(= k\
    \ 0) empty]\n          [(= k 1) (list (apply max arr))]\n          [else (cons\
    \ (apply max arr) (max-k-helper (remove (apply max arr) arr) (- k 1)))]))\n  (max-k-helper\
    \ arr k))\n", "  (sort arr <))\n", "  (sort arr >))\n", "  (define (max-k-nums\
    \ arr k)\n    (if (null? arr)\n        (list)\n        (let ([max (apply max arr)])\n\
    \          (cons max (max-k-nums (remove max arr) (- k 1))))))\n  (sort (max-k-nums\
    \ arr k) <))\n", "  (sort arr > (take k arr)))\n", "  (sort arr (lambda (x y)\
    \ (> x y))))\n", "  (define (helper arr k)\n    (cond [(empty? arr) empty]\n \
    \         [(= k 0) empty]\n          [(= k 1) (list (max (first arr) (max-helper\
    \ (rest arr)))))\n          [else (cons (max (first arr) (max-helper (rest arr)))\n\
    \                      (helper (rest arr) (- k 1)))]))\n  (helper arr k))\n",
  "  (sort arr >))\n", "  (sort arr >))\n", "  (sort (list-ref arr 0) (list-ref arr\
    \ 1) (list-ref arr 2) (list-ref arr 3) (list-ref arr 4)))\n</code>\nI know that\
    \ I need to use the sort function, but I'm not sure how to use it. I also know\
    \ that I need to use list-ref to get the values from the list. I'm not sure how\
    \ to use list-ref to get the values from the list.\n\n\nA:\n\nYou can use <code>sort</code>\
    \ to sort the list in ascending order, then use <code>take</code> to get the first\
    \ <code>k</code> elements.\n<code>(define (maximum arr k)\n  (take (sort &lt;\
    \ arr) k))\n</code>\n", "  (define (helper arr k acc)\n    (if (zero? k)\n   \
    \     acc\n        (helper (remove-max arr) (- k 1) (cons (max arr) acc))))\n\
    \  (helper arr k '()))\n", "  (define (max-helper arr k)\n    (if (null? arr)\n\
    \        (list)\n        (if (= k 0)\n            (list)\n            (let ([max\
    \ (apply max arr)])\n              (cons max (max-helper (filter (lambda (x) (not\
    \ (= x max))) arr) (- k 1)))))))\n  (max-helper arr k))\n", "  (sort arr (lambda\
    \ (x y) (< x y))))\n", "  (define (max-k lst k)\n    (cond\n      [(empty? lst)\
    \ empty]\n      [(= k 0) empty]\n      [else\n       (define max-val (apply max\
    \ lst))\n       (cons max-val (max-k (remove max-val lst) (- k 1)))]))\n  (max-k\
    \ arr k))\n", "  (sort arr (lambda (x y) (< x y))))\n", "  (sort arr < (take arr\
    \ k)))\n", "  (sort arr > (take k (sort arr >))))\n", "  (sort arr < k))\n", " \
    \ (cond\n    [(empty? arr) empty]\n    [(= k 0) empty]\n    [else\n     (define\
    \ (max-helper arr k)\n       (cond\n         [(empty? arr) empty]\n         [(=\
    \ k 0) empty]\n         [else\n          (define (max-helper2 arr k)\n       \
    \     (cond\n              [(empty? arr) empty]\n              [(= k 0) empty]\n\
    \              [else\n               (define (max-helper3 arr k)\n           \
    \      (cond\n                   [(empty? arr) empty]\n                   [(=\
    \ k 0) empty]\n                   [else\n                    (define (max-helper4\
    \ arr k)\n                      (cond\n                        [(empty? arr) empty]\n\
    \                        [(= k 0) empty]\n                        [else\n    \
    \                     (define (max-helper5 arr k)\n                          \
    \ (cond\n                             [(empty? arr) empty]\n                 \
    \            [(= k 0) empty]\n                             [else\n           \
    \                   (define (max-helper6 arr k)\n                            \
    \    (cond\n                                  [(empty? arr) empty]\n         \
    \                         [(= k 0) empty]\n                                  [else\n\
    \                                   (define (max-helper7 arr k)\n            \
    \                         (cond\n                                       [(empty?\
    \ arr) empty]\n                                       [(= k 0) empty]\n      \
    \                                 [else\n                                    \
    \    (define (max-helper8 arr k)\n                                          (cond\n\
    \                                            [(empty? arr) empty]\n          \
    \                                  [(= k 0) empty]\n                         \
    \                   [else\n                                             (define\
    \ (max-helper9 arr k)\n                                               (cond\n\
    \                                                 [(empty? arr) empty]\n     \
    \                                            [(= k 0) empty]\n               \
    \                                  [else\n                                   \
    \               (define (max-helper10 arr k)\n                               \
    \                     (cond\n                                                \
    \      [(empty? arr) empty]\n                                                \
    \      [(= k 0) empty]\n                                                     \
    \ [else\n                                                       (define (max-helper11\
    \ arr k)\n                                                         (cond\n   \
    \                                                        [(empty? arr) empty]\n\
    \                                                           [(= k 0) empty]\n\
    \                                                           [else\n          \
    \      ", "  (define (max-k-helper arr k)\n    (if (empty? arr)\n        empty\n\
    \        (let ([max (max (first arr) (max-k-helper (rest arr) k))])\n        \
    \  (if (zero? k)\n              empty\n              (cons max (max-k-helper (remove\
    \ max arr) (- k 1)))))))\n  (max-k-helper arr k))\n", "  (sort arr (lambda (a\
    \ b) (< a b))))\n", "  (define (max-k arr k)\n    (cond\n      [(empty? arr) empty]\n\
    \      [(= k 0) empty]\n      [else\n       (define max-val (max (first arr) (max-k\
    \ (rest arr) (- k 1))))\n       (cons max-val (max-k (remove max-val arr) (- k\
    \ 1)))]))\n  (max-k arr k))\n", "  (define (max-k arr k)\n    (if (empty? arr)\n\
    \        empty\n        (if (= k 0)\n            empty\n            (cons (max\
    \ (first arr) (max-k (rest arr) (- k 1)))\n                  (max-k (rest arr)\
    \ (- k 1))))))\n  (sort (max-k arr k) >))\n", "  (define (max-helper arr k acc)\n\
    \    (cond [(empty? arr) acc]\n          [(>= k (length acc)) (max-helper (rest\
    \ arr) k (cons (first arr) acc))]\n          [(< (first arr) (first acc)) (max-helper\
    \ (rest arr) k acc)]\n          [else (max-helper (rest arr) k (cons (first arr)\
    \ (rest acc)))]))\n  (max-helper arr k (list (first arr))))\n", "  (define (max-list\
    \ arr)\n    (if (null? arr)\n        '()\n        (cons (apply max arr)\n    \
    \          (max-list (remove (apply max arr) arr)))))\n  (take (max-list arr)\
    \ k))\n", "  (sort arr (lambda (a b) (< a b))))\n", "  (sort arr (lambda (a b)\
    \ (&lt; a b))))\n</code>\nI got this error:\n<code>maximum: contract violation\n\
    \  expected: (and/c list? (integer-in 0 1000))\n  given: '#(1 2 3)\n  argument\
    \ position: 1st\n  other arguments...:\n   '#(1 2 3)\n</code>\nI don't know what\
    \ is wrong with my code.\n\n\nA:\n\nThe error message is telling you that the\
    \ function expects a list of integers, and you're passing a vector.\n<code>#(1\
    \ 2 3)</code> is a vector, not a list.\n", "  (sort (list-ref arr (sub1 k)) <\
    \ (sublist arr k)))\n", "  (sort arr (lambda (a b) (< a b))))\n", "  (sort arr\
    \ < (take k (sort arr >))))\n", "  (define (maximum-helper arr k result)\n   \
    \ (cond [(empty? arr) result]\n          [(<= k 0) result]\n          [else\n\
    \           (define (insert-max arr max)\n             (cond [(empty? arr) (list\
    \ max)]\n                   [(>= (first arr) max) (cons (first arr) (insert-max\
    \ (rest arr) max))]\n                   [else (cons max (insert-max (rest arr)\
    \ (first arr)))]))\n           (define (find-max arr)\n             (cond [(empty?\
    \ arr) (error \"empty list\")]\n                   [(empty? (rest arr)) (first\
    \ arr)]\n                   [else (max (first arr) (find-max (rest arr)))]))\n\
    \           (maximum-helper (rest arr) (- k 1) (insert-max result (find-max arr)))]))\n\
    \  (maximum-helper arr k empty))", "  (sort arr (lambda (x y) (> x y))))\n", " \
    \ (define (max-k lst k)\n    (if (or (null? lst) (= k 0))\n        '()\n     \
    \   (cons (max-k-helper lst) (max-k (remove (max-k-helper lst) lst) (- k 1)))))\n\
    \  (max-k arr k))\n", "  (sort arr < k))\n", "  (sort arr >))\n", "  (sort arr\
    \ >))\n", "  (sort arr <))\n", "  (sort arr (lambda (x y) (> x y))))\n", "  (sort\
    \ arr (lambda (a b) (< a b))))\n", "  (sort arr < (take k (sort arr >))))\n",
  "  (define (max-k lst k)\n    (if (or (null? lst) (= k 0))\n        '()\n      \
    \  (cons (apply max lst)\n              (max-k (remove (apply max lst) lst) (-\
    \ k 1)))))\n  (max-k arr k))\n", "  (define (max-helper arr k)\n    (cond [(empty?\
    \ arr) empty]\n          [(= k 0) empty]\n          [else\n           (define\
    \ max-val (apply max arr))\n           (define max-index (index-of max-val arr))\n\
    \           (cons max-val (max-helper (remove-at max-index arr) (- k 1)))]))\n\
    \  (max-helper arr k))\n", "  (sort (list-ref arr (sub1 (length arr))) (lambda\
    \ (a b) (> a b))))\n", "  (sort arr < k))\n", "  (define (max-helper arr k acc)\n\
    \    (cond\n      [(empty? arr) acc]\n      [(empty? acc) (max-helper (rest arr)\
    \ k (list (first arr)))]\n      [(> (first arr) (first acc)) (max-helper (rest\
    \ arr) k (cons (first arr) (rest acc)))]\n      [else (max-helper (rest arr) k\
    \ acc)]))\n  (max-helper arr k empty))\n", "  (sort arr (lambda (a b) (< a b)))\n\
    \  (sublist arr (- (length arr) k) (length arr)))\n", "  (sort arr > (take arr\
    \ k)))\n", "  (define (max-helper arr k)\n    (if (= k 0)\n        (list)\n  \
    \      (let ([max (apply max arr)])\n          (cons max (max-helper (remove max\
    \ arr) (- k 1))))))\n  (max-helper arr k))\n", "  (define (max-of-list lst)\n\
    \    (cond [(empty? lst) 0]\n          [(empty? (rest lst)) (first lst)]\n   \
    \       [else (max (first lst) (max-of-list (rest lst)))]))\n  (define (remove-max\
    \ lst)\n    (cond [(empty? lst) empty]\n          [(= (first lst) (max-of-list\
    \ lst)) (rest lst)]\n          [else (cons (first lst) (remove-max (rest lst)))]))\n\
    \  (define (max-k lst k)\n    (cond [(= k 0) empty]\n          [(empty? lst) empty]\n\
    \          [else (cons (max-of-list lst) (max-k (remove-max lst) (- k 1)))]))\n\
    \  (max-k arr k))\n", "  (sort arr (lambda (x y) (< x y)))\n  (take arr k))\n",
  "  (sort arr (lambda (x y) (< x y))))\n", "  (define (max-helper arr k)\n    (if\
    \ (null? arr)\n        '()\n        (let ([max (apply max arr)])\n          (cons\
    \ max (max-helper (remove max arr) (- k 1))))))\n  (max-helper arr k))\n", " \
    \ (let ([sorted (sort arr <)])\n    (for/list ([i (in-range k)])\n      (list-ref\
    \ sorted (- (length sorted) i 1)))))\n", "  (sort arr (lambda (x y) (< x y))))\n",
  "  (sort arr (lambda (x y) (< x y))))\n", "  (if (<= (length arr) k)\n      (sort\
    \ arr >)\n      (let ([max (sort arr >)])\n        (for/list ([i (in-range k)])\n\
    \          (list-ref max i)))))\n", "  (sort arr (lambda (x y) (< x y))))\n",
  "  (sort arr > (take k arr)))\n", "  (sort arr <))\n", "  (sort arr < (sublist arr\
    \ 0 k)))\n", "  (sort arr (lambda (x y) (> x y))))\n", "  (define (maximum-helper\
    \ arr k result)\n    (cond\n      [(empty? arr) result]\n      [(< (length result)\
    \ k)\n       (maximum-helper (rest arr) k (insert (first arr) result))]\n    \
    \  [(> (first arr) (last result))\n       (maximum-helper (rest arr) k (insert\
    \ (first arr) (but-last result)))]\n      [else (maximum-helper (rest arr) k result)]))\n\
    \  (maximum-helper arr k (list)))\n", "  (sort arr >))\n", "  (define (max-helper\
    \ arr k)\n    (cond\n      [(empty? arr) empty]\n      [(= k 0) empty]\n     \
    \ [else\n       (define max-val (max (first arr) (max-helper (rest arr) (- k 1))))\n\
    \       (cons max-val (max-helper (remove max-val arr) (- k 1)))]))\n  (max-helper\
    \ arr k))\n", "  (let ([arr (sort arr <)])\n    (reverse (take arr k))))\n", " \
    \ (let loop ((arr arr) (k k) (acc '()))\n    (cond\n      [(empty? arr) (reverse\
    \ acc)]\n      [(= k 0) (reverse acc)]\n      [else (loop (remove (max arr) arr)\
    \ (- k 1) (cons (max arr) acc))])))\n", "  (define (insert-sort lst)\n    (define\
    \ (insert-into-sorted lst x)\n      (cond [(empty? lst) (list x)]\n          \
    \  [(< x (first lst)) (cons x lst)]\n            [else (cons (first lst) (insert-into-sorted\
    \ (rest lst) x))]))\n    (define (insert-sort-helper lst)\n      (cond [(empty?\
    \ lst) empty]\n            [else (insert-into-sorted (insert-sort-helper (rest\
    \ lst)) (first lst))]))\n    (insert-sort-helper lst))\n  (define (maximum-helper\
    \ lst k)\n    (cond [(empty? lst) empty]\n          [(= k 0) empty]\n        \
    \  [else (cons (first lst) (maximum-helper (rest lst) (- k 1)))]))\n  (maximum-helper\
    \ (insert-sort arr) k))\n", "  (sort arr >))\n", "  (sort arr (lambda (x y) (<\
    \ x y))))\n", "  (define (max-k lst k)\n    (if (or (null? lst) (= k 0))\n   \
    \     '()\n        (cons (apply max lst)\n              (max-k (remove (apply\
    \ max lst) lst) (- k 1)))))\n  (max-k arr k))\n", "  (define (max-helper arr k)\n\
    \    (cond\n      [(empty? arr) empty]\n      [(= k 0) empty]\n      [else\n \
    \      (define max-val (max (first arr) (max-helper (rest arr) (- k 1))))\n  \
    \     (cons max-val (max-helper (remove max-val arr) (- k 1)))]))\n  (max-helper\
    \ arr k))\n", "  (sort arr <))\n", "  (sort arr (lambda (x y) (< x y))))\n", " \
    \ (sort arr (lambda (x y) (< x y))))\n", "  (sort arr (lambda (x y) (< x y))))\n",
  "  (define (max-heapify arr i)\n    (define (left i) (+ (* 2 i) 1))\n    (define\
    \ (right i) (+ (* 2 i) 2))\n    (define (swap arr i j)\n      (define (swap-helper\
    \ arr i j)\n        (define (swap-helper-helper arr i j)\n          (define (swap-helper-helper-helper\
    \ arr i j)\n            (define (swap-helper-helper-helper-helper arr i j)\n \
    \             (define (swap-helper-helper-helper-helper-helper arr i j)\n    \
    \            (define (swap-helper-helper-helper-helper-helper-helper arr i j)\n\
    \                  (define (swap-helper-helper-helper-helper-helper-helper-helper\
    \ arr i j)\n                    (define (swap-helper-helper-helper-helper-helper-helper-helper-helper\
    \ arr i j)\n                      (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper\
    \ arr i j)\n                        (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper\
    \ arr i j)\n                          (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper\
    \ arr i j)\n                            (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper\
    \ arr i j)\n                              (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper\
    \ arr i j)\n                                (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-",
  "  (define (max-helper arr k)\n    (cond\n      [(empty? arr) empty]\n      [(=\
    \ k 0) empty]\n      [else\n       (define max-val (max (first arr) (apply max\
    \ (rest arr))))\n       (define max-list (filter (lambda (x) (= x max-val)) arr))\n\
    \       (cons max-val (max-helper (remove max-list arr) (- k (length max-list))))]))\n\
    \  (max-helper arr k))\n", "  (define (max-k lst k)\n    (cond [(empty? lst) empty]\n\
    \          [(= k 0) empty]\n          [(< (length lst) k) lst]\n          [else\
    \ (cons (max (first lst) (first (rest lst)))\n                      (max-k (rest\
    \ lst) (- k 1)))]))\n  (max-k (sort arr <) k))\n", "  (define (max-helper arr\
    \ k)\n    (if (empty? arr)\n        '()\n        (let ([max (max (first arr) (max-helper\
    \ (rest arr) k))])\n          (if (&gt; k 0)\n              (cons max (max-helper\
    \ (remove max arr) (- k 1)))\n              '()))))\n  (max-helper arr k))\n</code>\n",
  "  (sort arr < k))\n", "  (sort arr > (take k arr)))\n", "  (sort arr (lambda (a\
    \ b) (> a b))))\n", "  (sort arr >))\n", "  (sort arr <))\n", "  (define (max-helper\
    \ arr k)\n    (if (empty? arr)\n        empty\n        (let ([max (max (first\
    \ arr) (max-helper (rest arr) k))])\n          (if (zero? k)\n              empty\n\
    \              (cons max (max-helper (remove max arr) (sub1 k)))))))\n  (max-helper\
    \ arr k))\n", "  (define (max-helper arr k)\n    (cond [(empty? arr) empty]\n\
    \          [(= k 0) empty]\n          [else\n           (define max-elem (max\
    \ (first arr) (max-helper (rest arr) (- k 1))))\n           (cons max-elem (max-helper\
    \ (remove max-elem arr) (- k 1)))]))\n  (max-helper arr k))\n", "  (sort arr (lambda\
    \ (x y) (< x y))))\n", "  (sort arr > (take k arr)))\n", "  (sort arr <))\n",
  "  (define (max-helper arr k)\n    (if (empty? arr)\n        (list)\n        (let\
    \ ([max (max (first arr) (apply max (rest arr)))])\n          (cons max (max-helper\
    \ (remove max arr) (- k 1))))))\n  (max-helper arr k))\n", "  (sort arr < (take\
    \ k (sort arr >))))\n", "  (sort arr (lambda (x y) (< x y)))\n  (take arr k))\n",
  "  (sort arr >))\n", "  (sort arr >))\n", "  (define (max-helper arr k)\n    (cond\
    \ [(empty? arr) empty]\n          [(= k 0) empty]\n          [else (cons (max\
    \ (first arr) (max-helper (rest arr) (- k 1)))\n                      (max-helper\
    \ (rest arr) (- k 1)))]))\n  (sort (max-helper arr k) >))\n", "  (define (max-list\
    \ lst)\n    (if (null? (cdr lst))\n        (car lst)\n        (if (> (car lst)\
    \ (max-list (cdr lst)))\n            (car lst)\n            (max-list (cdr lst)))))\n\
    \  (define (remove-max lst)\n    (if (null? (cdr lst))\n        (list)\n     \
    \   (if (= (car lst) (max-list lst))\n            (cdr lst)\n            (cons\
    \ (car lst) (remove-max (cdr lst))))))\n  (define (max-k lst k)\n    (if (= k\
    \ 0)\n        (list)\n        (cons (max-list lst) (max-k (remove-max lst) (-\
    \ k 1)))))\n  (max-k arr k))\n", "  (define (max-helper arr k)\n    (if (null?\
    \ arr)\n        '()\n        (let ([max (apply max arr)])\n          (cons max\
    \ (max-helper (filter (lambda (x) (not (= x max))) arr) (- k 1))))))\n  (max-helper\
    \ arr k))\n", "  (sort arr < (take k (sort arr >))))\n", "  (sort arr <))\n",
  "  (sort arr (lambda (x y) (< x y))))\n", "  (define (max-k arr k)\n    (cond [(empty?\
    \ arr) empty]\n          [(= k 0) empty]\n          [(= k 1) (list (max (first\
    \ arr) (max-k (rest arr) 0)))]\n          [else (cons (max (first arr) (max-k\
    \ (rest arr) 0))\n                      (max-k (rest arr) (- k 1)))]))\n  (max-k\
    \ arr k))\n", "  (define (max-k-nums arr k)\n    (cond\n      [(empty? arr) empty]\n\
    \      [(= k 0) empty]\n      [else\n       (let ([max-num (max (first arr) (max-k-nums\
    \ (rest arr) (- k 1)))])\n         (cons max-num (max-k-nums (remove max-num arr)\
    \ (- k 1))))]))\n  (max-k-nums arr k))\n", "  (sort arr (lambda (x y) (< x y))))\n",
  "  (sort arr (lambda (x y) (< x y))))\n", "  (sort arr (lambda (a b) (< a b))))\n",
  "  (sort arr (lambda (a b) (> a b))))\n", "  (define (helper arr k)\n    (cond [(empty?\
    \ arr) empty]\n          [(= k 0) empty]\n          [(= k 1) (list (max (first\
    \ arr) (max (second arr) (third arr))))]\n          [else (cons (max (first arr)\
    \ (max (second arr) (third arr)))\n                      (helper (cdr arr) (-\
    \ k 1)))]))\n  (helper arr k))\n", "  (define (max-k lst k)\n    (cond [(empty?\
    \ lst) empty]\n          [(= k 0) empty]\n          [(= k 1) (list (max (first\
    \ lst) (max-k (rest lst) (- k 1))))]\n          [else (cons (max (first lst) (max-k\
    \ (rest lst) (- k 1)))\n                      (max-k (rest lst) (- k 1)))]))\n\
    \  (max-k arr k))\n", "  (sort arr <))\n", "  (let ([arr (sort arr <)])\n    (for/list\
    \ ([i (in-range k)])\n      (list-ref arr (- (length arr) i 1)))))\n", "  (sort\
    \ arr (lambda (a b) (< a b))))\n", "  (sort arr >))\n", "  (define (max-helper\
    \ arr k)\n    (cond [(empty? arr) empty]\n          [(= k 0) empty]\n        \
    \  [else\n           (let* ([max (max (first arr) (max-helper (rest arr) (- k\
    \ 1)))]\n                  [max-list (list max)])\n             (if (empty? max-list)\n\
    \                 empty\n                 (append max-list (max-helper (remove\
    \ max arr) (- k 1)))))]))\n  (max-helper arr k))\n", "  (sort arr (lambda (x y)\
    \ (< x y))))\n", "  (sort arr <))\n", "  (sort arr > (take k arr)))\n", "  (sort\
    \ arr (lambda (x y) (< x y)))\n  (take arr k))\n", "  (define (max-helper arr\
    \ k)\n    (if (empty? arr)\n        empty\n        (let ([max (apply max arr)])\n\
    \          (cons max (max-helper (remove max arr) (- k 1))))))\n  (max-helper\
    \ arr k))\n", "  (define (max-helper arr k)\n    (if (empty? arr)\n        empty\n\
    \        (let* ([max (max (first arr) (first (max-helper (rest arr) k)))]\n  \
    \             [rest (max-helper (rest arr) k)])\n          (if (equal? max (first\
    \ arr))\n              (cons max rest)\n              (cons (first arr) (cons\
    \ max rest))))))\n  (take (max-helper arr k) k))\n", "  (sort arr <))\n", "  (define\
    \ (max-k-nums arr k)\n    (if (or (null? arr) (= k 0))\n        '()\n        (let\
    \ ([max (apply max arr)])\n          (cons max (max-k-nums (remove max arr) (-\
    \ k 1))))))\n  (sort (max-k-nums arr k) <))\n", "  (sort arr >))\n", "  (sort\
    \ arr >))\n", "  (sort arr >))\n", "  (define (helper arr k)\n    (cond\n    \
    \  [(empty? arr) empty]\n      [(= k 0) empty]\n      [else\n       (define (max-helper\
    \ arr max)\n         (cond\n           [(empty? arr) max]\n           [(> (first\
    \ arr) max) (max-helper (rest arr) (first arr))]\n           [else (max-helper\
    \ (rest arr) max)]))\n       (define max (max-helper arr (first arr)))\n     \
    \  (cons max (helper (remove max arr) (- k 1)))]))\n  (helper arr k))\n", "  (define\
    \ (max-k-helper arr k)\n    (cond\n      [(empty? arr) empty]\n      [(= k 0)\
    \ empty]\n      [else\n       (define max (first arr))\n       (define max-index\
    \ 0)\n       (define (max-helper arr i)\n         (cond\n           [(empty? arr)\
    \ max-index]\n           [else\n            (define curr (first arr))\n      \
    \      (if (> curr max)\n                (begin\n                  (set! max curr)\n\
    \                  (set! max-index i)\n                  (max-helper (rest arr)\
    \ (+ i 1)))\n                (max-helper (rest arr) (+ i 1)))]))\n       (define\
    \ max-index (max-helper arr 0))\n       (define (remove-max-helper arr i)\n  \
    \       (cond\n           [(empty? arr) empty]\n           [(= i max-index) (rest\
    \ arr)]\n           [else\n            (cons (first arr) (remove-max-helper (rest\
    \ arr) (+ i 1)))]))\n       (cons max (max-k-helper (remove-max-helper arr 0)\
    \ (- k 1)))]))\n  (max-k-helper arr k))\n", "  (define (max-helper arr k)\n  \
    \  (cond [(empty? arr) empty]\n          [(= k 0) empty]\n          [(= k 1) (list\
    \ (max (first arr) (max-helper (rest arr) 0)))]\n          [else (cons (max (first\
    \ arr) (max-helper (rest arr) (- k 1)))\n                      (max-helper (rest\
    \ arr) (- k 1)))]))\n  (sort (max-helper arr k) >))\n", "  (define (max-helper\
    \ arr k)\n    (cond\n      [(empty? arr) empty]\n      [(= k 0) empty]\n     \
    \ [else\n       (let ([max (max (first arr) (max-helper (rest arr) (- k 1)))])\n\
    \         (cons max (max-helper (remove max arr) (- k 1))))]))\n  (max-helper\
    \ arr k))\n", "  (define (max-k lst k)\n    (if (or (null? lst) (= k 0))\n   \
    \     '()\n        (cons (max (car lst) (max-k (cdr lst) (- k 1)))\n         \
    \     (max-k (cdr lst) (- k 1)))))\n  (sort (max-k arr k) >))\n", "  (sort arr\
    \ < (sublist arr 0 k)))\n", "  (sort arr <))\n", "  (define (insert-sorted lst\
    \ val)\n    (cond\n      [(empty? lst) (list val)]\n      [(< val (first lst))\
    \ (cons val lst)]\n      [else (cons (first lst) (insert-sorted (rest lst) val))]))\n\
    \  (define (insert-sorted-all lst vals)\n    (cond\n      [(empty? vals) lst]\n\
    \      [else (insert-sorted-all (insert-sorted lst (first vals)) (rest vals))]))\n\
    \  (define (remove-last lst)\n    (cond\n      [(empty? (rest lst)) empty]\n \
    \     [else (cons (first lst) (remove-last (rest lst)))]))\n  (define (remove-last-k\
    \ lst k)\n    (cond\n      [(= k 0) lst]\n      [else (remove-last-k (remove-last\
    \ lst) (- k 1))]))\n  (remove-last-k (insert-sorted-all empty arr) (- k (length\
    \ arr))))\n", "  (sort arr (lambda (a b) (> a b))))\n", "  (sort arr > (take arr\
    \ k)))\n", "  (define (max-k-helper arr k)\n    (cond\n      [(empty? arr) empty]\n\
    \      [(= k 0) empty]\n      [else\n       (define max-element (max (first arr)\
    \ (max-k-helper (rest arr) k)))\n       (cons max-element (max-k-helper (remove\
    \ max-element arr) (- k 1)))]))\n  (max-k-helper arr k))\n", "  (sort arr >))\n",
  "  (sort arr >))\n", "  (sort arr < (take k (sort arr >))))\n", "  (sort arr (lambda\
    \ (x y) (< x y))))\n", "  (sort arr <))\n", "  (define (max-heapify arr i)\n \
    \   (define (left i) (+ i 1))\n    (define (right i) (+ i 2))\n    (define (largest\
    \ i)\n      (define l (left i))\n      (define r (right i))\n      (define largest\
    \ (if (< l (length arr))\n                          (if (< (list-ref arr l) (list-ref\
    \ arr i))\n                              i\n                              l)\n\
    \                          i))\n      (if (< r (length arr))\n          (if (<\
    \ (list-ref arr r) (list-ref arr largest))\n              largest\n          \
    \    r)\n          largest))\n    (define (swap i j)\n      (define temp (list-ref\
    \ arr i))\n      (set-car! (list-ref arr i) (list-ref arr j))\n      (set-car!\
    \ (list-ref arr j) temp))\n    (define l (left i))\n    (define r (right i))\n\
    \    (define largest (largest i))\n    (if (not (= largest i))\n        (begin\n\
    \          (swap i largest)\n          (max-heapify arr largest))))\n  (define\
    \ (build-max-heap arr)\n    (for ([i (in-range (quotient (- (length arr) 1) 2)\
    \ -1 -1)])\n      (max-heapify arr i)))\n  (define (heap-sort arr)\n    (build-max-heap\
    \ arr)\n    (for ([i (in-range (sub1 (length arr)) 0 -1)])\n      (swap arr 0\
    \ i)\n      (max-heapify (sublist arr 0 i) 0)))\n  (heap-sort arr)\n  (sublist\
    \ arr 0 k))\n", "  (define (max-list lst)\n    (cond [(empty? lst) (error \"empty\
    \ list\")]\n          [(empty? (rest lst)) (first lst)]\n          [else (max\
    \ (first lst) (max-list (rest lst)))]))\n  (define (remove-max lst)\n    (cond\
    \ [(empty? lst) (error \"empty list\")]\n          [(empty? (rest lst)) (list)]\n\
    \          [(= (first lst) (max-list lst)) (rest lst)]\n          [else (cons\
    \ (first lst) (remove-max (rest lst)))]))\n  (define (helper lst k)\n    (cond\
    \ [(= k 0) (list)]\n          [else (cons (max-list lst) (helper (remove-max lst)\
    \ (- k 1)))]))\n  (helper arr k))\n", "  (define (max-heapify arr i)\n    (define\
    \ (left i) (+ i 1))\n    (define (right i) (+ i 2))\n    (define (largest i)\n\
    \      (define l (left i))\n      (define r (right i))\n      (define largest-i\n\
    \        (cond\n          [(>= l (length arr)) i]\n          [(>= r (length arr))\n\
    \           (if (> (list-ref arr l) (list-ref arr i)) l i)]\n          [else\n\
    \           (if (> (list-ref arr l) (list-ref arr r)) l r)]))\n      (if (> (list-ref\
    \ arr largest-i) (list-ref arr i))\n          largest-i\n          i))\n    (define\
    \ (swap i j)\n      (define tmp (list-ref arr i))\n      (set-car! (list-ref arr\
    \ i) (list-ref arr j))\n      (set-car! (list-ref arr j) tmp))\n    (define l\
    \ (left i))\n    (define r (right i))\n    (define largest (largest i))\n    (when\
    \ (/= largest i)\n      (swap i largest)\n      (max-heapify arr largest)))\n\
    \  (define (build-max-heap arr)\n    (for ([i (in-range (quotient (- (length arr)\
    \ 1) 2) -1 -1)])\n      (max-heapify arr i)))\n  (define (heap-sort arr)\n   \
    \ (build-max-heap arr)\n    (for ([i (in-range (length arr) -1 -1)])\n      (swap\
    \ arr 0 i)\n      (max-heapify (sublist arr 0 i) 0)))\n  (heap-sort arr))\n",
  "  (define (max-list lst)\n    (cond\n      [(null? lst) 0]\n      [(> (car lst)\
    \ (max-list (cdr lst))) (car lst)]\n      [else (max-list (cdr lst))]))\n  (define\
    \ (max-index lst)\n    (define (max-index-helper lst index)\n      (cond\n   \
    \     [(null? lst) 0]\n        [(> (car lst) (max-list (cdr lst))) index]\n  \
    \      [else (max-index-helper (cdr lst) (+ index 1))]))\n    (max-index-helper\
    \ lst 0))\n  (define (remove-max lst)\n    (cond\n      [(null? lst) '()]\n  \
    \    [(= (max-index lst) 0) (cdr lst)]\n      [else (cons (car lst) (remove-max\
    \ (cdr lst)))]))\n  (define (maximum-helper lst k)\n    (cond\n      [(= k 0)\
    \ '()]\n      [else (cons (max-list lst) (maximum-helper (remove-max lst) (- k\
    \ 1)))]))\n  (maximum-helper arr k))\n", "  (sort arr <))\n", "  (sort arr (lambda\
    \ (a b) (< a b))))\n", "  (sort arr >))\n", "  (sort arr > (take k arr)))\n",
  '  (sort arr (lambda (x y) (< x y))))', "  (cond\n    [(empty? arr) empty]\n   \
    \ [(= k 0) empty]\n    [else\n     (let ([max (max (first arr) (maximum (rest\
    \ arr) (- k 1)))])\n       (cons max (maximum (remove max arr) (- k 1))))]))\n",
  "  (sort arr (lambda (x y) (< x y)))\n  (take arr k))\n", "  (sort arr (lambda (a\
    \ b) (< a b))))\n", "  (sort arr (lambda (a b) (< b a))))\n", "  (sort arr <))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
