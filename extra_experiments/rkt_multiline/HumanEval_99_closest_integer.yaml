name: HumanEval_99_closest_integer
language: rkt
prompt: "#lang racket\n\n#| Create a function that takes a value (string) representing\
  \ a number\nand returns the closest integer to it. If the number is equidistant\n\
  from two integers, round it away from zero.\nExamples\n>>> (closest_integer \"10\"\
  )\n10\n>>> (closest_integer \"15.3\")\n15\nNote:\nRounding away from zero means\
  \ that if the given number is equidistant\nfrom two integers, the one you should\
  \ return is the one that is the\nfarthest from zero. For example closest_integer(\"\
  14.5\") should\nreturn 15 and closest_integer(\"-14.5\") should return -15.|#\n\
  (define (closest_integer value)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
  \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
  ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
  \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
completions: ["  (round (string->number value)))\n", "  (round (string->number value)))\n",
  "  (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (if (negative? (string->number value))\n      (- (round (string->number value)))\n\
    \      (round (string->number value))))\n", "  (round (string->number value)))\n",
  "  (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (let ([value (string->number value)])\n\
    \    (if (negative? value)\n        (round (add1 value))\n        (round value))))\n",
  "  (round (string->number value)))\n", "  (define (round-away-from-zero x)\n   \
    \ (if (negative? x)\n        (round (- x 0.5))\n        (round (+ x 0.5))))\n\
    \  (round-away-from-zero (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (define (round-away-from-zero value)\n    (if (negative? value)\n\
    \        (round (- value) 0)\n        (round value 0)))\n  (round-away-from-zero\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (round\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (let\
    \ ([value (string->number value)])\n    (cond\n      [(< value 0) (round value\
    \ -1)]\n      [(> value 0) (round value 1)]\n      [else 0])))\n", "  (round (string->number\
    \ value)))\n", "  (if (negative? (string->number value))\n      (- (round (string->number\
    \ value)))\n      (round (string->number value))))\n", "  (let ([value-number\
    \ (string->number value)])\n    (if (negative? value-number)\n        (round (add1\
    \ value-number))\n        (round value-number))))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (define (round-away-from-zero n)\n    (if (negative? n)\n  \
    \      (round (- n) 0)\n        (round n 0)))\n  (round-away-from-zero (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (define (closest-integer-helper value)\n    (cond\n      [(<\
    \ value 0) (- (round value))]\n      [else (round value)]))\n  (closest-integer-helper\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (round\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (round\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (round\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (round\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (round\
    \ (string->number value)))\n", "  (define (closest-integer-helper value)\n   \
    \ (cond\n      [(< value 0) (round (- value))]\n      [else (round value)]))\n\
    \  (closest-integer-helper (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (define (round-away-from-zero\
    \ number)\n    (if (negative? number)\n        (floor number)\n        (ceiling\
    \ number)))\n  (round-away-from-zero (string->number value)))\n", "  (define (round-away-from-zero\
    \ value)\n    (if (negative? value)\n        (round (- value) 0)\n        (round\
    \ value 0)))\n  (round-away-from-zero (string->number value)))\n", "  (define\
    \ (round-away-from-zero x)\n    (if (negative? x)\n        (round (- x 0.5))\n\
    \        (round (+ x 0.5))))\n  (round-away-from-zero (string->number value)))\n",
  "  (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (define (round-away-from-zero x)\n  \
    \  (if (negative? x)\n        (round (- x 0.5))\n        (round (+ x 0.5))))\n\
    \  (round-away-from-zero (string->number value)))\n", "  (let ([value (string->number\
    \ value)])\n    (if (negative? value)\n        (round (add1 value))\n        (round\
    \ value))))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (define (round-away-from-zero n)\n    (if (negative? n)\n  \
    \      (ceiling n)\n        (floor n)))\n  (round-away-from-zero (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (let ([value (string->number\
    \ value)])\n    (if (negative? value)\n        (round (add1 value))\n        (round\
    \ value))))\n", "  (round (string->number value)))\n", "  (if (negative? (string->number\
    \ value))\n      (- (round (string->number value)))\n      (round (string->number\
    \ value))))\n", "  (round (string->number value)))\n", "  (cond\n    [(< (string->number\
    \ value) 0)\n     (round (string->number value) 0 -1)]\n    [else\n     (round\
    \ (string->number value) 0 1)]))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (define (round-away-from-zero n)\n  \
    \  (if (negative? n)\n        (round (- n) 0)\n        (round n 0)))\n  (round-away-from-zero\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (define\
    \ (closest-integer-helper value)\n    (cond\n      [(< value 0) (- (round value))]\n\
    \      [else (round value)]))\n  (closest-integer-helper (string->number value)))\n",
  "  (round (string->number value)))\n", "  (round (string->number value)))\n```\n\
    \n```racket\n#lang racket\n", "  (round (string->number value)))\n", "  (round\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (define\
    \ (round-away-from-zero n)\n    (if (< n 0)\n        (round n -1)\n        (round\
    \ n 1)))\n  (round-away-from-zero (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (let ([value (string->number\
    \ value)])\n    (if (negative? value)\n        (round (add1 value))\n        (round\
    \ value))))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (define (round-away-from-zero x)\n    (if (negative? x)\n  \
    \      (round (- x 0.5))\n        (round (+ x 0.5))))\n  (round-away-from-zero\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (round\
    \ (string->number value)))\n", "  (let ([value (string->number value)])\n    (cond\n\
    \      [(integer? value) value]\n      [(< value 0) (floor value)]\n      [else\
    \ (ceiling value)])))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (define (round-away-from-zero\
    \ n)\n    (if (negative? n)\n        (round (add1 n))\n        (round n)))\n \
    \ (round-away-from-zero (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (let ([value (string->number value)])\n    (cond\n      [(>\
    \ value 0) (round value)]\n      [(< value 0) (round value)]\n      [else 0])))\n",
  "  (cond\n    [(> (string->number value) 0) (round (string->number value))]\n  \
    \  [(< (string->number value) 0) (round (string->number value))]\n    [(= (string->number\
    \ value) 0) 0]))\n", "  (round value))\n", "  (round (string->number value)))\n",
  "  (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (define (round-away-from-zero n)\n    (if (negative? n)\n        (floor n)\n\
    \        (ceiling n)))\n  (round-away-from-zero (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (cond\n    [(> (string->number value)\
    \ 0) (round (string->number value))]\n    [(< (string->number value) 0) (round\
    \ (string->number value))]\n    [(= (string->number value) 0) 0]))\n", "  (define\
    \ (round-away-from-zero x)\n    (if (negative? x)\n        (floor x)\n       \
    \ (ceiling x)))\n  (round-away-from-zero (string->number value)))\n", "  (define\
    \ (closest-integer-helper value)\n    (if (integer? value)\n        value\n  \
    \      (if (negative? value)\n            (closest-integer-helper (- value 1))\n\
    \            (closest-integer-helper (+ value 1)))))\n  (closest-integer-helper\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (round\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (define\
    \ (closest-integer-helper value)\n    (if (negative? value)\n        (round (add1\
    \ value))\n        (round value)))\n  (closest-integer-helper (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", '  (round (string->number value)))', "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (if (negative? (string->number\
    \ value))\n      (- (round (string->number value)))\n      (round (string->number\
    \ value))))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (define (closest-integer-helper value)\n    (if (negative? value)\n\
    \        (- (round value))\n        (round value)))\n  (closest-integer-helper\
    \ (string->number value)))\n", "  (define (round-away-from-zero x)\n    (if (negative?\
    \ x)\n        (ceiling x)\n        (floor x)))\n  (round-away-from-zero (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (if (negative? (string->number value))\n      (- (round (string->number\
    \ value)))\n      (round (string->number value))))\n", "  (define (round-away-from-zero\
    \ x)\n    (if (negative? x)\n        (round (- x 0.5))\n        (round (+ x 0.5))))\n\
    \  (round-away-from-zero (string->number value)))\n", "  (define (closest-integer-helper\
    \ value)\n    (if (negative? value)\n        (round (add1 value))\n        (round\
    \ value)))\n  (closest-integer-helper (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (define (round-away-from-zero n)\n    (if (< n 0)\n        (round\
    \ n -1)\n        (round n 1)))\n  (round-away-from-zero (string->number value)))\n",
  "  (define (round-away-from-zero x)\n    (if (negative? x)\n        (round (- x\
    \ 0.5))\n        (round (+ x 0.5))))\n  (round-away-from-zero (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (define (round-away-from-zero\
    \ x)\n    (if (negative? x)\n        (round (add1 x))\n        (round x)))\n \
    \ (round-away-from-zero (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
