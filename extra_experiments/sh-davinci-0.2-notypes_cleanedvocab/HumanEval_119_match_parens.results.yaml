language: sh
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str3}; i++ )); do\n        if [[ ${str3:$i:1}\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ ${str3:$i:1} ==\
    \ \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str1_len=${#str1}\n\
    \    local str2_len=${#str2}\n    local str1_open_parens=0\n    local str1_close_parens=0\n\
    \    local str2_open_parens=0\n    local str2_close_parens=0\n    local i=0\n\
    \    local j=0\n    local k=0\n    local l=0\n    local str1_open_parens_index=()\n\
    \    local str1_close_parens_index=()\n    local str2_open_parens_index=()\n \
    \   local str2_close_parens_index=()\n    local str1_open_parens_index_len=0\n\
    \    local str1_close_parens_index_len=0\n    local str2_open_parens_index_len=0\n\
    \    local str2_close_parens_index_len=0\n    local str1_open_parens_index_last=0\n\
    \    local str1_close_parens_index_last=0\n    local str2_open_parens_index_last=0\n\
    \    local str2_close_parens_index_last=0\n    local str1_open_parens_index_last_plus_one=0\n\
    \    local str1_close_parens_index_last_plus_one=0\n    local str2_open_parens_index_last_plus_one=0\n\
    \    local str2_close_parens_index_last_plus_one=0\n    local str1_open_parens_index_last_plus_one_char=\"\
    \"\n    local str1_close_parens_index_last_plus_one_char=\"\"\n    local str2_open_parens_index_last_plus_one_char=\"\
    \"\n    local str2_close_parens_index_last_plus_one_char=\"\"\n    local str1_open_parens_index_last_plus_one_char_is_open_parens=0\n\
    \    local str1_close_parens_index_last_plus_one_\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6\
    \ == \"\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local good_str=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local good_str2=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ -z \"$good_str\"\
    \ ]]; then\n    echo \"Yes\"\n  elif [[ -z \"$good_str2\" ]]; then\n    echo \"\
    Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local parens=\"$1\"\n  local count=0\n  for (( i=0; i<${#parens}; i++ ));\
    \ do\n    if [[ \"${parens:$i:1}\" == \"(\" ]]; then\n      (( count++ ))\n  \
    \  else\n      (( count-- ))\n    fi\n    if (( count < 0 )); then\n      echo\
    \ \"No\"\n      return\n    fi\n  done\n  if (( count == 0 )); then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str1_len=${#str1}\n  local str2_len=${#str2}\n\
    \  local str1_open_parens=$(echo \"$str1\" | grep -o '(' | wc -l)\n  local str1_close_parens=$(echo\
    \ \"$str1\" | grep -o ')' | wc -l)\n  local str2_open_parens=$(echo \"$str2\"\
    \ | grep -o '(' | wc -l)\n  local str2_close_parens=$(echo \"$str2\" | grep -o\
    \ ')' | wc -l)\n  local str1_open_parens_remaining=$str1_open_parens\n  local\
    \ str1_close_parens_remaining=$str1_close_parens\n  local str2_open_parens_remaining=$str2_open_parens\n\
    \  local str2_close_parens_remaining=$str2_close_parens\n  local str1_open_parens_used=0\n\
    \  local str1_close_parens_used=0\n  local str2_open_parens_used=0\n  local str2_close_parens_used=0\n\
    \  local str1_open_parens_used_remaining=$str1_open_parens_used\n  local str1_close_parens_used_remaining=$str1_close_parens_used\n\
    \  local str2_open_parens_used_remaining=$str2_open_parens_used\n  local str2_close_parens_used_remaining=$str2_close_parens_used\n\
    \  local str1_open_parens_used_remaining_prev=$str1_open_parens_used_remaining\n\
    \  local str1_close_parens_used_remaining_prev=$str1_close_parens_used_remaining\n\
    \  local str2_open_parens_used_remaining_prev=$str2_open_parens_used_remaining\n\
    \  local str2_close_parens_used_remaining_prev=$str2_close_parens_\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [ -z \"$str5\" ] || [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n \
    \   echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local tmp_file=$(mktemp)\n  local\
    \ result=\"No\"\n  for ((i=0; i<${#str1}; i++)); do\n    local char1=\"${str1:$i:1}\"\
    \n    for ((j=0; j<${#str2}; j++)); do\n      local char2=\"${str2:$j:1}\"\n \
    \     echo \"$char1$char2\" >> \"$tmp_file\"\n    done\n  done\n  while read -r\
    \ line; do\n    if $(is_good_parens \"$line\"); then\n      result=\"Yes\"\n \
    \     break\n    fi\n  done < \"$tmp_file\"\n  rm \"$tmp_file\"\n  echo \"$result\"\
    \n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\"\
    \ ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \"\
    )()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" == \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str=\"$str1$str2\"\n    local\
    \ count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ ${str:$i:1} ==\
    \ \"(\" ]]; then\n            (( count++ ))\n        elif [[ ${str:$i:1} == \"\
    )\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count -lt\
    \ 0 ]]; then\n            echo \"No\"\n            return\n        fi\n    done\n\
    \    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n        echo\
    \ \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=\"$str1$str2\"\n   \
    \ local str4=\"$str2$str1\"\n    local str5=$(echo $str3 | sed 's/[()]//g')\n\
    \    local str6=$(echo $str4 | sed 's/[()]//g')\n    if [ -z \"$str5\" ] || [\
    \ -z \"$str6\" ]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\n\
    \    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\n  local str4=\"\
    $str2$str1\"\n  local str5=\"$(echo $str3 | sed 's/\\(/\\\\(/g' | sed 's/\\)/\\\
    \\)/g')\"\n  local str6=\"$(echo $str4 | sed 's/\\(/\\\\(/g' | sed 's/\\)/\\\\\
    )/g')\"\n  local str7=\"$(echo $str5 | sed 's/\\\\(/\\(/g' | sed 's/\\\\)/\\)/g')\"\
    \n  local str8=\"$(echo $str6 | sed 's/\\\\(/\\(/g' | sed 's/\\\\)/\\)/g')\"\n\
    \  local str9=\"$(echo $str7 | sed 's/\\(/\\\\(/g' | sed 's/\\)/\\\\)/g')\"\n\
    \  local str10=\"$(echo $str8 | sed 's/\\(/\\\\(/g' | sed 's/\\)/\\\\)/g')\"\n\
    \  local str11=\"$(echo $str9 | sed 's/\\\\(/\\(/g' | sed 's/\\\\)/\\)/g')\"\n\
    \  local str12=\"$(echo $str10 | sed 's/\\\\(/\\(/g' | sed 's/\\\\)/\\)/g')\"\n\
    \  local str13=\"$(echo $str11 | sed 's/\\(/\\\\(/g' | sed 's/\\)/\\\\)/g')\"\n\
    \  local str14=\"$(echo $str12 | sed 's/\\(/\\\\(/g' | sed 's/\\)/\\\\)/g')\"\n\
    \  local str15=\"$(echo $str13 | sed 's/\\\\(/\\(/g' | sed 's/\\\\)/\\)/g')\"\n\
    \  local str16=\"$(echo $str14 | sed 's/\\\\(/\\(/g' | sed 's/\\\\)/\\)/g')\"\n\
    \  local str17=\"$(echo $str15 | sed 's/\\(/\\\\(/g' | sed '\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b"/tmp/tmp9vyre0b0.sh: line 32: unexpected EOF while looking for matching
    `''''\n/tmp/tmp9vyre0b0.sh: line 56: syntax error: unexpected end of file\n"'
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str=\"$str1$str2\"\n  local count=0\n\
    \  for (( i=0; i<${#str}; i++ )); do\n    if [[ ${str:$i:1} == \"(\" ]]; then\n\
    \      (( count++ ))\n    elif [[ ${str:$i:1} == \")\" ]]; then\n      (( count--\
    \ ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\n      return\n\
    \    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\n  else\n   \
    \ echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n    local str6=$(echo\
    \ $str4 | sed 's/[()]//g')\n    if [[ $str5 == \"\" ]]; then\n        echo \"\
    Yes\"\n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\n    else\n  \
    \      echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | tr -d ' ')\n    local str6=$(echo\
    \ $str4 | tr -d ' ')\n    local str7=$(echo $str5 | sed 's/()//g')\n    local\
    \ str8=$(echo $str6 | sed 's/()//g')\n    if [[ $str7 == \"\" ]]; then\n     \
    \   echo \"Yes\"\n    elif [[ $str8 == \"\" ]]; then\n        echo \"Yes\"\n \
    \   else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n  if [[ \"$str5\" == \"\"\
    \ ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo \"\
    Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local s1=\"$1\"\n  local s2=\"$2\"\n  local s3=\"$s1$s2\"\n  local s4=\"\
    $s2$s1\"\n  local s5=\"$(echo $s3 | sed 's/()//g')\"\n  local s6=\"$(echo $s4\
    \ | sed 's/()//g')\"\n  if [[ -z \"$s5\" ]]; then\n    echo \"Yes\"\n  elif [[\
    \ -z \"$s6\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\n\
    candidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str3}; i++ )); do\n        if [[ ${str3:$i:1}\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ ${str3:$i:1} ==\
    \ \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\n  local str4=\"\
    $str2$str1\"\n  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo\
    \ $str4 | sed 's/[()]//g')\n  if [ -z \"$str5\" ] || [ -z \"$str6\" ]; then\n\
    \    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local open=0\n    local close=0\n    for (( i=0; i<${#str}; i++ )); do\n\
    \        if [[ \"${str:$i:1}\" == \"(\" ]]; then\n            (( open++ ))\n \
    \       elif [[ \"${str:$i:1}\" == \")\" ]]; then\n            (( close++ ))\n\
    \        fi\n    done\n    if [[ $open -eq $close ]]; then\n        echo \"Yes\"\
    \n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\n  local str4=\"\
    $str2$str1\"\n  local str5=$(echo \"$str3\" | sed 's/[()]//g')\n  local str6=$(echo\
    \ \"$str4\" | sed 's/[()]//g')\n  if [[ -z \"$str5\" ]]; then\n    echo \"Yes\"\
    \n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n\
    \  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=\"$str1$str2\"\n   \
    \ local str4=\"$str2$str1\"\n    local str5=$(echo \"$str3\" | sed 's/[()]//g')\n\
    \    local str6=$(echo \"$str4\" | sed 's/[()]//g')\n    if [[ -z \"$str5\" ]];\
    \ then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo $str3 | sed 's/[()]//g')\"\n\
    \  local str6=\"$(echo $str4 | sed 's/[()]//g')\"\n  if [ -z \"$str5\" ]; then\n\
    \    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n \
    \   echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [ -z $str5 ]; then\n        echo \"Yes\"\n  \
    \  elif [ -z $str6 ]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\
    \n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmph3gs4egj.sh: line 22: [: (: binary operator expected\n/tmp/tmph3gs4egj.sh:
    line 24: [: (: binary operator expected\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$(echo $str1$str2 |\
    \ sed 's/[()]//g')\n    if [[ -z $str3 ]]; then\n        echo \"Yes\"\n    else\n\
    \        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n    local str6=$(echo\
    \ $str4 | sed 's/[()]//g')\n    if [[ -z $str5 ]]; then\n        echo \"Yes\"\n\
    \    elif [[ -z $str6 ]]; then\n        echo \"Yes\"\n    else\n        echo \"\
    No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=\"$str1$str2\"\n   \
    \ local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [ -z \"$str5\"\
    \ ]; then\n        echo \"Yes\"\n    elif [ -z \"$str6\" ]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [ -z \"$str5\" ];\
    \ then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [ -z \"$str5\" ];\
    \ then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" == \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1 str2\n    str1=$1\n    str2=$2\n    if [[ $str1 == *\"(\"\
    * && $str2 == *\")\"* ]] || [[ $str1 == *\")\"* && $str2 == *\"(\"* ]]; then\n\
    \        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  if [[ $(check_parens \"$str3\") == \"Yes\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ $(check_parens \"$str4\") == \"Yes\" ]]; then\n\
    \    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmps12bct1s.sh: line 20: check_parens: command not found\n/tmp/tmps12bct1s.sh:
    line 22: check_parens: command not found\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6 == \"\" ]];\
    \ then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"\"\n    local\
    \ str4=\"\"\n    local str5=\"\"\n    local str6=\"\"\n    local str7=\"\"\n \
    \   local str8=\"\"\n    local str9=\"\"\n    local str10=\"\"\n    local str11=\"\
    \"\n    local str12=\"\"\n    local str13=\"\"\n    local str14=\"\"\n    local\
    \ str15=\"\"\n    local str16=\"\"\n    local str17=\"\"\n    local str18=\"\"\
    \n    local str19=\"\"\n    local str20=\"\"\n    local str21=\"\"\n    local\
    \ str22=\"\"\n    local str23=\"\"\n    local str24=\"\"\n    local str25=\"\"\
    \n    local str26=\"\"\n    local str27=\"\"\n    local str28=\"\"\n    local\
    \ str29=\"\"\n    local str30=\"\"\n    local str31=\"\"\n    local str32=\"\"\
    \n    local str33=\"\"\n    local str34=\"\"\n    local str35=\"\"\n    local\
    \ str36=\"\"\n    local str37=\"\"\n    local str38=\"\"\n    local str39=\"\"\
    \n    local str40=\"\"\n    local str41=\"\"\n    local str42=\"\"\n    local\
    \ str43=\"\"\n    local str44=\"\"\n    local str45=\"\"\n    local str46=\"\"\
    \n    local str47=\"\"\n    local str48=\"\"\n    local str49=\"\"\n    local\
    \ str50=\"\"\n    local str51=\"\"\n    local str52=\"\"\n    local str53=\"\"\
    \n    local str54=\"\"\n    local str55=\"\"\n    local str56=\"\"\n    local\
    \ str57=\"\"\n    local str58=\"\"\n    local str59=\"\"\n    local str60=\"\"\
    \n    local str61=\"\"\n    local str62=\"\"\n    local str63=\"\"\n    local\
    \ str64=\"\"\n    local str65=\"\"\n    local str66=\"\"\n    local str67=\"\"\
    \n    local str68=\"\"\n    local str69=\"\"\n    local str70=\"\"\n    local\
    \ str71=\"\"\n    local str72=\"\"\n    local str73=\"\"\n    local str74=\"\"\
    \n    local str75=\"\"\n    local str76=\"\"\n    local str77=\"\"\n    local\
    \ str78=\"\"\n    local str79=\"\"\n    local str80=\"\"\n    local str81=\"\"\
    \n    local str82=\"\"\n    local str83=\"\"\n    local str84=\"\"\n   \n}\n\n\
    candidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [ -z \"$str5\" ]; then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n\
    \    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | tr -d ' ')\n    local str6=$(echo\
    \ $str4 | tr -d ' ')\n    if [[ $(echo $str5 | grep -c '()') -eq ${#str5} ]];\
    \ then\n        echo \"Yes\"\n    elif [[ $(echo $str6 | grep -c '()') -eq ${#str6}\
    \ ]]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\n\
    candidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" == \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  if [[ \"$str3\" =~ ^\\(\\)\\( \\)$ ]] || [[ \"\
    $str4\" =~ ^\\(\\)\\( \\)$ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\
    \n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmpra0cq_ph.sh: line 20: syntax error in conditional expression\n/tmp/tmpra0cq_ph.sh:
    line 20: syntax error near `\\)$\''\n/tmp/tmpra0cq_ph.sh: line 20: `  if [[ "$str3"
    =~ ^\\(\\)\\( \\)$ ]] || [[ "$str4" =~ ^\\(\\)\\( \\)$ ]]; then\''\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str=\"$str1$str2\"\n    local\
    \ count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ ${str:$i:1} ==\
    \ \"(\" ]]; then\n            (( count++ ))\n        elif [[ ${str:$i:1} == \"\
    )\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count -lt\
    \ 0 ]]; then\n            echo \"No\"\n            return\n        fi\n    done\n\
    \    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n        echo\
    \ \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n    local str6=$(echo\
    \ $str4 | sed 's/[()]//g')\n    if [ -z \"$str5\" ]; then\n        echo \"Yes\"\
    \n    elif [ -z \"$str6\" ]; then\n        echo \"Yes\"\n    else\n        echo\
    \ \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str_len=${#str1}\n    local\
    \ str_len2=${#str2}\n    local str_len_total=$((str_len + str_len2))\n    local\
    \ str_len_half=$((str_len_total / 2))\n    local str_len_half_plus=$((str_len_half\
    \ + 1))\n    local str_len_half_minus=$((str_len_half - 1))\n    local str_len_half_plus_plus=$((str_len_half_plus\
    \ + 1))\n    local str_len_half_minus_minus=$((str_len_half_minus - 1))\n    local\
    \ str_len_half_plus_minus=$((str_len_half_plus - 1))\n    local str_len_half_minus_plus=$((str_len_half_minus\
    \ + 1))\n    local str_len_half_plus_plus_plus=$((str_len_half_plus_plus + 1))\n\
    \    local str_len_half_minus_minus_minus=$((str_len_half_minus_minus - 1))\n\
    \    local str_len_half_plus_minus_minus=$((str_len_half_plus_minus - 1))\n  \
    \  local str_len_half_minus_plus_plus=$((str_len_half_minus_plus + 1))\n    local\
    \ str_len_half_plus_plus_minus=$((str_len_half_plus_plus - 1))\n    local str_len_half_minus_minus_plus=$((str_len_half_minus_minus\
    \ + 1))\n    local str_len_half_plus_minus_plus=$((str_len_half_plus_minus + 1))\n\
    \    local str_len_half_minus_plus_minus=$((str_len_half_minus_plus - 1))\n  \
    \  local str_len_half_plus_plus_plus_plus=$((str_len_half_plus_plus_plus + 1))\n\
    \    local str_len_half_minus_minus_minus_minus=$((str_len_half_minus_minus_minus\
    \ - 1))\n    local str_len_half_plus_minus\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"\"\n    local str5=\"\"\n    local str6=\"\"\n    local str7=\"\
    \"\n    local str8=\"\"\n    local str9=\"\"\n    local str10=\"\"\n    local\
    \ str11=\"\"\n    local str12=\"\"\n    local str13=\"\"\n    local str14=\"\"\
    \n    local str15=\"\"\n    local str16=\"\"\n    local str17=\"\"\n    local\
    \ str18=\"\"\n    local str19=\"\"\n    local str20=\"\"\n    local str21=\"\"\
    \n    local str22=\"\"\n    local str23=\"\"\n    local str24=\"\"\n    local\
    \ str25=\"\"\n    local str26=\"\"\n    local str27=\"\"\n    local str28=\"\"\
    \n    local str29=\"\"\n    local str30=\"\"\n    local str31=\"\"\n    local\
    \ str32=\"\"\n    local str33=\"\"\n    local str34=\"\"\n    local str35=\"\"\
    \n    local str36=\"\"\n    local str37=\"\"\n    local str38=\"\"\n    local\
    \ str39=\"\"\n    local str40=\"\"\n    local str41=\"\"\n    local str42=\"\"\
    \n    local str43=\"\"\n    local str44=\"\"\n    local str45=\"\"\n    local\
    \ str46=\"\"\n    local str47=\"\"\n    local str48=\"\"\n    local str49=\"\"\
    \n    local str50=\"\"\n    local str51=\"\"\n    local str52=\"\"\n    local\
    \ str53=\"\"\n    local str54=\"\"\n    local str55=\"\"\n    local str56=\"\"\
    \n    local str57=\"\"\n    local str58=\"\"\n    local str59=\"\"\n    local\
    \ str60=\"\"\n    local str61=\"\"\n    local str62=\"\"\n    local str63=\"\"\
    \n    local str64=\"\"\n    local str65=\"\"\n    local str66=\"\"\n    local\
    \ str67=\"\"\n    local str68=\"\"\n    local str69=\"\"\n    local str70=\"\"\
    \n    local str71=\"\"\n    local str72=\"\"\n    local str73=\"\"\n    local\
    \ str74=\"\"\n    local str75=\"\"\n    local str76=\"\"\n    local str77=\"\"\
    \n    local str78=\"\"\n    local str79=\"\"\n    local str80=\"\"\n    local\
    \ str81=\"\"\n    local str82=\"\"\n    local str83=\"\"\n\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [[ -z $str5 ]]; then\n        echo \"Yes\"\n\
    \    elif [[ -z $str6 ]]; then\n        echo \"Yes\"\n    else\n        echo \"\
    No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6 ]]; then\n  \
    \  echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  if [[ $(is_balanced $str3) == \"Yes\" ]] || [[ $(is_balanced $str4) == \"Yes\"\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpke3vt3fa.sh: line 20: is_balanced: command not found\n/tmp/tmpke3vt3fa.sh:
    line 20: is_balanced: command not found\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str=\"$str1$str2\"\n  local count=0\n\
    \  for (( i=0; i<${#str}; i++ )); do\n    if [[ ${str:$i:1} == \"(\" ]]; then\n\
    \      (( count++ ))\n    elif [[ ${str:$i:1} == \")\" ]]; then\n      (( count--\
    \ ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\n      return\n\
    \    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\n  else\n   \
    \ echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [[ \"$str5\"\
    \ == \"\" ]]; then\n        echo \"Yes\"\n    elif [[ \"$str6\" == \"\" ]]; then\n\
    \        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n    local str6=$(echo\
    \ $str4 | sed 's/[()]//g')\n    if [[ -z $str5 ]]; then\n        echo \"Yes\"\n\
    \    elif [[ -z $str6 ]]; then\n        echo \"Yes\"\n    else\n        echo \"\
    No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"\"\n    local str6=\"\"\n  \
    \  local str7=\"\"\n    local str8=\"\"\n    local str9=\"\"\n    local str10=\"\
    \"\n    local str11=\"\"\n    local str12=\"\"\n    local str13=\"\"\n    local\
    \ str14=\"\"\n    local str15=\"\"\n    local str16=\"\"\n    local str17=\"\"\
    \n    local str18=\"\"\n    local str19=\"\"\n    local str20=\"\"\n    local\
    \ str21=\"\"\n    local str22=\"\"\n    local str23=\"\"\n    local str24=\"\"\
    \n    local str25=\"\"\n    local str26=\"\"\n    local str27=\"\"\n    local\
    \ str28=\"\"\n    local str29=\"\"\n    local str30=\"\"\n    local str31=\"\"\
    \n    local str32=\"\"\n    local str33=\"\"\n    local str34=\"\"\n    local\
    \ str35=\"\"\n    local str36=\"\"\n    local str37=\"\"\n    local str38=\"\"\
    \n    local str39=\"\"\n    local str40=\"\"\n    local str41=\"\"\n    local\
    \ str42=\"\"\n    local str43=\"\"\n    local str44=\"\"\n    local str45=\"\"\
    \n    local str46=\"\"\n    local str47=\"\"\n    local str48=\"\"\n    local\
    \ str49=\"\"\n    local str50=\"\"\n    local str51=\"\"\n    local str52=\"\"\
    \n    local str53=\"\"\n    local str54=\"\"\n    local str55=\"\"\n    local\
    \ str56=\"\"\n    local str57=\"\"\n    local str58=\"\"\n    local str59=\"\"\
    \n    local str60=\"\"\n    local str61=\"\"\n    local str62=\"\"\n    local\
    \ str63=\"\"\n    local str64=\"\"\n    local str65=\"\"\n    local str66=\"\"\
    \n    local str67=\"\"\n    local str68=\"\"\n    local str69=\"\"\n    local\
    \ str70=\"\"\n    local str71=\"\"\n    local str72=\"\"\n    local str73=\"\"\
    \n    local str74=\"\"\n    local str75=\"\"\n    local str76=\"\"\n    local\
    \ str77=\"\"\n    local str78=\"\"\n    local str79=\"\"\n    local str80=\"\"\
    \n    local str81=\"\"\n    local str82=\"\"\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/\\(.\\)/\\1 /g' | tr -d ' ')\n  local str6=$(echo\
    \ $str4 | sed 's/\\(.\\)/\\1 /g' | tr -d ' ')\n  local str7=$(echo $str5 | sed\
    \ 's/\\(.\\)/\\1 /g' | tr -d ' ')\n  local str8=$(echo $str6 | sed 's/\\(.\\)/\\\
    1 /g' | tr -d ' ')\n  local str9=$(echo $str7 | sed 's/\\(.\\)/\\1 /g' | tr -d\
    \ ' ')\n  local str10=$(echo $str8 | sed 's/\\(.\\)/\\1 /g' | tr -d ' ')\n  local\
    \ str11=$(echo $str9 | sed 's/\\(.\\)/\\1 /g' | tr -d ' ')\n  local str12=$(echo\
    \ $str10 | sed 's/\\(.\\)/\\1 /g' | tr -d ' ')\n  local str13=$(echo $str11 |\
    \ sed 's/\\(.\\)/\\1 /g' | tr -d ' ')\n  local str14=$(echo $str12 | sed 's/\\\
    (.\\)/\\1 /g' | tr -d ' ')\n  local str15=$(echo $str13 | sed 's/\\(.\\)/\\1 /g'\
    \ | tr -d ' ')\n  local str16=$(echo $str14 | sed 's/\\(.\\)/\\1 /g' | tr -d '\
    \ ')\n  local str17=$(echo $str15 | sed 's/\\(.\\)/\\1 /g' | tr -d ' ')\n  local\
    \ str18=$(echo $str16 | sed 's/\\(.\\)/\\1 /g' | tr -d ' ')\n  local str19=$(echo\
    \ $str17 | sed '\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b"/tmp/tmpho5zyhkg.sh: line 34: unexpected EOF while looking for matching
    `''''\n/tmp/tmpho5zyhkg.sh: line 58: syntax error: unexpected end of file\n"'
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [[ -z $str5 ]]; then\n        echo \"Yes\"\n\
    \    elif [[ -z $str6 ]]; then\n        echo \"Yes\"\n    else\n        echo \"\
    No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str_concat=\"$str1$str2\"\
    \n  local str_len=\"${#str_concat}\"\n  local str_len_half=\"$((str_len / 2))\"\
    \n  local str_len_half_plus_one=\"$((str_len_half + 1))\"\n  local str_len_half_minus_one=\"\
    $((str_len_half - 1))\"\n  local str_len_half_plus_two=\"$((str_len_half + 2))\"\
    \n  local str_len_half_minus_two=\"$((str_len_half - 2))\"\n  local str_len_half_plus_three=\"\
    $((str_len_half + 3))\"\n  local str_len_half_minus_three=\"$((str_len_half -\
    \ 3))\"\n  local str_len_half_plus_four=\"$((str_len_half + 4))\"\n  local str_len_half_minus_four=\"\
    $((str_len_half - 4))\"\n  local str_len_half_plus_five=\"$((str_len_half + 5))\"\
    \n  local str_len_half_minus_five=\"$((str_len_half - 5))\"\n  local str_len_half_plus_six=\"\
    $((str_len_half + 6))\"\n  local str_len_half_minus_six=\"$((str_len_half - 6))\"\
    \n  local str_len_half_plus_seven=\"$((str_len_half + 7))\"\n  local str_len_half_minus_seven=\"\
    $((str_len_half - 7))\"\n  local str_len_half_plus_eight=\"$((str_len_half + 8))\"\
    \n  local str_len_half_minus_eight=\"$((str_len_half - 8))\"\n  local str_len_half_plus_nine=\"\
    $((str_len_half + 9))\"\n  local str_len_half_minus_nine=\"$((str_len_half - 9))\"\
    \n  local str_len_half_plus_ten=\"$((\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b"/tmp/tmpg6txwop_.sh: line 39: unexpected EOF while looking for matching
    `)''\n/tmp/tmpg6txwop_.sh: line 63: syntax error: unexpected end of file\n"'
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed -e 's/()//g')\n    local\
    \ str6=$(echo $str4 | sed -e 's/()//g')\n    if [[ $str5 == \"\" ]]; then\n  \
    \      echo \"Yes\"\n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\n\
    \    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local string1=\"$1\"\n  local string2=\"$2\"\n  local string=\"$string1$string2\"\
    \n  local count=0\n  for (( i=0; i<${#string}; i++ )); do\n    if [[ \"${string:$i:1}\"\
    \ == \"(\" ]]; then\n      (( count++ ))\n    elif [[ \"${string:$i:1}\" == \"\
    )\" ]]; then\n      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n \
    \     echo \"No\"\n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n\
    \    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [ -z \"$str5\" ]; then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n\
    \    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed -e 's/()//g')\n  local str6=$(echo $str4 | sed\
    \ -e 's/()//g')\n  if [ -z \"$str5\" ]; then\n    echo \"Yes\"\n  elif [ -z \"\
    $str6\" ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  if [[ $str3 =~ ^\\(+\\)+$ ]] || [[ $str4 =~ ^\\(+\\)+$ ]]; then\n    echo \"\
    Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6 == \"\" ]];\
    \ then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local s1=$1\n  local s2=$2\n  local s3=$(echo \"$s1$s2\" | sed 's/[^()]//g')\n\
    \  local s4=$(echo \"$s3\" | sed 's/()//g')\n  if [ \"$s4\" == \"\" ]; then\n\
    \    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6 == \"\" ]];\
    \ then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local good_str1=$(echo $str3 | sed 's/[()]//g')\n    local\
    \ good_str2=$(echo $str4 | sed 's/[()]//g')\n    if [[ -z $good_str1 ]] || [[\
    \ -z $good_str2 ]]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\n\
    \    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      count=$(( count + 1 ))\n    elif [[ \"${str:$i:1}\" == \"\
    )\" ]]; then\n      count=$(( count - 1 ))\n    fi\n    if [[ $count -lt 0 ]];\
    \ then\n      echo \"No\"\n      return\n    fi\n  done\n  if [[ $count -eq 0\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=\"$str1$str2\"\n   \
    \ local str4=\"$str2$str1\"\n    local str5=\"$(echo $str3 | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo $str4 | sed 's/[()]//g')\"\n    if [[ -z $str5 ]]; then\n\
    \        echo \"Yes\"\n    elif [[ -z $str6 ]]; then\n        echo \"Yes\"\n \
    \   else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6 ]]; then\n  \
    \  echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\n  local str4=\"\
    $str2$str1\"\n  if [[ $(is_good \"$str3\") == \"Yes\" ]]; then\n    echo \"Yes\"\
    \n  elif [[ $(is_good \"$str4\") == \"Yes\" ]]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmphxk7wmd1.sh: line 20: is_good: command not found\n/tmp/tmphxk7wmd1.sh:
    line 22: is_good: command not found\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n    local str6=$(echo\
    \ $str4 | sed 's/[()]//g')\n    if [[ -z $str5 ]]; then\n        echo \"Yes\"\n\
    \    elif [[ -z $str6 ]]; then\n        echo \"Yes\"\n    else\n        echo \"\
    No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      count=$(( count + 1 ))\n    elif [[ \"${str:$i:1}\" == \"\
    )\" ]]; then\n      count=$(( count - 1 ))\n    fi\n    if [[ $count -lt 0 ]];\
    \ then\n      echo \"No\"\n      return\n    fi\n  done\n  if [[ $count -eq 0\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"\"\n  local str5=\"\"\n  local str6=\"\"\n  local str7=\"\"\n \
    \ local str8=\"\"\n  local str9=\"\"\n  local str10=\"\"\n  local str11=\"\"\n\
    \  local str12=\"\"\n  local str13=\"\"\n  local str14=\"\"\n  local str15=\"\"\
    \n  local str16=\"\"\n  local str17=\"\"\n  local str18=\"\"\n  local str19=\"\
    \"\n  local str20=\"\"\n  local str21=\"\"\n  local str22=\"\"\n  local str23=\"\
    \"\n  local str24=\"\"\n  local str25=\"\"\n  local str26=\"\"\n  local str27=\"\
    \"\n  local str28=\"\"\n  local str29=\"\"\n  local str30=\"\"\n  local str31=\"\
    \"\n  local str32=\"\"\n  local str33=\"\"\n  local str34=\"\"\n  local str35=\"\
    \"\n  local str36=\"\"\n  local str37=\"\"\n  local str38=\"\"\n  local str39=\"\
    \"\n  local str40=\"\"\n  local str41=\"\"\n  local str42=\"\"\n  local str43=\"\
    \"\n  local str44=\"\"\n  local str45=\"\"\n  local str46=\"\"\n  local str47=\"\
    \"\n  local str48=\"\"\n  local str49=\"\"\n  local str50=\"\"\n  local str51=\"\
    \"\n  local str52=\"\"\n  local str53=\"\"\n  local str54=\"\"\n  local str55=\"\
    \"\n  local str56=\"\"\n  local str57=\"\"\n  local str58=\"\"\n  local str59=\"\
    \"\n  local str60=\"\"\n  local str61=\"\"\n  local str62=\"\"\n  local str63=\"\
    \"\n  local str64=\"\"\n  local str65=\"\"\n  local str66=\"\"\n  local str67=\"\
    \"\n  local str68=\"\"\n  local str69=\"\"\n  local str70=\"\"\n  local str71=\"\
    \"\n  local str72=\"\"\n  local str73=\"\"\n  local str74=\"\"\n  local str75=\"\
    \"\n  local str76=\"\"\n  local str77=\"\"\n  local str78=\"\"\n  local str79=\"\
    \"\n  local str80=\"\"\n  local str81=\"\"\n  local str82=\"\"\n  local str83=\"\
    \"\n\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            count=$((count+1))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            count=$((count-1))\n        fi\n        if [[\
    \ $count -lt 0 ]]; then\n            echo \"No\"\n            return\n       \
    \ fi\n    done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n\
    \        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [ -z \"$str5\" ] || [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n \
    \   echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$str3\"\n    local str6=\"$str4\"\
    \n    local str7=\"$str5\"\n    local str8=\"$str6\"\n    local str9=\"$str7\"\
    \n    local str10=\"$str8\"\n    local str11=\"$str9\"\n    local str12=\"$str10\"\
    \n    local str13=\"$str11\"\n    local str14=\"$str12\"\n    local str15=\"$str13\"\
    \n    local str16=\"$str14\"\n    local str17=\"$str15\"\n    local str18=\"$str16\"\
    \n    local str19=\"$str17\"\n    local str20=\"$str18\"\n    local str21=\"$str19\"\
    \n    local str22=\"$str20\"\n    local str23=\"$str21\"\n    local str24=\"$str22\"\
    \n    local str25=\"$str23\"\n    local str26=\"$str24\"\n    local str27=\"$str25\"\
    \n    local str28=\"$str26\"\n    local str29=\"$str27\"\n    local str30=\"$str28\"\
    \n    local str31=\"$str29\"\n    local str32=\"$str30\"\n    local str33=\"$str31\"\
    \n    local str34=\"$str32\"\n    local str35=\"$str33\"\n    local str36=\"$str34\"\
    \n    local str37=\"$str35\"\n    local str38=\"$str36\"\n    local str39=\"$str37\"\
    \n    local str40=\"$str38\"\n    local str41=\"$str39\"\n    local str42=\"$str40\"\
    \n    local str43=\"$str41\"\n    local str44=\"$str42\"\n    local str45=\"$str43\"\
    \n    local str46=\"$str44\"\n    local str47=\"$str45\"\n    local str48=\"$str46\"\
    \n    local str49=\"$str47\"\n    local str50=\"$str48\"\n    local str51=\"$str\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcdcav2z0.sh: line 86: unexpected EOF while looking for matching
    `"\''\n/tmp/tmpcdcav2z0.sh: line 90: syntax error: unexpected end of file\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [ -z \"$str5\" ]; then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n\
    \    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$(echo \"$str1$str2\"\
    \ | sed 's/[()]//g')\n    if [ -z \"$str3\" ]; then\n        echo \"Yes\"\n  \
    \  else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local len=$((${#str} - 1))\n    local i=0\n    local count=0\n    while\
    \ [ $i -le $len ]; do\n        local char=${str:$i:1}\n        if [ \"$char\"\
    \ == \"(\" ]; then\n            count=$((count + 1))\n        elif [ \"$char\"\
    \ == \")\" ]; then\n            count=$((count - 1))\n        fi\n        if [\
    \ $count -lt 0 ]; then\n            echo \"No\"\n            return\n        fi\n\
    \        i=$((i + 1))\n    done\n    if [ $count -eq 0 ]; then\n        echo \"\
    Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [ -z \"$str5\" ];\
    \ then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/\\(\\)//g')\n  local str6=$(echo $str4 | sed\
    \ 's/\\(\\)//g')\n  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\n  local str4=\"\
    $str2$str1\"\n  local str5=\"$(echo $str3 | sed 's/()//g')\"\n  local str6=\"\
    $(echo $str4 | sed 's/()//g')\"\n  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n\
    \  elif [[ -z $str6 ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6 == \"\" ]];\
    \ then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6\
    \ == \"\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str=\"$str1$str2\"\n  local count=0\n\
    \  for (( i=0; i<${#str}; i++ )); do\n    if [[ ${str:$i:1} == \"(\" ]]; then\n\
    \      count=$((count+1))\n    elif [[ ${str:$i:1} == \")\" ]]; then\n      count=$((count-1))\n\
    \    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\n      return\n  \
    \  fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\n  else\n    echo\
    \ \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local count=0\n  local i=0\n  local len=${#str3}\n  while [ $i -lt $len ]; do\n\
    \    if [ \"${str3:$i:1}\" == \"(\" ]; then\n      count=$((count + 1))\n    elif\
    \ [ \"${str3:$i:1}\" == \")\" ]; then\n      count=$((count - 1))\n    fi\n  \
    \  if [ $count -lt 0 ]; then\n      echo \"No\"\n      return\n    fi\n    i=$((i\
    \ + 1))\n  done\n  if [ $count -eq 0 ]; then\n    echo \"Yes\"\n  else\n    echo\
    \ \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  local str7=\"$(echo\
    \ \"$str5\" | sed 's/[()]//g')\"\n  local str8=\"$(echo \"$str6\" | sed 's/[()]//g')\"\
    \n  if [[ -z \"$str7\" ]] || [[ -z \"$str8\" ]]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" == \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local count1=$(echo $str3 | grep -o '(' | wc -l)\n  local count2=$(echo $str3\
    \ | grep -o ')' | wc -l)\n  local count3=$(echo $str4 | grep -o '(' | wc -l)\n\
    \  local count4=$(echo $str4 | grep -o ')' | wc -l)\n  if [ $count1 -eq $count2\
    \ ] && [ $count3 -eq $count4 ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\
    \n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  if [[ $(echo $str3 | $(dirname $0)/balanced_parens.sh) == \"Yes\" ]]; then\n\
    \    echo \"Yes\"\n  elif [[ $(echo $str4 | $(dirname $0)/balanced_parens.sh)\
    \ == \"Yes\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\n\
    candidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpqgzh1x59.sh: line 20: /tmp/balanced_parens.sh: No such file
    or directory\n/tmp/tmpqgzh1x59.sh: line 22: /tmp/balanced_parens.sh: No such file
    or directory\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [ \"$str5\" == \"\" ]; then\n    echo \"Yes\"\n  elif [ \"$str6\" == \"\"\
    \ ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ open=0\n  local close=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n      (( open++ ))\n    elif [[ \"${str:$i:1}\" == \")\"\
    \ ]]; then\n      (( close++ ))\n    fi\n  done\n  if [[ $open -eq $close ]];\
    \ then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      count=$(( count + 1 ))\n    elif [[ \"${str:$i:1}\" == \"\
    )\" ]]; then\n      count=$(( count - 1 ))\n    fi\n    if [[ $count -lt 0 ]];\
    \ then\n      echo \"No\"\n      return\n    fi\n  done\n  if [[ $count -eq 0\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"\"\n  local str6=\"\"\n  local str7=\"\
    \"\n  local str8=\"\"\n  local str9=\"\"\n  local str10=\"\"\n  local str11=\"\
    \"\n  local str12=\"\"\n  local str13=\"\"\n  local str14=\"\"\n  local str15=\"\
    \"\n  local str16=\"\"\n  local str17=\"\"\n  local str18=\"\"\n  local str19=\"\
    \"\n  local str20=\"\"\n  local str21=\"\"\n  local str22=\"\"\n  local str23=\"\
    \"\n  local str24=\"\"\n  local str25=\"\"\n  local str26=\"\"\n  local str27=\"\
    \"\n  local str28=\"\"\n  local str29=\"\"\n  local str30=\"\"\n  local str31=\"\
    \"\n  local str32=\"\"\n  local str33=\"\"\n  local str34=\"\"\n  local str35=\"\
    \"\n  local str36=\"\"\n  local str37=\"\"\n  local str38=\"\"\n  local str39=\"\
    \"\n  local str40=\"\"\n  local str41=\"\"\n  local str42=\"\"\n  local str43=\"\
    \"\n  local str44=\"\"\n  local str45=\"\"\n  local str46=\"\"\n  local str47=\"\
    \"\n  local str48=\"\"\n  local str49=\"\"\n  local str50=\"\"\n  local str51=\"\
    \"\n  local str52=\"\"\n  local str53=\"\"\n  local str54=\"\"\n  local str55=\"\
    \"\n  local str56=\"\"\n  local str57=\"\"\n  local str58=\"\"\n  local str59=\"\
    \"\n  local str60=\"\"\n  local str61=\"\"\n  local str62=\"\"\n  local str63=\"\
    \"\n  local str64=\"\"\n  local str65=\"\"\n  local str66=\"\"\n  local str67=\"\
    \"\n  local str68=\"\"\n  local str69=\"\"\n  local str70=\"\"\n  local str71=\"\
    \"\n  local str72=\"\"\n  local str73=\"\"\n  local str74=\"\"\n  local str75=\"\
    \"\n  local str76=\"\"\n  local str77=\"\"\n  local str78=\"\"\n  local str79=\"\
    \"\n  local str80=\"\"\n  local str81=\"\"\n  local str82=\"\"\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$str3\"\n    local str6=\"$str4\"\
    \n    local str7=\"$str3\"\n    local str8=\"$str4\"\n    local str9=\"$str3\"\
    \n    local str10=\"$str4\"\n    local str11=\"$str3\"\n    local str12=\"$str4\"\
    \n    local str13=\"$str3\"\n    local str14=\"$str4\"\n    local str15=\"$str3\"\
    \n    local str16=\"$str4\"\n    local str17=\"$str3\"\n    local str18=\"$str4\"\
    \n    local str19=\"$str3\"\n    local str20=\"$str4\"\n    local str21=\"$str3\"\
    \n    local str22=\"$str4\"\n    local str23=\"$str3\"\n    local str24=\"$str4\"\
    \n    local str25=\"$str3\"\n    local str26=\"$str4\"\n    local str27=\"$str3\"\
    \n    local str28=\"$str4\"\n    local str29=\"$str3\"\n    local str30=\"$str4\"\
    \n    local str31=\"$str3\"\n    local str32=\"$str4\"\n    local str33=\"$str3\"\
    \n    local str34=\"$str4\"\n    local str35=\"$str3\"\n    local str36=\"$str4\"\
    \n    local str37=\"$str3\"\n    local str38=\"$str4\"\n    local str39=\"$str3\"\
    \n    local str40=\"$str4\"\n    local str41=\"$str3\"\n    local str42=\"$str4\"\
    \n    local str43=\"$str3\"\n    local str44=\"$str4\"\n    local str45=\"$str3\"\
    \n    local str46=\"$str4\"\n    local str47=\"$str3\"\n    local str48=\"$str4\"\
    \n    local str49=\"$str3\"\n    local str50=\"$str4\"\n    local str51=\"$str\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy3pvvf9d.sh: line 86: unexpected EOF while looking for matching
    `"\''\n/tmp/tmpy3pvvf9d.sh: line 90: syntax error: unexpected end of file\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local s1=$1\n    local s2=$2\n    local s3=$s1$s2\n    local s4=$s2$s1\n\
    \    local s5=$(echo $s3 | sed 's/()//g')\n    local s6=$(echo $s4 | sed 's/()//g')\n\
    \    if [[ -z $s5 ]]; then\n        echo \"Yes\"\n    elif [[ -z $s6 ]]; then\n\
    \        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=\"$str1$str2\"\n   \
    \ local str4=\"$str2$str1\"\n    if [[ $(is_good_parens \"$str3\") == \"Yes\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ $(is_good_parens \"$str4\") == \"\
    Yes\" ]]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmp1edrjmcc.sh: line 20: is_good_parens: command not found\n/tmp/tmp1edrjmcc.sh:
    line 22: is_good_parens: command not found\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | tr -d ' ')\n  local str6=$(echo $str4 | tr -d ' ')\n\
    \  local str7=$(echo $str5 | sed 's/()//g')\n  local str8=$(echo $str6 | sed 's/()//g')\n\
    \  if [[ -z $str7 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str8 ]]; then\n  \
    \  echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str=\"$str1$str2\"\n  local count=0\n\
    \  for (( i=0; i<${#str}; i++ )); do\n    if [[ ${str:$i:1} == \"(\" ]]; then\n\
    \      (( count++ ))\n    elif [[ ${str:$i:1} == \")\" ]]; then\n      (( count--\
    \ ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\n      return\n\
    \    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\n  else\n   \
    \ echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  local i\n  for ((i=0; i<${#str}; i++)); do\n    if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n      ((count++))\n    elif [[ \"${str:$i:1}\" == \")\" ]];\
    \ then\n      ((count--))\n    fi\n    if ((count < 0)); then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if ((count == 0)); then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[^()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[^()]//g')\n  local str7=$(echo $str5 | sed 's/()//g')\n  local str8=$(echo\
    \ $str6 | sed 's/()//g')\n  if [ -z $str7 ]; then\n    echo \"Yes\"\n  elif [\
    \ -z $str8 ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/\\\
    (\\)//g')\"\n    local str6=\"$(echo \"$str4\" | sed 's/\\(\\)//g')\"\n    if\
    \ [[ -z \"$str5\" ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]];\
    \ then\n        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    if [[ $(is_good_parens $str3) == \"Yes\" ]]; then\n   \
    \     echo \"Yes\"\n    elif [[ $(is_good_parens $str4) == \"Yes\" ]]; then\n\
    \        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpljht8crn.sh: line 20: is_good_parens: command not found\n/tmp/tmpljht8crn.sh:
    line 22: is_good_parens: command not found\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    if [[ $(echo $str3 | grep -P '\\(\\)\\s*\\(\\)\\s*\\(\\\
    )\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\\
    (\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\\
    (\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\\
    (\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\\
    (\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\\
    (\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\\
    (\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\\
    (\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\\
    (\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\\
    (\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\\
    (\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\(\\)\\s*\\\
    (\\)\\s*\\(\\)\\s*\\(\\\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b"/tmp/tmpdx91ulrq.sh: line 20: unexpected EOF while looking for matching
    `''''\n/tmp/tmpdx91ulrq.sh: line 44: unexpected token `\xff'' in conditional command\n/tmp/tmpdx91ulrq.sh:
    line 44: syntax error: unexpected end of file\n"'
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo $str3 | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo $str4 | sed 's/[()]//g')\"\n    if [[ -z \"$str5\" ]];\
    \ then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"\"\n    local str6=\"\"\n  \
    \  local str7=\"\"\n    local str8=\"\"\n    local str9=\"\"\n    local str10=\"\
    \"\n    local str11=\"\"\n    local str12=\"\"\n    local str13=\"\"\n    local\
    \ str14=\"\"\n    local str15=\"\"\n    local str16=\"\"\n    local str17=\"\"\
    \n    local str18=\"\"\n    local str19=\"\"\n    local str20=\"\"\n    local\
    \ str21=\"\"\n    local str22=\"\"\n    local str23=\"\"\n    local str24=\"\"\
    \n    local str25=\"\"\n    local str26=\"\"\n    local str27=\"\"\n    local\
    \ str28=\"\"\n    local str29=\"\"\n    local str30=\"\"\n    local str31=\"\"\
    \n    local str32=\"\"\n    local str33=\"\"\n    local str34=\"\"\n    local\
    \ str35=\"\"\n    local str36=\"\"\n    local str37=\"\"\n    local str38=\"\"\
    \n    local str39=\"\"\n    local str40=\"\"\n    local str41=\"\"\n    local\
    \ str42=\"\"\n    local str43=\"\"\n    local str44=\"\"\n    local str45=\"\"\
    \n    local str46=\"\"\n    local str47=\"\"\n    local str48=\"\"\n    local\
    \ str49=\"\"\n    local str50=\"\"\n    local str51=\"\"\n    local str52=\"\"\
    \n    local str53=\"\"\n    local str54=\"\"\n    local str55=\"\"\n    local\
    \ str56=\"\"\n    local str57=\"\"\n    local str58=\"\"\n    local str59=\"\"\
    \n    local str60=\"\"\n    local str61=\"\"\n    local str62=\"\"\n    local\
    \ str63=\"\"\n    local str64=\"\"\n    local str65=\"\"\n    local str66=\"\"\
    \n    local str67=\"\"\n    local str68=\"\"\n    local str69=\"\"\n    local\
    \ str70=\"\"\n    local str71=\"\"\n    local str72=\"\"\n    local str73=\"\"\
    \n    local str74=\"\"\n    local str75=\"\"\n    local str76=\"\"\n    local\
    \ str77=\"\"\n    local str78=\"\"\n    local str79=\"\"\n    local str80=\"\"\
    \n    local str81=\"\"\n    local str82=\"\"\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local string1=$1\n    local string2=$2\n    local string1_len=${#string1}\n\
    \    local string2_len=${#string2}\n    local string1_open=0\n    local string1_close=0\n\
    \    local string2_open=0\n    local string2_close=0\n    local i=0\n    local\
    \ j=0\n    local k=0\n    local l=0\n    local string1_open_index=()\n    local\
    \ string1_close_index=()\n    local string2_open_index=()\n    local string2_close_index=()\n\
    \    local string1_open_index_len=0\n    local string1_close_index_len=0\n   \
    \ local string2_open_index_len=0\n    local string2_close_index_len=0\n    local\
    \ string1_open_index_last=0\n    local string1_close_index_last=0\n    local string2_open_index_last=0\n\
    \    local string2_close_index_last=0\n    local string1_open_index_first=0\n\
    \    local string1_close_index_first=0\n    local string2_open_index_first=0\n\
    \    local string2_close_index_first=0\n    local string1_open_index_first_len=0\n\
    \    local string1_close_index_first_len=0\n    local string2_open_index_first_len=0\n\
    \    local string2_close_index_first_len=0\n    local string1_open_index_last_len=0\n\
    \    local string1_close_index_last_len=0\n    local string2_open_index_last_len=0\n\
    \    local string2_close_index_last_len=0\n    local string1_open_index_first_last_len=0\n\
    \    local string1_close_index_first_last_len=0\n    local string2_open_index_first_last_len=0\n\
    \    local string2_close_index_first_last_len=0\n    local string1_open_index_first_last_len_max=0\n\
    \    local string1\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n    if [[ \"$str5\" ==\
    \ \"\" ]]; then\n        echo \"Yes\"\n    elif [[ \"$str6\" == \"\" ]]; then\n\
    \        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/\\(\\)//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/\\(\\)//g')\"\n  if [[ -z \"$str5\"\
    \ ]]; then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [[ $str5 == \"\" ]]; then\n        echo \"Yes\"\
    \n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\n    else\n       \
    \ echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str=\"$str1$str2\"\n    local\
    \ count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ ${str:$i:1} ==\
    \ \"(\" ]]; then\n            (( count++ ))\n        elif [[ ${str:$i:1} == \"\
    )\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count -lt\
    \ 0 ]]; then\n            echo \"No\"\n            return\n        fi\n    done\n\
    \    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n        echo\
    \ \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      count=$(( count + 1 ))\n    elif [[ \"${str:$i:1}\" == \"\
    )\" ]]; then\n      count=$(( count - 1 ))\n    fi\n    if [[ $count -lt 0 ]];\
    \ then\n      echo \"No\"\n      return\n    fi\n  done\n  if [[ $count -eq 0\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6 == \"\" ]];\
    \ then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n    local str6=$(echo\
    \ $str4 | sed 's/[()]//g')\n    if [[ $str5 == \"\" ]]; then\n        echo \"\
    Yes\"\n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\n    else\n  \
    \      echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" == \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str=\"$str1$str2\"\n  local count=0\n\
    \  for (( i=0; i<${#str}; i++ )); do\n    if [[ ${str:$i:1} == \"(\" ]]; then\n\
    \      (( count++ ))\n    elif [[ ${str:$i:1} == \")\" ]]; then\n      (( count--\
    \ ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\n      return\n\
    \    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\n  else\n   \
    \ echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    if [[ $str3 =~ ^\\(+\\)+$ ]] || [[ $str4 =~ ^\\(+\\)+$\
    \ ]]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\n\
    candidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local string1=\"$1\"\n    local string2=\"$2\"\n    local string=\"$string1$string2\"\
    \n    local count=0\n    for (( i=0; i<${#string}; i++ )); do\n        if [[ \"\
    ${string:$i:1}\" == \"(\" ]]; then\n            (( count++ ))\n        elif [[\
    \ \"${string:$i:1}\" == \")\" ]]; then\n            (( count-- ))\n        fi\n\
    \        if [[ $count -lt 0 ]]; then\n            echo \"No\"\n            return\n\
    \        fi\n    done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n\
    \    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local parens=\"$1\"\n  local count=0\n  for (( i=0; i<${#parens}; i++ ));\
    \ do\n    if [[ \"${parens:$i:1}\" == \"(\" ]]; then\n      (( count++ ))\n  \
    \  else\n      (( count-- ))\n    fi\n    if (( count < 0 )); then\n      echo\
    \ \"No\"\n      return\n    fi\n  done\n  if (( count == 0 )); then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [ -z \"$str5\" ]; then\n    echo \"Yes\"\n  elif [ -z \"\
    $str6\" ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=\"$str1$str2\"\n   \
    \ local str4=\"$str2$str1\"\n    local str5=\"$str3$str4\"\n    local str6=\"\
    $str4$str3\"\n    local str7=\"$str5$str6\"\n    local str8=\"$str6$str5\"\n \
    \   local str9=\"$str7$str8\"\n    local str10=\"$str8$str7\"\n    local str11=\"\
    $str9$str10\"\n    local str12=\"$str10$str9\"\n    local str13=\"$str11$str12\"\
    \n    local str14=\"$str12$str11\"\n    local str15=\"$str13$str14\"\n    local\
    \ str16=\"$str14$str13\"\n    local str17=\"$str15$str16\"\n    local str18=\"\
    $str16$str15\"\n    local str19=\"$str17$str18\"\n    local str20=\"$str18$str17\"\
    \n    local str21=\"$str19$str20\"\n    local str22=\"$str20$str19\"\n    local\
    \ str23=\"$str21$str22\"\n    local str24=\"$str22$str21\"\n    local str25=\"\
    $str23$str24\"\n    local str26=\"$str24$str23\"\n    local str27=\"$str25$str26\"\
    \n    local str28=\"$str26$str25\"\n    local str29=\"$str27$str28\"\n    local\
    \ str30=\"$str28$str27\"\n    local str31=\"$str29$str30\"\n    local str32=\"\
    $str30$str29\"\n    local str33=\"$str31$str32\"\n    local str34=\"$str32$str31\"\
    \n    local str35=\"$str33$str34\"\n    local str36=\"$str34$str33\"\n    local\
    \ str37=\"$str35$str36\"\n    local str38=\"$str36$str35\"\n    local str39=\"\
    $str37$str38\"\n    local str40=\"$str38$str37\"\n    local str\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357870
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local len=${#str}\n    local i=0\n    local count=0\n    while [ $i -lt\
    \ $len ]; do\n        if [ \"${str:$i:1}\" == \"(\" ]; then\n            count=$((count\
    \ + 1))\n        else\n            count=$((count - 1))\n        fi\n        if\
    \ [ $count -lt 0 ]; then\n            echo \"No\"\n            return\n      \
    \  fi\n        i=$((i + 1))\n    done\n    if [ $count -eq 0 ]; then\n       \
    \ echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n  \
    \  match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"\
    (()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"()\
    \ ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[\
    \ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\") =\
    \ \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n  if [[ \"$str5\" == \"\"\
    \ ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo \"\
    Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str=\"$str1$str2\"\n    local\
    \ count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ ${str:$i:1} ==\
    \ \"(\" ]]; then\n            (( count++ ))\n        elif [[ ${str:$i:1} == \"\
    )\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count -lt\
    \ 0 ]]; then\n            echo \"No\"\n            return\n        fi\n    done\n\
    \    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n        echo\
    \ \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=\"${str1}${str2}\"\n\
    \    local str4=\"${str2}${str1}\"\n    if [[ $(is_good_parens \"${str3}\") ==\
    \ \"Yes\" ]]; then\n        echo \"Yes\"\n    elif [[ $(is_good_parens \"${str4}\"\
    ) == \"Yes\" ]]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\n \
    \   fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmp2qinlu6h.sh: line 20: is_good_parens: command not found\n/tmp/tmp2qinlu6h.sh:
    line 22: is_good_parens: command not found\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed -e 's/()//g')\n    local\
    \ str6=$(echo $str4 | sed -e 's/()//g')\n    if [[ $str5 == \"\" ]]; then\n  \
    \      echo \"Yes\"\n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\n\
    \    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6\
    \ == \"\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [[ -z $str5 ]]; then\n        echo \"Yes\"\n\
    \    elif [[ -z $str6 ]]; then\n        echo \"Yes\"\n    else\n        echo \"\
    No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  if [[ $(check_parens $str3) == \"Yes\" ]]; then\n    echo \"Yes\"\n  elif [[\
    \ $(check_parens $str4) == \"Yes\" ]]; then\n    echo \"Yes\"\n  else\n    echo\
    \ \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmptieff44i.sh: line 20: check_parens: command not found\n/tmp/tmptieff44i.sh:
    line 22: check_parens: command not found\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [ -z \"$str5\" ]; then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n\
    \    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str1_parens=$(echo $str1 | tr -d\
    \ -c '()')\n  local str2_parens=$(echo $str2 | tr -d -c '()')\n  local str1_parens_count=$(echo\
    \ $str1_parens | wc -c)\n  local str2_parens_count=$(echo $str2_parens | wc -c)\n\
    \  local str1_open_parens_count=$(echo $str1_parens | tr -d -c '(' | wc -c)\n\
    \  local str2_open_parens_count=$(echo $str2_parens | tr -d -c '(' | wc -c)\n\
    \  local str1_close_parens_count=$(echo $str1_parens | tr -d -c ')' | wc -c)\n\
    \  local str2_close_parens_count=$(echo $str2_parens | tr -d -c ')' | wc -c)\n\
    \  local str1_open_parens_count_odd=$(($str1_open_parens_count % 2))\n  local\
    \ str2_open_parens_count_odd=$(($str2_open_parens_count % 2))\n  local str1_close_parens_count_odd=$(($str1_close_parens_count\
    \ % 2))\n  local str2_close_parens_count_odd=$(($str2_close_parens_count % 2))\n\
    \  if [[ $str1_parens_count -eq 0 && $str2_parens_count -eq 0 ]]; then\n    echo\
    \ \"Yes\"\n  elif [[ $str1_parens_count -eq 0 && $str2_parens_count -ne 0 ]];\
    \ then\n    if [[ $str2_open_parens_count_odd -eq 0 && $str2_close_parens_count_odd\
    \ -eq 0 ]]; then\n      echo \"Yes\"\n    else\n      echo \"No\"\n    fi\n  elif\
    \ [[ $str1_parens_count -ne 0 && $str2_parens\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b"/tmp/tmp_bxnqd4k.sh: line 38: unexpected token `newline'', conditional
    binary operator expected\n/tmp/tmp_bxnqd4k.sh: line 38: syntax error near `$str2_parens''\n/tmp/tmp_bxnqd4k.sh:
    line 38: `  elif [[ $str1_parens_count -ne 0 && $str2_parens''\n"'
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\n  local str4=\"\
    $str2$str1\"\n  if [[ $(is_good_parens \"$str3\") = \"Yes\" ]]; then\n    echo\
    \ \"Yes\"\n  elif [[ $(is_good_parens \"$str4\") = \"Yes\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpxsbaknpm.sh: line 20: is_good_parens: command not found\n/tmp/tmpxsbaknpm.sh:
    line 22: is_good_parens: command not found\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6 == \"\" ]];\
    \ then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  if [[ $(is_good_parens $str3) == \"Yes\" ]]; then\n    echo \"Yes\"\n  elif\
    \ [[ $(is_good_parens $str4) == \"Yes\" ]]; then\n    echo \"Yes\"\n  else\n \
    \   echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmp33hcw3r1.sh: line 20: is_good_parens: command not found\n/tmp/tmp33hcw3r1.sh:
    line 22: is_good_parens: command not found\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    if [[ $(check_parens $str3) == \"Yes\" ]]; then\n     \
    \   echo \"Yes\"\n    elif [[ $(check_parens $str4) == \"Yes\" ]]; then\n    \
    \    echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmp7l1mo3fy.sh: line 20: check_parens: command not found\n/tmp/tmp7l1mo3fy.sh:
    line 22: check_parens: command not found\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" == \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n    local str6=$(echo\
    \ $str4 | sed 's/[()]//g')\n    if [[ -z $str5 ]]; then\n        echo \"Yes\"\n\
    \    elif [[ -z $str6 ]]; then\n        echo \"Yes\"\n    else\n        echo \"\
    No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$str3\n  local str6=$str4\n  local str7=$str5\n  local str8=$str6\n\
    \  local str9=$str7\n  local str10=$str8\n  local str11=$str9\n  local str12=$str10\n\
    \  local str13=$str11\n  local str14=$str12\n  local str15=$str13\n  local str16=$str14\n\
    \  local str17=$str15\n  local str18=$str16\n  local str19=$str17\n  local str20=$str18\n\
    \  local str21=$str19\n  local str22=$str20\n  local str23=$str21\n  local str24=$str22\n\
    \  local str25=$str23\n  local str26=$str24\n  local str27=$str25\n  local str28=$str26\n\
    \  local str29=$str27\n  local str30=$str28\n  local str31=$str29\n  local str32=$str30\n\
    \  local str33=$str31\n  local str34=$str32\n  local str35=$str33\n  local str36=$str34\n\
    \  local str37=$str35\n  local str38=$str36\n  local str39=$str37\n  local str40=$str38\n\
    \  local str41=$str39\n  local str42=$str40\n  local str43=$str41\n  local str44=$str42\n\
    \  local str45=$str43\n  local str46=$str44\n  local str47=$str45\n  local str48=$str46\n\
    \  local str49=$str47\n  local str50=$str48\n  local str51=$str49\n  local str52=$str50\n\
    \  local str53=$str51\n  local str54=$str52\n  local str55=$str53\n  local str56=$str54\n\
    \  local str57=$str55\n  local str58=$str56\n  local str59=$str57\n  local str60=$str58\n\
    \  local str61=$str59\n  local str62=$str60\n  local str63=$str61\n  local str\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    if [[ $(is_good_parens $str3) == \"Yes\" ]]; then\n   \
    \     echo \"Yes\"\n    elif [[ $(is_good_parens $str4) == \"Yes\" ]]; then\n\
    \        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpljht8crn.sh: line 20: is_good_parens: command not found\n/tmp/tmpljht8crn.sh:
    line 22: is_good_parens: command not found\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [[ \"$str5\"\
    \ == \"\" ]]; then\n        echo \"Yes\"\n    elif [[ \"$str6\" == \"\" ]]; then\n\
    \        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n  local str4=$4\n  local\
    \ str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n  local str9=$9\n\
    \  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n  local str13=${13}\n\
    \  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n  local str17=${17}\n\
    \  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n  local str21=${21}\n\
    \  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n  local str25=${25}\n\
    \  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n  local str29=${29}\n\
    \  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n  local str33=${33}\n\
    \  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n  local str37=${37}\n\
    \  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n  local str41=${41}\n\
    \  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n  local str45=${45}\n\
    \  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n  local str49=${49}\n\
    \  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n  local str53=${53}\n\
    \  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n  local str57=${57}\n\
    \  local str58=${58}\n  local str59=${59\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmpepday35m.sh: line 98: syntax error: unexpected end of file\n'''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ len=\"${#str}\"\n  local i=0\n  local count=0\n  while [ $i -lt $len ]; do\n\
    \    local char=\"${str:$i:1}\"\n    if [ \"$char\" == \"(\" ]; then\n      count=$((count\
    \ + 1))\n    elif [ \"$char\" == \")\" ]; then\n      count=$((count - 1))\n \
    \   fi\n    if [ $count -lt 0 ]; then\n      echo \"No\"\n      return\n    fi\n\
    \    i=$((i + 1))\n  done\n  if [ $count -eq 0 ]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [[ $str5 == \"\" ]]; then\n        echo \"Yes\"\
    \n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\n    else\n       \
    \ echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local count1=$(echo $str3 | grep -o \"(\" | wc -l)\n  \
    \  local count2=$(echo $str3 | grep -o \")\" | wc -l)\n    local count3=$(echo\
    \ $str4 | grep -o \"(\" | wc -l)\n    local count4=$(echo $str4 | grep -o \")\"\
    \ | wc -l)\n    if [[ $count1 -eq $count2 ]] && [[ $count3 -eq $count4 ]]; then\n\
    \        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357870
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [[ $str5 == \"\" ]]; then\n        echo \"Yes\"\
    \n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\n    else\n       \
    \ echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local s1=\"$1\"\n    local s2=\"$2\"\n    local s3=\"$s1$s2\"\n    local\
    \ s4=\"$s2$s1\"\n    local s5=\"$(echo \"$s3\" | sed 's/[()]//g')\"\n    local\
    \ s6=\"$(echo \"$s4\" | sed 's/[()]//g')\"\n    if [ -z \"$s5\" ]; then\n    \
    \    echo \"Yes\"\n    elif [ -z \"$s6\" ]; then\n        echo \"Yes\"\n    else\n\
    \        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=\"$str1$str2\"\n   \
    \ local str4=\"$str2$str1\"\n    local str5=\"\"\n    local str6=\"\"\n    local\
    \ str7=\"\"\n    local str8=\"\"\n    local str9=\"\"\n    local str10=\"\"\n\
    \    local str11=\"\"\n    local str12=\"\"\n    local str13=\"\"\n    local str14=\"\
    \"\n    local str15=\"\"\n    local str16=\"\"\n    local str17=\"\"\n    local\
    \ str18=\"\"\n    local str19=\"\"\n    local str20=\"\"\n    local str21=\"\"\
    \n    local str22=\"\"\n    local str23=\"\"\n    local str24=\"\"\n    local\
    \ str25=\"\"\n    local str26=\"\"\n    local str27=\"\"\n    local str28=\"\"\
    \n    local str29=\"\"\n    local str30=\"\"\n    local str31=\"\"\n    local\
    \ str32=\"\"\n    local str33=\"\"\n    local str34=\"\"\n    local str35=\"\"\
    \n    local str36=\"\"\n    local str37=\"\"\n    local str38=\"\"\n    local\
    \ str39=\"\"\n    local str40=\"\"\n    local str41=\"\"\n    local str42=\"\"\
    \n    local str43=\"\"\n    local str44=\"\"\n    local str45=\"\"\n    local\
    \ str46=\"\"\n    local str47=\"\"\n    local str48=\"\"\n    local str49=\"\"\
    \n    local str50=\"\"\n    local str51=\"\"\n    local str52=\"\"\n    local\
    \ str53=\"\"\n    local str54=\"\"\n    local str55=\"\"\n    local str56=\"\"\
    \n    local str57=\"\"\n    local str58=\"\"\n    local str59=\"\"\n    local\
    \ str60=\"\"\n    local str61=\"\"\n    local str62=\"\"\n    local str63=\"\"\
    \n    local str64=\"\"\n    local str65=\"\"\n    local str66=\"\"\n    local\
    \ str67=\"\"\n    local str68=\"\"\n    local str69=\"\"\n    local str70=\"\"\
    \n    local str71=\"\"\n    local str72=\"\"\n    local str73=\"\"\n    local\
    \ str74=\"\"\n    local str75=\"\"\n    local str76=\"\"\n    local str77=\"\"\
    \n    local str78=\"\"\n    local str79=\"\"\n    local str80=\"\"\n    local\
    \ str81=\"\"\n    local str82=\"\"\n    local str\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [[ $str5 == \"\" ]]; then\n        echo \"Yes\"\
    \n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\n    else\n       \
    \ echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" == \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [[ -z $str5 ]]; then\n        echo \"Yes\"\n\
    \    elif [[ -z $str6 ]]; then\n        echo \"Yes\"\n    else\n        echo \"\
    No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660357869
