name: HumanEval_115_max_fill
language: ts
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n// 6\n// Example\
  \ 2:\n// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
  \ 2)\n// 5\n// Example 3:\n// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n// 0\n//\
  \ Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid: any, capacity: any): any {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0,\
  \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0,\
  \ 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n\
  }\n\ntest();"
completions: ["    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n \
    \       for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                grid[i][j] = 0;\n                count++;\n      \
    \          let k = i;\n                while (k < grid.length && grid[k][j] ===\
    \ 1) {\n                    grid[k][j] = 0;\n                    k++;\n      \
    \          }\n            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let row_count = 0;\n        for\
    \ (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n      \
    \          row_count++;\n            }\n        }\n        count += Math.ceil(row_count\
    \ / capacity);\n    }\n    return count;\n}\n", "    let total = 0;\n    let row\
    \ = grid.length;\n    let col = grid[0].length;\n    let buckets = new Array(col).fill(0);\n\
    \    let buckets_count = 0;\n    for (let i = 0; i < row; i++) {\n        for\
    \ (let j = 0; j < col; j++) {\n            if (grid[i][j] === 1) {\n         \
    \       buckets[j] += 1;\n                total += 1;\n            }\n       \
    \ }\n    }\n    buckets_count = Math.ceil(Math.max(...buckets) / capacity);\n\
    \    return buckets_count * col + total;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                grid[i][j] = 0;\n            }\n        }\n    }\n    return\
    \ count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "    let count\
    \ = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n    let max\
    \ = 0;\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col;\
    \ j++) {\n            if (grid[i][j] == 1) {\n                count++;\n     \
    \       }\n        }\n        max = Math.max(max, count);\n        count = 0;\n\
    \    }\n    return max * capacity;\n}\n", "    let count = 0;\n    for (let i\
    \ = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++)\
    \ {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                grid[i][j] = 0;\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    let max = 0;\n    let row = 0;\n    let\
    \ col = 0;\n    let maxRow = 0;\n    let maxCol = 0;\n    let maxRowCount = 0;\n\
    \    let maxColCount = 0;\n    let maxRowCount2 = 0;\n    let maxColCount2 = 0;\n\
    \    let maxRowCount3 = 0;\n    let maxColCount3 = 0;\n    let maxRowCount4 =\
    \ 0;\n    let maxColCount4 = 0;\n    let maxRowCount5 = 0;\n    let maxColCount5\
    \ = 0;\n    let maxRowCount6 = 0;\n    let maxColCount6 = 0;\n    let maxRowCount7\
    \ = 0;\n    let maxColCount7 = 0;\n    let maxRowCount8 = 0;\n    let maxColCount8\
    \ = 0;\n    let maxRowCount9 = 0;\n    let maxColCount9 = 0;\n    let maxRowCount10\
    \ = 0;\n    let maxColCount10 = 0;\n    let maxRowCount11 = 0;\n    let maxColCount11\
    \ = 0;\n    let maxRowCount12 = 0;\n    let maxColCount12 = 0;\n    let maxRowCount13\
    \ = 0;\n    let maxColCount13 = 0;\n    let maxRowCount14 = 0;\n    let maxColCount14\
    \ = 0;\n    let maxRowCount15 = 0;\n    let maxColCount15 = 0;\n    let maxRowCount16\
    \ = 0;\n    let maxColCount16 = 0;\n    let maxRowCount17 = 0;\n    let maxColCount17\
    \ = 0;\n    let maxRowCount18 = 0;\n    let maxColCount18 = 0;\n    let maxRowCount19\
    \ = 0;\n    let maxColCount19 = 0;\n    let maxRowCount20 = 0;\n    let maxColCount20\
    \ = 0;\n    let maxRowCount21 = 0;\n    let maxColCount21 = 0;\n    let maxRowCount22\
    \ = 0;\n    let maxColCount22 = 0;\n    let maxRowCount23 = 0;\n    let maxColCount23\
    \ = 0;\n    let maxRowCount24 = 0;", "    let count = 0;\n    let row = grid.length;\n\
    \    let col = grid[0].length;\n    let max = 0;\n    for (let i = 0; i < row;\
    \ i++) {\n        for (let j = 0; j < col; j++) {\n            if (grid[i][j]\
    \ == 1) {\n                count++;\n            }\n        }\n        if (count\
    \ > max) {\n            max = count;\n        }\n        count = 0;\n    }\n \
    \   return max * capacity;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1,\
    \ 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]],\
    \ 5));", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n  \
    \      for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                grid[i][j] = 0;\n                count++;\n      \
    \          let k = i;\n                while (k < grid.length && grid[k][j] ===\
    \ 1) {\n                    grid[k][j] = 0;\n                    k++;\n      \
    \          }\n            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let max = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count++;\n    \
    \        }\n        }\n        if (count > max) {\n            max = count;\n\
    \        }\n        count = 0;\n    }\n    return max * capacity;\n}\n", "   \
    \ let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             count += capacity;\n                grid[i][j] = 0;\n          \
    \  }\n        }\n    }\n    return count;\n}\n", "    let result = 0;\n    let\
    \ max = 0;\n    let min = 0;\n    for (let i = 0; i < grid.length; i++) {\n  \
    \      for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                max = max + 1;\n            }\n        }\n       \
    \ if (max > min) {\n            min = max;\n        }\n        max = 0;\n    }\n\
    \    result = min * capacity;\n    return result;\n}\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let row_max = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let\
    \ row_sum = row.reduce((a, b) => a + b, 0);\n        if (row_sum > row_max) {\n\
    \            row_max = row_sum;\n        }\n    }\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b)\
    \ => a + b, 0);\n        if (row_sum < row_max) {\n            let diff = row_max\
    \ - row_sum;\n            count += diff;\n        }\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let max = 0;\n    let max_index\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (grid[i][j] == 1) {\n             \
    \   count++;\n            }\n        }\n        if (count > max) {\n         \
    \   max = count;\n            max_index = i;\n        }\n        count = 0;\n\
    \    }\n    let max_count = 0;\n    for (let i = 0; i < grid[max_index].length;\
    \ i++) {\n        if (grid[max_index][i] == 1) {\n            max_count++;\n \
    \       }\n    }\n    return max_count * capacity;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let wells = grid.length;\n\
    \    let well_length = grid[0].length;\n    let well_depth = 0;\n    let bucket_depth\
    \ = 0;\n    let bucket_capacity = capacity;\n    let bucket_full = false;\n  \
    \  let bucket_empty = false;\n    let bucket_depth_increment = 0;\n    let bucket_depth_decrement\
    \ = 0;\n    let bucket_depth_increment_count = 0;\n    let bucket_depth_decrement_count\
    \ = 0;\n    let bucket_depth_increment_count_total = 0;\n    let bucket_depth_decrement_count_total\
    \ = 0;\n    let bucket_depth_increment_count_total_max = 0;\n    let bucket_depth_decrement_count_total_max\
    \ = 0;\n    let bucket_depth_increment_count_total_max_index = 0;\n    let bucket_depth_decrement_count_total_max_index\
    \ = 0;\n    let bucket_depth_increment_count_total_max_index_row = 0;\n    let\
    \ bucket_depth_decrement_count_total_max_index_row = 0;\n    let bucket_depth_increment_count_total_max_index_col\
    \ = 0;\n    let bucket_depth_decrement_count_total_max_index_col = 0;\n    let\
    \ bucket_depth_increment_count_total_max_index_row_col = 0;\n    let bucket_depth_decrement_count_total_max_index_row_col\
    \ = 0;\n    let bucket_depth_increment_count_total_max_index_row_col_row = 0;\n\
    \    let bucket_depth_decrement_count_total_max_index_row_col_row = 0;\n    let\
    \ bucket_depth_increment_count_total_max_index_row_col_col = 0;\n    let bucket_depth_decrement_count_total_max_index_row_col_col\
    \ = 0;\n    let bucket_depth_increment_count_total_max_index_row_col_row_col =\
    \ 0;", "    let count = 0;\n    let max = 0;\n    let max_index = 0;\n    let\
    \ max_index_array = [];\n    let max_array = [];\n    let max_array_index = 0;\n\
    \    let max_array_index_array = [];\n    let max_array_index_array_index = 0;\n\
    \    let max_array_index_array_index_array = [];\n    let max_array_index_array_index_array_index\
    \ = 0;\n    let max_array_index_array_index_array_index_array = [];\n    let max_array_index_array_index_array_index_array_index\
    \ = 0;\n    let max_array_index_array_index_array_index_array_index_array = [];\n\
    \    let max_array_index_array_index_array_index_array_index_array_index = 0;\n\
    \    let max_array_index_array_index_array_index_array_index_array_index_array\
    \ = [];\n    let max_array_index_array_index_array_index_array_index_array_index_array_index\
    \ = 0;\n    let max_array_index_array_index_array_index_array_index_array_index_array_index_array\
    \ = [];\n    let max_array_index_array_index_array_index_array_index_array_index_array_index_array_index\
    \ = 0;\n    let max_array_index_array_index_array_index_array_index_array_index_array_index_array_index_array\
    \ = [];\n    let max_array_index_array_index_array_index_array_index_array_index_array_index_array_index_array_index\
    \ = 0;\n    let max_array_index_array_index_array_index_array_index_array_index_array_index_array_index_array_index_array\
    \ = [];\n    let max_array_index_array_index_array_index_array_index_array_index_array_index_array_index_array_index_array_index\
    \ = 0;\n    let max_array_index_array_index_array_index_array_index", "    let\
    \ count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j\
    \ = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
    \           count += capacity;\n                grid[i][j] = 0;\n            }\n\
    \        }\n    }\n    return count;\n}\n", "    let times = 0;\n    let max =\
    \ 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j <\
    \ grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n              \
    \  max = Math.max(max, j);\n            }\n        }\n    }\n    for (let i =\
    \ 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++)\
    \ {\n            if (grid[i][j] === 1) {\n                times += 1;\n      \
    \          grid[i][j] = 0;\n                if (j + capacity > max) {\n      \
    \              capacity = j + capacity - max;\n                } else {\n    \
    \                capacity = 0;\n                }\n            }\n        }\n\
    \    }\n    return times;\n}\n", "    let count = 0;\n    for (let i = 0; i <\
    \ grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n  \
    \          if (grid[i][j] === 1) {\n                count += capacity;\n     \
    \           grid[i][j] = 0;\n            }\n        }\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let rowSum = row.reduce((a, b) =>\
    \ a + b, 0);\n        if (rowSum > capacity) {\n            return -1;\n     \
    \   }\n        if (rowSum === capacity) {\n            count += row.length;\n\
    \        } else {\n            for (let j = 0; j < row.length; j++) {\n      \
    \          if (row[j] === 1) {\n                    count++;\n               \
    \ }\n            }\n        }\n    }\n    return count;\n}\n", "    let count\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n            \
    \    count += capacity;\n                grid[i][j] = 0;\n            }\n    \
    \    }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0,\
    \ 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
    \ 0, 0]], 5));", "    // your code here\n    return 0;\n}\n", "    let count =\
    \ 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n      \
    \      sum += row[j];\n        }\n        count += Math.ceil(sum / capacity);\n\
    \    }\n    return count;\n}\n", "    let count = 0;\n    for (let i = 0; i <\
    \ grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n  \
    \          if (grid[i][j] === 1) {\n                count += capacity;\n     \
    \           grid[i][j] = 0;\n            }\n        }\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let row_count = 0;\n        for\
    \ (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n      \
    \          row_count++;\n            }\n        }\n        count += Math.ceil(row_count\
    \ / capacity);\n    }\n    return count;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count++;\n    \
    \            grid[i][j] = 0;\n                let bucket = capacity;\n       \
    \         while (bucket > 0) {\n                    if (i - 1 >= 0 && grid[i -\
    \ 1][j] === 1) {\n                        grid[i - 1][j] = 0;\n              \
    \          bucket--;\n                    }\n                    if (i + 1 < grid.length\
    \ && grid[i + 1][j] === 1) {\n                        grid[i + 1][j] = 0;\n  \
    \                      bucket--;\n                    }\n                    if\
    \ (j - 1 >= 0 && grid[i][j - 1] === 1) {\n                        grid[i][j -\
    \ 1] = 0;\n                        bucket--;\n                    }\n        \
    \            if (j + 1 < grid[i].length && grid[i][j + 1] === 1) {\n         \
    \               grid[i][j + 1] = 0;\n                        bucket--;\n     \
    \               }\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "    let result = 0;\n    let wells = grid.length;\n    let length\
    \ = grid[0].length;\n    let buckets = [];\n    for (let i = 0; i < wells; i++)\
    \ {\n        buckets.push(0);\n    }\n    for (let i = 0; i < length; i++) {\n\
    \        for (let j = 0; j < wells; j++) {\n            if (grid[j][i] === 1)\
    \ {\n                buckets[j]++;\n            }\n        }\n        let max\
    \ = Math.max(...buckets);\n        if (max > capacity) {\n            result +=\
    \ max - capacity;\n            for (let j = 0; j < wells; j++) {\n           \
    \     buckets[j] = capacity;\n            }\n        }\n    }\n    return result;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let row_count = 0;\n        for\
    \ (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n      \
    \          row_count++;\n            }\n        }\n        count += Math.ceil(row_count\
    \ / capacity);\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1,\
    \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0,\
    \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0],\
    \ [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                grid[i][j] = 0;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                grid[i][j] = 0;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let max = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count++;\n    \
    \        }\n        }\n        if (count > max) {\n            max = count;\n\
    \        }\n        count = 0;\n    }\n    return max * capacity;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let max = 0;\n    let max_index\
    \ = 0;\n    let max_index_arr = [];\n    let max_arr = [];\n    let max_arr_index\
    \ = [];\n    let max_arr_index_arr = [];\n    let max_arr_index_arr_index = [];\n\
    \    let max_arr_index_arr_index_arr = [];\n    let max_arr_index_arr_index_arr_index\
    \ = [];\n    let max_arr_index_arr_index_arr_index_arr = [];\n    let max_arr_index_arr_index_arr_index_arr_index\
    \ = [];\n    let max_arr_index_arr_index_arr_index_arr_index_arr = [];\n    let\
    \ max_arr_index_arr_index_arr_index_arr_index_arr_index = [];\n    let max_arr_index_arr_index_arr_index_arr_index_arr_index_arr\
    \ = [];\n    let max_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index\
    \ = [];\n    let max_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index_arr\
    \ = [];\n    let max_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index\
    \ = [];\n    let max_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index_arr\
    \ = [];\n    let max_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index\
    \ = [];\n    let max_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index_arr\
    \ = [];\n    let max_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index\
    \ = [];\n    let max_arr_index_arr_index_arr_index_arr_index_arr_index_arr_index_",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             grid[i][j] = 0;\n                count++;\n                let bucket\
    \ = capacity;\n                while (bucket > 0) {\n                    if (i\
    \ - 1 >= 0 && grid[i - 1][j] === 1) {\n                        grid[i - 1][j]\
    \ = 0;\n                        bucket--;\n                    }\n           \
    \         if (i + 1 < grid.length && grid[i + 1][j] === 1) {\n               \
    \         grid[i + 1][j] = 0;\n                        bucket--;\n           \
    \         }\n                    if (j - 1 >= 0 && grid[i][j - 1] === 1) {\n \
    \                       grid[i][j - 1] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j + 1 < grid[i].length && grid[i][j\
    \ + 1] === 1) {\n                        grid[i][j + 1] = 0;\n               \
    \         bucket--;\n                    }\n                }\n            }\n\
    \        }\n    }\n    return count;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                grid[i][j] = 0;\n            }\n        }\n    }\n    return\
    \ count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "    let count\
    \ = 0;\n    let max = 0;\n    let max_index = 0;\n    let max_count = 0;\n   \
    \ let max_count_index = 0;\n    for (let i = 0; i < grid.length; i++) {\n    \
    \    for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] ===\
    \ 1) {\n                count++;\n            }\n        }\n        if (count\
    \ > max) {\n            max = count;\n            max_index = i;\n        }\n\
    \        count = 0;\n    }\n    for (let i = 0; i < grid[max_index].length; i++)\
    \ {\n        if (grid[max_index][i] === 1) {\n            max_count++;\n     \
    \   }\n    }\n    max_count_index = max_count;\n    let result = (max_count_index\
    \ * capacity) + ((grid.length - 1) * max_count_index);\n    return result;\n}\n",
  "    let max_fill = 0;\n    let wells = grid.length;\n    let well_length = grid[0].length;\n\
    \    let buckets = capacity;\n    let bucket_count = 0;\n    let bucket_fill =\
    \ 0;\n    let bucket_fill_count = 0;\n    let bucket_fill_max = 0;\n    let bucket_fill_max_count\
    \ = 0;\n    let bucket_fill_max_count_max = 0;\n    let bucket_fill_max_count_max_count\
    \ = 0;\n    let bucket_fill_max_count_max_count_max = 0;\n    let bucket_fill_max_count_max_count_max_count\
    \ = 0;\n    let bucket_fill_max_count_max_count_max_count_max = 0;\n    let bucket_fill_max_count_max_count_max_count_max_count\
    \ = 0;\n    let bucket_fill_max_count_max_count_max_count_max_count_max = 0;\n\
    \    let bucket_fill_max_count_max_count_max_count_max_count_max_count = 0;\n\
    \    let bucket_fill_max_count_max_count_max_count_max_count_max_count_max = 0;\n\
    \    let bucket_fill_max_count_max_count_max_count_max_count_max_count_max_count\
    \ = 0;\n    let bucket_fill_max_count_max_count_max_count_max_count_max_count_max_count_max\
    \ = 0;\n    let bucket_fill_max_count_max_count_max_count_max_count_max_count_max_count_max_count\
    \ = 0;\n    let bucket_fill_max_count_max_count_max_count_max_count_max_count_max_count_max_count_max\
    \ = 0;\n    let bucket_fill_max_count_max_count_max_count_max_count_max_count_max_count_max_count_max_count\
    \ = 0;\n    let bucket_fill_max_count_max_count_max_count_max_count_max_count_max_",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             count += capacity;\n                grid[i][j] = 0;\n          \
    \  }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1,\
    \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0,\
    \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0],\
    \ [0, 0, 0]], 5));", "    let count = 0;\n    let row = grid.length;\n    let\
    \ col = grid[0].length;\n    let max = 0;\n    for (let i = 0; i < row; i++) {\n\
    \        for (let j = 0; j < col; j++) {\n            if (grid[i][j] === 1) {\n\
    \                max = Math.max(max, i);\n            }\n        }\n    }\n  \
    \  for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n\
    \            if (grid[i][j] === 1) {\n                count++;\n            }\n\
    \        }\n    }\n    return count * capacity;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let row = grid.length;\n\
    \    let col = grid[0].length;\n    let max = 0;\n    for (let i = 0; i < row;\
    \ i++) {\n        for (let j = 0; j < col; j++) {\n            if (grid[i][j]\
    \ == 1) {\n                max = Math.max(max, j);\n            }\n        }\n\
    \    }\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col;\
    \ j++) {\n            if (grid[i][j] == 1) {\n                count += capacity;\n\
    \            }\n            if (j == max) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n   \
    \     let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n         \
    \   sum += row[j];\n        }\n        if (sum > capacity) {\n            count\
    \ += sum - capacity;\n        }\n    }\n    return count;\n}\n", "    let count\
    \ = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n    let max\
    \ = 0;\n    let max_index = 0;\n    let max_row = 0;\n    let max_col = 0;\n \
    \   let max_row_index = 0;\n    let max_col_index = 0;\n    let max_row_col_index\
    \ = 0;\n    let max_row_col = 0;\n    let max_row_col_row = 0;\n    let max_row_col_col\
    \ = 0;\n    let max_row_col_row_index = 0;\n    let max_row_col_col_index = 0;\n\
    \    let max_row_col_row_col_index = 0;\n    let max_row_col_row_col = 0;\n  \
    \  let max_row_col_row_col_row = 0;\n    let max_row_col_row_col_col = 0;\n  \
    \  let max_row_col_row_col_row_index = 0;\n    let max_row_col_row_col_col_index\
    \ = 0;\n    let max_row_col_row_col_row_col_index = 0;\n    let max_row_col_row_col_row_col\
    \ = 0;\n    let max_row_col_row_col_row_col_row = 0;\n    let max_row_col_row_col_row_col_col\
    \ = 0;\n    let max_row_col_row_col_row_col_row_index = 0;\n    let max_row_col_row_col_row_col_col_index\
    \ = 0;\n    let max_row_col_row_col_row_col_row_col_index = 0;\n    let max_row_col_row_col_row_col_row_col\
    \ = 0;\n    let max_row_col_row_col_row_col_row_col_row = 0;\n    let max_row_col_row_col_row_col_row_col_col\
    \ = 0;\n    let max_row_col_row_col_row_col_row_", "    let count = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                grid[i][j] = 0;\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    let row = grid.length;\n    let col =\
    \ grid[0].length;\n    let max = 0;\n    for (let i = 0; i < row; i++) {\n   \
    \     for (let j = 0; j < col; j++) {\n            if (grid[i][j] == 1) {\n  \
    \              max = Math.max(max, j);\n            }\n        }\n    }\n    for\
    \ (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n     \
    \       if (grid[i][j] == 1) {\n                count++;\n                grid[i][j]\
    \ = 0;\n            }\n            if (j == max) {\n                break;\n \
    \           }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let row = grid.length;\n\
    \    let col = grid[0].length;\n    let max = 0;\n    for (let i = 0; i < row;\
    \ i++) {\n        for (let j = 0; j < col; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                max = Math.max(max, j);\n            }\n        }\n\
    \    }\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += 1;\n \
    \           }\n            if (j === max) {\n                count += 1;\n   \
    \         }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             count++;\n            }\n        }\n        if (count > max) {\n\
    \            max = count;\n        }\n        count = 0;\n    }\n    return max\
    \ * capacity;\n}\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "    let\
    \ count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j\
    \ = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
    \           count += capacity;\n                grid[i][j] = 0;\n            }\n\
    \        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
    \ 0, 0]], 5));", "    let result = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        let row = grid[i];\n        let count = 0;\n        for (let j =\
    \ 0; j < row.length; j++) {\n            if (row[j] === 1) {\n               \
    \ count++;\n            }\n        }\n        if (count > 0) {\n            result\
    \ += Math.ceil(count / capacity);\n        }\n    }\n    return result;\n}\n",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             count += capacity;\n                grid[i][j] = 0;\n          \
    \  }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1,\
    \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0,\
    \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0],\
    \ [0, 0, 0]], 5));", "    let count = 0;\n    let row = grid.length;\n    let\
    \ col = grid[0].length;\n    let max = 0;\n    for (let i = 0; i < row; i++) {\n\
    \        for (let j = 0; j < col; j++) {\n            if (grid[i][j] > max) {\n\
    \                max = grid[i][j];\n            }\n        }\n    }\n    for (let\
    \ i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n          \
    \  if (grid[i][j] < max) {\n                count += max - grid[i][j];\n     \
    \       }\n        }\n    }\n    return count;\n}\n", "    let max_fill = 0;\n\
    \    let bucket = capacity;\n    for (let i = 0; i < grid.length; i++) {\n   \
    \     for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] ===\
    \ 1) {\n                if (bucket === 0) {\n                    max_fill++;\n\
    \                    bucket = capacity;\n                }\n                bucket--;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\n", "    let count =\
    \ 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let row_count = 0;\n        for (let j = 0; j < row.length; j++) {\n\
    \            if (row[j] === 1) {\n                row_count++;\n            }\n\
    \        }\n        count += Math.ceil(row_count / capacity);\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                grid[i][j] = 0;\n                count++;\n      \
    \          let bucket = capacity;\n                while (bucket > 0) {\n    \
    \                if (i > 0 && grid[i - 1][j] === 1) {\n                      \
    \  grid[i - 1][j] = 0;\n                        bucket--;\n                  \
    \  }\n                    if (i < grid.length - 1 && grid[i + 1][j] === 1) {\n\
    \                        grid[i + 1][j] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j > 0 && grid[i][j - 1] === 1)\
    \ {\n                        grid[i][j - 1] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j < grid[i].length - 1 && grid[i][j\
    \ + 1] === 1) {\n                        grid[i][j + 1] = 0;\n               \
    \         bucket--;\n                    }\n                }\n            }\n\
    \        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
    \ 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                grid[i][j] = 0;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count++;\n                grid[i][j] = 0;\n      \
    \          for (let k = i; k < grid.length; k++) {\n                    if (grid[k][j]\
    \ === 1) {\n                        grid[k][j] = 0;\n                    }\n \
    \               }\n            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let max_fill = 0;\n    let row_length = grid[0].length;\n\
    \    let col_length = grid.length;\n    let row_index = 0;\n    let col_index\
    \ = 0;\n    let row_sum = 0;\n    let col_sum = 0;\n    let row_max = 0;\n   \
    \ let col_max = 0;\n    let row_max_index = 0;\n    let col_max_index = 0;\n \
    \   let row_max_sum = 0;\n    let col_max_sum = 0;\n    let row_max_index_sum\
    \ = 0;\n    let col_max_index_sum = 0;\n    let row_max_index_sum_index = 0;\n\
    \    let col_max_index_sum_index = 0;\n    let row_max_index_sum_index_sum = 0;\n\
    \    let col_max_index_sum_index_sum = 0;\n    let row_max_index_sum_index_sum_index\
    \ = 0;\n    let col_max_index_sum_index_sum_index = 0;\n    let row_max_index_sum_index_sum_index_sum\
    \ = 0;\n    let col_max_index_sum_index_sum_index_sum = 0;\n    let row_max_index_sum_index_sum_index_sum_index\
    \ = 0;\n    let col_max_index_sum_index_sum_index_sum_index = 0;\n    let row_max_index_sum_index_sum_index_sum_index_sum\
    \ = 0;\n    let col_max_index_sum_index_sum_index_sum_index_sum = 0;\n    let\
    \ row_max_index_sum_index_sum_index_sum_index_sum_index = 0;\n    let col_max_index_sum_index_sum_index_sum_index_sum_index\
    \ = 0;\n    let row_max_index_sum_index_sum_index_sum_index_sum_index_sum = 0;\n\
    \    let col_max_index_sum_index_sum_index_sum_index_sum_index_sum = 0;\n    let",
  "    let max_fill = 0;\n    let row_max = 0;\n    let row_sum = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        row_max = Math.max(...grid[i]);\n  \
    \      row_sum = grid[i].reduce((a, b) => a + b, 0);\n        max_fill += Math.max(row_max,\
    \ Math.ceil(row_sum / capacity));\n    }\n    return max_fill;\n}\n", "    let\
    \ count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let sum = 0;\n        for (let j = 0; j < row.length; j++) {\n      \
    \      let cell = row[j];\n            sum += cell;\n        }\n        if (sum\
    \ > capacity) {\n            count += sum - capacity;\n        }\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        let row = grid[i];\n        let bucket = capacity;\n        for (let\
    \ j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n           \
    \     if (bucket > 0) {\n                    bucket--;\n                    row[j]\
    \ = 0;\n                } else {\n                    count++;\n             \
    \       bucket = capacity - 1;\n                    row[j] = 0;\n            \
    \    }\n            }\n        }\n    }\n    return count;\n}\n", "    let count\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let row_count = 0;\n        for (let j = 0; j < row.length; j++) {\n\
    \            if (row[j] === 1) {\n                row_count++;\n            }\n\
    \        }\n        if (row_count > 0) {\n            count += Math.ceil(row_count\
    \ / capacity);\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                grid[i][j] = 0;\n\
    \                count++;\n                let bucket = capacity;\n          \
    \      while (bucket > 0) {\n                    if (i - 1 >= 0 && grid[i - 1][j]\
    \ === 1) {\n                        grid[i - 1][j] = 0;\n                    \
    \    bucket--;\n                    }\n                    if (i + 1 < grid.length\
    \ && grid[i + 1][j] === 1) {\n                        grid[i + 1][j] = 0;\n  \
    \                      bucket--;\n                    }\n                    if\
    \ (j - 1 >= 0 && grid[i][j - 1] === 1) {\n                        grid[i][j -\
    \ 1] = 0;\n                        bucket--;\n                    }\n        \
    \            if (j + 1 < grid[i].length && grid[i][j + 1] === 1) {\n         \
    \               grid[i][j + 1] = 0;\n                        bucket--;\n     \
    \               }\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b) => a\
    \ + b, 0);\n        if (row_sum > 0) {\n            count += Math.ceil(row_sum\
    \ / capacity);\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                grid[i][j] = 0;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let row = grid.length;\n\
    \    let col = grid[0].length;\n    let max = 0;\n    for (let i = 0; i < row;\
    \ i++) {\n        for (let j = 0; j < col; j++) {\n            if (grid[i][j]\
    \ == 1) {\n                max = Math.max(max, j);\n            }\n        }\n\
    \    }\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col;\
    \ j++) {\n            if (grid[i][j] == 1) {\n                count += 1;\n  \
    \          }\n            if (j == max) {\n                count += 1;\n     \
    \       }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let total = 0;\n    let max = 0;\n    let count\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            total += grid[i][j];\n        }\n    \
    \    if (total > max) {\n            max = total;\n        }\n        total =\
    \ 0;\n    }\n    if (max > capacity) {\n        count = max - capacity;\n    }\n\
    \    return count;\n}\n", "    let max_fill = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                max_fill += capacity;\n            }\n        }\n\
    \    }\n    return max_fill;\n}\n", "    let count = 0;\n    for (let row = 0;\
    \ row < grid.length; row++) {\n        for (let col = 0; col < grid[row].length;\
    \ col++) {\n            if (grid[row][col] === 1) {\n                count +=\
    \ capacity;\n                let bucket = capacity;\n                for (let\
    \ i = row; i < grid.length; i++) {\n                    for (let j = 0; j < grid[i].length;\
    \ j++) {\n                        if (grid[i][j] === 1) {\n                  \
    \          if (bucket > 0) {\n                                grid[i][j] = 0;\n\
    \                                bucket--;\n                            }\n  \
    \                      }\n                    }\n                }\n         \
    \   }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
    \ 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                grid[i][j] = 0;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                grid[i][j] = 0;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let result = 0;\n    let row = grid.length;\n\
    \    let col = grid[0].length;\n    let max = 0;\n    let max_row = 0;\n    let\
    \ max_col = 0;\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j\
    \ < col; j++) {\n            if (grid[i][j] > max) {\n                max = grid[i][j];\n\
    \                max_row = i;\n                max_col = j;\n            }\n \
    \       }\n    }\n    for (let i = 0; i < row; i++) {\n        for (let j = 0;\
    \ j < col; j++) {\n            if (grid[i][j] === 1) {\n                result\
    \ += capacity;\n            }\n        }\n    }\n    result -= max;\n    return\
    \ result;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                grid[i][j] = 0;\n                count++;\n      \
    \          let bucket = capacity;\n                while (bucket > 0) {\n    \
    \                if (i - 1 >= 0 && grid[i - 1][j] === 1) {\n                 \
    \       grid[i - 1][j] = 0;\n                        bucket--;\n             \
    \       }\n                    if (i + 1 < grid.length && grid[i + 1][j] === 1)\
    \ {\n                        grid[i + 1][j] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j - 1 >= 0 && grid[i][j - 1] ===\
    \ 1) {\n                        grid[i][j - 1] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j + 1 < grid[i].length && grid[i][j\
    \ + 1] === 1) {\n                        grid[i][j + 1] = 0;\n               \
    \         bucket--;\n                    }\n                }\n            }\n\
    \        }\n    }\n    return count;\n}\n", "    let count = 0;\n    let row =\
    \ grid.length;\n    let col = grid[0].length;\n    let max = 0;\n    let max_row\
    \ = 0;\n    let max_col = 0;\n    let max_row_count = 0;\n    let max_col_count\
    \ = 0;\n    let max_row_count_index = 0;\n    let max_col_count_index = 0;\n \
    \   let max_row_count_index_list = [];\n    let max_col_count_index_list = [];\n\
    \    let max_row_count_list = [];\n    let max_col_count_list = [];\n    let max_row_list\
    \ = [];\n    let max_col_list = [];\n    let max_row_index = 0;\n    let max_col_index\
    \ = 0;\n    let max_row_index_list = [];\n    let max_col_index_list = [];\n \
    \   let max_row_list_list = [];\n    let max_col_list_list = [];\n    let max_row_list_list_list\
    \ = [];\n    let max_col_list_list_list = [];\n    let max_row_list_list_list_list\
    \ = [];\n    let max_col_list_list_list_list = [];\n    let max_row_list_list_list_list_list\
    \ = [];\n    let max_col_list_list_list_list_list = [];\n    let max_row_list_list_list_list_list_list\
    \ = [];\n    let max_col_list_list_list_list_list_list = [];\n    let max_row_list_list_list_list_list_list_list\
    \ = [];\n    let max_col_list_list_list_list_list_list_list = [];\n    let max_row_list_list_list_list_list_list_list_list\
    \ = [];\n    let max_col_list_list_list_list_list_list_list_list = [];\n    let\
    \ max_row_list_list_list_list_list_list_list_list_list = [];\n    let max_col_list_list_list_list_list",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             grid[i][j] = 0;\n                count++;\n                let k\
    \ = i;\n                while (k < grid.length && capacity > 0) {\n          \
    \          if (grid[k][j] === 1) {\n                        grid[k][j] = 0;\n\
    \                        capacity--;\n                    }\n                \
    \    k++;\n                }\n            }\n        }\n    }\n    return count;\n\
    }\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let max = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count++;\n    \
    \        }\n        }\n        if (count > max) {\n            max = count;\n\
    \        }\n        count = 0;\n    }\n    return max * capacity;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let max = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count++;\n    \
    \        }\n        }\n        if (count > max) {\n            max = count;\n\
    \        }\n        count = 0;\n    }\n    return max * capacity;\n}\n", "   \
    \ let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             grid[i][j] = 0;\n                count++;\n                if (i\
    \ > 0) {\n                    grid[i - 1][j] = 0;\n                }\n       \
    \         if (i < grid.length - 1) {\n                    grid[i + 1][j] = 0;\n\
    \                }\n                if (j > 0) {\n                    grid[i][j\
    \ - 1] = 0;\n                }\n                if (j < grid[i].length - 1) {\n\
    \                    grid[i][j + 1] = 0;\n                }\n            }\n \
    \       }\n    }\n    return count;\n}\n", "    let count = 0;\n    for (let i\
    \ = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++)\
    \ {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                for (let k = i; k < grid.length; k++) {\n                   \
    \ if (grid[k][j] === 1) {\n                        grid[k][j] = 0;\n         \
    \           }\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "    let count\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n            \
    \    count++;\n                grid[i][j] = 0;\n                let bucket = capacity;\n\
    \                while (bucket > 0) {\n                    if (i > 0 && grid[i\
    \ - 1][j] === 1) {\n                        grid[i - 1][j] = 0;\n            \
    \            bucket--;\n                    }\n                    if (i < grid.length\
    \ - 1 && grid[i + 1][j] === 1) {\n                        grid[i + 1][j] = 0;\n\
    \                        bucket--;\n                    }\n                  \
    \  if (j > 0 && grid[i][j - 1] === 1) {\n                        grid[i][j - 1]\
    \ = 0;\n                        bucket--;\n                    }\n           \
    \         if (j < grid[i].length - 1 && grid[i][j + 1] === 1) {\n            \
    \            grid[i][j + 1] = 0;\n                        bucket--;\n        \
    \            }\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "    let count\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n            \
    \    count += capacity;\n                grid[i][j] = 0;\n            }\n    \
    \    }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0,\
    \ 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
    \ 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                grid[i][j] = 0;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                for (let k = i\
    \ + 1; k < grid.length; k++) {\n                    if (grid[k][j] === 1) {\n\
    \                        count += capacity;\n                    } else {\n  \
    \                      break;\n                    }\n                }\n    \
    \        }\n        }\n    }\n    return count;\n}\n", "    let result = 0;\n\
    \    let row = grid.length;\n    let col = grid[0].length;\n    let i = 0;\n \
    \   let j = 0;\n    while (i < row) {\n        if (grid[i][j] === 1) {\n     \
    \       result += capacity;\n            grid[i][j] = 0;\n        }\n        if\
    \ (j === col - 1) {\n            i++;\n            j = 0;\n        } else {\n\
    \            j++;\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let row = 0;\n    let col\
    \ = 0;\n    let max = 0;\n    let maxRow = 0;\n    let maxCol = 0;\n    let maxRowCount\
    \ = 0;\n    let maxColCount = 0;\n    let maxRowCount2 = 0;\n    let maxColCount2\
    \ = 0;\n    let maxRowCount3 = 0;\n    let maxColCount3 = 0;\n    let maxRowCount4\
    \ = 0;\n    let maxColCount4 = 0;\n    let maxRowCount5 = 0;\n    let maxColCount5\
    \ = 0;\n    let maxRowCount6 = 0;\n    let maxColCount6 = 0;\n    let maxRowCount7\
    \ = 0;\n    let maxColCount7 = 0;\n    let maxRowCount8 = 0;\n    let maxColCount8\
    \ = 0;\n    let maxRowCount9 = 0;\n    let maxColCount9 = 0;\n    let maxRowCount10\
    \ = 0;\n    let maxColCount10 = 0;\n    let maxRowCount11 = 0;\n    let maxColCount11\
    \ = 0;\n    let maxRowCount12 = 0;\n    let maxColCount12 = 0;\n    let maxRowCount13\
    \ = 0;\n    let maxColCount13 = 0;\n    let maxRowCount14 = 0;\n    let maxColCount14\
    \ = 0;\n    let maxRowCount15 = 0;\n    let maxColCount15 = 0;\n    let maxRowCount16\
    \ = 0;\n    let maxColCount16 = 0;\n    let maxRowCount17 = 0;\n    let maxColCount17\
    \ = 0;\n    let maxRowCount18 = 0;\n    let maxColCount18 = 0;\n    let maxRowCount19\
    \ = 0;\n    let maxColCount19 = 0;\n    let maxRowCount20 = 0;\n    let maxColCount20\
    \ = 0;\n    let maxRowCount21 = 0;\n    let maxColCount21 = 0;\n    let maxRowCount22\
    \ = 0;\n    let maxColCount22 = 0;\n    let maxRowCount23 = 0;\n    let maxColCount23\
    \ = 0;\n    let maxRowCount24 = 0;", "    let count = 0;\n    for (let i = 0;\
    \ i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (grid[i][j] === 1) {\n                count += capacity;\n   \
    \             grid[i][j] = 0;\n            }\n        }\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let wells = grid.length;\n\
    \    let wellLength = grid[0].length;\n    let buckets = [];\n    for (let i =\
    \ 0; i < wells; i++) {\n        buckets.push(capacity);\n    }\n    for (let i\
    \ = 0; i < wellLength; i++) {\n        for (let j = 0; j < wells; j++) {\n   \
    \         if (grid[j][i] === 1) {\n                if (buckets[j] > 0) {\n   \
    \                 buckets[j]--;\n                } else {\n                  \
    \  count++;\n                }\n            }\n        }\n    }\n    return count;\n\
    }\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] ===\
    \ 1) {\n                grid[i][j] = 0;\n                count++;\n          \
    \      let bucket = capacity;\n                while (bucket > 0) {\n        \
    \            if (i - 1 >= 0 && grid[i - 1][j] === 1) {\n                     \
    \   grid[i - 1][j] = 0;\n                        bucket--;\n                 \
    \   }\n                    if (i + 1 < grid.length && grid[i + 1][j] === 1) {\n\
    \                        grid[i + 1][j] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j - 1 >= 0 && grid[i][j - 1] ===\
    \ 1) {\n                        grid[i][j - 1] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j + 1 < grid[i].length && grid[i][j\
    \ + 1] === 1) {\n                        grid[i][j + 1] = 0;\n               \
    \         bucket--;\n                    }\n                }\n            }\n\
    \        }\n    }\n    return count;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                grid[i][j] = 0;\n\
    \                count++;\n                if (i > 0) {\n                    grid[i\
    \ - 1][j] = 0;\n                }\n                if (i < grid.length - 1) {\n\
    \                    grid[i + 1][j] = 0;\n                }\n                if\
    \ (j > 0) {\n                    grid[i][j - 1] = 0;\n                }\n    \
    \            if (j < grid[i].length - 1) {\n                    grid[i][j + 1]\
    \ = 0;\n                }\n            }\n        }\n    }\n    return count;\n\
    }\n", "    let max_fill = 0;\n    let row_count = grid.length;\n    let col_count\
    \ = grid[0].length;\n    let row_sum = [];\n    let col_sum = [];\n    let row_max\
    \ = 0;\n    let col_max = 0;\n    for (let i = 0; i < row_count; i++) {\n    \
    \    let row_sum_val = 0;\n        for (let j = 0; j < col_count; j++) {\n   \
    \         row_sum_val += grid[i][j];\n        }\n        row_sum.push(row_sum_val);\n\
    \        row_max = Math.max(row_max, row_sum_val);\n    }\n    for (let i = 0;\
    \ i < col_count; i++) {\n        let col_sum_val = 0;\n        for (let j = 0;\
    \ j < row_count; j++) {\n            col_sum_val += grid[j][i];\n        }\n \
    \       col_sum.push(col_sum_val);\n        col_max = Math.max(col_max, col_sum_val);\n\
    \    }\n    let row_max_count = 0;\n    let col_max_count = 0;\n    for (let i\
    \ = 0; i < row_count; i++) {\n        if (row_sum[i] == row_max) {\n         \
    \   row_max_count++;\n        }\n    }\n    for (let i = 0; i < col_count; i++)\
    \ {\n        if (col_sum[i] == col_max) {\n            col_max_count++;\n    \
    \    }\n    }\n    let row_max_fill = row_max_count * capacity;\n    let col_max_fill\
    \ = col_max_count * capacity;\n    max_fill = Math.max(row_max_fill, col_max_fill);\n\
    \    return max_fill;\n}\n", "    let count = 0;\n    let row = grid.length;\n\
    \    let col = grid[0].length;\n    let max = 0;\n    for (let i = 0; i < row;\
    \ i++) {\n        for (let j = 0; j < col; j++) {\n            if (grid[i][j]\
    \ == 1) {\n                max = Math.max(max, j);\n            }\n        }\n\
    \    }\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col;\
    \ j++) {\n            if (grid[i][j] == 1) {\n                if (j == max) {\n\
    \                    count += capacity;\n                } else {\n          \
    \          count += 1;\n                }\n            }\n        }\n    }\n \
    \   return count;\n}\n", "    let count = 0;\n    let max = 0;\n    let max_index\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n            \
    \    count++;\n            }\n        }\n        if (count > max) {\n        \
    \    max = count;\n            max_index = i;\n        }\n        count = 0;\n\
    \    }\n    return max * capacity;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0,\
    \ 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
    \ 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                grid[i][j] = 0;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                grid[i][j] = 0;\n            }\n        }\n    }\n    return\
    \ count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "    let count\
    \ = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n    let max_row\
    \ = 0;\n    let max_col = 0;\n    let max_row_count = 0;\n    let max_col_count\
    \ = 0;\n    for (let i = 0; i < row; i++) {\n        let row_count = 0;\n    \
    \    for (let j = 0; j < col; j++) {\n            if (grid[i][j] == 1) {\n   \
    \             row_count++;\n            }\n        }\n        if (row_count >\
    \ max_row_count) {\n            max_row_count = row_count;\n            max_row\
    \ = i;\n        }\n    }\n    for (let i = 0; i < col; i++) {\n        let col_count\
    \ = 0;\n        for (let j = 0; j < row; j++) {\n            if (grid[j][i] ==\
    \ 1) {\n                col_count++;\n            }\n        }\n        if (col_count\
    \ > max_col_count) {\n            max_col_count = col_count;\n            max_col\
    \ = i;\n        }\n    }\n    if (max_row_count > max_col_count) {\n        count\
    \ = max_row_count;\n        for (let i = 0; i < col; i++) {\n            if (grid[max_row][i]\
    \ == 1) {\n                grid[max_row][i] = 0;\n            }\n        }\n \
    \   } else {\n        count = max_col_count;\n        for (let i = 0; i < row;\
    \ i++) {\n            if (grid[i][max_col] == 1) {\n                grid[i][max_col]\
    \ = 0;\n            }\n        }\n    }\n    return count;\n}\n", "    let count\
    \ = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n      \
    \  max = Math.max(...grid[i]);\n        count += max;\n        for (let j = 0;\
    \ j < grid[i].length; j++) {\n            grid[i][j] -= max;\n        }\n    }\n\
    \    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
    \ = grid[i];\n        let row_sum = row.reduce((a, b) => a + b, 0);\n        if\
    \ (row_sum > capacity) {\n            result += capacity;\n        } else {\n\
    \            result += row_sum;\n        }\n    }\n    return result;\n}\n", " \
    \   let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count++;\n            }\n        }\n        if (count\
    \ > max) {\n            max = count;\n        }\n        count = 0;\n    }\n \
    \   return max * capacity;\n}\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "    // TODO: implement\n    return 0;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let rowCount\
    \ = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j]\
    \ === 1) {\n                rowCount += 1;\n            }\n        }\n       \
    \ if (rowCount > 0) {\n            count += Math.ceil(rowCount / capacity);\n\
    \        }\n    }\n    return count;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                grid[i][j] = 0;\n\
    \                count++;\n                for (let k = 0; k < capacity; k++)\
    \ {\n                    if (grid[i + k] && grid[i + k][j] === 1) {\n        \
    \                grid[i + k][j] = 0;\n                        count++;\n     \
    \               }\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                grid[i][j] = 0;\n                count++;\n      \
    \          let k = i;\n                while (k < grid.length && capacity > 0)\
    \ {\n                    if (grid[k][j] === 1) {\n                        grid[k][j]\
    \ = 0;\n                        capacity--;\n                    }\n         \
    \           k++;\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b) => a\
    \ + b, 0);\n        if (row_sum > 0) {\n            count += Math.ceil(row_sum\
    \ / capacity);\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    let row = grid.length;\n    let col = grid[0].length;\n    let bucket = capacity;\n\
    \    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n\
    \            if (grid[i][j] === 1) {\n                count++;\n             \
    \   bucket--;\n                if (bucket === 0) {\n                    bucket\
    \ = capacity;\n                    count++;\n                }\n            }\n\
    \        }\n    }\n    return count;\n}\nconsole.log(max_fill([[0, 0, 1, 0], [0,\
    \ 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
    \ 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        let bucket = capacity;\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                if (bucket > 0)\
    \ {\n                    bucket--;\n                    grid[i][j] = 0;\n    \
    \            } else {\n                    count++;\n                    bucket\
    \ = capacity - 1;\n                    grid[i][j] = 0;\n                }\n  \
    \          }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count++;\n    \
    \            grid[i][j] = 0;\n                let temp = capacity;\n         \
    \       while (temp > 0) {\n                    if (i - 1 >= 0 && grid[i - 1][j]\
    \ === 1) {\n                        grid[i - 1][j] = 0;\n                    \
    \    temp--;\n                    }\n                    if (i + 1 < grid.length\
    \ && grid[i + 1][j] === 1) {\n                        grid[i + 1][j] = 0;\n  \
    \                      temp--;\n                    }\n                    if\
    \ (j - 1 >= 0 && grid[i][j - 1] === 1) {\n                        grid[i][j -\
    \ 1] = 0;\n                        temp--;\n                    }\n          \
    \          if (j + 1 < grid[i].length && grid[i][j + 1] === 1) {\n           \
    \             grid[i][j + 1] = 0;\n                        temp--;\n         \
    \           }\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    let max = 0;\n    let max_index = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count++;\n    \
    \        }\n        }\n        if (count > max) {\n            max = count;\n\
    \            max_index = i;\n        }\n        count = 0;\n    }\n    return\
    \ max * capacity;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                grid[i][j] = 0;\n                count++;\n      \
    \          let bucket = capacity;\n                while (bucket > 0) {\n    \
    \                if (i - 1 >= 0 && grid[i - 1][j] === 1) {\n                 \
    \       grid[i - 1][j] = 0;\n                        bucket--;\n             \
    \       }\n                    if (i + 1 < grid.length && grid[i + 1][j] === 1)\
    \ {\n                        grid[i + 1][j] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j - 1 >= 0 && grid[i][j - 1] ===\
    \ 1) {\n                        grid[i][j - 1] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j + 1 < grid[i].length && grid[i][j\
    \ + 1] === 1) {\n                        grid[i][j + 1] = 0;\n               \
    \         bucket--;\n                    }\n                }\n            }\n\
    \        }\n    }\n    return count;\n}\n", "    let count = 0;\n    let max =\
    \ 0;\n    let max_row = 0;\n    let max_col = 0;\n    let max_row_count = 0;\n\
    \    let max_col_count = 0;\n    for (let i = 0; i < grid.length; i++) {\n   \
    \     for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] ===\
    \ 1) {\n                count++;\n            }\n        }\n        if (count\
    \ > max) {\n            max = count;\n            max_row = i;\n            max_row_count\
    \ = count;\n        }\n        count = 0;\n    }\n    for (let i = 0; i < grid[0].length;\
    \ i++) {\n        for (let j = 0; j < grid.length; j++) {\n            if (grid[j][i]\
    \ === 1) {\n                count++;\n            }\n        }\n        if (count\
    \ > max) {\n            max = count;\n            max_col = i;\n            max_col_count\
    \ = count;\n        }\n        count = 0;\n    }\n    if (max_row_count > max_col_count)\
    \ {\n        return max_row_count * capacity;\n    } else {\n        return max_col_count\
    \ * capacity;\n    }\n}\n", "    let count = 0;\n    let max = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count++;\n    \
    \        }\n        }\n        if (count > max) {\n            max = count;\n\
    \        }\n        count = 0;\n    }\n    return max * capacity;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        for (let j = 0; j < row.length;\
    \ j++) {\n            if (row[j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                grid[i][j] = 0;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let row = grid.length;\n\
    \    let col = grid[0].length;\n    let wells = [];\n    for (let i = 0; i < row;\
    \ i++) {\n        wells.push([]);\n        for (let j = 0; j < col; j++) {\n \
    \           wells[i].push(0);\n        }\n    }\n    for (let i = 0; i < row;\
    \ i++) {\n        for (let j = 0; j < col; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                wells[i][j] = capacity;\n                count++;\n\
    \            }\n        }\n    }\n    while (count > 0) {\n        count = 0;\n\
    \        for (let i = 0; i < row; i++) {\n            for (let j = 0; j < col;\
    \ j++) {\n                if (wells[i][j] > 0) {\n                    if (i >\
    \ 0 && wells[i - 1][j] < capacity) {\n                        wells[i - 1][j]++;\n\
    \                        wells[i][j]--;\n                        count++;\n  \
    \                  }\n                    if (i < row - 1 && wells[i + 1][j] <\
    \ capacity) {\n                        wells[i + 1][j]++;\n                  \
    \      wells[i][j]--;\n                        count++;\n                    }\n\
    \                    if (j > 0 && wells[i][j - 1] < capacity) {\n            \
    \            wells[i][j - 1]++;\n                        wells[i][j]--;\n    \
    \                    count++;\n                    }\n                    if (j\
    \ < col - 1 && wells[i][j + 1] < capacity) {\n                        wells[i][j\
    \ + 1]++;\n                        wells[i][j]--;\n                        count++;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return wells;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let rowSum = row.reduce((a, b) =>\
    \ a + b, 0);\n        if (rowSum > capacity) {\n            count += rowSum -\
    \ capacity;\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n   \
    \     let row_count = 0;\n        for (let j = 0; j < row.length; j++) {\n   \
    \         if (row[j] === 1) {\n                row_count++;\n            }\n \
    \       }\n        if (row_count > 0) {\n            count += Math.ceil(row_count\
    \ / capacity);\n        }\n    }\n    return count;\n}\n", "    let total = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n   \
    \     let row_total = 0;\n        for (let j = 0; j < row.length; j++) {\n   \
    \         let cell = row[j];\n            if (cell === 1) {\n                row_total++;\n\
    \            }\n        }\n        total += Math.ceil(row_total / capacity);\n\
    \    }\n    return total;\n}\n", "    let count = 0;\n    for (let i = 0; i <\
    \ grid.length; i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((a,\
    \ b) => a + b, 0);\n        if (row_sum > 0) {\n            count += Math.ceil(row_sum\
    \ / capacity);\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                grid[i][j] = 0;\n            }\n        }\n    }\n    return\
    \ count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "    let count\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let row_sum = row.reduce((a, b) => a + b, 0);\n        if (row_sum >\
    \ 0) {\n            count += Math.ceil(row_sum / capacity);\n        }\n    }\n\
    \    return count;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                grid[i][j] = 0;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let max_row = 0;\n    let\
    \ max_col = 0;\n    let max_row_index = 0;\n    let max_col_index = 0;\n    let\
    \ max_row_count = 0;\n    let max_col_count = 0;\n    let max_row_sum = 0;\n \
    \   let max_col_sum = 0;\n    let max_row_sum_index = 0;\n    let max_col_sum_index\
    \ = 0;\n    let max_row_sum_count = 0;\n    let max_col_sum_count = 0;\n    let\
    \ max_row_sum_total = 0;\n    let max_col_sum_total = 0;\n    let max_row_sum_total_index\
    \ = 0;\n    let max_col_sum_total_index = 0;\n    let max_row_sum_total_count\
    \ = 0;\n    let max_col_sum_total_count = 0;\n    let max_row_sum_total_total\
    \ = 0;\n    let max_col_sum_total_total = 0;\n    let max_row_sum_total_total_index\
    \ = 0;\n    let max_col_sum_total_total_index = 0;\n    let max_row_sum_total_total_count\
    \ = 0;\n    let max_col_sum_total_total_count = 0;\n    let max_row_sum_total_total_total\
    \ = 0;\n    let max_col_sum_total_total_total = 0;\n    let max_row_sum_total_total_total_index\
    \ = 0;\n    let max_col_sum_total_total_total_index = 0;\n    let max_row_sum_total_total_total_count\
    \ = 0;\n    let max_col_sum_total_total_total_count = 0;\n    let max_row_sum_total_total_total_total\
    \ = 0;\n    let max_col_sum_total_total_total_total = 0;\n    let max_row_sum_total_total_total_total_index\
    \ = 0;\n    let max_col_sum_total_total_total_total", "    let count = 0;\n  \
    \  for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                grid[i][j] = 0;\n            }\n        }\n    }\n    return\
    \ count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "    let count\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n            \
    \    count += capacity;\n                grid[i][j] = 0;\n            }\n    \
    \    }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0,\
    \ 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
    \ 0, 0]], 5));", "    let count = 0;\n    let max = 0;\n    let min = 0;\n   \
    \ let sum = 0;\n    let max_index = 0;\n    let min_index = 0;\n    let sum_index\
    \ = 0;\n    let max_index_arr = [];\n    let min_index_arr = [];\n    let sum_index_arr\
    \ = [];\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0;\
    \ j < grid[i].length; j++) {\n            if (grid[i][j] == 1) {\n           \
    \     max++;\n            }\n        }\n        max_index_arr.push(max);\n   \
    \     max = 0;\n    }\n    for (let i = 0; i < grid.length; i++) {\n        for\
    \ (let j = 0; j < grid[i].length; j++) {\n            if (grid[j][i] == 1) {\n\
    \                min++;\n            }\n        }\n        min_index_arr.push(min);\n\
    \        min = 0;\n    }\n    for (let i = 0; i < grid.length; i++) {\n      \
    \  for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] == 1)\
    \ {\n                sum++;\n            }\n        }\n        sum_index_arr.push(sum);\n\
    \        sum = 0;\n    }\n    for (let i = 0; i < max_index_arr.length; i++) {\n\
    \        if (max_index_arr[i] > max_index) {\n            max_index = max_index_arr[i];\n\
    \        }\n    }\n    for (let i = 0; i < min_index_arr.length; i++) {\n    \
    \    if (min_index_arr[i] > min_index) {\n            min_index = min_index_arr[i];\n\
    \        }\n    }\n    for (let i = 0; i < sum_index_arr.length; i++) {\n    \
    \    if (sum_index_arr[i] > sum_index) {\n            sum_index = sum_index_arr[i];\n\
    \        }\n", "    let total = 0;\n    let rows = grid.length;\n    let cols\
    \ = grid[0].length;\n    let buckets = [];\n    for (let i = 0; i < rows; i++)\
    \ {\n        buckets.push(0);\n    }\n    for (let i = 0; i < cols; i++) {\n \
    \       for (let j = 0; j < rows; j++) {\n            if (grid[j][i] === 1) {\n\
    \                buckets[j]++;\n            }\n        }\n        buckets.sort((a,\
    \ b) => a - b);\n        let min = buckets[0];\n        let max = buckets[rows\
    \ - 1];\n        if (max - min > capacity) {\n            total += max - min -\
    \ capacity;\n            buckets[rows - 1] = min + capacity;\n        }\n    }\n\
    \    return total;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let row_count = 0;\n        for\
    \ (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n      \
    \          row_count += 1;\n            }\n        }\n        if (row_count >\
    \ 0) {\n            count += Math.ceil(row_count / capacity);\n        }\n   \
    \ }\n    return count;\n}\n", "    let count = 0;\n    let row = grid.length;\n\
    \    let col = grid[0].length;\n    let wells = [];\n    let buckets = [];\n \
    \   for (let i = 0; i < row; i++) {\n        wells.push([]);\n        buckets.push([]);\n\
    \        for (let j = 0; j < col; j++) {\n            wells[i].push(grid[i][j]);\n\
    \            buckets[i].push(0);\n        }\n    }\n    for (let i = 0; i < row;\
    \ i++) {\n        for (let j = 0; j < col; j++) {\n            if (wells[i][j]\
    \ === 1) {\n                if (buckets[i][j] < capacity) {\n                \
    \    buckets[i][j]++;\n                    count++;\n                }\n     \
    \           if (i + 1 < row && buckets[i + 1][j] < capacity) {\n             \
    \       buckets[i + 1][j]++;\n                    count++;\n                }\n\
    \                if (j + 1 < col && buckets[i][j + 1] < capacity) {\n        \
    \            buckets[i][j + 1]++;\n                    count++;\n            \
    \    }\n            }\n        }\n    }\n    return count;\n}\n", "    let result\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let row_sum = row.reduce((a, b) => a + b, 0);\n        let row_max =\
    \ Math.max(...row);\n        if (row_sum > capacity) {\n            result +=\
    \ row_max;\n        } else {\n            result += row_sum;\n        }\n    }\n\
    \    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             grid[i][j] = 0;\n                count++;\n                for (let\
    \ k = i + 1; k < grid.length; k++) {\n                    if (grid[k][j] === 1)\
    \ {\n                        grid[k][j] = 0;\n                        count++;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "    let total_water = 0;\n    let total_buckets = 0;\n    let row_length = grid[0].length;\n\
    \    let row_count = grid.length;\n    for (let i = 0; i < row_count; i++) {\n\
    \        let row = grid[i];\n        let row_water = row.reduce((a, b) => a +\
    \ b, 0);\n        total_water += row_water;\n        total_buckets += Math.ceil(row_water\
    \ / capacity);\n    }\n    return total_buckets;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                grid[i][j] = 0;\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "    // your code here\n    let count = 0;\n    for (let i = 0;\
    \ i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (grid[i][j] === 1) {\n                count += capacity;\n   \
    \             grid[i][j] = 0;\n            }\n        }\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                for (let k = i;\
    \ k < grid.length; k++) {\n                    if (grid[k][j] === 1) {\n     \
    \                   grid[k][j] = 0;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             count++;\n            }\n        }\n        if (count > max) {\n\
    \            max = count;\n        }\n        count = 0;\n    }\n    return max\
    \ * capacity;\n}\n", "    let result = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                result += capacity;\n                grid[i][j] =\
    \ 0;\n            }\n        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let row_count = 0;\n        for\
    \ (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n      \
    \          row_count += 1;\n            }\n        }\n        count += Math.ceil(row_count\
    \ / capacity);\n    }\n    return count;\n}\n", "    let max_fill = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                max_fill += capacity;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\n", "    let count =\
    \ 0;\n    let row = grid.length;\n    let col = grid[0].length;\n    let wells\
    \ = [];\n    for (let i = 0; i < row; i++) {\n        wells.push([]);\n      \
    \  for (let j = 0; j < col; j++) {\n            wells[i].push(0);\n        }\n\
    \    }\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                wells[i][j] = capacity;\n\
    \                count++;\n            }\n        }\n    }\n    for (let i = 0;\
    \ i < row; i++) {\n        for (let j = 0; j < col; j++) {\n            if (wells[i][j]\
    \ > 0) {\n                if (i - 1 >= 0 && wells[i - 1][j] === 0) {\n       \
    \             wells[i - 1][j] = wells[i][j] - 1;\n                    wells[i][j]\
    \ = 1;\n                    count++;\n                }\n                if (i\
    \ + 1 < row && wells[i + 1][j] === 0) {\n                    wells[i + 1][j] =\
    \ wells[i][j] - 1;\n                    wells[i][j] = 1;\n                   \
    \ count++;\n                }\n                if (j - 1 >= 0 && wells[i][j -\
    \ 1] === 0) {\n                    wells[i][j - 1] = wells[i][j] - 1;\n      \
    \              wells[i][j] = 1;\n                    count++;\n              \
    \  }\n                if (j + 1 < col && wells[i][j + 1] === 0) {\n          \
    \          wells[i][j + 1] = wells[i][j] - 1;\n                    wells[i][j]\
    \ = 1;\n                    count++;\n                }\n            }\n     \
    \   }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0,\
    \ 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[", "  let count = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j] = 0;\n        count++;\n\
    \        for (let k = 0; k < capacity; k++) {\n          if (grid[i + k] && grid[i\
    \ + k][j] === 1) {\n            grid[i + k][j] = 0;\n            count++;\n  \
    \        }\n        }\n      }\n    }\n  }\n  return count;\n}\n", "    let count\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n            \
    \    count += capacity;\n                for (let k = i + 1; k < grid.length;\
    \ k++) {\n                    if (grid[k][j] === 1) {\n                      \
    \  count += capacity;\n                    } else {\n                        break;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "    let count = 0;\n    let wells = grid.length;\n    let length = grid[0].length;\n\
    \    let buckets = new Array(wells).fill(0);\n    let buckets_capacity = new Array(wells).fill(capacity);\n\
    \    let buckets_filled = new Array(wells).fill(false);\n    let buckets_filled_count\
    \ = 0;\n    while (true) {\n        for (let i = 0; i < wells; i++) {\n      \
    \      if (buckets_filled[i]) {\n                continue;\n            }\n  \
    \          for (let j = 0; j < length; j++) {\n                if (grid[i][j]\
    \ === 1) {\n                    buckets[i]++;\n                    if (buckets[i]\
    \ === buckets_capacity[i]) {\n                        buckets_filled[i] = true;\n\
    \                        buckets_filled_count++;\n                    }\n    \
    \            }\n            }\n        }\n        if (buckets_filled_count ===\
    \ wells) {\n            break;\n        }\n        count++;\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    let row = grid.length;\n    let col =\
    \ grid[0].length;\n    for (let i = 0; i < row; i++) {\n        for (let j = 0;\
    \ j < col; j++) {\n            if (grid[i][j] == 1) {\n                count++;\n\
    \                grid[i][j] = 0;\n                if (i - 1 >= 0 && grid[i - 1][j]\
    \ == 1) {\n                    grid[i - 1][j] = 0;\n                }\n      \
    \          if (i + 1 < row && grid[i + 1][j] == 1) {\n                    grid[i\
    \ + 1][j] = 0;\n                }\n                if (j - 1 >= 0 && grid[i][j\
    \ - 1] == 1) {\n                    grid[i][j - 1] = 0;\n                }\n \
    \               if (j + 1 < col && grid[i][j + 1] == 1) {\n                  \
    \  grid[i][j + 1] = 0;\n                }\n            }\n        }\n    }\n \
    \   return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             count += capacity;\n                grid[i][j] = 0;\n          \
    \  }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                for (let k = i + 1; k < grid.length; k++) {\n               \
    \     if (grid[k][j] === 1) {\n                        count += capacity;\n  \
    \                  } else {\n                        break;\n                \
    \    }\n                }\n            }\n        }\n    }\n    return count;\n\
    }\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] ===\
    \ 1) {\n                count += capacity;\n                grid[i][j] = 0;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let max = 0;\n    let max_index\
    \ = 0;\n    let max_row = 0;\n    let max_col = 0;\n    let max_fill = 0;\n  \
    \  let max_fill_index = 0;\n    let max_fill_row = 0;\n    let max_fill_col =\
    \ 0;\n    let max_fill_count = 0;\n    let max_fill_count_index = 0;\n    let\
    \ max_fill_count_row = 0;\n    let max_fill_count_col = 0;\n    let max_fill_count_fill\
    \ = 0;\n    let max_fill_count_fill_index = 0;\n    let max_fill_count_fill_row\
    \ = 0;\n    let max_fill_count_fill_col = 0;\n    let max_fill_count_fill_count\
    \ = 0;\n    let max_fill_count_fill_count_index = 0;\n    let max_fill_count_fill_count_row\
    \ = 0;\n    let max_fill_count_fill_count_col = 0;\n    let max_fill_count_fill_count_fill\
    \ = 0;\n    let max_fill_count_fill_count_fill_index = 0;\n    let max_fill_count_fill_count_fill_row\
    \ = 0;\n    let max_fill_count_fill_count_fill_col = 0;\n    let max_fill_count_fill_count_fill_count\
    \ = 0;\n    let max_fill_count_fill_count_fill_count_index = 0;\n    let max_fill_count_fill_count_fill_count_row\
    \ = 0;\n    let max_fill_count_fill_count_fill_count_col = 0;\n    let max_fill_count_fill_count_fill_count_fill\
    \ = 0;\n    let max_fill_count_fill_count_fill_count_fill_index = 0;\n    let\
    \ max_fill_count_fill_count_fill_count_fill_row = 0;\n    let max_fill_count_fill_count_fill_count_fill_col\
    \ = 0;\n    let max_fill_count_", "    let count = 0;\n    for (let i = 0; i <\
    \ grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n  \
    \          if (grid[i][j] === 1) {\n                grid[i][j] = 0;\n        \
    \        count++;\n                let k = i;\n                while (capacity\
    \ > 0 && k < grid.length) {\n                    if (grid[k][j] === 1) {\n   \
    \                     grid[k][j] = 0;\n                        capacity--;\n \
    \                   }\n                    k++;\n                }\n         \
    \   }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n    let\
    \ i = 0;\n    let j = 0;\n    let k = 0;\n    let l = 0;\n    let m = 0;\n   \
    \ let n = 0;\n    let o = 0;\n    let p = 0;\n    let q = 0;\n    let r = 0;\n\
    \    let s = 0;\n    let t = 0;\n    let u = 0;\n    let v = 0;\n    let w = 0;\n\
    \    let x = 0;\n    let y = 0;\n    let z = 0;\n    let aa = 0;\n    let bb =\
    \ 0;\n    let cc = 0;\n    let dd = 0;\n    let ee = 0;\n    let ff = 0;\n   \
    \ let gg = 0;\n    let hh = 0;\n    let ii = 0;\n    let jj = 0;\n    let kk =\
    \ 0;\n    let ll = 0;\n    let mm = 0;\n    let nn = 0;\n    let oo = 0;\n   \
    \ let pp = 0;\n    let qq = 0;\n    let rr = 0;\n    let ss = 0;\n    let tt =\
    \ 0;\n    let uu = 0;\n    let vv = 0;\n    let ww = 0;\n    let xx = 0;\n   \
    \ let yy = 0;\n    let zz = 0;\n    let aaa = 0;\n    let bbb = 0;\n    let ccc\
    \ = 0;\n    let ddd = 0;\n    let eee = 0;\n    let fff = 0;\n    let ggg = 0;\n\
    \    let hhh = 0;\n    let iii = 0;\n    let jjj = 0;\n    let kkk = 0;\n    let\
    \ lll = 0;\n    let mmm = 0;\n    let nnn = 0;\n    let ooo = 0;\n    let ppp\
    \ = 0;\n    let qqq = 0;\n    let rrr = 0;\n    let sss = 0;\n    let ttt = 0;\n\
    \    let uuu = 0;\n    let vvv = 0;\n    let www =", "    let count = 0;\n   \
    \ let row = grid.length;\n    let col = grid[0].length;\n    let row_sum = [];\n\
    \    let col_sum = [];\n    for (let i = 0; i < row; i++) {\n        row_sum.push(grid[i].reduce((a,\
    \ b) => a + b));\n    }\n    for (let i = 0; i < col; i++) {\n        let sum\
    \ = 0;\n        for (let j = 0; j < row; j++) {\n            sum += grid[j][i];\n\
    \        }\n        col_sum.push(sum);\n    }\n    for (let i = 0; i < row; i++)\
    \ {\n        for (let j = 0; j < col; j++) {\n            if (grid[i][j] === 1)\
    \ {\n                count += Math.min(row_sum[i], col_sum[j]);\n            }\n\
    \        }\n    }\n    return count * capacity;\n}\n", "    let count = 0;\n \
    \   for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                grid[i][j] = 0;\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "    let max_fill = 0;\n    let rows = grid.length;\n    let cols\
    \ = grid[0].length;\n    let buckets = [];\n    for (let i = 0; i < rows; i++)\
    \ {\n        buckets.push(0);\n    }\n    for (let i = 0; i < cols; i++) {\n \
    \       for (let j = 0; j < rows; j++) {\n            if (grid[j][i] === 1) {\n\
    \                buckets[j]++;\n            }\n        }\n        let max_bucket\
    \ = Math.max(...buckets);\n        if (max_bucket > capacity) {\n            max_fill\
    \ += max_bucket - capacity;\n            for (let j = 0; j < rows; j++) {\n  \
    \              buckets[j] = buckets[j] - (max_bucket - capacity);\n          \
    \  }\n        }\n    }\n    return max_fill;\n}\n", "    let count = 0;\n    let\
    \ row = grid.length;\n    let col = grid[0].length;\n    let max = 0;\n    for\
    \ (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n     \
    \       if (grid[i][j] === 1) {\n                count++;\n            }\n   \
    \     }\n        if (count > max) {\n            max = count;\n        }\n   \
    \     count = 0;\n    }\n    return max * capacity;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                for (let k = i + 1; k < grid.length; k++) {\n               \
    \     if (grid[k][j] === 1) {\n                        count += capacity;\n  \
    \                  } else {\n                        break;\n                \
    \    }\n                }\n            }\n        }\n    }\n    return count;\n\
    }\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] ===\
    \ 1) {\n                grid[i][j] = 0;\n                count++;\n          \
    \      let bucket = capacity;\n                while (bucket > 0) {\n        \
    \            if (i - 1 >= 0 && grid[i - 1][j] === 1) {\n                     \
    \   grid[i - 1][j] = 0;\n                        bucket--;\n                 \
    \   }\n                    if (i + 1 < grid.length && grid[i + 1][j] === 1) {\n\
    \                        grid[i + 1][j] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j - 1 >= 0 && grid[i][j - 1] ===\
    \ 1) {\n                        grid[i][j - 1] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j + 1 < grid[i].length && grid[i][j\
    \ + 1] === 1) {\n                        grid[i][j + 1] = 0;\n               \
    \         bucket--;\n                    }\n                }\n            }\n\
    \        }\n    }\n    return count;\n}\n", "    let count = 0;\n    let bucket\
    \ = capacity;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j\
    \ = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
    \           if (bucket > 0) {\n                    bucket--;\n               \
    \     grid[i][j] = 0;\n                } else {\n                    bucket =\
    \ capacity;\n                    count++;\n                    j--;\n        \
    \        }\n            }\n        }\n    }\n    return count;\n}\n", "    let\
    \ count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j\
    \ = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
    \           count++;\n                grid[i][j] = 0;\n                let k =\
    \ i;\n                while (k < grid.length && capacity > 0) {\n            \
    \        if (grid[k][j] === 1) {\n                        grid[k][j] = 0;\n  \
    \                      capacity--;\n                    }\n                  \
    \  k++;\n                }\n                capacity = capacity + 1;\n       \
    \     }\n        }\n    }\n    return count;\n}\n", "    let max_fill = 0;\n \
    \   for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                max_fill += capacity;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\n", "    let count =\
    \ 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j <\
    \ grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n              \
    \  count += capacity;\n                grid[i][j] = 0;\n            }\n      \
    \  }\n    }\n    return count;\n}\n", "    let count = 0;\n    for (let i = 0;\
    \ i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (grid[i][j] == 1) {\n                count += capacity;\n    \
    \            if (i > 0) {\n                    grid[i - 1][j] = 1;\n         \
    \       }\n                if (i < grid.length - 1) {\n                    grid[i\
    \ + 1][j] = 1;\n                }\n                if (j > 0) {\n            \
    \        grid[i][j - 1] = 1;\n                }\n                if (j < grid[i].length\
    \ - 1) {\n                    grid[i][j + 1] = 1;\n                }\n       \
    \     }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n    let\
    \ row = grid.length;\n    let col = grid[0].length;\n    let max = 0;\n    for\
    \ (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n     \
    \       if (grid[i][j] === 1) {\n                max = Math.max(max, j);\n   \
    \         }\n        }\n    }\n    for (let i = 0; i < row; i++) {\n        for\
    \ (let j = 0; j < col; j++) {\n            if (grid[i][j] === 1) {\n         \
    \       count += capacity;\n            }\n            if (j === max) {\n    \
    \            count += capacity;\n            }\n        }\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let max = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count++;\n    \
    \        }\n        }\n        if (count > max) {\n            max = count;\n\
    \        }\n        count = 0;\n    }\n    return max * capacity;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                grid[i][j] = 0;\n                count++;\n      \
    \          let bucket = capacity;\n                while (bucket > 0) {\n    \
    \                if (i + 1 < grid.length && grid[i + 1][j] === 1) {\n        \
    \                grid[i + 1][j] = 0;\n                        bucket--;\n    \
    \                }\n                    if (i - 1 >= 0 && grid[i - 1][j] === 1)\
    \ {\n                        grid[i - 1][j] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j + 1 < grid[i].length && grid[i][j\
    \ + 1] === 1) {\n                        grid[i][j + 1] = 0;\n               \
    \         bucket--;\n                    }\n                    if (j - 1 >= 0\
    \ && grid[i][j - 1] === 1) {\n                        grid[i][j - 1] = 0;\n  \
    \                      bucket--;\n                    }\n                }\n \
    \           }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                grid[i][j] = 0;\n            }\n        }\n    }\n    return\
    \ count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "    let count\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n            \
    \    count += capacity;\n                grid[i][j] = 0;\n            }\n    \
    \    }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0,\
    \ 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
    \ 0, 0]], 5));", "    // your code here\n    let count = 0;\n    let max = 0;\n\
    \    let max_index = 0;\n    for (let i = 0; i < grid.length; i++) {\n       \
    \ for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] == 1)\
    \ {\n                count++;\n            }\n        }\n        if (count > max)\
    \ {\n            max = count;\n            max_index = i;\n        }\n       \
    \ count = 0;\n    }\n    let max_count = 0;\n    for (let i = 0; i < grid[max_index].length;\
    \ i++) {\n        if (grid[max_index][i] == 1) {\n            max_count++;\n \
    \       }\n    }\n    return max_count * capacity;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                grid[i][j] = 0;\n                count++;\n      \
    \          let bucket = capacity;\n                while (bucket > 0) {\n    \
    \                if (i - 1 >= 0 && grid[i - 1][j] === 1) {\n                 \
    \       grid[i - 1][j] = 0;\n                        bucket--;\n             \
    \       }\n                    if (i + 1 < grid.length && grid[i + 1][j] === 1)\
    \ {\n                        grid[i + 1][j] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j - 1 >= 0 && grid[i][j - 1] ===\
    \ 1) {\n                        grid[i][j - 1] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j + 1 < grid[i].length && grid[i][j\
    \ + 1] === 1) {\n                        grid[i][j + 1] = 0;\n               \
    \         bucket--;\n                    }\n                }\n            }\n\
    \        }\n    }\n    return count;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum\
    \ = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n\
    \        }\n        if (sum > capacity) {\n            count += sum - capacity;\n\
    \        }\n    }\n    return count;\n}\n", "    let count = 0;\n    let max =\
    \ 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j <\
    \ grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n              \
    \  count++;\n            }\n        }\n        if (count > max) {\n          \
    \  max = count;\n        }\n        count = 0;\n    }\n    return max * capacity;\n\
    }\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   let row = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length;\
    \ j++) {\n            sum += row[j];\n        }\n        if (sum > capacity) {\n\
    \            count += sum - capacity;\n        }\n    }\n    return count;\n}\n",
  "    let times = 0;\n    let wells = grid.length;\n    let well_length = grid[0].length;\n\
    \    let bucket = capacity;\n    for (let i = 0; i < wells; i++) {\n        for\
    \ (let j = 0; j < well_length; j++) {\n            if (grid[i][j] === 1) {\n \
    \               if (bucket > 0) {\n                    bucket--;\n           \
    \         grid[i][j] = 0;\n                } else {\n                    bucket\
    \ = capacity;\n                    times++;\n                    bucket--;\n \
    \                   grid[i][j] = 0;\n                }\n            }\n      \
    \  }\n    }\n    return times;\n}\n", "    let count = 0;\n    for (let i = 0;\
    \ i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (grid[i][j] === 1) {\n                grid[i][j] = 0;\n      \
    \          count++;\n                if (i + 1 < grid.length) {\n            \
    \        grid[i + 1][j] = 1;\n                }\n            }\n        }\n  \
    \  }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             count += capacity;\n                grid[i][j] = 0;\n          \
    \  }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1,\
    \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0,\
    \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0],\
    \ [0, 0, 0]], 5));", "    let max_fill = 0;\n    let row_count = grid.length;\n\
    \    let col_count = grid[0].length;\n    let row_index = 0;\n    let col_index\
    \ = 0;\n    let row_sum = 0;\n    let col_sum = 0;\n    let row_max = 0;\n   \
    \ let col_max = 0;\n    let row_max_index = 0;\n    let col_max_index = 0;\n \
    \   let row_max_count = 0;\n    let col_max_count = 0;\n    let row_max_sum =\
    \ 0;\n    let col_max_sum = 0;\n    let row_max_sum_index = 0;\n    let col_max_sum_index\
    \ = 0;\n    let row_max_sum_count = 0;\n    let col_max_sum_count = 0;\n    let\
    \ row_max_sum_count_index = 0;\n    let col_max_sum_count_index = 0;\n    let\
    \ row_max_sum_count_index_count = 0;\n    let col_max_sum_count_index_count =\
    \ 0;\n    let row_max_sum_count_index_count_index = 0;\n    let col_max_sum_count_index_count_index\
    \ = 0;\n    let row_max_sum_count_index_count_index_count = 0;\n    let col_max_sum_count_index_count_index_count\
    \ = 0;\n    let row_max_sum_count_index_count_index_count_index = 0;\n    let\
    \ col_max_sum_count_index_count_index_count_index = 0;\n    let row_max_sum_count_index_count_index_count_index_count\
    \ = 0;\n    let col_max_sum_count_index_count_index_count_index_count = 0;\n \
    \   let row_max_sum_count_index_count_index_count_index_count_index = 0;\n   \
    \ let col_max_sum_count_index_count_index_count_index_count_index = 0;\n    let\
    \ row_max_sum_count_index_", "    let count = 0;\n    let max = 0;\n    let maxIndex\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let sum = 0;\n  \
    \      for (let j = 0; j < grid[i].length; j++) {\n            sum += grid[i][j];\n\
    \        }\n        if (sum > max) {\n            max = sum;\n            maxIndex\
    \ = i;\n        }\n    }\n    for (let i = 0; i < grid.length; i++) {\n      \
    \  let sum = 0;\n        for (let j = 0; j < grid[i].length; j++) {\n        \
    \    sum += grid[i][j];\n        }\n        if (i !== maxIndex) {\n          \
    \  count += sum;\n        }\n    }\n    return count;\n}\n", "    let count =\
    \ 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j <\
    \ grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n              \
    \  for (let k = 0; k < capacity; k++) {\n                    if (i + k < grid.length)\
    \ {\n                        if (grid[i + k][j] === 0) {\n                   \
    \         grid[i + k][j] = 1;\n                            count++;\n        \
    \                }\n                    }\n                }\n            }\n\
    \        }\n    }\n    return count;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let row_count\
    \ = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j]\
    \ === 1) {\n                row_count++;\n            }\n        }\n        if\
    \ (row_count > 0) {\n            count += Math.ceil(row_count / capacity);\n \
    \       }\n    }\n    return count;\n}\n", "    let count = 0;\n    for (let i\
    \ = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++)\
    \ {\n            if (grid[i][j] === 1) {\n                grid[i][j] = 0;\n  \
    \              count++;\n                let bucket = capacity;\n            \
    \    while (bucket > 0) {\n                    if (i - 1 >= 0 && grid[i - 1][j]\
    \ === 1) {\n                        grid[i - 1][j] = 0;\n                    \
    \    bucket--;\n                    }\n                    if (i + 1 < grid.length\
    \ && grid[i + 1][j] === 1) {\n                        grid[i + 1][j] = 0;\n  \
    \                      bucket--;\n                    }\n                    if\
    \ (j - 1 >= 0 && grid[i][j - 1] === 1) {\n                        grid[i][j -\
    \ 1] = 0;\n                        bucket--;\n                    }\n        \
    \            if (j + 1 < grid[i].length && grid[i][j + 1] === 1) {\n         \
    \               grid[i][j + 1] = 0;\n                        bucket--;\n     \
    \               }\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    let max = 0;\n    let wells = grid.length;\n\
    \    let units = grid[0].length;\n    for (let i = 0; i < wells; i++) {\n    \
    \    for (let j = 0; j < units; j++) {\n            if (grid[i][j] === 1) {\n\
    \                count++;\n            }\n        }\n        if (count > max)\
    \ {\n            max = count;\n        }\n        count = 0;\n    }\n    return\
    \ max * capacity;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "    let count = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
    \    let row_max = [];\n    let col_max = [];\n    for (let i = 0; i < row; i++)\
    \ {\n        let max = 0;\n        for (let j = 0; j < col; j++) {\n         \
    \   if (grid[i][j] > max) {\n                max = grid[i][j];\n            }\n\
    \        }\n        row_max.push(max);\n    }\n    for (let i = 0; i < col; i++)\
    \ {\n        let max = 0;\n        for (let j = 0; j < row; j++) {\n         \
    \   if (grid[j][i] > max) {\n                max = grid[j][i];\n            }\n\
    \        }\n        col_max.push(max);\n    }\n    for (let i = 0; i < row; i++)\
    \ {\n        for (let j = 0; j < col; j++) {\n            let max = Math.min(row_max[i],\
    \ col_max[j]);\n            if (grid[i][j] < max) {\n                count +=\
    \ max - grid[i][j];\n            }\n        }\n    }\n    return count;\n}\n",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             grid[i][j] = 0;\n                count++;\n                let bucket\
    \ = capacity;\n                while (bucket > 0) {\n                    if (i\
    \ - 1 >= 0 && grid[i - 1][j] === 1) {\n                        grid[i - 1][j]\
    \ = 0;\n                        bucket--;\n                    }\n           \
    \         if (i + 1 < grid.length && grid[i + 1][j] === 1) {\n               \
    \         grid[i + 1][j] = 0;\n                        bucket--;\n           \
    \         }\n                    if (j - 1 >= 0 && grid[i][j - 1] === 1) {\n \
    \                       grid[i][j - 1] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j + 1 < grid[i].length && grid[i][j\
    \ + 1] === 1) {\n                        grid[i][j + 1] = 0;\n               \
    \         bucket--;\n                    }\n                }\n            }\n\
    \        }\n    }\n    return count;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                grid[i][j] = 0;\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    let row = grid.length;\n    let col =\
    \ grid[0].length;\n    let max = 0;\n    for (let i = 0; i < row; i++) {\n   \
    \     for (let j = 0; j < col; j++) {\n            if (grid[i][j] === 1) {\n \
    \               max = Math.max(max, j);\n            }\n        }\n    }\n   \
    \ for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n \
    \           if (grid[i][j] === 1) {\n                if (j === max) {\n      \
    \              count += capacity;\n                } else {\n                \
    \    count += 1;\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "    let fill_count\
    \ = 0;\n    let row_count = grid.length;\n    let col_count = grid[0].length;\n\
    \    let row_index = 0;\n    let col_index = 0;\n    let row_sum = 0;\n    let\
    \ col_sum = 0;\n    let row_max = 0;\n    let col_max = 0;\n    let row_max_index\
    \ = 0;\n    let col_max_index = 0;\n    let row_max_sum = 0;\n    let col_max_sum\
    \ = 0;\n    let row_max_count = 0;\n    let col_max_count = 0;\n    let row_max_index_count\
    \ = 0;\n    let col_max_index_count = 0;\n    let row_max_index_sum = 0;\n   \
    \ let col_max_index_sum = 0;\n    let row_max_index_count_sum = 0;\n    let col_max_index_count_sum\
    \ = 0;\n    let row_max_index_count_sum_index = 0;\n    let col_max_index_count_sum_index\
    \ = 0;\n    let row_max_index_count_sum_index_count = 0;\n    let col_max_index_count_sum_index_count\
    \ = 0;\n    let row_max_index_count_sum_index_count_sum = 0;\n    let col_max_index_count_sum_index_count_sum\
    \ = 0;\n    let row_max_index_count_sum_index_count_sum_index = 0;\n    let col_max_index_count_sum_index_count_sum_index\
    \ = 0;\n    let row_max_index_count_sum_index_count_sum_index_count = 0;\n   \
    \ let col_max_index_count_sum_index_count_sum_index_count = 0;\n    let row_max_index_count_sum_index_count_sum_index_count_sum\
    \ = 0;\n    let col_max_index_count_sum_index_count_sum_index_count_sum = 0;\n\
    \    let row_max_index_count_sum_", "    let result = 0;\n    let row = grid.length;\n\
    \    let col = grid[0].length;\n    let wells = [];\n    let buckets = [];\n \
    \   for (let i = 0; i < row; i++) {\n        wells.push([]);\n        buckets.push([]);\n\
    \        for (let j = 0; j < col; j++) {\n            wells[i].push(grid[i][j]);\n\
    \            buckets[i].push(0);\n        }\n    }\n    for (let i = 0; i < row;\
    \ i++) {\n        for (let j = 0; j < col; j++) {\n            if (wells[i][j]\
    \ === 1) {\n                if (buckets[i][j] < capacity) {\n                \
    \    buckets[i][j]++;\n                    result++;\n                }\n    \
    \            if (i > 0 && buckets[i - 1][j] < capacity) {\n                  \
    \  buckets[i - 1][j]++;\n                    result++;\n                }\n  \
    \              if (i < row - 1 && buckets[i + 1][j] < capacity) {\n          \
    \          buckets[i + 1][j]++;\n                    result++;\n             \
    \   }\n                if (j > 0 && buckets[i][j - 1] < capacity) {\n        \
    \            buckets[i][j - 1]++;\n                    result++;\n           \
    \     }\n                if (j < col - 1 && buckets[i][j + 1] < capacity) {\n\
    \                    buckets[i][j + 1]++;\n                    result++;\n   \
    \             }\n            }\n        }\n    }\n    return result;\n}\n", " \
    \   let count = 0;\n    let wells = grid.length;\n    let len = grid[0].length;\n\
    \    let buckets = new Array(wells).fill(0);\n    let i = 0;\n    let j = 0;\n\
    \    let max = 0;\n    while (true) {\n        if (i === wells) {\n          \
    \  i = 0;\n            j++;\n        }\n        if (j === len) {\n           \
    \ break;\n        }\n        if (grid[i][j] === 1) {\n            buckets[i] =\
    \ capacity;\n        }\n        buckets[i]--;\n        if (buckets[i] < 0) {\n\
    \            buckets[i] = 0;\n        }\n        i++;\n    }\n    for (let i =\
    \ 0; i < buckets.length; i++) {\n        if (buckets[i] > max) {\n           \
    \ max = buckets[i];\n        }\n    }\n    return max;\n}\n", "    let count =\
    \ 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j <\
    \ grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n              \
    \  grid[i][j] = 0;\n                count++;\n                let bucket = capacity;\n\
    \                while (bucket > 0) {\n                    if (i - 1 >= 0 && grid[i\
    \ - 1][j] === 1) {\n                        grid[i - 1][j] = 0;\n            \
    \            bucket--;\n                    }\n                    if (i + 1 <\
    \ grid.length && grid[i + 1][j] === 1) {\n                        grid[i + 1][j]\
    \ = 0;\n                        bucket--;\n                    }\n           \
    \         if (j - 1 >= 0 && grid[i][j - 1] === 1) {\n                        grid[i][j\
    \ - 1] = 0;\n                        bucket--;\n                    }\n      \
    \              if (j + 1 < grid[i].length && grid[i][j + 1] === 1) {\n       \
    \                 grid[i][j + 1] = 0;\n                        bucket--;\n   \
    \                 }\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                grid[i][j] = 0;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let max = 0;\n    let max_index\
    \ = 0;\n    let max_row = 0;\n    let max_col = 0;\n    let row = 0;\n    let\
    \ col = 0;\n    let row_max = grid.length;\n    let col_max = grid[0].length;\n\
    \    let row_index = 0;\n    let col_index = 0;\n    let row_count = 0;\n    let\
    \ col_count = 0;\n    let row_sum = 0;\n    let col_sum = 0;\n    let row_sum_max\
    \ = 0;\n    let col_sum_max = 0;\n    let row_sum_index = 0;\n    let col_sum_index\
    \ = 0;\n    let row_sum_count = 0;\n    let col_sum_count = 0;\n    let row_sum_max_index\
    \ = 0;\n    let col_sum_max_index = 0;\n    let row_sum_max_count = 0;\n    let\
    \ col_sum_max_count = 0;\n    let row_sum_max_row = 0;\n    let col_sum_max_col\
    \ = 0;\n    let row_sum_max_row_count = 0;\n    let col_sum_max_col_count = 0;\n\
    \    let row_sum_max_row_index = 0;\n    let col_sum_max_col_index = 0;\n    let\
    \ row_sum_max_row_count_index = 0;\n    let col_sum_max_col_count_index = 0;\n\
    \    let row_sum_max_row_count_index_count = 0;\n    let col_sum_max_col_count_index_count\
    \ = 0;\n    let row_sum_max_row_count_index_count_index = 0;\n    let col_sum_max_col_count_index_count_index\
    \ = 0;\n    let row_sum_max_row_count_index_count_index_count = 0;\n    let col_sum_max_col_count_index_count_index_count\
    \ = 0;\n    let row_sum_max_row_count_index_", "    let max_fill = 0;\n    let\
    \ max_fill_count = 0;\n    let max_fill_row = 0;\n    let max_fill_col = 0;\n\
    \    let max_fill_row_count = 0;\n    let max_fill_col_count = 0;\n    let max_fill_row_col_count\
    \ = 0;\n    let max_fill_row_col_count_2 = 0;\n    let max_fill_row_col_count_3\
    \ = 0;\n    let max_fill_row_col_count_4 = 0;\n    let max_fill_row_col_count_5\
    \ = 0;\n    let max_fill_row_col_count_6 = 0;\n    let max_fill_row_col_count_7\
    \ = 0;\n    let max_fill_row_col_count_8 = 0;\n    let max_fill_row_col_count_9\
    \ = 0;\n    let max_fill_row_col_count_10 = 0;\n    let max_fill_row_col_count_11\
    \ = 0;\n    let max_fill_row_col_count_12 = 0;\n    let max_fill_row_col_count_13\
    \ = 0;\n    let max_fill_row_col_count_14 = 0;\n    let max_fill_row_col_count_15\
    \ = 0;\n    let max_fill_row_col_count_16 = 0;\n    let max_fill_row_col_count_17\
    \ = 0;\n    let max_fill_row_col_count_18 = 0;\n    let max_fill_row_col_count_19\
    \ = 0;\n    let max_fill_row_col_count_20 = 0;\n    let max_fill_row_col_count_21\
    \ = 0;\n    let max_fill_row_col_count_22 = 0;\n    let max_fill_row_col_count_23\
    \ = 0;\n    let max_fill_row_col_count_24 = 0;\n    let max_fill_row_col_count_25\
    \ = 0;\n    let max_fill_row_col_count_26 = 0;\n    let max", "    let count =\
    \ 0;\n    let max = 0;\n    let max_index = 0;\n    let max_sum = 0;\n    let\
    \ sum = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j =\
    \ 0; j < grid[i].length; j++) {\n            sum += grid[i][j];\n        }\n \
    \       if (sum > max_sum) {\n            max_sum = sum;\n            max_index\
    \ = i;\n        }\n        sum = 0;\n    }\n    for (let i = 0; i < grid[max_index].length;\
    \ i++) {\n        max += grid[max_index][i];\n    }\n    count = Math.ceil(max\
    \ / capacity);\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0,\
    \ 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
    \ 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                grid[i][j] = 0;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let max_fill = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                max_fill += capacity;\n            }\n        }\n\
    \    }\n    return max_fill;\n}\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1,\
    \ 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]],\
    \ 5));", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n  \
    \      for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += 1;\n            }\n        }\n    }\n   \
    \ return count * capacity;\n}\n", "    let count = 0;\n    for (let i = 0; i <\
    \ grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n  \
    \          if (grid[i][j] === 1) {\n                grid[i][j] = 0;\n        \
    \        count++;\n                let bucket = capacity;\n                let\
    \ k = i;\n                while (bucket > 0 && k < grid.length) {\n          \
    \          if (grid[k][j] === 1) {\n                        grid[k][j] = 0;\n\
    \                        bucket--;\n                    }\n                  \
    \  k++;\n                }\n            }\n        }\n    }\n    return count;\n\
    }\n", "    let count = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
    \    let wells = [];\n    for (let i = 0; i < row; i++) {\n        wells.push([]);\n\
    \        for (let j = 0; j < col; j++) {\n            wells[i].push(0);\n    \
    \    }\n    }\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j\
    \ < col; j++) {\n            if (grid[i][j] === 1) {\n                wells[i][j]\
    \ = capacity;\n                count += capacity;\n            }\n        }\n\
    \    }\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col;\
    \ j++) {\n            if (wells[i][j] > 0) {\n                if (wells[i][j]\
    \ > wells[i - 1][j]) {\n                    count -= wells[i][j] - wells[i - 1][j];\n\
    \                    wells[i][j] = wells[i - 1][j];\n                }\n     \
    \           if (wells[i][j] > wells[i + 1][j]) {\n                    count -=\
    \ wells[i][j] - wells[i + 1][j];\n                    wells[i][j] = wells[i +\
    \ 1][j];\n                }\n                if (wells[i][j] > wells[i][j - 1])\
    \ {\n                    count -= wells[i][j] - wells[i][j - 1];\n           \
    \         wells[i][j] = wells[i][j - 1];\n                }\n                if\
    \ (wells[i][j] > wells[i][j + 1]) {\n                    count -= wells[i][j]\
    \ - wells[i][j + 1];\n                    wells[i][j] = wells[i][j + 1];\n   \
    \             }\n            }\n        }\n    }\n    return count;\n}\n", " \
    \   let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count++;\n            }\n        }\n        if (count\
    \ > max) {\n            max = count;\n        }\n        count = 0;\n    }\n \
    \   return max * capacity;\n}\n", "    let count = 0;\n    for (let i = 0; i <\
    \ grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n  \
    \          if (grid[i][j] === 1) {\n                count += capacity;\n     \
    \           grid[i][j] = 0;\n            }\n        }\n    }\n    return count;\n\
    }\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                grid[i][j] = 0;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                grid[i][j] = 0;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                for (let k = i + 1; k < grid.length; k++) {\n               \
    \     if (grid[k][j] === 1) {\n                        count += capacity;\n  \
    \                  } else {\n                        break;\n                \
    \    }\n                }\n            }\n        }\n    }\n    return count;\n\
    }\n", "    let count = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
    \    let arr: any = [];\n    for (let i = 0; i < row; i++) {\n        arr.push([]);\n\
    \        for (let j = 0; j < col; j++) {\n            arr[i].push(0);\n      \
    \  }\n    }\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j <\
    \ col; j++) {\n            if (grid[i][j] == 1) {\n                if (arr[i][j]\
    \ == 0) {\n                    count++;\n                    arr[i][j] = 1;\n\
    \                }\n                if (i + 1 < row && arr[i + 1][j] == 0) {\n\
    \                    arr[i + 1][j] = 1;\n                }\n                if\
    \ (j + 1 < col && arr[i][j + 1] == 0) {\n                    arr[i][j + 1] = 1;\n\
    \                }\n            }\n        }\n    }\n    return count;\n}\n",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             count++;\n                for (let k = i; k < grid.length; k++)\
    \ {\n                    if (grid[k][j] === 1) {\n                        grid[k][j]\
    \ = 0;\n                    }\n                }\n            }\n        }\n \
    \   }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             grid[i][j] = 0;\n                count++;\n                for (let\
    \ k = i + 1; k < grid.length; k++) {\n                    if (grid[k][j] === 1)\
    \ {\n                        grid[k][j] = 0;\n                        count++;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return count;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
