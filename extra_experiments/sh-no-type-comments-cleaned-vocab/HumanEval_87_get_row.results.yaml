language: sh
name: HumanEval_87_get_row
results:
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while IFS= read -r line; do\n        col=0\n  \
    \      for i in $line; do\n            if [[ $i == $x ]]; then\n             \
    \   res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | sort -t '\"' -k 1,1n -k 3,3nr\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3\
    \ 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1\
    \ 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\" | tr \" \" \"\\n\" | sort -t \"\\\"\"\
    \ -k1n -k2nr | tr \"\\n\" \" \"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"\
    1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4\
    \ 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    local row_result=()\n    local row_result_sorted=()\n\
    \    local row_result_sorted_reversed=()\n    local row_result_sorted_reversed_joined=()\n\
    \    local result_joined=()\n    for i in $(echo $lst | tr ' ' '\\n'); do\n  \
    \      if [[ $i == $x ]]; then\n            row_result+=($col)\n        fi\n \
    \       if [[ $i == $'\\n' ]]; then\n            if [[ ${#row_result[@]} -gt 0\
    \ ]]; then\n                row_result_sorted=($(printf '%s\\n' \"${row_result[@]}\"\
    \ | sort -n))\n                row_result_sorted_reversed=($(printf '%s\\n' \"\
    ${row_result_sorted[@]}\" | tac))\n                row_result_sorted_reversed_joined=$(printf\
    \ '\"%s\" ' \"${row_result_sorted_reversed[@]}\")\n                result+=($row\
    \ $row_result_sorted_reversed_joined)\n            fi\n            row_result=()\n\
    \            row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    if [[ ${#row_result[@]} -gt 0 ]]; then\n  \
    \      row_result_sorted=($(printf '%s\\n' \"${row_result[@]}\" | sort -n))\n\
    \        row_result_sorted_reversed=($(printf '%s\\n' \"${row_result_sorted[@]}\"\
    \ | tac))\n        row_result_sorted_reversed_joined=$(printf '\"%s\" ' \"${row_result_sorted_reversed[@]}\"\
    )\n        result+=($row $row_result_sorted_reversed_joined)\n    fi\n    result_sorted=($(printf\
    \ '%s\\n' \"${result[@]}\" |\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5\
    \ 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\"\
    \ \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b"/tmp/tmp9upqyqpc.sh: line 52: unexpected EOF while looking for matching
    `)''\n/tmp/tmp9upqyqpc.sh: line 70: syntax error: unexpected end of file\n"'
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local row=0\n  local col=0\n\
    \  local res=()\n  while read -r line; do\n    col=0\n    for i in $line; do\n\
    \      if [[ $i == $x ]]; then\n        res+=(\"[\\\"$row\\\", \\\"$col\\\"]\"\
    )\n      fi\n      col=$((col+1))\n    done\n    row=$((row+1))\n  done <<< \"\
    $lst\"\n  echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5\
    \ 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\"\
    \ \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a col=()\n    local -a tmp=()\n    local -a tmp2=()\n\
    \    local -a tmp3=()\n    local -a tmp4=()\n    local -a tmp5=()\n    local -a\
    \ tmp6=()\n    local -a tmp7=()\n    local -a tmp8=()\n    local -a tmp9=()\n\
    \    local -a tmp10=()\n    local -a tmp11=()\n    local -a tmp12=()\n    local\
    \ -a tmp13=()\n    local -a tmp14=()\n    local -a tmp15=()\n    local -a tmp16=()\n\
    \    local -a tmp17=()\n    local -a tmp18=()\n    local -a tmp19=()\n    local\
    \ -a tmp20=()\n    local -a tmp21=()\n    local -a tmp22=()\n    local -a tmp23=()\n\
    \    local -a tmp24=()\n    local -a tmp25=()\n    local -a tmp26=()\n    local\
    \ -a tmp27=()\n    local -a tmp28=()\n    local -a tmp29=()\n    local -a tmp30=()\n\
    \    local -a tmp31=()\n    local -a tmp32=()\n    local -a tmp33=()\n    local\
    \ -a tmp34=()\n    local -a tmp35=()\n    local -a tmp36=()\n    local -a tmp37=()\n\
    \    local -a tmp38=()\n    local -a tmp39=()\n    local -a tmp40=()\n    local\
    \ -a tmp41=()\n    local -a tmp42=()\n    local -a tmp43=()\n    local -a tmp44=()\n\
    \    local -a tmp45=()\n    local -a tmp46=()\n    local -a tmp47=()\n    local\
    \ -a tmp48=()\n    local -a tmp49=()\n    local -a tmp50=()\n    local -a tmp51=()\n\
    \    local -a tmp52=()\n    local -a tmp53=\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a col=()\n    local -a tmp=()\n    local -a tmp2=()\n\
    \    local -a tmp3=()\n    local -a tmp4=()\n    local -a tmp5=()\n    local -a\
    \ tmp6=()\n    local -a tmp7=()\n    local -a tmp8=()\n    local -a tmp9=()\n\
    \    local -a tmp10=()\n    local -a tmp11=()\n    local -a tmp12=()\n    local\
    \ -a tmp13=()\n    local -a tmp14=()\n    local -a tmp15=()\n    local -a tmp16=()\n\
    \    local -a tmp17=()\n    local -a tmp18=()\n    local -a tmp19=()\n    local\
    \ -a tmp20=()\n    local -a tmp21=()\n    local -a tmp22=()\n    local -a tmp23=()\n\
    \    local -a tmp24=()\n    local -a tmp25=()\n    local -a tmp26=()\n    local\
    \ -a tmp27=()\n    local -a tmp28=()\n    local -a tmp29=()\n    local -a tmp30=()\n\
    \    local -a tmp31=()\n    local -a tmp32=()\n    local -a tmp33=()\n    local\
    \ -a tmp34=()\n    local -a tmp35=()\n    local -a tmp36=()\n    local -a tmp37=()\n\
    \    local -a tmp38=()\n    local -a tmp39=()\n    local -a tmp40=()\n    local\
    \ -a tmp41=()\n    local -a tmp42=()\n    local -a tmp43=()\n    local -a tmp44=()\n\
    \    local -a tmp45=()\n    local -a tmp46=()\n    local -a tmp47=()\n    local\
    \ -a tmp48=()\n    local -a tmp49=()\n    local -a tmp50=()\n    local -a tmp51=()\n\
    \    local -a tmp52=()\n    local -a tmp53=\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a i\n    local -a j\n    local -a k\n \
    \   local -a l\n    local -a m\n    local -a n\n    local -a o\n    local -a p\n\
    \    local -a q\n    local -a r\n    local -a s\n    local -a t\n    local -a\
    \ u\n    local -a v\n    local -a w\n    local -a y\n    local -a z\n    local\
    \ -a aa\n    local -a ab\n    local -a ac\n    local -a ad\n    local -a ae\n\
    \    local -a af\n    local -a ag\n    local -a ah\n    local -a ai\n    local\
    \ -a aj\n    local -a ak\n    local -a al\n    local -a am\n    local -a an\n\
    \    local -a ao\n    local -a ap\n    local -a aq\n    local -a ar\n    local\
    \ -a as\n    local -a at\n    local -a au\n    local -a av\n    local -a aw\n\
    \    local -a ax\n    local -a ay\n    local -a az\n    local -a ba\n    local\
    \ -a bb\n    local -a bc\n    local -a bd\n    local -a be\n    local -a bf\n\
    \    local -a bg\n    local -a bh\n    local -a bi\n    local -a bj\n    local\
    \ -a bk\n    local -a bl\n    local -a bm\n    local -a bn\n    local -a bo\n\
    \    local -a bp\n    local -a bq\n    local -a br\n    local -a bs\n    local\
    \ -a bt\n    local -a bu\n    local -a bv\n    local -a bw\n    local -a bx\n\
    \    local -a by\n    local -a bz\n    local -a ca\n    local -a cb\n    local\
    \ -a cc\n    local -a cd\n    local -a ce\n    local -a cf\n    local -a cg\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=\"\"\n\
    \    local row=0\n    local col=0\n    local row_count=0\n    local col_count=0\n\
    \    local row_max=0\n    local col_max=0\n    local row_max_index=0\n    local\
    \ col_max_index=0\n    local row_max_count=0\n    local col_max_count=0\n    local\
    \ row_max_count_index=0\n    local col_max_count_index=0\n    local row_max_count_index_count=0\n\
    \    local col_max_count_index_count=0\n    local row_max_count_index_count_index=0\n\
    \    local col_max_count_index_count_index=0\n    local row_max_count_index_count_index_count=0\n\
    \    local col_max_count_index_count_index_count=0\n    local row_max_count_index_count_index_count_index=0\n\
    \    local col_max_count_index_count_index_count_index=0\n    local row_max_count_index_count_index_count_index_count=0\n\
    \    local col_max_count_index_count_index_count_index_count=0\n    local row_max_count_index_count_index_count_index_count_index=0\n\
    \    local col_max_count_index_count_index_count_index_count_index=0\n    local\
    \ row_max_count_index_count_index_count_index_count_index_count=0\n    local col_max_count_index_count_index_count_index_count_index_count=0\n\
    \    local row_max_count_index_count_index_count_index_count_index_count_index=0\n\
    \    local col_max_count_index_count_index_count_index_count_index_count_index=0\n\
    \    local row_max_count_index_count_index_count_index_count_index_count_index_count=0\n\
    \    local col_max_count_index_count_index_count_index_count\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    while read -r line; do\n        col=0\n    \
    \    for i in $line; do\n            if [[ $i == $x ]]; then\n               \
    \ result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${result[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr \" \" \"\\n\" | sort -t '\"' -k 1,1n -k 3,3nr | tr \"\\n\" \" \"\n}\n\n\
    candidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a res_sorted\n    local -a res_sorted_final\n    local i=0\n    local\
    \ j=0\n    local k=0\n    local l=0\n    local m=0\n    local n=0\n    local o=0\n\
    \    local p=0\n    local q=0\n    local r=0\n    local s=0\n    local t=0\n \
    \   local u=0\n    local v=0\n    local w=0\n    local x=0\n    local y=0\n  \
    \  local z=0\n    local aa=0\n    local bb=0\n    local cc=0\n    local dd=0\n\
    \    local ee=0\n    local ff=0\n    local gg=0\n    local hh=0\n    local ii=0\n\
    \    local jj=0\n    local kk=0\n    local ll=0\n    local mm=0\n    local nn=0\n\
    \    local oo=0\n    local pp=0\n    local qq=0\n    local rr=0\n    local ss=0\n\
    \    local tt=0\n    local uu=0\n    local vv=0\n    local ww=0\n    local xx=0\n\
    \    local yy=0\n    local zz=0\n    local aaa=0\n    local bbb=0\n    local ccc=0\n\
    \    local ddd=0\n    local eee=0\n    local fff=0\n    local ggg=0\n    local\
    \ hhh=0\n    local iii=0\n    local jjj=0\n    local kkk=0\n    local lll=0\n\
    \    local mmm=0\n    local nnn=0\n    local ooo=0\n    local ppp=0\n    local\
    \ qqq=0\n    local rrr=0\n    local sss=0\n    local ttt=0\n    local uuu=0\n\
    \    local vvv=0\n    local www=0\n   \n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    for i in $(echo \"$lst\" | tr \" \" \"\\\
    n\"); do\n        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\"\
    , \\\"$col\\\"]\")\n        fi\n        col=$((col + 1))\n        if [[ $i ==\
    \ \"\\n\" ]]; then\n            row=$((row + 1))\n            col=0\n        fi\n\
    \    done\n    echo \"${result[@]}\" | tr \" \" \"\\n\" | sort -t \"\\\"\" -k\
    \ 1n -k 3nr | tr \"\\n\" \" \"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"\
    1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4\
    \ 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -i i=0\n    local -i j=0\n    local -i k=0\n    local -i row_count=0\n\
    \    local -i column_count=0\n    local -i column_count_prev=0\n    local -i column_count_curr=0\n\
    \    local -i column_count_next=0\n    local -i row_count_prev=0\n    local -i\
    \ row_count_curr=0\n    local -i row_count_next=0\n    local -i row_count_prev_prev=0\n\
    \    local -i row_count_curr_prev=0\n    local -i row_count_next_prev=0\n    local\
    \ -i row_count_prev_curr=0\n    local -i row_count_curr_curr=0\n    local -i row_count_next_curr=0\n\
    \    local -i row_count_prev_next=0\n    local -i row_count_curr_next=0\n    local\
    \ -i row_count_next_next=0\n    local -i row_count_prev_prev_prev=0\n    local\
    \ -i row_count_curr_prev_prev=0\n    local -i row_count_next_prev_prev=0\n   \
    \ local -i row_count_prev_curr_prev=0\n    local -i row_count_curr_curr_prev=0\n\
    \    local -i row_count_next_curr_prev=0\n    local -i row_count_prev_next_prev=0\n\
    \    local -i row_count_curr_next_prev=0\n    local -i row_count_next_next_prev=0\n\
    \    local -i row_count_prev_prev_curr=0\n    local -i row_count_curr_prev_curr=0\n\
    \    local -i row_count_next_prev_curr=0\n    local -i row_count_prev_curr_curr=0\n\
    \    local -i row_count_curr_curr_curr=0\n    local -\n}\n\ncandidate() {\n  \
    \  get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n   \
    \ [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -a row\n    local -a column\n    local -a row_column\n    local -a row_column_sorted\n\
    \    local -a row_column_sorted_desc\n    local -a row_column_sorted_desc_str\n\
    \    local -a row_column_sorted_desc_str_joined\n    local -a row_column_sorted_desc_str_joined_str\n\
    \    local -a row_column_sorted_desc_str_joined_str_joined\n    local -a row_column_sorted_desc_str_joined_str_joined_str\n\
    \    local -a row_column_sorted_desc_str_joined_str_joined_str_joined\n    local\
    \ -a row_column_sorted_desc_str_joined_str_joined_str_joined_str\n    local -a\
    \ row_column_sorted_desc_str_joined_str_joined_str_joined_str_joined\n    local\
    \ -a row_column_sorted_desc_str_joined_str_joined_str_joined_str_joined_str\n\
    \    local -a row_column_sorted_desc_str_joined_str_joined_str_joined_str_joined_str_joined\n\
    \    local -a row_column_sorted_desc_str_joined_str_joined_str_joined_str_joined_str_joined_str\n\
    \    local -a row_column_sorted_desc_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined\n\
    \    local -a row_column_sorted_desc_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined_str\n\
    \    local -a row_column_sorted_desc_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined\n\
    \    local -a row_column_sorted_desc_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined_str\n\
    \    local -a row_column_sorted_desc_\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local i=0\n    local\
    \ j=0\n    local res=()\n    for row in $lst; do\n        j=0\n        for col\
    \ in $row; do\n            if [[ $col -eq $x ]]; then\n                res+=(\"\
    [\\\"$i\\\", \\\"$j\\\"]\")\n            fi\n            j=$((j+1))\n        done\n\
    \        i=$((i+1))\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n  \
    \  get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n   \
    \ [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmptbk_0cq6.sh: line 26: [[: 6\\n1: syntax error: invalid arithmetic
    operator (error token is "\\n1")\n/tmp/tmptbk_0cq6.sh: line 26: [[: 6\\n1: syntax
    error: invalid arithmetic operator (error token is "\\n1")\n'''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sort\n\
    \    local -a row_col_sort_rev\n    local -a res_sort\n    local -a res_sort_rev\n\
    \    local i=0\n    local j=0\n    local k=0\n    local l=0\n    local m=0\n \
    \   local n=0\n    local o=0\n    local p=0\n    local q=0\n    local r=0\n  \
    \  local s=0\n    local t=0\n    local u=0\n    local v=0\n    local w=0\n   \
    \ local x=0\n    local y=0\n    local z=0\n    local aa=0\n    local bb=0\n  \
    \  local cc=0\n    local dd=0\n    local ee=0\n    local ff=0\n    local gg=0\n\
    \    local hh=0\n    local ii=0\n    local jj=0\n    local kk=0\n    local ll=0\n\
    \    local mm=0\n    local nn=0\n    local oo=0\n    local pp=0\n    local qq=0\n\
    \    local rr=0\n    local ss=0\n    local tt=0\n    local uu=0\n    local vv=0\n\
    \    local ww=0\n    local xx=0\n    local yy=0\n    local zz=0\n    local aaa=0\n\
    \    local bbb=0\n    local ccc=0\n    local ddd=0\n    local eee=0\n    local\
    \ fff=0\n    local ggg=0\n    local hhh=0\n    local iii=0\n    local jjj=0\n\
    \    local kkk=0\n    local lll=0\n    local mmm=0\n    local nnn=0\n    local\
    \ ooo=0\n    local ppp=0\n    local qqq=0\n    local rrr=0\n    local sss=0\n\
    \    local ttt=0\n    local uuu=0\n    local vvv=\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local row_res=()\n    for i in $(echo \"$lst\"\
    \ | tr ' ' '\\n'); do\n        if [[ $i == $x ]]; then\n            row_res+=($row)\n\
    \            row_res+=($col)\n            res+=(\"[\\\"$row\\\", \\\"$col\\\"\
    ]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            ((row++))\n\
    \            col=0\n        else\n            ((col++))\n        fi\n    done\n\
    \    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n\
    \    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5\
    \ 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a row_col\n    local -a row_col_res\n \
    \   local -a row_col_res_res\n    local -a row_col_res_res_res\n    local -a row_col_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res\n    local -a row_col_res_res_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res_res_res\n    local -a row_col_res_res_res_res_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res\n    local -a row_col_res_res_res_res_res_res_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_res\n    local -a\
    \ row_col_res_res_res_res_res_res_res_res_res_res_res_res\n    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_res_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_res_res_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local -a\
    \ row_col_sorted=()\n    local -a res_sorted=()\n    local -a row_col_sorted_rev=()\n\
    \    local -a res_sorted_rev=()\n    local -a res_sorted_rev_str=()\n    local\
    \ -a res_sorted_rev_str_quoted=()\n    local -a res_sorted_rev_str_quoted_str=()\n\
    \    local -a res_sorted_rev_str_quoted_str_str=()\n    local -a res_sorted_rev_str_quoted_str_str_str=()\n\
    \    local -a res_sorted_rev_str_quoted_str_str_str_str=()\n    local -a res_sorted_rev_str_quoted_str_str_str_str_str=()\n\
    \    local -a res_sorted_rev_str_quoted_str_str_str_str_str_str=()\n    local\
    \ -a res_sorted_rev_str_quoted_str_str_str_str_str_str_str=()\n    local -a res_sorted_rev_str_quoted_str_str_str_str_str_str_str_str=()\n\
    \    local -a res_sorted_rev_str_quoted_str_str_str_str_str_str_str_str_str=()\n\
    \    local -a res_sorted_rev_str_quoted_str_str_str_str_str_str_str_str_str_str=()\n\
    \    local -a res_sorted_rev_str_quoted_str_str_str_str_str_str_str_str_str_str_str=()\n\
    \    local -a res_sorted_rev_str_quoted_str_str_str_str_str_str_str_str_str_str_str_str=()\n\
    \    local -a res_s\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            ((row++))\n\
    \            col=0\n        else\n            ((col++))\n        fi\n    done\n\
    \    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -i i=0\n    local -i j=0\n    local -i k=0\n    local -i m=0\n    local\
    \ -i n=0\n    local -i p=0\n    local -i q=0\n    local -i r=0\n    local -i s=0\n\
    \    local -i t=0\n    local -i u=0\n    local -i v=0\n    local -i w=0\n    local\
    \ -i x=0\n    local -i y=0\n    local -i z=0\n    local -i aa=0\n    local -i\
    \ bb=0\n    local -i cc=0\n    local -i dd=0\n    local -i ee=0\n    local -i\
    \ ff=0\n    local -i gg=0\n    local -i hh=0\n    local -i ii=0\n    local -i\
    \ jj=0\n    local -i kk=0\n    local -i ll=0\n    local -i mm=0\n    local -i\
    \ nn=0\n    local -i oo=0\n    local -i pp=0\n    local -i qq=0\n    local -i\
    \ rr=0\n    local -i ss=0\n    local -i tt=0\n    local -i uu=0\n    local -i\
    \ vv=0\n    local -i ww=0\n    local -i xx=0\n    local -i yy=0\n    local -i\
    \ zz=0\n    local -i aaa=0\n    local -i bbb=0\n    local -i ccc=0\n    local\
    \ -i ddd=0\n    local -i eee=0\n    local -i fff=0\n    local -i ggg=0\n    local\
    \ -i hhh=0\n    local -i iii=0\n    local -i jjj=0\n    local -i kkk=0\n    local\
    \ -i lll=0\n    local -i mmm=0\n    local -i nnn=0\n    local -i ooo=0\n    local\
    \ -i p\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\\
    n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\\
    n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\
    \ = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\"\
    \ ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\"\
    ) = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result=()\n\
    \    local -a rows=()\n    local -a columns=()\n    local -a row=()\n    local\
    \ -a column=()\n    local -a row_column=()\n    local -a row_columns=()\n    local\
    \ -a row_columns_sorted=()\n    local -a row_columns_sorted_desc=()\n    local\
    \ -a row_columns_sorted_desc_joined=()\n    local -a result_joined=()\n    local\
    \ -a result_joined_sorted=()\n    local -a result_joined_sorted_desc=()\n    local\
    \ -a result_joined_sorted_desc_joined=()\n    local -a result_joined_sorted_desc_joined_joined=()\n\
    \    local -a result_joined_sorted_desc_joined_joined_joined=()\n    local -a\
    \ result_joined_sorted_desc_joined_joined_joined_joined=()\n    local -a result_joined_sorted_desc_joined_joined_joined_joined_joined=()\n\
    \    local -a result_joined_sorted_desc_joined_joined_joined_joined_joined_joined=()\n\
    \    local -a result_joined_sorted_desc_joined_joined_joined_joined_joined_joined_joined=()\n\
    \    local -a result_joined_sorted_desc_joined_joined_joined_joined_joined_joined_joined_joined=()\n\
    \    local -a result_joined_sorted_desc_joined_joined_joined_joined_joined_joined_joined_joined_joined=()\n\
    \    local -a result_joined_sorted_desc_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined=()\n\
    \    local -a result_joined_sorted_desc_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined=()\n\
    \    local -a result_joined_sorted_desc_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined=()\n\
    \    local -a result_joined_sorted_desc_joined_\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -a rows\n    local -a columns\n    local -a row\n    local -a column\n\
    \    local -a row_column\n    local -a row_columns\n    local -a row_columns_sorted\n\
    \    local -a row_columns_sorted_desc\n    local -a row_columns_sorted_desc_str\n\
    \    local -a row_columns_sorted_desc_str_sorted\n    local -a row_columns_sorted_desc_str_sorted_str\n\
    \    local -a row_columns_sorted_desc_str_sorted_str_sorted\n    local -a row_columns_sorted_desc_str_sorted_str_sorted_str\n\
    \    local -a row_columns_sorted_desc_str_sorted_str_sorted_str_sorted\n    local\
    \ -a row_columns_sorted_desc_str_sorted_str_sorted_str_sorted_str\n    local -a\
    \ row_columns_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted\n    local\
    \ -a row_columns_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_columns_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_columns_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_columns_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_columns_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_columns_sorted_desc_str_sorted_\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a rows\n   \
    \ local -a row\n    local -a cols\n    local -a col\n    local -a res\n    local\
    \ -a tmp\n    local -a tmp2\n    local -a tmp3\n    local -a tmp4\n    local -a\
    \ tmp5\n    local -a tmp6\n    local -a tmp7\n    local -a tmp8\n    local -a\
    \ tmp9\n    local -a tmp10\n    local -a tmp11\n    local -a tmp12\n    local\
    \ -a tmp13\n    local -a tmp14\n    local -a tmp15\n    local -a tmp16\n    local\
    \ -a tmp17\n    local -a tmp18\n    local -a tmp19\n    local -a tmp20\n    local\
    \ -a tmp21\n    local -a tmp22\n    local -a tmp23\n    local -a tmp24\n    local\
    \ -a tmp25\n    local -a tmp26\n    local -a tmp27\n    local -a tmp28\n    local\
    \ -a tmp29\n    local -a tmp30\n    local -a tmp31\n    local -a tmp32\n    local\
    \ -a tmp33\n    local -a tmp34\n    local -a tmp35\n    local -a tmp36\n    local\
    \ -a tmp37\n    local -a tmp38\n    local -a tmp39\n    local -a tmp40\n    local\
    \ -a tmp41\n    local -a tmp42\n    local -a tmp43\n    local -a tmp44\n    local\
    \ -a tmp45\n    local -a tmp46\n    local -a tmp47\n    local -a tmp48\n    local\
    \ -a tmp49\n    local -a tmp50\n    local -a tmp51\n    local -a tmp52\n    local\
    \ -a tmp53\n    local -a tmp54\n    local -a tmp55\n    local -a tmp56\n    local\
    \ -a tmp57\n    local -a tmp58\n    local -a tmp59\n    local -a tmp60\n    local\
    \ -a tmp61\n    local -a tmp62\n    local -a tmp63\n    local -a tmp64\n    local\
    \ -a tmp65\n    local -a tmp66\n    local -a tmp67\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local -a res\n    while read -r line; do\n        col=0\n       \
    \ for num in $line; do\n            if [[ $num -eq $x ]]; then\n             \
    \   res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col\
    \ + 1))\n        done\n        row=$((row + 1))\n    done <<< \"$lst\"\n    echo\
    \ \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuw7stz6k.sh: line 26: [[: 6\\n1: syntax error: invalid arithmetic
    operator (error token is "\\n1")\n/tmp/tmpuw7stz6k.sh: line 26: [[: 6\\n1: syntax
    error: invalid arithmetic operator (error token is "\\n1")\n'''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local arr=()\n    for i in $(echo \"$lst\" | tr\
    \ \" \" \"\\n\"); do\n        if [[ $i == $x ]]; then\n            res+=(\"[\\\
    \"$row\\\", \\\"$col\\\"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n\
    \            row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${res[@]}\" | tr \" \" \"\\n\" | sort\
    \ -t \"\\\"\" -k 1 -n -r -k 2 -n\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"\
    1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4\
    \ 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            result+=(\"[\\\"$row\\\"\
    , \\\"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n   \
    \         row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/'\
    \ | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"\
    ); do\n        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\",\
    \ \\\"$col\\\"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n       \
    \     row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr \" \" \"\\n\" |\
    \ sort -t \"\\\"\" -k 2 -n -r | sort -t \"\\\"\" -k 1 -n\n}\n\ncandidate() {\n\
    \    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5\
    \ 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local -a res\n\
    \    local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a res_sorted\n    local -a row_col_sorted_rev\n    local -a res_sorted_rev\n\
    \    local -a row_col_sorted_rev_str\n    local -a res_sorted_rev_str\n    local\
    \ -a res_str\n    local -a res_str_sorted\n    local -a res_str_sorted_rev\n \
    \   local -a res_str_sorted_rev_str\n    local -a res_str_sorted_rev_str_sorted\n\
    \    local -a res_str_sorted_rev_str_sorted_rev\n    local -a res_str_sorted_rev_str_sorted_rev_str\n\
    \    local -a res_str_sorted_rev_str_sorted_rev_str_sorted\n    local -a res_str_sorted_rev_str_sorted_rev_str_sorted_rev\n\
    \    local -a res_str_sorted_rev_str_sorted_rev_str_sorted_rev_str\n    local\
    \ -a res_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted\n    local -a\
    \ res_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev\n    local -a\
    \ res_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str\n    local\
    \ -a res_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted\n\
    \    local -a res_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev\n\
    \    local -a res_str_sorted_rev_str_sorted_rev_str_sorted_rev\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local line\n    local word\n    while read -r line;\
    \ do\n        col=0\n        while read -r word; do\n            if [[ \"$word\"\
    \ == \"$x\" ]]; then\n                res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n\
    \            fi\n            col=$((col + 1))\n        done <<< \"$line\"\n  \
    \      row=$((row + 1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\" | tr '\
    \ ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5\
    \ 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\"\
    \ \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_rev\n    local -a row_col_sorted_rev_str\n    local\
    \ -a row_col_sorted_rev_str_sorted\n    local -a row_col_sorted_rev_str_sorted_rev\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str\n    local -a row_col_sorted_rev_str_sorted_rev_str_sorted\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev\n    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted\n  \
    \  local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            res+=(\"[\\\"$row\\\", \\\
    \"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n       \
    \     row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local row_len=0\n    local row_len_prev=0\n   \
    \ local row_len_diff=0\n    local row_len_diff_prev=0\n    local row_len_diff_prev_prev=0\n\
    \    local row_len_diff_prev_prev_prev=0\n    local row_len_diff_prev_prev_prev_prev=0\n\
    \    local row_len_diff_prev_prev_prev_prev_prev=0\n    local row_len_diff_prev_prev_prev_prev_prev_prev=0\n\
    \    local row_len_diff_prev_prev_prev_prev_prev_prev_prev=0\n    local row_len_diff_prev_prev_prev_prev_prev_prev_prev_prev=0\n\
    \    local row_len_diff_prev_prev_prev_prev_prev_prev_prev_prev_prev=0\n    local\
    \ row_len_diff_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev=0\n    local\
    \ row_len_diff_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev=0\n    local\
    \ row_len_diff_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev=0\n\
    \    local row_len_diff_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev=0\n\
    \    local row_len_diff_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev=0\n\
    \    local row_len_diff_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev=0\n\
    \    local row_len_diff_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev=0\n\
    \    local row_len_diff_prev_prev_prev_prev_prev_prev_\n}\n\ncandidate() {\n \
    \   get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5\
    \ 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row_num=0\n \
    \   local col_num=0\n    local result=()\n    for row in $lst; do\n        col_num=0\n\
    \        for col in $row; do\n            if [[ $col == $x ]]; then\n        \
    \        result+=(\"[\\\"$row_num\\\", \\\"$col_num\\\"]\")\n            fi\n\
    \            col_num=$((col_num + 1))\n        done\n        row_num=$((row_num\
    \ + 1))\n    done\n    echo ${result[@]} | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    echo \"$lst\" | awk\
    \ -v x=$x '{\n        for (i = 1; i <= NF; i++) {\n            if ($i == x) {\n\
    \                printf(\"[\\\"%s\\\", \\\"%s\\\"] \", NR - 1, i - 1)\n      \
    \      }\n        }\n    }' | sort -t '\"' -k1,1n -k2,2nr\n}\n\ncandidate() {\n\
    \    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5\
    \ 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local row=0\n  local col=0\n\
    \  local res=()\n  local row_len=0\n  local row_arr=()\n  local row_arr_len=0\n\
    \  local row_arr_str=()\n  local row_arr_str_len=0\n  local row_arr_str_str=()\n\
    \  local row_arr_str_str_len=0\n  local row_arr_str_str_str=()\n  local row_arr_str_str_str_len=0\n\
    \  local row_arr_str_str_str_str=()\n  local row_arr_str_str_str_str_len=0\n \
    \ local row_arr_str_str_str_str_str=()\n  local row_arr_str_str_str_str_str_len=0\n\
    \  local row_arr_str_str_str_str_str_str=()\n  local row_arr_str_str_str_str_str_str_len=0\n\
    \  local row_arr_str_str_str_str_str_str_str=()\n  local row_arr_str_str_str_str_str_str_str_len=0\n\
    \  local row_arr_str_str_str_str_str_str_str_str=()\n  local row_arr_str_str_str_str_str_str_str_str_len=0\n\
    \  local row_arr_str_str_str_str_str_str_str_str_str=()\n  local row_arr_str_str_str_str_str_str_str_str_str_len=0\n\
    \  local row_arr_str_str_str_str_str_str_str_str_str_str=()\n  local row_arr_str_str_str_str_str_str_str_str_str_str_len=0\n\
    \  local row_arr_str_str_str_str_str_str_str_str_str_str_str=()\n  local row_arr_str_str_str_str_str_str_str_str_str_\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local ret=()\n    local tmp=()\n    local i=0\n    local j=0\n  \
    \  local k=0\n    local n=0\n    local m=0\n    local p=0\n    local q=0\n   \
    \ local r=0\n    local s=0\n    local t=0\n    local u=0\n    local v=0\n    local\
    \ w=0\n    local x=0\n    local y=0\n    local z=0\n    local aa=0\n    local\
    \ bb=0\n    local cc=0\n    local dd=0\n    local ee=0\n    local ff=0\n    local\
    \ gg=0\n    local hh=0\n    local ii=0\n    local jj=0\n    local kk=0\n    local\
    \ ll=0\n    local mm=0\n    local nn=0\n    local oo=0\n    local pp=0\n    local\
    \ qq=0\n    local rr=0\n    local ss=0\n    local tt=0\n    local uu=0\n    local\
    \ vv=0\n    local ww=0\n    local xx=0\n    local yy=0\n    local zz=0\n    local\
    \ aaa=0\n    local bbb=0\n    local ccc=0\n    local ddd=0\n    local eee=0\n\
    \    local fff=0\n    local ggg=0\n    local hhh=0\n    local iii=0\n    local\
    \ jjj=0\n    local kkk=0\n    local lll=0\n    local mmm=0\n    local nnn=0\n\
    \    local ooo=0\n    local ppp=0\n    local qqq=0\n    local rrr=0\n    local\
    \ sss=0\n    local ttt=0\n    local uuu=0\n    local vvv=0\n    local www=0\n\
    \    local xxx=0\n    local yyy=0\n    local zzz=0\n    local aaaa=0\n    local\
    \ bbbb=0\n    local cccc=0\n    local\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    while read -r line; do\n        col=0\n    \
    \    for i in $line; do\n            if [[ $i == $x ]]; then\n               \
    \ result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${result[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a rows=()\n    local -a cols=()\n    local -a row=()\n    local -a\
    \ col=()\n    local -a row_col=()\n    local -a row_cols=()\n    local -a row_cols_sorted=()\n\
    \    local -a res_sorted=()\n    local -a res_sorted_cols=()\n    local -a res_sorted_cols_sorted=()\n\
    \    local -a res_sorted_cols_sorted_str=()\n    local -a res_sorted_cols_sorted_str_quoted=()\n\
    \    local -a res_sorted_cols_sorted_str_quoted_str=()\n    local -a res_sorted_cols_sorted_str_quoted_str_str=()\n\
    \    local -a res_sorted_cols_sorted_str_quoted_str_str_str=()\n    local -a res_sorted_cols_sorted_str_quoted_str_str_str_str=()\n\
    \    local -a res_sorted_cols_sorted_str_quoted_str_str_str_str_str=()\n    local\
    \ -a res_sorted_cols_sorted_str_quoted_str_str_str_str_str_str=()\n    local -a\
    \ res_sorted_cols_sorted_str_quoted_str_str_str_str_str_str_str=()\n    local\
    \ -a res_sorted_cols_sorted_str_quoted_str_str_str_str_str_str_str_str=()\n  \
    \  local -a res_sorted_cols_sorted_str_quoted_str_str_str_str_str_str_str_str_str=()\n\
    \    local -a res_sorted_cols_sorted_str_quoted_str_str_str_str_str_str_str_str_str_str=()\n\
    \    local -a res_sorted_\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"\
    1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\")\
    \ = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\\
    n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate\
    \ \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=\"\"\n    for i in $(echo \"$lst\" | tr ' ' '\\n');\
    \ do\n        if [ \"$i\" = \"$x\" ]; then\n            result=\"$result [\\\"\
    $row\\\", \\\"$col\\\"]\"\n        fi\n        col=$((col + 1))\n        if [\
    \ \"$i\" = \"$(echo \"$lst\" | tr ' ' '\\n' | tail -n 1)\" ]; then\n         \
    \   row=$((row + 1))\n            col=0\n        fi\n    done\n    echo \"$result\"\
    \ | tr '\\n' ' ' | sed 's/^ *//g' | sed 's/ *$//g'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    while read -r line; do\n        col=0\n    \
    \    for i in $line; do\n            if [[ $i == $x ]]; then\n               \
    \ result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${result[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_desc\n    local -a row_col_sorted_desc_str\n    local\
    \ -a row_col_sorted_desc_str_sorted\n    local -a row_col_sorted_desc_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted\n    local -a row_col_sorted_desc_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted\n    local\
    \ -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str\n    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a res_sorted\n    local -a row_col_sorted_rev\n    local -a res_sorted_rev\n\
    \    local -a row_col_sorted_rev_str\n    local -a res_sorted_rev_str\n    local\
    \ -a res_sorted_rev_str_str\n    local -a res_sorted_rev_str_str_str\n    local\
    \ -a res_sorted_rev_str_str_str_str\n    local -a res_sorted_rev_str_str_str_str_str\n\
    \    local -a res_sorted_rev_str_str_str_str_str_str\n    local -a res_sorted_rev_str_str_str_str_str_str_str\n\
    \    local -a res_sorted_rev_str_str_str_str_str_str_str_str\n    local -a res_sorted_rev_str_str_str_str_str_str_str_str_str\n\
    \    local -a res_sorted_rev_str_str_str_str_str_str_str_str_str_str\n    local\
    \ -a res_sorted_rev_str_str_str_str_str_str_str_str_str_str_str\n    local -a\
    \ res_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str\n    local -a\
    \ res_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str_str\n    local\
    \ -a res_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a res_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a res_sorted\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"\
    1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\")\
    \ = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\\
    n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate\
    \ \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local row=0\n  local col=0\n\
    \  local res=()\n  while read -r line; do\n    col=0\n    for i in $line; do\n\
    \      if [ \"$i\" == \"$x\" ]; then\n        res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n      fi\n      col=$((col+1))\n    done\n    row=$((row+1))\n  done <<<\
    \ \"$lst\"\n  echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a res_sorted\n    local -a row_col_sorted_rev\n    local -a res_sorted_rev\n\
    \    local -a res_sorted_rev_str\n    local -a res_sorted_rev_str_quoted\n   \
    \ local -a res_sorted_rev_str_quoted_joined\n    local -a res_sorted_rev_str_quoted_joined_quoted\n\
    \    local -a res_sorted_rev_str_quoted_joined_quoted_joined\n    local -a res_sorted_rev_str_quoted_joined_quoted_joined_quoted\n\
    \    local -a res_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined\n \
    \   local -a res_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted\n\
    \    local -a res_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted_joined\n\
    \    local -a res_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted\n\
    \    local -a res_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined\n\
    \    local -a res_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted\n\
    \    local -a res_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined\n\
    \    local -a res_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted\n\
    \    local -a res_sorted_rev_str_quoted\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row=0\n\
    \    local col=0\n    local result=()\n    while read -r line; do\n        col=0\n\
    \        for i in $line; do\n            if [[ \"$i\" == \"$x\" ]]; then\n   \
    \             result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n   \
    \         col=$((col+1))\n        done\n        row=$((row+1))\n    done <<< \"\
    $lst\"\n    echo \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3\
    \ 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1\
    \ 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ row=0\n    local col=0\n    local row_len=0\n    local row_arr=()\n    local\
    \ row_arr_len=0\n    local row_arr_str=''\n    local row_arr_str_len=0\n    local\
    \ row_arr_str_arr=()\n    local row_arr_str_arr_len=0\n    local row_arr_str_arr_str=''\n\
    \    local row_arr_str_arr_str_len=0\n    local row_arr_str_arr_str_arr=()\n \
    \   local row_arr_str_arr_str_arr_len=0\n    local row_arr_str_arr_str_arr_str=''\n\
    \    local row_arr_str_arr_str_arr_str_len=0\n    local row_arr_str_arr_str_arr_str_arr=()\n\
    \    local row_arr_str_arr_str_arr_str_arr_len=0\n    local row_arr_str_arr_str_arr_str_arr_str=''\n\
    \    local row_arr_str_arr_str_arr_str_arr_str_len=0\n    local row_arr_str_arr_str_arr_str_arr_str_arr=()\n\
    \    local row_arr_str_arr_str_arr_str_arr_str_arr_len=0\n    local row_arr_str_arr_str_arr_str_arr_str_arr_str=''\n\
    \    local row_arr_str_arr_str_arr_str_arr_str_arr_str_len=0\n    local row_arr_str_arr_str_arr_str_arr_str_arr_str_arr=()\n\
    \    local row_arr_str_arr_str_arr_str_arr_str_arr_str_arr_len=0\n    local row_arr_str_arr_str_arr_str_arr_str_arr_str_arr_str=''\n\
    \    local row_arr_str_arr_str_arr_str_arr_str_arr_str_\n}\n\ncandidate() {\n\
    \    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5\
    \ 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row=0\n\
    \    local col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\\
    n'); do\n        if [[ \"$i\" == \"$x\" ]]; then\n            result+=(\"[\\\"\
    $row\\\", \\\"$col\\\"]\")\n        fi\n        col=$((col + 1))\n        if [[\
    \ \"$i\" == \"$(echo \"$lst\" | tr ' ' '\\n' | tail -n 1)\" ]]; then\n       \
    \     row=$((row + 1))\n            col=0\n        fi\n    done\n    echo \"${result[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            result+=(\"[\\\"$row\\\"\
    , \\\"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n   \
    \         row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    while read line; do\n        col=0\n   \
    \     for item in $line; do\n            if [ \"$item\" == \"$x\" ]; then\n  \
    \              result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n  \
    \          col=$((col+1))\n        done\n        row=$((row+1))\n    done <<<\
    \ \"$lst\"\n    echo \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=\"$1\"\n  local x=\"$2\"\n  local -a res\n  local\
    \ -a row\n  local -a col\n  local -a row_col\n  local -a row_col_sorted\n  local\
    \ -a res_sorted\n  local -a res_sorted_col\n  local -a res_sorted_col_sorted\n\
    \  local -a res_sorted_col_sorted_str\n  local -a res_sorted_col_sorted_str_sorted\n\
    \  local -a res_sorted_col_sorted_str_sorted_str\n  local -a res_sorted_col_sorted_str_sorted_str_sorted\n\
    \  local -a res_sorted_col_sorted_str_sorted_str_sorted_str\n  local -a res_sorted_col_sorted_str_sorted_str_sorted_str_sorted\n\
    \  local -a res_sorted_col_sorted_str_sorted_str_sorted_str_sorted_str\n  local\
    \ -a res_sorted_col_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n  local\
    \ -a res_sorted_col_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n \
    \ local -a res_sorted_col_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \  local -a res_sorted_col_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \  local -a res_sorted_col_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \  local -a res_sorted_col_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \  local -a res_sorted_col_sorted_str_s\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ i=0\n    local j=0\n    while read -r line; do\n        j=0\n        for y in\
    \ $line; do\n            if [[ $y == $x ]]; then\n                res+=([\"$i,$j\"\
    ])\n            fi\n            j=$((j+1))\n        done\n        i=$((i+1))\n\
    \    done <<< \"$lst\"\n    local res_str=$(printf '%s\\n' \"${res[@]}\" | sort\
    \ -t, -k1n -k2nr | sed 's/^/\"/;s/$/\"/')\n    echo \"[$res_str]\"\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local row_res=()\n    local row_res_str=\"\"\n\
    \    local res_str=\"\"\n    while read -r line; do\n        col=0\n        row_res=()\n\
    \        for i in $line; do\n            if [[ $i == $x ]]; then\n           \
    \     row_res+=(\"$row\" \"$col\")\n            fi\n            col=$((col+1))\n\
    \        done\n        if [[ ${#row_res[@]} -gt 0 ]]; then\n            row_res_str=$(echo\
    \ ${row_res[@]} | tr ' ' ',')\n            res+=(\"[$row_res_str]\")\n       \
    \ fi\n        row=$((row+1))\n    done <<< \"$lst\"\n    res_str=$(echo ${res[@]}\
    \ | tr ' ' ',')\n    echo \"[$res_str]\"\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result=()\n\
    \    local -i i=0\n    local -i j=0\n    local -i k=0\n    local -i l=0\n    local\
    \ -i m=0\n    local -i n=0\n    local -i o=0\n    local -i p=0\n    local -i q=0\n\
    \    local -i r=0\n    local -i s=0\n    local -i t=0\n    local -i u=0\n    local\
    \ -i v=0\n    local -i w=0\n    local -i x=0\n    local -i y=0\n    local -i z=0\n\
    \    local -i aa=0\n    local -i bb=0\n    local -i cc=0\n    local -i dd=0\n\
    \    local -i ee=0\n    local -i ff=0\n    local -i gg=0\n    local -i hh=0\n\
    \    local -i ii=0\n    local -i jj=0\n    local -i kk=0\n    local -i ll=0\n\
    \    local -i mm=0\n    local -i nn=0\n    local -i oo=0\n    local -i pp=0\n\
    \    local -i qq=0\n    local -i rr=0\n    local -i ss=0\n    local -i tt=0\n\
    \    local -i uu=0\n    local -i vv=0\n    local -i ww=0\n    local -i xx=0\n\
    \    local -i yy=0\n    local -i zz=0\n    local -i aaa=0\n    local -i bbb=0\n\
    \    local -i ccc=0\n    local -i ddd=0\n    local -i eee=0\n    local -i fff=0\n\
    \    local -i ggg=0\n    local -i hhh=0\n    local -i iii=0\n    local -i jjj=0\n\
    \    local -i kkk=0\n    local -i lll=0\n    local -i mmm=0\n    local -i n\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo $lst | tr ' ' '\\n'); do\n \
    \       if [[ $i == $x ]]; then\n            result+=([\"$row,$col\"])\n     \
    \   fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row+1))\n    \
    \        col=0\n        else\n            col=$((col+1))\n        fi\n    done\n\
    \    if [[ ${#result[@]} -eq 0 ]]; then\n        echo \"[]\"\n    else\n     \
    \   echo \"[\"\n        for i in \"${!result[@]}\"; do\n            echo \"[\\\
    \"${i%%,*}\\\", \\\"${i##*,}\\\"]\"\n        done\n        echo \"]\"\n    fi\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    local row_result=()\n    for i in $lst;\
    \ do\n        if [[ $i == $x ]]; then\n            row_result=(\"$row\" \"$col\"\
    )\n            result+=(\"${row_result[@]}\")\n        fi\n        if [[ $i ==\
    \ *\"\\n\"* ]]; then\n            row=$((row + 1))\n            col=0\n      \
    \  else\n            col=$((col + 1))\n        fi\n    done\n    echo \"${result[@]}\"\
    \ | tr ' ' '\\n' | sort -n -k1 -k2 -r | tr '\\n' ' '\n}\n\ncandidate() {\n   \
    \ get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n   \
    \ [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row=0\n\
    \    local col=0\n    local result=\"\"\n    for i in $(echo \"$lst\" | tr \"\
    \ \" \"\\n\"); do\n        if [ \"$i\" == \"$x\" ]; then\n            result=\"\
    $result [\\\"$row\\\", \\\"$col\\\"]\"\n        fi\n        if [ \"$i\" == \"\\\
    n\" ]; then\n            row=$((row + 1))\n            col=0\n        else\n \
    \           col=$((col + 1))\n        fi\n    done\n    echo \"$result\" | sort\
    \ -t '\"' -k 2 -n -r | sort -t '\"' -k 1 -n\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\" | tr \" \" \"\\n\" | sort -t \"\\\"\"\
    \ -k 2 -n -r | sort -t \"\\\"\" -k 1 -n\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    for i in $(echo \"$lst\" | tr ' ' '\\n');\
    \ do\n        if [[ \"$i\" == \"$x\" ]]; then\n            result+=(\"[\\\"$row\\\
    \", \\\"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n \
    \           row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/'\
    \ | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local row_res=()\n    for i in $(echo \"$lst\"\
    \ | tr \" \" \"\\n\"); do\n        if [[ $i == $x ]]; then\n            row_res+=(\"\
    $row\")\n            row_res+=(\"$col\")\n            res+=(\"$(echo \"${row_res[@]}\"\
    \ | tr \" \" \",\")\")\n            row_res=()\n        fi\n        if [[ $i ==\
    \ \"\\n\" ]]; then\n            row=$((row + 1))\n            col=0\n        else\n\
    \            col=$((col + 1))\n        fi\n    done\n    echo \"${res[@]}\" |\
    \ tr \" \" \"\\n\" | sort -t \",\" -k 1 -n -k 2 -r | tr \"\\n\" \" \"\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            result+=(\"[\\\"$row\\\"\
    , \\\"$col\\\"]\")\n        fi\n        if [[ \"$i\" == $'\\n' ]]; then\n    \
    \        row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local row_res=()\n    local col_res=()\n    local\
    \ row_len=0\n    local col_len=0\n    local i=0\n    local j=0\n    local k=0\n\
    \    local l=0\n    local m=0\n    local n=0\n    local p=0\n    local q=0\n \
    \   local r=0\n    local s=0\n    local t=0\n    local u=0\n    local v=0\n  \
    \  local w=0\n    local x=0\n    local y=0\n    local z=0\n    local aa=0\n  \
    \  local bb=0\n    local cc=0\n    local dd=0\n    local ee=0\n    local ff=0\n\
    \    local gg=0\n    local hh=0\n    local ii=0\n    local jj=0\n    local kk=0\n\
    \    local ll=0\n    local mm=0\n    local nn=0\n    local oo=0\n    local pp=0\n\
    \    local qq=0\n    local rr=0\n    local ss=0\n    local tt=0\n    local uu=0\n\
    \    local vv=0\n    local ww=0\n    local xx=0\n    local yy=0\n    local zz=0\n\
    \    local aaa=0\n    local bbb=0\n    local ccc=0\n    local ddd=0\n    local\
    \ eee=0\n    local fff=0\n    local ggg=0\n    local hhh=0\n    local iii=0\n\
    \    local jjj=0\n    local kkk=0\n    local lll=0\n    local mmm=0\n    local\
    \ nnn=0\n    local ooo=0\n    local ppp=0\n    local qqq=0\n    local rrr=0\n\
    \    local sss=0\n    local ttt=0\n    local uuu=0\n    local vvv=0\n    local\
    \ www=0\n    local xxx=0\n    local yyy=0\n\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result=()\n\
    \    local -a row=()\n    local -a col=()\n    local -a rows=()\n    local -a\
    \ cols=()\n    local -a sorted_rows=()\n    local -a sorted_cols=()\n    local\
    \ -a sorted_result=()\n    local -a sorted_result_cols=()\n    local -a sorted_result_rows=()\n\
    \    local -a sorted_result_cols_rows=()\n    local -a sorted_result_rows_cols=()\n\
    \    local -a sorted_result_rows_cols_rows=()\n    local -a sorted_result_rows_cols_rows_cols=()\n\
    \    local -a sorted_result_rows_cols_rows_cols_rows=()\n    local -a sorted_result_rows_cols_rows_cols_rows_cols=()\n\
    \    local -a sorted_result_rows_cols_rows_cols_rows_cols_rows=()\n    local -a\
    \ sorted_result_rows_cols_rows_cols_rows_cols_rows_cols=()\n    local -a sorted_result_rows_cols_rows_cols_rows_cols_rows_cols_rows=()\n\
    \    local -a sorted_result_rows_cols_rows_cols_rows_cols_rows_cols_rows_cols=()\n\
    \    local -a sorted_result_rows_cols_rows_cols_rows_cols_rows_cols_rows_cols_rows=()\n\
    \    local -a sorted_result_rows_cols_rows_cols_rows_cols_rows_cols_rows_cols_rows_cols=()\n\
    \    local -a sorted_result_rows_cols_rows_cols_rows_cols_rows_cols_rows_cols_rows_cols_rows=()\n\
    \    local -a sorted_result_rows_cols_rows_cols_rows_cols_rows_cols_rows_cols_rows_cols_rows_cols=()\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local -a\
    \ row_col_res=()\n    local -a row_col_res_sorted=()\n    local -a row_col_res_sorted_res=()\n\
    \    local -a row_col_res_sorted_res_sorted=()\n    local -a row_col_res_sorted_res_sorted_res=()\n\
    \    local -a row_col_res_sorted_res_sorted_res_sorted=()\n    local -a row_col_res_sorted_res_sorted_res_sorted_res=()\n\
    \    local -a row_col_res_sorted_res_sorted_res_sorted_res_sorted=()\n    local\
    \ -a row_col_res_sorted_res_sorted_res_sorted_res_sorted_res=()\n    local -a\
    \ row_col_res_sorted_res_sorted_res_sorted_res_sorted_res_sorted=()\n    local\
    \ -a row_col_res_sorted_res_sorted_res_sorted_res_sorted_res_sorted_res=()\n \
    \   local -a row_col_res_sorted_res_sorted_res_sorted_res_sorted_res_sorted_res_sorted=()\n\
    \    local -a row_col_res_sorted_res_sorted_res_sorted_res_sorted_res_sorted_res_sorted_res=()\n\
    \    local -a row_col_res_sorted_res_sorted_res_sorted_res_sorted_res_sorted_res_sorted_res_sorted=()\n\
    \    local -a row_col_res_sorted_res_sorted_res_sorted_res_sorted_res_sorted_res_sorted_res_sorted_res=()\n\
    \    local -a row_col_res_sorted_res_sorted_\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            res+=(\"[\\\"$row\\\", \\\
    \"$col\\\"]\")\n        fi\n        if [[ \"$i\" == $'\\n' ]]; then\n        \
    \    ((row++))\n            col=0\n        else\n            ((col++))\n     \
    \   fi\n    done\n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a col=()\n    local -a row_idx=()\n    local -a\
    \ col_idx=()\n    local -a row_col=()\n    local -a row_col_idx=()\n    local\
    \ -a row_col_idx_sorted=()\n    local -a row_col_sorted=()\n    local -a row_col_sorted_idx=()\n\
    \    local -a row_col_sorted_idx_sorted=()\n    local -a row_col_sorted_sorted=()\n\
    \    local -a row_col_sorted_sorted_idx=()\n    local -a row_col_sorted_sorted_idx_sorted=()\n\
    \    local -a row_col_sorted_sorted_sorted=()\n    local -a row_col_sorted_sorted_sorted_idx=()\n\
    \    local -a row_col_sorted_sorted_sorted_idx_sorted=()\n    local -a row_col_sorted_sorted_sorted_sorted=()\n\
    \    local -a row_col_sorted_sorted_sorted_sorted_idx=()\n    local -a row_col_sorted_sorted_sorted_sorted_idx_sorted=()\n\
    \    local -a row_col_sorted_sorted_sorted_sorted_sorted=()\n    local -a row_col_sorted_sorted_sorted_sorted_sorted_idx=()\n\
    \    local -a row_col_sorted_sorted_sorted_sorted_sorted_idx_sorted=()\n    local\
    \ -a row_col_sorted_sorted_sorted_sorted_sorted_sorted=()\n    local -a row_col_sorted_sorted_sorted_sorted_sorted_sorted_idx=()\n\
    \    local -a row_col_sorted_sorted_sorted_sorted_sorted_s\n}\n\ncandidate() {\n\
    \    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5\
    \ 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=\"$1\"\n  local x=\"$2\"\n  local -a res=()\n\
    \  local -a row=()\n  local -a rows=()\n  local -a cols=()\n  local -a col=()\n\
    \  local -a cols_sorted=()\n  local -a rows_sorted=()\n  local -a res_sorted=()\n\
    \  local -a res_sorted_cols=()\n  local -a res_sorted_rows=()\n  local -a res_sorted_rows_cols=()\n\
    \  local -a res_sorted_rows_cols_sorted=()\n  local -a res_sorted_rows_cols_sorted_str=()\n\
    \  local -a res_sorted_rows_cols_sorted_str_sorted=()\n  local -a res_sorted_rows_cols_sorted_str_sorted_str=()\n\
    \  local -a res_sorted_rows_cols_sorted_str_sorted_str_sorted=()\n  local -a res_sorted_rows_cols_sorted_str_sorted_str_sorted_str=()\n\
    \  local -a res_sorted_rows_cols_sorted_str_sorted_str_sorted_str_sorted=()\n\
    \  local -a res_sorted_rows_cols_sorted_str_sorted_str_sorted_str_sorted_str=()\n\
    \  local -a res_sorted_rows_cols_sorted_str_sorted_str_sorted_str_sorted_str_sorted=()\n\
    \  local -a res_sorted_rows_cols_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str=()\n\
    \  local -a res_sorted_rows_cols_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted=()\n\
    \  local -a res_sorted_rows_cols_sorted_str_sorted_str_sorted_str_sorted_\n}\n\
    \ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_rev\n    local -a res_sorted\n    local -a res_sorted_rev\n\
    \    local -a res_sorted_rev_str\n    local -a res_sorted_rev_str_str\n    local\
    \ -a res_sorted_rev_str_str_str\n    local -a res_sorted_rev_str_str_str_str\n\
    \    local -a res_sorted_rev_str_str_str_str_str\n    local -a res_sorted_rev_str_str_str_str_str_str\n\
    \    local -a res_sorted_rev_str_str_str_str_str_str_str\n    local -a res_sorted_rev_str_str_str_str_str_str_str_str\n\
    \    local -a res_sorted_rev_str_str_str_str_str_str_str_str_str\n    local -a\
    \ res_sorted_rev_str_str_str_str_str_str_str_str_str_str\n    local -a res_sorted_rev_str_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a res_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a res_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a res_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a res_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a res_sorted_rev_str_str_str_str_str_str_\n}\n\ncandidate() {\n  \
    \  get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n   \
    \ [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    for i in $(echo \"$lst\" | tr -s ' ' '\\\
    n'); do\n        if [ \"$i\" == \"$x\" ]; then\n            result+=(\"[\\\"$row\\\
    \", \\\"$col\\\"]\")\n        fi\n        if [ \"$i\" == \"$(echo \"$lst\" | tr\
    \ -s ' ' '\\n' | tail -n 1)\" ]; then\n            row=$((row + 1))\n        \
    \    col=0\n        else\n            col=$((col + 1))\n        fi\n    done\n\
    \    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a arr\n    local\
    \ -a res\n    local -a tmp\n    local -a tmp2\n    local -a tmp3\n    local -a\
    \ tmp4\n    local -a tmp5\n    local -a tmp6\n    local -a tmp7\n    local -a\
    \ tmp8\n    local -a tmp9\n    local -a tmp10\n    local -a tmp11\n    local -a\
    \ tmp12\n    local -a tmp13\n    local -a tmp14\n    local -a tmp15\n    local\
    \ -a tmp16\n    local -a tmp17\n    local -a tmp18\n    local -a tmp19\n    local\
    \ -a tmp20\n    local -a tmp21\n    local -a tmp22\n    local -a tmp23\n    local\
    \ -a tmp24\n    local -a tmp25\n    local -a tmp26\n    local -a tmp27\n    local\
    \ -a tmp28\n    local -a tmp29\n    local -a tmp30\n    local -a tmp31\n    local\
    \ -a tmp32\n    local -a tmp33\n    local -a tmp34\n    local -a tmp35\n    local\
    \ -a tmp36\n    local -a tmp37\n    local -a tmp38\n    local -a tmp39\n    local\
    \ -a tmp40\n    local -a tmp41\n    local -a tmp42\n    local -a tmp43\n    local\
    \ -a tmp44\n    local -a tmp45\n    local -a tmp46\n    local -a tmp47\n    local\
    \ -a tmp48\n    local -a tmp49\n    local -a tmp50\n    local -a tmp51\n    local\
    \ -a tmp52\n    local -a tmp53\n    local -a tmp54\n    local -a tmp55\n    local\
    \ -a tmp56\n    local -a tmp57\n    local -a tmp58\n    local -a tmp59\n    local\
    \ -a tmp60\n    local -a tmp61\n    local -a tmp62\n    local -a tmp63\n    local\
    \ -a tmp64\n    local -a tmp65\n    local -a tmp66\n    local -a tmp67\n    local\
    \ -a tmp68\n    local -a tmp69\n    local -a\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=\"\"\n\
    \    local row=0\n    local col=0\n    for i in $(echo \"$lst\" | tr \" \" \"\\\
    n\"); do\n        if [ \"$i\" = \"$x\" ]; then\n            result=\"$result [\\\
    \"$row\\\", \\\"$col\\\"]\"\n        fi\n        if [ \"$i\" = \"\\n\" ]; then\n\
    \            row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"$result\" | sort -k1,1n -k2,2nr | tr\
    \ -d \" \"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\\
    n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\\
    n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\
    \ = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\"\
    \ ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\"\
    ) = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a col=()\n    local -a tmp=()\n    local i=0\n\
    \    local j=0\n    local k=0\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"\
    ); do\n        if [[ $i == $x ]]; then\n            row+=($k)\n            col+=($j)\n\
    \        fi\n        if [[ $i == \"\\n\" ]]; then\n            k=$((k+1))\n  \
    \          j=0\n        else\n            j=$((j+1))\n        fi\n    done\n \
    \   for ((i=0; i<${#row[@]}; i++)); do\n        tmp+=(\"${row[i]}\" \"${col[i]}\"\
    )\n    done\n    res=($(echo \"${tmp[@]}\" | tr \" \" \"\\n\" | sort -n | tr \"\
    \\n\" \" \"))\n    for ((i=0; i<${#res[@]}; i+=2)); do\n        echo \"[\\\"${res[i]}\\\
    \", \\\"${res[i+1]}\\\"]\"\n    done\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    echo \"$lst\"\
    \ | awk -v x=\"$x\" '\n    BEGIN {\n        RS=\"\\n\";\n        FS=\" \";\n \
    \       OFS=\"\\\"\";\n        ORS=\"], [\";\n    }\n    {\n        for (i = 1;\
    \ i <= NF; i++) {\n            if ($i == x) {\n                print \"\\\"\"\
    \ NR - 1 \"\\\"\", \"\\\"\" i - 1 \"\\\"\";\n            }\n        }\n    }\n\
    \    END {\n        print \"]\";\n    }' | sed 's/^/[/'\n}\n\ncandidate() {\n\
    \    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5\
    \ 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ while read -r num; do\n            if [[ $num -eq $x ]]; then\n            \
    \    res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done <<< \"$line\"\n        row=$((row+1))\n    done <<< \"$lst\"\n \
    \   echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"\
    1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\")\
    \ = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\\
    n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate\
    \ \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6f301mxd.sh: line 26: [[: 1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3
    4 5 1: syntax error in expression (error token is "2 3 4 5 6\\n1 2 3 4 1 6\\n1
    2 3 4 5 1")\n'''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    while read -r line; do\n        col=0\n    \
    \    for i in $line; do\n            if [[ $i == $x ]]; then\n               \
    \ result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${result[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    local row_col=()\n    for i in $(echo \"\
    $lst\" | tr \" \" \"\\n\"); do\n        if [[ $i == $x ]]; then\n            row_col+=(\"\
    $row\")\n            row_col+=(\"$col\")\n            result+=(\"$(echo \"${row_col[@]}\"\
    \ | tr \" \" \",\")\")\n            row_col=()\n        fi\n        if [[ $i ==\
    \ \"\\n\" ]]; then\n            row=$((row + 1))\n            col=0\n        else\n\
    \            col=$((col + 1))\n        fi\n    done\n    echo \"${result[@]}\"\
    \ | tr \" \" \"\\n\" | sort -t \",\" -k 1n -k 2nr | tr \"\\n\" \" \"\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row=0\n\
    \    local col=0\n    local res=()\n    local row_res=()\n    local col_res=()\n\
    \    local row_res_sorted=()\n    local col_res_sorted=()\n    local res_sorted=()\n\
    \    local res_str=()\n    local res_str_sorted=()\n    local res_str_sorted_str=()\n\
    \    local res_str_sorted_str_sorted=()\n    local res_str_sorted_str_sorted_str=()\n\
    \    local res_str_sorted_str_sorted_str_sorted=()\n    local res_str_sorted_str_sorted_str_sorted_str=()\n\
    \    local res_str_sorted_str_sorted_str_sorted_str_sorted=()\n    local res_str_sorted_str_sorted_str_sorted_str_sorted_str=()\n\
    \    local res_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted=()\n   \
    \ local res_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str=()\n  \
    \  local res_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted=()\n\
    \    local res_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str=()\n\
    \    local res_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted=()\n\
    \    local res_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str=()\n\
    \    local res_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local -a result\n\
    \    local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_rev\n    local -a result_sorted\n    local -a result_sorted_rev\n\
    \    local -a result_sorted_rev_str\n    local -a result_sorted_rev_str_quoted\n\
    \    local -a result_sorted_rev_str_quoted_joined\n    local -a result_sorted_rev_str_quoted_joined_str\n\
    \    local -a result_sorted_rev_str_quoted_joined_str_quoted\n    local -a result_sorted_rev_str_quoted_joined_str_quoted_joined\n\
    \    local -a result_sorted_rev_str_quoted_joined_str_quoted_joined_str\n    local\
    \ -a result_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted\n    local\
    \ -a result_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted_joined\n\
    \    local -a result_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted_joined_str\n\
    \    local -a result_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted_joined_str_quoted\n\
    \    local -a result_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted_joined_str_quoted_joined\n\
    \    local -a result_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted_joined_str_quoted_joined_str\n\
    \    local -a result_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted_joined_str_quoted_joined_str_quoted\n\
    \    local -a result_sorted_rev_str_quoted_joined_str_quoted_joined_\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_desc\n    local -a row_col_sorted_desc_str\n    local\
    \ -a row_col_sorted_desc_str_sorted\n    local -a row_col_sorted_desc_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted\n    local -a row_col_sorted_desc_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted\n    local\
    \ -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str\n    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local -a\
    \ row_col_sorted=()\n    local -a res_sorted=()\n    local -a row_col_sorted_desc=()\n\
    \    local -a res_sorted_desc=()\n    local -a res_sorted_desc_str=()\n    local\
    \ -a res_sorted_desc_str_quoted=()\n    local -a res_sorted_desc_str_quoted_str=()\n\
    \    local -a res_sorted_desc_str_quoted_str_joined=()\n    local -a res_sorted_desc_str_quoted_str_joined_str=()\n\
    \    local -a res_sorted_desc_str_quoted_str_joined_str_joined=()\n    local -a\
    \ res_sorted_desc_str_quoted_str_joined_str_joined_str=()\n    local -a res_sorted_desc_str_quoted_str_joined_str_joined_str_joined=()\n\
    \    local -a res_sorted_desc_str_quoted_str_joined_str_joined_str_joined_str=()\n\
    \    local -a res_sorted_desc_str_quoted_str_joined_str_joined_str_joined_str_joined=()\n\
    \    local -a res_sorted_desc_str_quoted_str_joined_str_joined_str_joined_str_joined_str=()\n\
    \    local -a res_sorted_desc_str_quoted_str_joined_str_joined_str_joined_str_joined_str_joined=()\n\
    \    local -a res_sorted_desc_str_quoted_str_joined_str_joined_str_joined_str_joined_str_joined_str=()\n\
    \    local -a res_sorted_desc_str_quoted_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined=()\n\
    \    local -a res_s\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            res+=(\"[\\\"$row\\\", \\\
    \"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n       \
    \     row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/'\
    \ | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local row=0\n  local col=0\n\
    \  local result=()\n  while read line; do\n    col=0\n    for i in $line; do\n\
    \      if [[ $i == $x ]]; then\n        result+=(\"[\\\"$row\\\", \\\"$col\\\"\
    ]\")\n      fi\n      col=$((col+1))\n    done\n    row=$((row+1))\n  done <<<\
    \ \"$lst\"\n  echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    while read -r line; do\n        col=0\n    \
    \    for i in $line; do\n            if [[ $i == $x ]]; then\n               \
    \ result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${result[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    local row_result=()\n    while read -r line;\
    \ do\n        col=0\n        row_result=()\n        for i in $line; do\n     \
    \       if [[ $i == $x ]]; then\n                row_result+=($row $col)\n   \
    \         fi\n            col=$((col+1))\n        done\n        if [[ ${#row_result[@]}\
    \ -gt 0 ]]; then\n            result+=(${row_result[@]})\n        fi\n       \
    \ row=$((row+1))\n    done <<< \"$lst\"\n    if [[ ${#result[@]} -gt 0 ]]; then\n\
    \        echo \"${result[@]}\" | tr ' ' '\\n' | sort -n -k1 -k2 -r | tr '\\n'\
    \ ' '\n    else\n        echo \"[]\"\n    fi\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result=()\n\
    \    local -a row=()\n    local -a col=()\n    local -a tmp=()\n    local -a tmp2=()\n\
    \    local -a tmp3=()\n    local -a tmp4=()\n    local -a tmp5=()\n    local -a\
    \ tmp6=()\n    local -a tmp7=()\n    local -a tmp8=()\n    local -a tmp9=()\n\
    \    local -a tmp10=()\n    local -a tmp11=()\n    local -a tmp12=()\n    local\
    \ -a tmp13=()\n    local -a tmp14=()\n    local -a tmp15=()\n    local -a tmp16=()\n\
    \    local -a tmp17=()\n    local -a tmp18=()\n    local -a tmp19=()\n    local\
    \ -a tmp20=()\n    local -a tmp21=()\n    local -a tmp22=()\n    local -a tmp23=()\n\
    \    local -a tmp24=()\n    local -a tmp25=()\n    local -a tmp26=()\n    local\
    \ -a tmp27=()\n    local -a tmp28=()\n    local -a tmp29=()\n    local -a tmp30=()\n\
    \    local -a tmp31=()\n    local -a tmp32=()\n    local -a tmp33=()\n    local\
    \ -a tmp34=()\n    local -a tmp35=()\n    local -a tmp36=()\n    local -a tmp37=()\n\
    \    local -a tmp38=()\n    local -a tmp39=()\n    local -a tmp40=()\n    local\
    \ -a tmp41=()\n    local -a tmp42=()\n    local -a tmp43=()\n    local -a tmp44=()\n\
    \    local -a tmp45=()\n    local -a tmp46=()\n    local -a tmp47=()\n    local\
    \ -a tmp48=()\n    local -a tmp49=()\n    local -a tmp50=()\n    local -a tmp51=()\n\
    \    local -a tmp52=()\n    local -a tmp53=\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result=()\n\
    \    local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local\
    \ -a row_col_sorted=()\n    local -a row_col_sorted_rev=()\n    local -a row_col_sorted_rev_str=()\n\
    \    local -a row_col_sorted_rev_str_quoted=()\n    local -a row_col_sorted_rev_str_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_str=()\n    local -a row_col_sorted_rev_str_quoted_joined_str_quoted=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined=()\n    local\
    \ -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined_str=()\n    local\
    \ -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted=()\n  \
    \  local -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted_joined_str=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted_joined_str_quoted=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted_joined_str_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted_joined_str_quoted_joined_str=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined_str_\n}\n\
    \ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for word in $line; do\n            if [[ $word == $x ]]; then\n            \
    \    res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            ((col++))\n\
    \        done\n        ((row++))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=\"$1\"\n  local x=\"$2\"\n  local -a arr\n  local\
    \ -a arr_x\n  local -a arr_y\n  local -a arr_res\n  local -a arr_res_x\n  local\
    \ -a arr_res_y\n  local i=0\n  local j=0\n  local k=0\n  local l=0\n  local m=0\n\
    \  local n=0\n  local p=0\n  local q=0\n  local r=0\n  local s=0\n  local t=0\n\
    \  local u=0\n  local v=0\n  local w=0\n  local x=0\n  local y=0\n  local z=0\n\
    \  local aa=0\n  local bb=0\n  local cc=0\n  local dd=0\n  local ee=0\n  local\
    \ ff=0\n  local gg=0\n  local hh=0\n  local ii=0\n  local jj=0\n  local kk=0\n\
    \  local ll=0\n  local mm=0\n  local nn=0\n  local oo=0\n  local pp=0\n  local\
    \ qq=0\n  local rr=0\n  local ss=0\n  local tt=0\n  local uu=0\n  local vv=0\n\
    \  local ww=0\n  local xx=0\n  local yy=0\n  local zz=0\n  local aaa=0\n  local\
    \ bbb=0\n  local ccc=0\n  local ddd=0\n  local eee=0\n  local fff=0\n  local ggg=0\n\
    \  local hhh=0\n  local iii=0\n  local jjj=0\n  local kkk=0\n  local lll=0\n \
    \ local mmm=0\n  local nnn=0\n  local ooo=0\n  local ppp=0\n  local qqq=0\n  local\
    \ rrr=0\n  local sss=0\n  local ttt=0\n  local uuu=0\n  local vvv=0\n  local www=0\n\
    \  local xxx=0\n  local y\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"\
    1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\")\
    \ = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\\
    n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate\
    \ \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a arr=()\n \
    \   local -a res=()\n    local -a tmp=()\n    local -a tmp2=()\n    local -a tmp3=()\n\
    \    local -a tmp4=()\n    local -a tmp5=()\n    local -a tmp6=()\n    local -a\
    \ tmp7=()\n    local -a tmp8=()\n    local -a tmp9=()\n    local -a tmp10=()\n\
    \    local -a tmp11=()\n    local -a tmp12=()\n    local -a tmp13=()\n    local\
    \ -a tmp14=()\n    local -a tmp15=()\n    local -a tmp16=()\n    local -a tmp17=()\n\
    \    local -a tmp18=()\n    local -a tmp19=()\n    local -a tmp20=()\n    local\
    \ -a tmp21=()\n    local -a tmp22=()\n    local -a tmp23=()\n    local -a tmp24=()\n\
    \    local -a tmp25=()\n    local -a tmp26=()\n    local -a tmp27=()\n    local\
    \ -a tmp28=()\n    local -a tmp29=()\n    local -a tmp30=()\n    local -a tmp31=()\n\
    \    local -a tmp32=()\n    local -a tmp33=()\n    local -a tmp34=()\n    local\
    \ -a tmp35=()\n    local -a tmp36=()\n    local -a tmp37=()\n    local -a tmp38=()\n\
    \    local -a tmp39=()\n    local -a tmp40=()\n    local -a tmp41=()\n    local\
    \ -a tmp42=()\n    local -a tmp43=()\n    local -a tmp44=()\n    local -a tmp45=()\n\
    \    local -a tmp46=()\n    local -a tmp47=()\n    local -a tmp48=()\n    local\
    \ -a tmp49=()\n    local -a tmp50=()\n    local -a tmp51=()\n    local -a tmp52=()\n\
    \    local -a tmp53=()\n    local -a tmp54\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local row_len=0\n    local tmp=()\n    for i in\
    \ $(echo \"$lst\" | tr ' ' '\\n'); do\n        if [[ $i == $x ]]; then\n     \
    \       res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n        fi\n        col=$((col\
    \ + 1))\n        if [[ $i == $'\\n' ]]; then\n            if [[ $col -gt $row_len\
    \ ]]; then\n                row_len=$col\n            fi\n            col=0\n\
    \            row=$((row + 1))\n        fi\n    done\n    for i in $(seq 0 $((row_len\
    \ - 1))); do\n        for j in \"${res[@]}\"; do\n            if [[ $(echo $j\
    \ | tr -d '[]\"' | cut -d ',' -f 2) == $i ]]; then\n                tmp+=(\"$j\"\
    )\n            fi\n        done\n    done\n    res=()\n    for i in $(seq 0 $((row\
    \ - 1))); do\n        for j in \"${tmp[@]}\"; do\n            if [[ $(echo $j\
    \ | tr -d '[]\"' | cut -d ',' -f 1) == $i ]]; then\n                res+=(\"$j\"\
    )\n            fi\n        done\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_desc\n    local -a row_col_sorted_desc_str\n    local\
    \ -a row_col_sorted_desc_str_joined\n    local -a row_col_sorted_desc_str_joined_quoted\n\
    \    local -a row_col_sorted_desc_str_joined_quoted_joined\n    local -a row_col_sorted_desc_str_joined_quoted_joined_quoted\n\
    \    local -a row_col_sorted_desc_str_joined_quoted_joined_quoted_joined\n   \
    \ local -a row_col_sorted_desc_str_joined_quoted_joined_quoted_joined_quoted\n\
    \    local -a row_col_sorted_desc_str_joined_quoted_joined_quoted_joined_quoted_joined\n\
    \    local -a row_col_sorted_desc_str_joined_quoted_joined_quoted_joined_quoted_joined_quoted\n\
    \    local -a row_col_sorted_desc_str_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined\n\
    \    local -a row_col_sorted_desc_str_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted\n\
    \    local -a row_col_sorted_desc_str_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined\n\
    \    local -a row_col_sorted_desc_str_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted\n\
    \    local -a row_col_sorted_desc_str_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined\n\
    \    local -a row_col_sorted_desc_str\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local -a arr\n\
    \    local -a res\n    local -a tmp\n    local -a tmp2\n    local -a tmp3\n  \
    \  local -a tmp4\n    local -a tmp5\n    local -a tmp6\n    local -a tmp7\n  \
    \  local -a tmp8\n    local -a tmp9\n    local -a tmp10\n    local -a tmp11\n\
    \    local -a tmp12\n    local -a tmp13\n    local -a tmp14\n    local -a tmp15\n\
    \    local -a tmp16\n    local -a tmp17\n    local -a tmp18\n    local -a tmp19\n\
    \    local -a tmp20\n    local -a tmp21\n    local -a tmp22\n    local -a tmp23\n\
    \    local -a tmp24\n    local -a tmp25\n    local -a tmp26\n    local -a tmp27\n\
    \    local -a tmp28\n    local -a tmp29\n    local -a tmp30\n    local -a tmp31\n\
    \    local -a tmp32\n    local -a tmp33\n    local -a tmp34\n    local -a tmp35\n\
    \    local -a tmp36\n    local -a tmp37\n    local -a tmp38\n    local -a tmp39\n\
    \    local -a tmp40\n    local -a tmp41\n    local -a tmp42\n    local -a tmp43\n\
    \    local -a tmp44\n    local -a tmp45\n    local -a tmp46\n    local -a tmp47\n\
    \    local -a tmp48\n    local -a tmp49\n    local -a tmp50\n    local -a tmp51\n\
    \    local -a tmp52\n    local -a tmp53\n    local -a tmp54\n    local -a tmp55\n\
    \    local -a tmp56\n    local -a tmp57\n    local -a tmp58\n    local -a tmp59\n\
    \    local -a tmp60\n    local -a tmp61\n    local -a tmp62\n    local -a tmp63\n\
    \    local -a tmp64\n    local -a tmp65\n    local -a tmp66\n    local -a tmp67\n\
    \    local -a tmp68\n    local -a tmp69\n\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a col=()\n    local -a tmp=()\n    local -a tmp2=()\n\
    \    local -a tmp3=()\n    local -a tmp4=()\n    local -a tmp5=()\n    local -a\
    \ tmp6=()\n    local -a tmp7=()\n    local -a tmp8=()\n    local -a tmp9=()\n\
    \    local -a tmp10=()\n    local -a tmp11=()\n    local -a tmp12=()\n    local\
    \ -a tmp13=()\n    local -a tmp14=()\n    local -a tmp15=()\n    local -a tmp16=()\n\
    \    local -a tmp17=()\n    local -a tmp18=()\n    local -a tmp19=()\n    local\
    \ -a tmp20=()\n    local -a tmp21=()\n    local -a tmp22=()\n    local -a tmp23=()\n\
    \    local -a tmp24=()\n    local -a tmp25=()\n    local -a tmp26=()\n    local\
    \ -a tmp27=()\n    local -a tmp28=()\n    local -a tmp29=()\n    local -a tmp30=()\n\
    \    local -a tmp31=()\n    local -a tmp32=()\n    local -a tmp33=()\n    local\
    \ -a tmp34=()\n    local -a tmp35=()\n    local -a tmp36=()\n    local -a tmp37=()\n\
    \    local -a tmp38=()\n    local -a tmp39=()\n    local -a tmp40=()\n    local\
    \ -a tmp41=()\n    local -a tmp42=()\n    local -a tmp43=()\n    local -a tmp44=()\n\
    \    local -a tmp45=()\n    local -a tmp46=()\n    local -a tmp47=()\n    local\
    \ -a tmp48=()\n    local -a tmp49=()\n    local -a tmp50=()\n    local -a tmp51=()\n\
    \    local -a tmp52=()\n    local -a tmp53=\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ i=0\n    local j=0\n    while read -r line; do\n        j=0\n        for y in\
    \ $line; do\n            if [[ $y == $x ]]; then\n                res+=(\"[\\\"\
    $i\\\", \\\"$j\\\"]\")\n            fi\n            j=$((j+1))\n        done\n\
    \        i=$((i+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local result=()\n  local\
    \ i=0\n  local j=0\n  for row in $lst; do\n    for col in $row; do\n      if [[\
    \ $col -eq $x ]]; then\n        result+=(\"[\\\"$i\\\", \\\"$j\\\"]\")\n     \
    \ fi\n      j=$((j+1))\n    done\n    j=0\n    i=$((i+1))\n  done\n  echo ${result[@]}\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6lpyorrm.sh: line 25: [[: 6\\n1: syntax error: invalid arithmetic
    operator (error token is "\\n1")\n/tmp/tmp6lpyorrm.sh: line 25: [[: 6\\n1: syntax
    error: invalid arithmetic operator (error token is "\\n1")\n'''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed\
    \ 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\\
    n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\\
    n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\
    \ = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\"\
    \ ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\"\
    ) = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"\
    ); do\n        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\",\
    \ \\\"$col\\\"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n       \
    \     row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr \" \" \"\\n\" |\
    \ sort -t \"\\\"\" -k 2 -n -r | sort -t \"\\\"\" -k 1 -n\n}\n\ncandidate() {\n\
    \    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5\
    \ 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 2
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    local row_result=()\n    local row_result_sorted=()\n\
    \    local row_result_sorted_reversed=()\n    local row_result_sorted_reversed_string=()\n\
    \    local result_string=()\n    local result_string_sorted=()\n    local result_string_sorted_reversed=()\n\
    \    local result_string_sorted_reversed_string=()\n    for i in $(echo \"$lst\"\
    \ | tr \" \" \"\\n\"); do\n        if [[ $i == $x ]]; then\n            row_result+=(\"\
    $row\")\n            row_result+=(\"$col\")\n        fi\n        if [[ $i == \"\
    \\n\" ]]; then\n            row=$((row + 1))\n            col=0\n        else\n\
    \            col=$((col + 1))\n        fi\n    done\n    for i in ${row_result[@]};\
    \ do\n        if [[ $i == ${row_result[0]} ]]; then\n            result+=(\"$i\"\
    )\n        else\n            result+=(\"$i\")\n            result+=(\"\\n\")\n\
    \        fi\n    done\n    for i in ${result[@]}; do\n        if [[ $i == \"\\\
    n\" ]]; then\n            row_result_sorted=(\"${row_result_sorted[@]}\" \"${row_result_sorted_reversed[@]}\"\
    )\n            row_result_sorted_reversed=()\n        else\n            row_result_sorted_reversed+=(\"\
    $i\")\n        fi\n    done\n    row_result_sorted=(\"${row_result_sorted[@]}\"\
    \ \"${row_result_sorted_reversed[@]}\")\n    for i in ${row_result_sorted[@]};\
    \ do\n        if [[ $i == \"\\n\" ]]; then\n            result_string+=(\"${result_string_sorted_reversed_string[@]}\"\
    )\n            result_string_sorted_reversed_string=()\n        else\n       \
    \     result_\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: SyntaxError
  stderr: 'b"/tmp/tmpzza5vs55.sh: line 66: syntax error near unexpected token `}''\n/tmp/tmpzza5vs55.sh:
    line 66: `}''\n"'
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    while read line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                result+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${result[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local row_res=()\n    while read -r line; do\n\
    \        col=0\n        row_res=()\n        for i in $line; do\n            if\
    \ [ \"$i\" == \"$x\" ]; then\n                row_res+=(\"[\\\"$row\\\", \\\"\
    $col\\\"]\")\n            fi\n            col=$((col+1))\n        done\n     \
    \   if [ ${#row_res[@]} -gt 0 ]; then\n            res+=(\"[${row_res[@]}]\")\n\
    \        fi\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"[${res[@]}]\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local i=0\n    local j=0\n    for row in $lst; do\n        for col in $row;\
    \ do\n            if [[ $col == $x ]]; then\n                result+=(\"[\\\"\
    $i\\\", \\\"$j\\\"]\")\n            fi\n            ((j++))\n        done\n  \
    \      ((i++))\n        j=0\n    done\n    echo ${result[@]}\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    for i in $(echo \"$lst\" | tr ' ' '\\n');\
    \ do\n        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\", \\\
    \"$col\\\"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed -e 's/^/[/' -e\
    \ 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\\
    n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\\
    n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\
    \ = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\"\
    \ ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\"\
    ) = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local i=0\n    local j=0\n    for row in $lst; do\n        j=0\n        for\
    \ col in $row; do\n            if [[ $col == $x ]]; then\n                result+=(\"\
    [\\\"$i\\\", \\\"$j\\\"]\")\n            fi\n            j=$((j+1))\n        done\n\
    \        i=$((i+1))\n    done\n    echo ${result[@]} | tr ' ' ',' | sed 's/,/],[/g'\
    \ | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"\
    1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4\
    \ 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local row=0\n  local col=0\n\
    \  local res=()\n  while read -r line; do\n    col=0\n    for i in $line; do\n\
    \      if [[ $i == $x ]]; then\n        res+=(\"[\\\"$row\\\", \\\"$col\\\"]\"\
    )\n      fi\n      col=$((col+1))\n    done\n    row=$((row+1))\n  done <<< \"\
    $lst\"\n  echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5\
    \ 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\"\
    \ \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local row=0\n  local col=0\n\
    \  local result=()\n  while read -r line; do\n    col=0\n    for i in $line; do\n\
    \      if [[ $i -eq $x ]]; then\n        result+=(\"[\\\"$row\\\", \\\"$col\\\"\
    ]\")\n      fi\n      col=$((col + 1))\n    done\n    row=$((row + 1))\n  done\
    \ <<< \"$lst\"\n  echo \"${result[@]}\" | tr ' ' ',' | sed -e 's/^/[/' -e 's/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk3u82pup.sh: line 26: [[: 6\\n1: syntax error: invalid arithmetic
    operator (error token is "\\n1")\n/tmp/tmpk3u82pup.sh: line 26: [[: 6\\n1: syntax
    error: invalid arithmetic operator (error token is "\\n1")\n'''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    for i in $(echo \"$lst\" | tr \" \" \"\\\
    n\"); do\n        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\"\
    , \\\"$col\\\"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n       \
    \     row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr \" \" \"\\n\" |\
    \ sort -t \"\\\"\" -k 1n -k 3nr | tr \"\\n\" \" \"\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            ((row++))\n\
    \            col=0\n        else\n            ((col++))\n        fi\n    done\n\
    \    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -i i=0\n    local\
    \ -i j=0\n    local -i k=0\n    local -i l=0\n    local -i m=0\n    local -i n=0\n\
    \    local -i o=0\n    local -i p=0\n    local -i q=0\n    local -i r=0\n    local\
    \ -i s=0\n    local -i t=0\n    local -i u=0\n    local -i v=0\n    local -i w=0\n\
    \    local -i x=0\n    local -i y=0\n    local -i z=0\n    local -i aa=0\n   \
    \ local -i bb=0\n    local -i cc=0\n    local -i dd=0\n    local -i ee=0\n   \
    \ local -i ff=0\n    local -i gg=0\n    local -i hh=0\n    local -i ii=0\n   \
    \ local -i jj=0\n    local -i kk=0\n    local -i ll=0\n    local -i mm=0\n   \
    \ local -i nn=0\n    local -i oo=0\n    local -i pp=0\n    local -i qq=0\n   \
    \ local -i rr=0\n    local -i ss=0\n    local -i tt=0\n    local -i uu=0\n   \
    \ local -i vv=0\n    local -i ww=0\n    local -i xx=0\n    local -i yy=0\n   \
    \ local -i zz=0\n    local -i aaa=0\n    local -i bbb=0\n    local -i ccc=0\n\
    \    local -i ddd=0\n    local -i eee=0\n    local -i fff=0\n    local -i ggg=0\n\
    \    local -i hhh=0\n    local -i iii=0\n    local -i jjj=0\n    local -i kkk=0\n\
    \    local -i lll=0\n    local -i mmm=0\n    local -i nnn=0\n    local -i\n}\n\
    \ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            ((row++))\n\
    \            col=0\n        else\n            ((col++))\n        fi\n    done\n\
    \    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local len=$(echo \"\
    $lst\" | wc -l)\n    local i=0\n    local res=()\n    while [ $i -lt $len ]; do\n\
    \        local row=$(echo \"$lst\" | head -n $((i + 1)) | tail -n 1)\n       \
    \ local j=0\n        local len_row=$(echo \"$row\" | wc -w)\n        while [ $j\
    \ -lt $len_row ]; do\n            local elem=$(echo \"$row\" | cut -d \" \" -f\
    \ $((j + 1)))\n            if [ \"$elem\" == \"$x\" ]; then\n                res+=(\"\
    [\\\"$i\\\", \\\"$j\\\"]\")\n            fi\n            j=$((j + 1))\n      \
    \  done\n        i=$((i + 1))\n    done\n    echo \"${res[@]}\" | tr \" \" \"\\\
    n\" | sort -t \"\\\"\" -k 2 -n -r | sort -t \"\\\"\" -k 1 -n\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local -a\
    \ row_col_sorted=()\n    local -a row_col_sorted_rev=()\n    local -a row_col_sorted_rev_str=()\n\
    \    local -a row_col_sorted_rev_str_json=()\n    local -a row_col_sorted_rev_str_json_str=()\n\
    \    local -a row_col_sorted_rev_str_json_str_json=()\n    local -a row_col_sorted_rev_str_json_str_json_str=()\n\
    \    local -a row_col_sorted_rev_str_json_str_json_str_json=()\n    local -a row_col_sorted_rev_str_json_str_json_str_json_str=()\n\
    \    local -a row_col_sorted_rev_str_json_str_json_str_json_str_json=()\n    local\
    \ -a row_col_sorted_rev_str_json_str_json_str_json_str_json_str=()\n    local\
    \ -a row_col_sorted_rev_str_json_str_json_str_json_str_json_str_json=()\n    local\
    \ -a row_col_sorted_rev_str_json_str_json_str_json_str_json_str_json_str=()\n\
    \    local -a row_col_sorted_rev_str_json_str_json_str_json_str_json_str_json_str_json=()\n\
    \    local -a row_col_sorted_rev_str_json_str_json_str_json_str_json_str_json_str_json_str=()\n\
    \    local -a row_col_sorted_rev_str_json_str_json_str_json_str_json_str_json_str_json_str_json=()\n\
    \    local -a row_col_sorted_rev_str_json\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a result_sorted\n    local -a row_col_sorted_desc\n    local -a result_sorted_desc\n\
    \    local -a result_sorted_desc_str\n    local -a result_sorted_desc_str_quoted\n\
    \    local -a result_sorted_desc_str_quoted_joined\n    local -a result_sorted_desc_str_quoted_joined_joined\n\
    \    local -a result_sorted_desc_str_quoted_joined_joined_joined\n    local -a\
    \ result_sorted_desc_str_quoted_joined_joined_joined_joined\n    local -a result_sorted_desc_str_quoted_joined_joined_joined_joined_joined\n\
    \    local -a result_sorted_desc_str_quoted_joined_joined_joined_joined_joined_joined\n\
    \    local -a result_sorted_desc_str_quoted_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a result_sorted_desc_str_quoted_joined_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a result_sorted_desc_str_quoted_joined_joined_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a result_sorted_desc_str_quoted_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a result_sorted_desc_str_quoted_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a result_sorted_desc_str_quoted_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a result_sorted_desc_str_quoted_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a result_sorted_\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5\
    \ 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\"\
    \ \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a res_sorted\n    local -a res_sorted_col\n    local -a res_sorted_col_sorted\n\
    \    local -a res_sorted_col_sorted_str\n    local -a res_sorted_col_sorted_str_str\n\
    \    local -a res_sorted_col_sorted_str_str_str\n    local -a res_sorted_col_sorted_str_str_str_str\n\
    \    local -a res_sorted_col_sorted_str_str_str_str_str\n    local -a res_sorted_col_sorted_str_str_str_str_str_str\n\
    \    local -a res_sorted_col_sorted_str_str_str_str_str_str_str\n    local -a\
    \ res_sorted_col_sorted_str_str_str_str_str_str_str_str\n    local -a res_sorted_col_sorted_str_str_str_str_str_str_str_str_str\n\
    \    local -a res_sorted_col_sorted_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a res_sorted_col_sorted_str_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a res_sorted_col_sorted_str_str_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a res_sorted_col_sorted_str_str_str_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a res_sorted_col_sorted_str_str_str_str_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a res_sorted_col_sorted_str_str_str_str\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local -a res\n\
    \    local -a row\n    local -a col\n    local -a tmp\n    local -a tmp2\n   \
    \ local -a tmp3\n    local -a tmp4\n    local -a tmp5\n    local -a tmp6\n   \
    \ local -a tmp7\n    local -a tmp8\n    local -a tmp9\n    local -a tmp10\n  \
    \  local -a tmp11\n    local -a tmp12\n    local -a tmp13\n    local -a tmp14\n\
    \    local -a tmp15\n    local -a tmp16\n    local -a tmp17\n    local -a tmp18\n\
    \    local -a tmp19\n    local -a tmp20\n    local -a tmp21\n    local -a tmp22\n\
    \    local -a tmp23\n    local -a tmp24\n    local -a tmp25\n    local -a tmp26\n\
    \    local -a tmp27\n    local -a tmp28\n    local -a tmp29\n    local -a tmp30\n\
    \    local -a tmp31\n    local -a tmp32\n    local -a tmp33\n    local -a tmp34\n\
    \    local -a tmp35\n    local -a tmp36\n    local -a tmp37\n    local -a tmp38\n\
    \    local -a tmp39\n    local -a tmp40\n    local -a tmp41\n    local -a tmp42\n\
    \    local -a tmp43\n    local -a tmp44\n    local -a tmp45\n    local -a tmp46\n\
    \    local -a tmp47\n    local -a tmp48\n    local -a tmp49\n    local -a tmp50\n\
    \    local -a tmp51\n    local -a tmp52\n    local -a tmp53\n    local -a tmp54\n\
    \    local -a tmp55\n    local -a tmp56\n    local -a tmp57\n    local -a tmp58\n\
    \    local -a tmp59\n    local -a tmp60\n    local -a tmp61\n    local -a tmp62\n\
    \    local -a tmp63\n    local -a tmp64\n    local -a tmp65\n    local -a tmp66\n\
    \    local -a tmp67\n    local -a tmp68\n   \n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"); do\n\
    \        if [[ $i == $x ]]; then\n            res+=([\"$row\"]=\"$col\")\n   \
    \     fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row + 1))\n\
    \            col=0\n        else\n            col=$((col + 1))\n        fi\n \
    \   done\n    local res_str=\"\"\n    for i in \"${!res[@]}\"; do\n        res_str+=\"\
    [\\\"$i\\\", \\\"${res[$i]}\\\"] \"\n    done\n    echo \"[$res_str]\"\n}\n\n\
    candidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local row_res=()\n    while read -r line; do\n\
    \        col=0\n        row_res=()\n        for i in $line; do\n            if\
    \ [ \"$i\" == \"$x\" ]; then\n                row_res+=(\"[\\\"$row\\\", \\\"\
    $col\\\"]\")\n            fi\n            col=$((col+1))\n        done\n     \
    \   if [ ${#row_res[@]} -gt 0 ]; then\n            res+=(\"[${row_res[@]}]\")\n\
    \        fi\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"[${res[@]}]\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row_num=0\n\
    \    local col_num=0\n    local row_cols=()\n    local row_cols_num=0\n    local\
    \ row_cols_str=\"\"\n    local row_cols_str_arr=()\n    local row_cols_str_arr_num=0\n\
    \    local row_cols_str_arr_str=\"\"\n    local row_cols_str_arr_str_arr=()\n\
    \    local row_cols_str_arr_str_arr_num=0\n    local row_cols_str_arr_str_arr_str=\"\
    \"\n    local row_cols_str_arr_str_arr_str_arr=()\n    local row_cols_str_arr_str_arr_str_arr_num=0\n\
    \    local row_cols_str_arr_str_arr_str_arr_str=\"\"\n    local row_cols_str_arr_str_arr_str_arr_str_arr=()\n\
    \    local row_cols_str_arr_str_arr_str_arr_str_arr_num=0\n    local row_cols_str_arr_str_arr_str_arr_str_arr_str=\"\
    \"\n    local row_cols_str_arr_str_arr_str_arr_str_arr_str_arr=()\n    local row_cols_str_arr_str_arr_str_arr_str_arr_str_arr_num=0\n\
    \    local row_cols_str_arr_str_arr_str_arr_str_arr_str_arr_str=\"\"\n    local\
    \ row_cols_str_arr_str_arr_str_arr_str_arr_str_arr_str_arr=()\n    local row_cols_str_arr_str_arr_str_arr_str_arr_str_arr_str_arr_num=0\n\
    \    local row_cols_str_arr_str_arr_str_arr_str_arr_str_arr_str_arr_str=\"\"\n\
    \    local row_cols_str_arr_str_arr_str\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local i=0\n    local j=0\n    for row in $lst; do\n        j=0\n        for\
    \ col in $row; do\n            if [[ $col == $x ]]; then\n                result+=(\"\
    [\\\"$i\\\", \\\"$j\\\"]\")\n            fi\n            j=$((j+1))\n        done\n\
    \        i=$((i+1))\n    done\n    echo \"${result[@]}\"\n}\n\ncandidate() {\n\
    \    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5\
    \ 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ row=0\n    local col=0\n    local line=()\n    while read line; do\n       \
    \ col=0\n        for i in ${line[@]}; do\n            if [[ $i == $x ]]; then\n\
    \                res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n   \
    \         col=$((col+1))\n        done\n        row=$((row+1))\n    done <<< \"\
    $lst\"\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"\
    1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4\
    \ 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ i=0\n    local j=0\n    for row in $lst; do\n        j=0\n        for col in\
    \ $row; do\n            if [[ $col == $x ]]; then\n                res+=(\"[\\\
    \"$i\\\", \\\"$j\\\"]\")\n            fi\n            j=$((j+1))\n        done\n\
    \        i=$((i+1))\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n  \
    \  get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n   \
    \ [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local row_res=()\n    for i in $(echo \"$lst\"\
    \ | tr ' ' '\\n'); do\n        if [[ $i == $x ]]; then\n            row_res+=($row)\n\
    \            row_res+=($col)\n            res+=(\"[\\\"$row\\\", \\\"$col\\\"\
    ]\")\n        fi\n        col=$((col + 1))\n        if [[ $i == $'\\n' ]]; then\n\
    \            row=$((row + 1))\n            col=0\n        fi\n    done\n    echo\
    \ \"${res[@]}\" | tr ' ' '\\n' | sort -t '\"' -k 2 -n -r | sort -t '\"' -k 1 -n\
    \ | tr '\\n' ' '\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"\
    ); do\n        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\",\
    \ \\\"$col\\\"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n       \
    \     row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr \" \" \"\\n\" |\
    \ sort -t \"\\\"\" -k1,1n -k3,3nr | tr \"\\n\" \" \"\n}\n\ncandidate() {\n   \
    \ get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n   \
    \ [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a col=()\n    local -a tmp=()\n    local -a tmp2=()\n\
    \    local -a tmp3=()\n    local -a tmp4=()\n    local -a tmp5=()\n    local -a\
    \ tmp6=()\n    local -a tmp7=()\n    local -a tmp8=()\n    local -a tmp9=()\n\
    \    local -a tmp10=()\n    local -a tmp11=()\n    local -a tmp12=()\n    local\
    \ -a tmp13=()\n    local -a tmp14=()\n    local -a tmp15=()\n    local -a tmp16=()\n\
    \    local -a tmp17=()\n    local -a tmp18=()\n    local -a tmp19=()\n    local\
    \ -a tmp20=()\n    local -a tmp21=()\n    local -a tmp22=()\n    local -a tmp23=()\n\
    \    local -a tmp24=()\n    local -a tmp25=()\n    local -a tmp26=()\n    local\
    \ -a tmp27=()\n    local -a tmp28=()\n    local -a tmp29=()\n    local -a tmp30=()\n\
    \    local -a tmp31=()\n    local -a tmp32=()\n    local -a tmp33=()\n    local\
    \ -a tmp34=()\n    local -a tmp35=()\n    local -a tmp36=()\n    local -a tmp37=()\n\
    \    local -a tmp38=()\n    local -a tmp39=()\n    local -a tmp40=()\n    local\
    \ -a tmp41=()\n    local -a tmp42=()\n    local -a tmp43=()\n    local -a tmp44=()\n\
    \    local -a tmp45=()\n    local -a tmp46=()\n    local -a tmp47=()\n    local\
    \ -a tmp48=()\n    local -a tmp49=()\n    local -a tmp50=()\n    local -a tmp51=()\n\
    \    local -a tmp52=()\n    local -a tmp53=\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            result+=(\"[\\\"$row\\\"\
    , \\\"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n   \
    \         row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/'\
    \ | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local i=0\n    local j=0\n    for row in $lst; do\n        for col in $row;\
    \ do\n            if [[ $col == $x ]]; then\n                result+=(\"[\\\"\
    $i\\\", \\\"$j\\\"]\")\n            fi\n            j=$((j+1))\n        done\n\
    \        j=0\n        i=$((i+1))\n    done\n    echo \"${result[@]}\"\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local row=0\n  local col=0\n\
    \  local result=()\n  for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n    if [[\
    \ \"$i\" == \"$x\" ]]; then\n      result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n\
    \    fi\n    if [[ \"$i\" == $'\\n' ]]; then\n      ((row++))\n      col=0\n \
    \   else\n      ((col++))\n    fi\n  done\n  echo \"${result[@]}\" | tr ' ' ','\
    \ | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"\
    1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\")\
    \ = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\\
    n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate\
    \ \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a res_sorted\n    local -a res_sorted_col\n    local -a res_sorted_col_sorted\n\
    \    local -a res_sorted_col_sorted_str\n    local -a res_sorted_col_sorted_str_quoted\n\
    \    local -a res_sorted_col_sorted_str_quoted_joined\n    local -a res_sorted_col_sorted_str_quoted_joined_joined\n\
    \    local -a res_sorted_col_sorted_str_quoted_joined_joined_joined\n    local\
    \ -a res_sorted_col_sorted_str_quoted_joined_joined_joined_joined\n    local -a\
    \ res_sorted_col_sorted_str_quoted_joined_joined_joined_joined_joined\n    local\
    \ -a res_sorted_col_sorted_str_quoted_joined_joined_joined_joined_joined_joined\n\
    \    local -a res_sorted_col_sorted_str_quoted_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a res_sorted_col_sorted_str_quoted_joined_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a res_sorted_col_sorted_str_quoted_joined_joined_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a res_sorted_col_sorted_str_quoted_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a res_sorted_col_sorted_str_quoted_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a res_sorted_col_sorted_str_quoted_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a res_sorted\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"\
    1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\")\
    \ = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\\
    n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate\
    \ \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local -a result\n\
    \    local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_desc\n    local -a row_col_sorted_desc_str\n    local\
    \ -a row_col_sorted_desc_str_sorted\n    local -a row_col_sorted_desc_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted\n    local -a row_col_sorted_desc_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted\n    local\
    \ -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str\n    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local row=0\n  local col=0\n\
    \  local result=\"\"\n  while read -r line; do\n    col=0\n    for word in $line;\
    \ do\n      if [[ $word == $x ]]; then\n        result=\"$result [\\\"$row\\\"\
    , \\\"$col\\\"]\"\n      fi\n      col=$((col+1))\n    done\n    row=$((row+1))\n\
    \  done <<< \"$lst\"\n  echo \"$result\" | sort -t '\"' -k 1 -n -k 3 -r | tr -d\
    \ ' '\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\\
    n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\\
    n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\
    \ = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\"\
    \ ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\"\
    ) = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\" | tr \" \" \"\\n\" | sort -t \"\\\"\"\
    \ -k 1 -n -k 3 -r\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result=()\n\
    \    local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local\
    \ -a row_col_sorted=()\n    local -a result_sorted=()\n    local -a row_col_sorted_desc=()\n\
    \    local -a result_sorted_desc=()\n    local -a result_sorted_desc_str=()\n\
    \    local -a result_sorted_desc_str_quoted=()\n    local -a result_sorted_desc_str_quoted_str=()\n\
    \    local -a result_sorted_desc_str_quoted_str_str=()\n    local -a result_sorted_desc_str_quoted_str_str_str=()\n\
    \    local -a result_sorted_desc_str_quoted_str_str_str_str=()\n    local -a result_sorted_desc_str_quoted_str_str_str_str_str=()\n\
    \    local -a result_sorted_desc_str_quoted_str_str_str_str_str_str=()\n    local\
    \ -a result_sorted_desc_str_quoted_str_str_str_str_str_str_str=()\n    local -a\
    \ result_sorted_desc_str_quoted_str_str_str_str_str_str_str_str=()\n    local\
    \ -a result_sorted_desc_str_quoted_str_str_str_str_str_str_str_str_str=()\n  \
    \  local -a result_sorted_desc_str_quoted_str_str_str_str_str_str_str_str_str_str=()\n\
    \    local -a result_sorted_desc_str_quoted_str_str_str_str_str_str_str_str_str_str_str=()\n\
    \    local -a result_sorted_desc_str_quoted_str_str_str_str_str_str_str_str_str_str_str_str=()\n\
    \    local -a result_s\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"\
    1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\")\
    \ = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\\
    n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate\
    \ \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            result+=(\"[\\\"$row\\\"\
    , \\\"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n   \
    \         row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            result+=(\"[\\\"$row\\\"\
    , \\\"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n   \
    \         row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/'\
    \ | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=\"\"\n\
    \    local row=0\n    local col=0\n    for i in $(echo \"$lst\" | tr \" \" \"\\\
    n\")\n    do\n        if [ \"$i\" = \"$x\" ]\n        then\n            result=\"\
    $result [\\\"$row\\\", \\\"$col\\\"]\"\n        fi\n        col=$((col+1))\n \
    \       if [ \"$i\" = \"\\n\" ]\n        then\n            row=$((row+1))\n  \
    \          col=0\n        fi\n    done\n    echo \"$result\" | tr -d \"\\n\" |\
    \ sed 's/^[[:space:]]*//g' | sed 's/[[:space:]]*$//g'\n}\n\ncandidate() {\n  \
    \  get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n   \
    \ [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local row=0\n  local col=0\n\
    \  local result=()\n  while read -r line; do\n    col=0\n    for word in $line;\
    \ do\n      if [[ $word == $x ]]; then\n        result+=(\"[\\\"$row\\\", \\\"\
    $col\\\"]\")\n      fi\n      col=$((col+1))\n    done\n    row=$((row+1))\n \
    \ done <<< \"$lst\"\n  echo \"${result[@]}\"\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    local row_result=()\n    local row_results=()\n\
    \    local row_results_sorted=()\n    local row_results_sorted_sorted=()\n   \
    \ local row_results_sorted_sorted_sorted=()\n    local row_results_sorted_sorted_sorted_sorted=()\n\
    \    local row_results_sorted_sorted_sorted_sorted_sorted=()\n    local row_results_sorted_sorted_sorted_sorted_sorted_sorted=()\n\
    \    local row_results_sorted_sorted_sorted_sorted_sorted_sorted_sorted=()\n \
    \   local row_results_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted=()\n\
    \    local row_results_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted=()\n\
    \    local row_results_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted=()\n\
    \    local row_results_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted=()\n\
    \    local row_results_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted=()\n\
    \    local row_results_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted=()\n\
    \    local row_results_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted=()\n\
    \    local row_results_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_s\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_desc\n    local -a row_col_sorted_desc_str\n    local\
    \ -a result_str\n    local -a result_str_sorted\n    local -a result_str_sorted_desc\n\
    \    local -a result_str_sorted_desc_str\n    local -a result_str_sorted_desc_str_sorted\n\
    \    local -a result_str_sorted_desc_str_sorted_str\n    local -a result_str_sorted_desc_str_sorted_str_sorted\n\
    \    local -a result_str_sorted_desc_str_sorted_str_sorted_str\n    local -a result_str_sorted_desc_str_sorted_str_sorted_str_sorted\n\
    \    local -a result_str_sorted_desc_str_sorted_str_sorted_str_sorted_str\n  \
    \  local -a result_str_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a result_str_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a result_str_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a result_str_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a result_str_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a result_str_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a result_str_\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"\
    1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\")\
    \ = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\\
    n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate\
    \ \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local -a res\n\
    \    local -a row\n    local -a col\n    local -a tmp\n    local i=0\n    local\
    \ j=0\n    local k=0\n    local -i cnt=0\n    local -i len=0\n    local -i len_row=0\n\
    \    local -i len_col=0\n    local -i len_tmp=0\n    local -i len_res=0\n    local\
    \ -i len_x=0\n    local -i len_y=0\n    local -i len_z=0\n    local -i len_w=0\n\
    \    local -i len_v=0\n    local -i len_u=0\n    local -i len_t=0\n    local -i\
    \ len_s=0\n    local -i len_r=0\n    local -i len_q=0\n    local -i len_p=0\n\
    \    local -i len_o=0\n    local -i len_n=0\n    local -i len_m=0\n    local -i\
    \ len_l=0\n    local -i len_k=0\n    local -i len_j=0\n    local -i len_i=0\n\
    \    local -i len_h=0\n    local -i len_g=0\n    local -i len_f=0\n    local -i\
    \ len_e=0\n    local -i len_d=0\n    local -i len_c=0\n    local -i len_b=0\n\
    \    local -i len_a=0\n    local -i len_0=0\n    local -i len_1=0\n    local -i\
    \ len_2=0\n    local -i len_3=0\n    local -i len_4=0\n    local -i len_5=0\n\
    \    local -i len_6=0\n    local -i len_7=0\n    local -i len_8=0\n    local -i\
    \ len_9=0\n    local -i len_10=0\n    local -i len_11=0\n    local -i len_12=0\n\
    \    local -i len\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result=()\n\
    \    local -a row=()\n    local -a col=()\n    local -a rows=()\n    local -a\
    \ cols=()\n    local -a row_col=()\n    local -a row_cols=()\n    local -a row_col_sorted=()\n\
    \    local -a row_cols_sorted=()\n    local -a row_col_sorted_str=()\n    local\
    \ -a row_cols_sorted_str=()\n    local -a row_col_sorted_str_quoted=()\n    local\
    \ -a row_cols_sorted_str_quoted=()\n    local -a row_col_sorted_str_quoted_joined=()\n\
    \    local -a row_cols_sorted_str_quoted_joined=()\n    local -a row_col_sorted_str_quoted_joined_str=()\n\
    \    local -a row_cols_sorted_str_quoted_joined_str=()\n    local -a row_col_sorted_str_quoted_joined_str_quoted=()\n\
    \    local -a row_cols_sorted_str_quoted_joined_str_quoted=()\n    local -a row_col_sorted_str_quoted_joined_str_quoted_joined=()\n\
    \    local -a row_cols_sorted_str_quoted_joined_str_quoted_joined=()\n    local\
    \ -a row_col_sorted_str_quoted_joined_str_quoted_joined_str=()\n    local -a row_cols_sorted_str_quoted_joined_str_quoted_joined_str=()\n\
    \    local -a row_col_sorted_str_quoted_joined_str_quoted_joined_str_quoted=()\n\
    \    local -a row_cols_sorted_str_quoted_joined_str_quoted_joined_str_quoted=()\n\
    \    local -a row_col_sorted_str_quoted_joined_str_quoted_joined_\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ i=0\n    local j=0\n    for row in $lst; do\n        j=0\n        for col in\
    \ $row; do\n            if [[ $col -eq $x ]]; then\n                res+=(\"[\\\
    \"$i\\\", \\\"$j\\\"]\")\n            fi\n            j=$((j+1))\n        done\n\
    \        i=$((i+1))\n    done\n    echo ${res[@]} | tr ' ' ','\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1sl0vbjg.sh: line 26: [[: 6\\n1: syntax error: invalid arithmetic
    operator (error token is "\\n1")\n/tmp/tmp1sl0vbjg.sh: line 26: [[: 6\\n1: syntax
    error: invalid arithmetic operator (error token is "\\n1")\n'''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local -a row_cols\n  local\
    \ -a row_cols_sorted\n  local -a row_cols_sorted_uniq\n  local -a row_cols_sorted_uniq_final\n\
    \  local -a row_cols_sorted_uniq_final_final\n  local -a row_cols_sorted_uniq_final_final_final\n\
    \  local -a row_cols_sorted_uniq_final_final_final_final\n  local -a row_cols_sorted_uniq_final_final_final_final_final\n\
    \  local -a row_cols_sorted_uniq_final_final_final_final_final_final\n  local\
    \ -a row_cols_sorted_uniq_final_final_final_final_final_final_final\n  local -a\
    \ row_cols_sorted_uniq_final_final_final_final_final_final_final_final\n  local\
    \ -a row_cols_sorted_uniq_final_final_final_final_final_final_final_final_final\n\
    \  local -a row_cols_sorted_uniq_final_final_final_final_final_final_final_final_final_final\n\
    \  local -a row_cols_sorted_uniq_final_final_final_final_final_final_final_final_final_final_final\n\
    \  local -a row_cols_sorted_uniq_final_final_final_final_final_final_final_final_final_final_final_final\n\
    \  local -a row_cols_sorted_uniq_final_final_final_final_final_final_final_final_final_final_final_final_final\n\
    \  local -a row_cols_sorted_uniq_final_final_final_final_final_final_final_final_final_final_final_final_final_final\n\
    \  local -a row_cols_sorted_uniq_final_final_final_final_final_final_final_final_final_final_final_final_final_final\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for line in $lst; do\n        col=0\n      \
    \  for num in $line; do\n            if [[ $num -eq $x ]]; then\n            \
    \    result+=([\"$row,$col\"])\n            fi\n            ((col++))\n      \
    \  done\n        ((row++))\n    done\n    echo ${result[@]} | tr ' ' '\\n' | sort\
    \ -t, -k1,1n -k2,2nr | tr '\\n' ' '\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzp6hv042.sh: line 26: [[: 6\\n1: syntax error: invalid arithmetic
    operator (error token is "\\n1")\n/tmp/tmpzp6hv042.sh: line 26: [[: 6\\n1: syntax
    error: invalid arithmetic operator (error token is "\\n1")\n'''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    echo \"$lst\" | awk\
    \ -v x=$x '\n        BEGIN {\n            OFS=\"\\\", \\\"\";\n            print\
    \ \"[\";\n        }\n        {\n            for (i = 1; i <= NF; i++) {\n    \
    \            if ($i == x) {\n                    print \"[\\\"\" NR-1 \"\\\",\
    \ \\\"\" i-1 \"\\\"]\";\n                }\n            }\n        }\n       \
    \ END {\n            print \"]\";\n        }\n    '\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read line; do\n        col=0\n        for\
    \ i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result=()\n\
    \    local -a rows=()\n    local -a columns=()\n    local -a row=()\n    local\
    \ -a column=()\n    local -a row_column=()\n    local i=0\n    local j=0\n   \
    \ local k=0\n    local m=0\n    local n=0\n    local -a row_columns=()\n    local\
    \ -a row_columns_sorted=()\n    local -a row_columns_sorted_desc=()\n    local\
    \ -a row_columns_sorted_desc_sorted=()\n    local -a row_columns_sorted_desc_sorted_desc=()\n\
    \    local -a row_columns_sorted_desc_sorted_desc_sorted=()\n    local -a row_columns_sorted_desc_sorted_desc_sorted_desc=()\n\
    \    local -a row_columns_sorted_desc_sorted_desc_sorted_desc_sorted=()\n    local\
    \ -a row_columns_sorted_desc_sorted_desc_sorted_desc_sorted_desc=()\n    local\
    \ -a row_columns_sorted_desc_sorted_desc_sorted_desc_sorted_desc_sorted=()\n \
    \   local -a row_columns_sorted_desc_sorted_desc_sorted_desc_sorted_desc_sorted_desc=()\n\
    \    local -a row_columns_sorted_desc_sorted_desc_sorted_desc_sorted_desc_sorted_desc_sorted=()\n\
    \    local -a row_columns_sorted_desc_sorted_desc_sorted_desc_sorted_desc_sorted_desc_sorted_desc=()\n\
    \    local -a row_columns_sorted_desc_sorted_desc_sorted_desc_sorted_desc_sorted_desc_sorted_desc_sorted=()\n\
    \    local -a row_columns_sorted_desc_sorted_desc_sorted_desc_sorted_desc_sorted_desc\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local input=$1\n    local x=$2\n    local result=()\n\
    \    local row=0\n    local col=0\n    while read -r line; do\n        col=0\n\
    \        for i in $line; do\n            if [[ $i == $x ]]; then\n           \
    \     result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n           \
    \ col=$((col+1))\n        done\n        row=$((row+1))\n    done <<< \"$input\"\
    \n    echo \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5\
    \ 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\"\
    \ \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    while read -r line; do\n        col=0\n    \
    \    for i in $line; do\n            if [[ $i == $x ]]; then\n               \
    \ result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            ((col++))\n\
    \        done\n        ((row++))\n    done <<< \"$lst\"\n    echo \"${result[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed\
    \ 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\\
    n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\\
    n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\
    \ = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\"\
    \ ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\"\
    ) = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ row=0\n    local col=0\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\" | tr \" \" \"\\n\" | sort -t \",\" -k\
    \ 1 -n -r -k 2 -n\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    for i in $(echo \"$lst\" | tr \" \" \"\\\
    n\"); do\n        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\"\
    , \\\"$col\\\"]\")\n        fi\n        col=$((col + 1))\n        if [[ $i ==\
    \ \"\\n\" ]]; then\n            row=$((row + 1))\n            col=0\n        fi\n\
    \    done\n    echo \"${result[@]}\" | tr \" \" \"\\n\" | sort -t \"\\\"\" -k\
    \ 1n -k 3nr | tr \"\\n\" \" \"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"\
    1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4\
    \ 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            ((row++))\n\
    \            col=0\n        else\n            ((col++))\n        fi\n    done\n\
    \    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row=0\n\
    \    local col=0\n    local res=()\n    while read line; do\n        col=0\n \
    \       for i in $line; do\n            if [ \"$i\" == \"$x\" ]; then\n      \
    \          res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n         \
    \   col=$((col+1))\n        done\n        row=$((row+1))\n    done <<< \"$lst\"\
    \n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local row=0\n  local col=0\n\
    \  local res=()\n  local row_res=()\n  local row_res_str=()\n  local col_res=()\n\
    \  local col_res_str=()\n  local res_str=()\n  local res_str_sorted=()\n  local\
    \ res_str_sorted_final=()\n  local res_str_sorted_final_str=()\n  local res_str_sorted_final_str_sorted=()\n\
    \  local res_str_sorted_final_str_sorted_final=()\n  local res_str_sorted_final_str_sorted_final_str=()\n\
    \  local res_str_sorted_final_str_sorted_final_str_sorted=()\n  local res_str_sorted_final_str_sorted_final_str_sorted_final=()\n\
    \  local res_str_sorted_final_str_sorted_final_str_sorted_final_str=()\n  local\
    \ res_str_sorted_final_str_sorted_final_str_sorted_final_str_sorted=()\n  local\
    \ res_str_sorted_final_str_sorted_final_str_sorted_final_str_sorted_final=()\n\
    \  local res_str_sorted_final_str_sorted_final_str_sorted_final_str_sorted_final_str=()\n\
    \  local res_str_sorted_final_str_sorted_final_str_sorted_final_str_sorted_final_str_sorted=()\n\
    \  local res_str_sorted_final_str_sorted_final_str_sorted_final_str_sorted_final_str_sorted_final=()\n\
    \  local res_str_sorted_final_str_sorted_final_str_sorted_final_str_sorted_final_str_sorted_final_str=()\n\
    \  local res_str_sorted_final_str_sorted_final_str_sorted_final_str_sorted_final\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    while read line; do\n        local col=0\n        for num\
    \ in $line; do\n            if [ \"$num\" = \"$x\" ]; then\n                result+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col + 1))\n\
    \        done\n        row=$((row + 1))\n    done <<< \"$lst\"\n    echo \"${result[@]}\"\
    \ | tr ' ' ',' | sed -e 's/^/[/' -e 's/$/]/'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i -eq $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6sv_3jk0.sh: line 26: [[: 6\\n1: syntax error: invalid arithmetic
    operator (error token is "\\n1")\n/tmp/tmp6sv_3jk0.sh: line 26: [[: 6\\n1: syntax
    error: invalid arithmetic operator (error token is "\\n1")\n'''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    local line\n    while read -r line; do\n\
    \        col=0\n        for i in $line; do\n            if [[ $i -eq $x ]]; then\n\
    \                result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n\
    \            col=$((col + 1))\n        done\n        row=$((row + 1))\n    done\
    \ <<< \"$lst\"\n    echo \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmplfkacvo8.sh: line 27: [[: 6\\n1: syntax error: invalid arithmetic
    operator (error token is "\\n1")\n/tmp/tmplfkacvo8.sh: line 27: [[: 6\\n1: syntax
    error: invalid arithmetic operator (error token is "\\n1")\n'''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row=0\n\
    \    local col=0\n    local res=()\n    while read -r line; do\n        col=0\n\
    \        for i in $line; do\n            if [[ \"$i\" == \"$x\" ]]; then\n   \
    \             res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n      \
    \      col=$((col+1))\n        done\n        row=$((row+1))\n    done <<< \"$lst\"\
    \n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed\
    \ 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\\
    n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\\
    n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\
    \ = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\"\
    \ ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\"\
    ) = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -a row\n    local -a column\n    local -a row_column\n    local -a row_column_sorted\n\
    \    local -a row_column_sorted_desc\n    local -a row_column_sorted_desc_str\n\
    \    local -a row_column_sorted_desc_str_sorted\n    local -a row_column_sorted_desc_str_sorted_str\n\
    \    local -a row_column_sorted_desc_str_sorted_str_sorted\n    local -a row_column_sorted_desc_str_sorted_str_sorted_str\n\
    \    local -a row_column_sorted_desc_str_sorted_str_sorted_str_sorted\n    local\
    \ -a row_column_sorted_desc_str_sorted_str_sorted_str_sorted_str\n    local -a\
    \ row_column_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted\n    local\
    \ -a row_column_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_column_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_column_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_column_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_column_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_column_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_column\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"\
    1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\")\
    \ = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\\
    n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate\
    \ \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=\"\"\n\
    \    local row=0\n    local col=0\n    for i in $(echo \"$lst\" | tr \" \" \"\\\
    n\"); do\n        if [ \"$i\" == \"$x\" ]; then\n            result=\"$result\
    \ [\\\"$row\\\", \\\"$col\\\"]\"\n        fi\n        if [ \"$i\" == \"\\n\" ];\
    \ then\n            row=$((row + 1))\n            col=0\n        else\n      \
    \      col=$((col + 1))\n        fi\n    done\n    echo \"$result\" | sort -t\
    \ \",\" -k 1 -n -r -k 2 -n\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"\
    1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\")\
    \ = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\\
    n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate\
    \ \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ row=0\n    local col=0\n    for i in $lst; do\n        if [[ $i == $x ]]; then\n\
    \            res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n        fi\n        if [[\
    \ $i == \"\\n\" ]]; then\n            row=$((row + 1))\n            col=0\n  \
    \      else\n            col=$((col + 1))\n        fi\n    done\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $lst; do\n        if [[ $i == $x ]];\
    \ then\n            result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n        fi\n \
    \       col=$((col + 1))\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        fi\n    done\n    echo \"${result[@]}\" |\
    \ tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3\
    \ 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1\
    \ 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local res=()\n\
    \    local i=0\n    local j=0\n    while read -r line; do\n        j=0\n     \
    \   for y in $line; do\n            if [[ \"$y\" == \"$x\" ]]; then\n        \
    \        res+=(\"[\\\"$i\\\", \\\"$j\\\"]\")\n            fi\n            j=$((j+1))\n\
    \        done\n        i=$((i+1))\n    done <<< \"$lst\"\n    if [[ \"${#res[@]}\"\
    \ -eq 0 ]]; then\n        echo \"[]\"\n    else\n        echo \"$(IFS=,; echo\
    \ \"[${res[*]}]\")\"\n    fi\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5\
    \ 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\"\
    \ \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read line; do\n        col=0\n        for\
    \ i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            ((col++))\n     \
    \   done\n        ((row++))\n    done <<< \"$lst\"\n    echo \"${res[@]}\" | tr\
    \ ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    local line\n    while read -r line; do\n\
    \        col=0\n        for i in $line; do\n            if [ \"$i\" == \"$x\"\
    \ ]; then\n                result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n      \
    \      fi\n            col=$((col+1))\n        done\n        row=$((row+1))\n\
    \    done <<< \"$lst\"\n    echo \"${result[@]}\"\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    while read -r line; do\n        col=0\n\
    \        for i in $line; do\n            if [[ $i == $x ]]; then\n           \
    \     result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n           \
    \ ((col++))\n        done\n        ((row++))\n    done <<< \"$lst\"\n    echo\
    \ \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local row=0\n  local col=0\n\
    \  local result=()\n  local row_result=()\n  local row_result_sorted=()\n  local\
    \ row_result_sorted_desc=()\n  local row_result_sorted_desc_str=()\n  local row_result_sorted_desc_str_str=()\n\
    \  local row_result_sorted_desc_str_str_str=()\n  local row_result_sorted_desc_str_str_str_str=()\n\
    \  local row_result_sorted_desc_str_str_str_str_str=()\n  local row_result_sorted_desc_str_str_str_str_str_str=()\n\
    \  local row_result_sorted_desc_str_str_str_str_str_str_str=()\n  local row_result_sorted_desc_str_str_str_str_str_str_str_str=()\n\
    \  local row_result_sorted_desc_str_str_str_str_str_str_str_str_str=()\n  local\
    \ row_result_sorted_desc_str_str_str_str_str_str_str_str_str_str=()\n  local row_result_sorted_desc_str_str_str_str_str_str_str_str_str_str_str=()\n\
    \  local row_result_sorted_desc_str_str_str_str_str_str_str_str_str_str_str_str=()\n\
    \  local row_result_sorted_desc_str_str_str_str_str_str_str_str_str_str_str_str_str=()\n\
    \  local row_result_sorted_desc_str_str_str_str_str_str_str_str_str_str_str_str_str_str=()\n\
    \  local row_result_sorted_desc_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str=()\n\
    \  local row_result_sorted_desc_str_\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    while read -r line; do\n        col=0\n    \
    \    for i in $line; do\n            if [[ $i == $x ]]; then\n               \
    \ result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${result[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            res+=(\"[\\\"$row\\\", \\\
    \"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n       \
    \     row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/'\
    \ | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a row_col\n    local -a row_col_res\n \
    \   local -a row_col_res_res\n    local -a row_col_res_res_res\n    local -a row_col_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res\n    local -a row_col_res_res_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res_res_res\n    local -a row_col_res_res_res_res_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res\n    local -a row_col_res_res_res_res_res_res_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_res\n    local -a\
    \ row_col_res_res_res_res_res_res_res_res_res_res_res_res\n    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_res_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_res_res_res_res_res_res\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local res=()\n  local i=0\n\
    \  local j=0\n  local row=()\n  local rows=()\n  for row in $lst; do\n    rows[$i]=$row\n\
    \    i=$((i+1))\n  done\n  for row in \"${rows[@]}\"; do\n    for col in $row;\
    \ do\n      if [[ $col == $x ]]; then\n        res+=([\"$i\" \"$j\"])\n      fi\n\
    \      j=$((j+1))\n    done\n    j=0\n    i=$((i+1))\n  done\n  echo \"${res[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $lst; do\n        if [[ $i == $x ]]; then\n\
    \            res+=([\"$row,$col\"])\n        fi\n        if [[ $i == \"\\n\" ]];\
    \ then\n            row=$((row+1))\n            col=0\n        else\n        \
    \    col=$((col+1))\n        fi\n    done\n    echo ${res[@]} | tr ' ' '\\n' |\
    \ sort -t ',' -k 1n -k 2nr | tr '\\n' ' '\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    while read line; do\n        col=0\n   \
    \     for i in $line; do\n            if [ \"$i\" = \"$x\" ]; then\n         \
    \       result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n         \
    \   col=$((col+1))\n        done\n        row=$((row+1))\n    done <<< \"$lst\"\
    \n    echo \"${result[@]}\" | tr \" \" \"\\n\" | sort -t \"\\\"\" -k 1 -n -k 3\
    \ -r\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\\
    n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\\
    n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3\
    \ 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n \
    \   [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\
    \" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"\
    ); do\n        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\",\
    \ \\\"$col\\\"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n        \
    \    row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr \" \" \"\\n\" |\
    \ sort -t \"\\\"\" -k 1,1n -k 2,2nr | tr \"\\n\" \" \"\n}\n\ncandidate() {\n \
    \   get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5\
    \ 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_rev\n    local -a res_sorted\n    local -a res_sorted_rev\n\
    \    local -a res_sorted_rev_str\n    local -a res_sorted_rev_str_joined\n   \
    \ local -a res_sorted_rev_str_joined_quoted\n    local -a res_sorted_rev_str_joined_quoted_joined\n\
    \    local -a res_sorted_rev_str_joined_quoted_joined_joined\n    local -a res_sorted_rev_str_joined_quoted_joined_joined_joined\n\
    \    local -a res_sorted_rev_str_joined_quoted_joined_joined_joined_joined\n \
    \   local -a res_sorted_rev_str_joined_quoted_joined_joined_joined_joined_joined\n\
    \    local -a res_sorted_rev_str_joined_quoted_joined_joined_joined_joined_joined_joined\n\
    \    local -a res_sorted_rev_str_joined_quoted_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a res_sorted_rev_str_joined_quoted_joined_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a res_sorted_rev_str_joined_quoted_joined_joined_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a res_sorted_rev_str_joined_quoted_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a res_sorted_rev_str_joined_quoted_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a res_sorted_rev_str_joined_quoted_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined_joined\n\
    \    local -a res_sorted_rev\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5\
    \ 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\"\
    \ \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n' | tr\
    \ '\\n' ' '); do\n        if [[ \"$i\" == \"$x\" ]]; then\n            result+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]];\
    \ then\n            row=$((row + 1))\n            col=0\n        else\n      \
    \      col=$((col + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr\
    \ ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local result=\"\"\n  local\
    \ row=0\n  local col=0\n  local row_count=0\n  local col_count=0\n  local row_count_max=0\n\
    \  local col_count_max=0\n  local row_count_max_prev=0\n  local col_count_max_prev=0\n\
    \  local row_count_max_prev_prev=0\n  local col_count_max_prev_prev=0\n  local\
    \ row_count_max_prev_prev_prev=0\n  local col_count_max_prev_prev_prev=0\n  local\
    \ row_count_max_prev_prev_prev_prev=0\n  local col_count_max_prev_prev_prev_prev=0\n\
    \  local row_count_max_prev_prev_prev_prev_prev=0\n  local col_count_max_prev_prev_prev_prev_prev=0\n\
    \  local row_count_max_prev_prev_prev_prev_prev_prev=0\n  local col_count_max_prev_prev_prev_prev_prev_prev=0\n\
    \  local row_count_max_prev_prev_prev_prev_prev_prev_prev=0\n  local col_count_max_prev_prev_prev_prev_prev_prev_prev=0\n\
    \  local row_count_max_prev_prev_prev_prev_prev_prev_prev_prev=0\n  local col_count_max_prev_prev_prev_prev_prev_prev_prev_prev=0\n\
    \  local row_count_max_prev_prev_prev_prev_prev_prev_prev_prev_prev=0\n  local\
    \ col_count_max_prev_prev_prev_prev_prev_prev_prev_prev_prev=0\n  local row_count_max_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev=0\n\
    \  local col_count_max_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev=0\n \
    \ local row_count_max_prev_prev_prev_prev_prev_prev_prev_prev_prev\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    while read -r line; do\n        col=0\n    \
    \    for num in $line; do\n            if [[ $num == $x ]]; then\n           \
    \     result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n           \
    \ col=$((col + 1))\n        done\n        row=$((row + 1))\n    done <<< \"$lst\"\
    \n    echo \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5\
    \ 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\"\
    \ \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a tmp\n    local -a tmp2\n    local -a\
    \ tmp3\n    local -a tmp4\n    local -a tmp5\n    local -a tmp6\n    local -a\
    \ tmp7\n    local -a tmp8\n    local -a tmp9\n    local -a tmp10\n    local -a\
    \ tmp11\n    local -a tmp12\n    local -a tmp13\n    local -a tmp14\n    local\
    \ -a tmp15\n    local -a tmp16\n    local -a tmp17\n    local -a tmp18\n    local\
    \ -a tmp19\n    local -a tmp20\n    local -a tmp21\n    local -a tmp22\n    local\
    \ -a tmp23\n    local -a tmp24\n    local -a tmp25\n    local -a tmp26\n    local\
    \ -a tmp27\n    local -a tmp28\n    local -a tmp29\n    local -a tmp30\n    local\
    \ -a tmp31\n    local -a tmp32\n    local -a tmp33\n    local -a tmp34\n    local\
    \ -a tmp35\n    local -a tmp36\n    local -a tmp37\n    local -a tmp38\n    local\
    \ -a tmp39\n    local -a tmp40\n    local -a tmp41\n    local -a tmp42\n    local\
    \ -a tmp43\n    local -a tmp44\n    local -a tmp45\n    local -a tmp46\n    local\
    \ -a tmp47\n    local -a tmp48\n    local -a tmp49\n    local -a tmp50\n    local\
    \ -a tmp51\n    local -a tmp52\n    local -a tmp53\n    local -a tmp54\n    local\
    \ -a tmp55\n    local -a tmp56\n    local -a tmp57\n    local -a tmp58\n    local\
    \ -a tmp59\n    local -a tmp60\n    local -a tmp61\n    local -a tmp62\n    local\
    \ -a tmp63\n    local -a tmp64\n    local -a tmp65\n    local -a tmp66\n    local\
    \ -a tmp67\n    local -a tmp68\n    local -a tmp\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local i=0\n    local\
    \ j=0\n    local res=()\n    while read -r line; do\n        j=0\n        for\
    \ num in $line; do\n            if [[ $num -eq $x ]]; then\n                res+=(\"\
    [\\\"$i\\\", \\\"$j\\\"]\")\n            fi\n            j=$((j+1))\n        done\n\
    \        i=$((i+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmpeyy1b3am.sh: line 26: [[: 6\\n1: syntax error: invalid arithmetic
    operator (error token is "\\n1")\n/tmp/tmpeyy1b3am.sh: line 26: [[: 6\\n1: syntax
    error: invalid arithmetic operator (error token is "\\n1")\n'''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    while read -r line; do\n        col=0\n\
    \        for i in $line; do\n            if [[ $i == $x ]]; then\n           \
    \     result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n           \
    \ col=$((col+1))\n        done\n        row=$((row+1))\n    done <<< \"$lst\"\n\
    \    if [[ ${#result[@]} -eq 0 ]]; then\n        echo \"[]\"\n    else\n     \
    \   echo \"$(IFS=,; echo \"${result[*]}\")\"\n    fi\n}\n\ncandidate() {\n   \
    \ get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n   \
    \ [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row_num=0\n \
    \   local col_num=0\n    local res=()\n    for row in $lst; do\n        col_num=0\n\
    \        for col in $row; do\n            if [[ $col == $x ]]; then\n        \
    \        res+=(\"[\\\"$row_num\\\", \\\"$col_num\\\"]\")\n            fi\n   \
    \         col_num=$((col_num + 1))\n        done\n        row_num=$((row_num +\
    \ 1))\n    done\n    echo \"${res[@]}\" | tr ' ' '\\n' | sort -t '\"' -k 1,1 -k\
    \ 3,3 -r | tr '\\n' ' '\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"\
    1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\")\
    \ = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\\
    n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate\
    \ \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a result_sorted\n    local -i i=0\n    local -i j=0\n    local -i\
    \ k=0\n    local -i l=0\n    local -i m=0\n    local -i n=0\n    local -i o=0\n\
    \    local -i p=0\n    local -i q=0\n    local -i r=0\n    local -i s=0\n    local\
    \ -i t=0\n    local -i u=0\n    local -i v=0\n    local -i w=0\n    local -i x=0\n\
    \    local -i y=0\n    local -i z=0\n    local -i aa=0\n    local -i bb=0\n  \
    \  local -i cc=0\n    local -i dd=0\n    local -i ee=0\n    local -i ff=0\n  \
    \  local -i gg=0\n    local -i hh=0\n    local -i ii=0\n    local -i jj=0\n  \
    \  local -i kk=0\n    local -i ll=0\n    local -i mm=0\n    local -i nn=0\n  \
    \  local -i oo=0\n    local -i pp=0\n    local -i qq=0\n    local -i rr=0\n  \
    \  local -i ss=0\n    local -i tt=0\n    local -i uu=0\n    local -i vv=0\n  \
    \  local -i ww=0\n    local -i xx=0\n    local -i yy=0\n    local -i zz=0\n  \
    \  local -i aaa=0\n    local -i bbb=0\n    local -i ccc=0\n    local -i ddd=0\n\
    \    local -i eee=0\n    local -i fff=0\n    local -i ggg=0\n    local -i hhh=0\n\
    \    local -i iii=0\n    local -\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"\
    1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4\
    \ 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\
    # each list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local -a rows\n\
    \    local -a cols\n    local -a res\n    local -i i=0\n    local -i j=0\n   \
    \ local -i k=0\n    local -i l=0\n    local -i m=0\n    local -i n=0\n    local\
    \ -i o=0\n    local -i p=0\n    local -i q=0\n    local -i r=0\n    local -i s=0\n\
    \    local -i t=0\n    local -i u=0\n    local -i v=0\n    local -i w=0\n    local\
    \ -i x=0\n    local -i y=0\n    local -i z=0\n    local -i aa=0\n    local -i\
    \ bb=0\n    local -i cc=0\n    local -i dd=0\n    local -i ee=0\n    local -i\
    \ ff=0\n    local -i gg=0\n    local -i hh=0\n    local -i ii=0\n    local -i\
    \ jj=0\n    local -i kk=0\n    local -i ll=0\n    local -i mm=0\n    local -i\
    \ nn=0\n    local -i oo=0\n    local -i pp=0\n    local -i qq=0\n    local -i\
    \ rr=0\n    local -i ss=0\n    local -i tt=0\n    local -i uu=0\n    local -i\
    \ vv=0\n    local -i ww=0\n    local -i xx=0\n    local -i yy=0\n    local -i\
    \ zz=0\n    local -i aaa=0\n    local -i bbb=0\n    local -i ccc=0\n    local\
    \ -i ddd=0\n    local -i eee=0\n    local -i fff=0\n    local -i ggg=0\n    local\
    \ -i hhh=0\n    local -i iii=0\n    local -i jjj=0\n    local -i kkk=0\n    local\
    \ -i lll=0\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\\
    n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\\
    n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\
    \ = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\"\
    \ ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\"\
    ) = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660361148
