language: pl
name: HumanEval_68_pluck
results:
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = 10001;\n    my $index = 0;\n    my $i\
    \ = 0;\n    foreach my $node (@$nodes) {\n        if ($node % 2 == 0) {\n    \
    \        if ($node < $min) {\n                $min = $node;\n                $index\
    \ = $i;\n            }\n        }\n        $i++;\n    }\n    if ($min == 10001)\
    \ {\n        return [];\n    }\n    return [$min, $index];\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min = undef;\n    my $min_index = undef;\n\
    \    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0) {\n     \
    \       if (not defined $min or $nodes->[$i] < $min) {\n                $min =\
    \ $nodes->[$i];\n                $min_index = $i;\n            }\n        }\n\
    \    }\n    if (defined $min) {\n        return [$min, $min_index];\n    } else\
    \ {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_index =\
    \ undef;\n    for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n\
    \            if (not defined $min_even or $nodes[$i] < $min_even) {\n        \
    \        $min_even = $nodes[$i];\n                $min_even_index = $i;\n    \
    \        }\n        }\n    }\n    if (defined $min_even) {\n        return [$min_even,\
    \ $min_even_index];\n    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my ($min, $index) = (undef, undef);\n    for my\
    \ $i (0 .. $#nodes) {\n        next if $nodes[$i] % 2;\n        if (not defined\
    \ $min or $nodes[$i] < $min) {\n            $min = $nodes[$i];\n            $index\
    \ = $i;\n        }\n    }\n    return defined $min ? [$min, $index] : [];\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $idx (0 .. $#$nodes) {\n        my $node = $nodes->[$idx];\n\
    \        next if $node % 2;\n        if (!defined $min_even || $node < $min_even)\
    \ {\n            $min_even = $node;\n            $min_even_idx = $idx;\n     \
    \   }\n    }\n    return defined $min_even ? [$min_even, $min_even_idx] : [];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227683
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_index =\
    \ undef;\n    for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n\
    \            if (not defined $min_even or $nodes[$i] < $min_even) {\n        \
    \        $min_even = $nodes[$i];\n                $min_even_index = $i;\n    \
    \        }\n        }\n    }\n    if (defined $min_even) {\n        return [$min_even,\
    \ $min_even_index];\n    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even_value = undef;\n    my $min_even_index\
    \ = undef;\n    for (my $i = 0; $i < @nodes; $i++) {\n        my $node = $nodes[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined($min_even_value) || $node\
    \ < $min_even_value) {\n                $min_even_value = $node;\n           \
    \     $min_even_index = $i;\n            }\n        }\n    }\n    if (defined($min_even_value))\
    \ {\n        return [$min_even_value, $min_even_index];\n    } else {\n      \
    \  return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0)\
    \ {\n            if (!defined $min_even || $nodes->[$i] < $min_even) {\n     \
    \           $min_even = $nodes->[$i];\n                $min_even_index = $i;\n\
    \            }\n        }\n    }\n    return defined $min_even ? [$min_even, $min_even_index]\
    \ : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = $nodes->[0];\n    my $min_index = 0;\n\
    \    my $found = 0;\n    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i]\
    \ % 2 == 0) {\n            if ($found == 0) {\n                $min = $nodes->[$i];\n\
    \                $min_index = $i;\n                $found = 1;\n            }\n\
    \            elsif ($nodes->[$i] < $min) {\n                $min = $nodes->[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    return\
    \ $found ? [$min, $min_index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my @evens = grep { $_ % 2 == 0 } @nodes;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $index = first_index {\
    \ $_ == $min } @nodes;\n    return [$min, $index];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmp4qcolu8n.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmp4qcolu8n.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmp4qcolu8n.pl line 34.\n"
  stdout: ''
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min = undef;\n    my $min_index = undef;\n\
    \    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min) {\n           \
    \     $min = $node;\n                $min_index = $i;\n            } elsif ($node\
    \ < $min) {\n                $min = $node;\n                $min_index = $i;\n\
    \            }\n        }\n    }\n    return defined $min ? [$min, $min_index]\
    \ : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $index = undef;\n    for\
    \ (my $i = 0; $i < @nodes; $i++) {\n        if ($nodes[$i] % 2 == 0) {\n     \
    \       if (!defined($min) || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $index = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $index];\n    } else {\n        return [];\n    }\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0)\
    \ {\n            if (!defined $min_even || $nodes->[$i] < $min_even) {\n     \
    \           $min_even = $nodes->[$i];\n                $min_even_index = $i;\n\
    \            }\n        }\n    }\n    if (defined $min_even) {\n        return\
    \ [$min_even, $min_even_index];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227683
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min = undef;\n    my $index = undef;\n  \
    \  for (my $i = 0; $i < scalar @$nodes; $i++) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min) {\n           \
    \     $min = $node;\n                $index = $i;\n            } else {\n    \
    \            if ($node < $min) {\n                    $min = $node;\n        \
    \            $index = $i;\n                }\n            }\n        }\n    }\n\
    \    if (defined $min) {\n        return [$min, $index];\n    } else {\n     \
    \   return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $n = $nodes->[$i];\n \
    \       if ($n % 2 == 0) {\n            if (!defined $min_even || $n < $min_even)\
    \ {\n                $min_even = $n;\n                $min_even_index = $i;\n\
    \            }\n        }\n    }\n    return defined $min_even ? [$min_even, $min_even_index]\
    \ : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my @evens = grep { $_ % 2 == 0 } @nodes;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $index = first_index {\
    \ $_ == $min } @nodes;\n    return [$min, $index];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmp4qcolu8n.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmp4qcolu8n.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmp4qcolu8n.pl line 34.\n"
  stdout: ''
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even_value = undef;\n    my $min_even_index\
    \ = undef;\n    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        my $node\
    \ = $nodes->[$i];\n        if ($node % 2 == 0) {\n            if (!defined $min_even_value\
    \ || $node < $min_even_value) {\n                $min_even_value = $node;\n  \
    \              $min_even_index = $i;\n            }\n        }\n    }\n    if\
    \ (defined $min_even_value) {\n        return [$min_even_value, $min_even_index];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        my $node =\
    \ $nodes->[$i];\n        if ($node % 2 == 0) {\n            if (!defined $min_even\
    \ || $node < $min_even) {\n                $min_even = $node;\n              \
    \  $min_even_idx = $i;\n            }\n        }\n    }\n    return defined $min_even\
    \ ? [$min_even, $min_even_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even_value = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n\
    \            if (!defined $min_even_value || $nodes[$i] < $min_even_value) {\n\
    \                $min_even_value = $nodes[$i];\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even_value) {\n\
    \        return [$min_even_value, $min_even_index];\n    } else {\n        return\
    \ [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate =\
    \ \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n       \
    \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231759
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = $nodes[0];\n    my $index = 0;\n    for\
    \ my $i (1..$#nodes) {\n        if ($nodes[$i] % 2 == 0 && $nodes[$i] < $min)\
    \ {\n            $min = $nodes[$i];\n            $index = $i;\n        }\n   \
    \ }\n    return $min % 2 == 0 ? [$min, $index] : [];\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231759
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_index =\
    \ undef;\n    for (my $i = 0; $i < @nodes; $i++) {\n        my $node = $nodes[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined($min_even) || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined($min_even)) {\n    \
    \    return [$min_even, $min_even_index];\n    } else {\n        return [];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231759
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = $nodes[0];\n    my $index = 0;\n    for\
    \ (my $i = 0; $i < scalar @nodes; $i++) {\n        if ($nodes[$i] % 2 == 0) {\n\
    \            if ($nodes[$i] < $min) {\n                $min = $nodes[$i];\n  \
    \              $index = $i;\n            }\n        }\n    }\n    return $min\
    \ == $nodes[0] ? [] : [$min, $index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231759
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $index = undef;\n    for\
    \ my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n            if (!defined\
    \ $min || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n         \
    \       $index = $i;\n            }\n        }\n    }\n    return defined $min\
    \ ? [$min, $index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $smallest_even = undef;\n    my $smallest_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0)\
    \ {\n            if (!defined $smallest_even) {\n                $smallest_even\
    \ = $nodes->[$i];\n                $smallest_even_index = $i;\n            } elsif\
    \ ($nodes->[$i] < $smallest_even) {\n                $smallest_even = $nodes->[$i];\n\
    \                $smallest_even_index = $i;\n            }\n        }\n    }\n\
    \    if (defined $smallest_even) {\n        return [$smallest_even, $smallest_even_index];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even_value = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even_value || $node\
    \ < $min_even_value) {\n                $min_even_value = $node;\n           \
    \     $min_even_index = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min_even_value) {\n        return [$min_even_value, $min_even_index];\n   \
    \ } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my @evens = grep { $_ % 2 == 0 } @nodes;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $min_index = first_index\
    \ { $_ == $min } @nodes;\n    return [$min, $min_index];\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmprtjv4jxe.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmprtjv4jxe.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmprtjv4jxe.pl line 34.\n"
  stdout: ''
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min = undef;\n    my $min_index = undef;\n\
    \    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n        if\
    \ ($node % 2 == 0) {\n            if (!defined $min || $node < $min) {\n     \
    \           $min = $node;\n                $min_index = $i;\n            }\n \
    \       }\n    }\n    if (defined $min) {\n        return [$min, $min_index];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $i (0 .. $#$nodes) {\n        my $n = $nodes->[$i];\n   \
    \     if ($n % 2 == 0) {\n            if (!defined $min_even || $n < $min_even)\
    \ {\n                $min_even = $n;\n                $min_even_idx = $i;\n  \
    \          }\n        }\n    }\n    if (defined $min_even) {\n        return [$min_even,\
    \ $min_even_idx];\n    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even_index = -1;\n    my $min_even_value\
    \ = -1;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n \
    \       if ($node % 2 == 0) {\n            if ($min_even_index == -1 || $node\
    \ < $min_even_value) {\n                $min_even_index = $i;\n              \
    \  $min_even_value = $node;\n            }\n        }\n    }\n    return $min_even_index\
    \ == -1 ? [] : [$min_even_value, $min_even_index];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min = $nodes->[0];\n    my $min_index = 0;\n\
    \    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0) {\n     \
    \       if ($nodes->[$i] < $min) {\n                $min = $nodes->[$i];\n   \
    \             $min_index = $i;\n            }\n        }\n    }\n    if ($min\
    \ % 2 == 0) {\n        return [$min, $min_index];\n    }\n    return [];\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $i (0 .. $#$nodes) {\n        my $v = $nodes->[$i];\n   \
    \     if ($v % 2 == 0) {\n            if (!defined $min_even || $v < $min_even)\
    \ {\n                $min_even = $v;\n                $min_even_idx = $i;\n  \
    \          }\n        }\n    }\n    return defined $min_even ? [$min_even, $min_even_idx]\
    \ : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0)\
    \ {\n            if (not defined $min_even or $nodes->[$i] < $min_even) {\n  \
    \              $min_even = $nodes->[$i];\n                $min_even_index = $i;\n\
    \            }\n        }\n    }\n    return defined $min_even ? [$min_even, $min_even_index]\
    \ : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min = undef;\n    my $index = undef;\n  \
    \  for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0) {\n       \
    \     if (!defined $min || $nodes->[$i] < $min) {\n                $min = $nodes->[$i];\n\
    \                $index = $i;\n            }\n        }\n    }\n    return defined\
    \ $min ? [$min, $index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n \
    \   my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my @evens = grep { $_ % 2 == 0 } @nodes;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $index = first_index {\
    \ $_ == $min } @nodes;\n    return [$min, $index];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmp4qcolu8n.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmp4qcolu8n.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmp4qcolu8n.pl line 34.\n"
  stdout: ''
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min = undef;\n    my $min_index = undef;\n\
    \    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min) {\n           \
    \     $min = $node;\n                $min_index = $i;\n            } elsif ($node\
    \ < $min) {\n                $min = $node;\n                $min_index = $i;\n\
    \            }\n        }\n    }\n    if (defined $min) {\n        return [$min,\
    \ $min_index];\n    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\
    \nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $n = $nodes->[$i];\n \
    \       if ($n % 2 == 0) {\n            if (!defined $min_even || $n < $min_even)\
    \ {\n                $min_even = $n;\n                $min_even_index = $i;\n\
    \            }\n        }\n    }\n    return defined $min_even ? [$min_even, $min_even_index]\
    \ : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        if ($nodes->[$i]\
    \ % 2 == 0) {\n            if (!defined $min_even || $nodes->[$i] < $min_even)\
    \ {\n                $min_even = $nodes->[$i];\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_idx\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_idx];\n    } else {\n        return [];\n   \
    \ }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my @evens = grep { $_ % 2 == 0 } @nodes;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $index = firstidx { $_\
    \ == $min } @nodes;\n    return [$min, $index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmpzhjirafm.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmpzhjirafm.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmpzhjirafm.pl line 34.\n"
  stdout: ''
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $min_index = undef;\n\
    \    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n        if\
    \ ($node % 2 == 0) {\n            if (!defined $min || $node < $min) {\n     \
    \           $min = $node;\n                $min_index = $i;\n            }\n \
    \       }\n    }\n    if (defined $min) {\n        return [$min, $min_index];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $min_index = undef;\n \
    \   for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n         \
    \   if (!defined $min || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min) {\n        return [$min, $min_index];\n    } else {\n        return [];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min   = undef;\n    my $index = undef;\n\
    \    for my $i ( 0 .. $#$nodes ) {\n        my $node = $nodes->[$i];\n       \
    \ if ( $node % 2 == 0 ) {\n            if ( !defined $min ) {\n              \
    \  $min   = $node;\n                $index = $i;\n            }\n            elsif\
    \ ( $node < $min ) {\n                $min   = $node;\n                $index\
    \ = $i;\n            }\n        }\n    }\n    if ( defined $min ) {\n        return\
    \ [ $min, $index ];\n    }\n    else {\n        return [];\n    }\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $min_index = undef;\n \
    \   for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n         \
    \   if (!defined $min) {\n                $min = $nodes[$i];\n               \
    \ $min_index = $i;\n            } elsif ($nodes[$i] < $min) {\n              \
    \  $min = $nodes[$i];\n                $min_index = $i;\n            }\n     \
    \   }\n    }\n    if (defined $min) {\n        return [$min, $min_index];\n  \
    \  } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231759
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $index = undef;\n    for\
    \ my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n            if (!defined\
    \ $min || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n         \
    \       $index = $i;\n            }\n        }\n    }\n    if (defined $min) {\n\
    \        return [$min, $index];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231759
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my @evens = grep { $_ % 2 == 0 } @nodes;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $index = first_index {\
    \ $_ == $min } @nodes;\n    return [$min, $index];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmp4qcolu8n.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmp4qcolu8n.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmp4qcolu8n.pl line 34.\n"
  stdout: ''
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $min_idx = undef;\n   \
    \ for my $i (0..$#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n            if\
    \ (not defined $min) {\n                $min = $nodes[$i];\n                $min_idx\
    \ = $i;\n            } elsif ($nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min) {\n        return [$min, $min_idx];\n    } else {\n        return [];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min = 1e9;\n    my $index = -1;\n    for\
    \ my $i (0..$#$nodes) {\n        my $node = $nodes->[$i];\n        if ($node %\
    \ 2 == 0) {\n            if ($node < $min) {\n                $min = $node;\n\
    \                $index = $i;\n            }\n        }\n    }\n    if ($index\
    \ == -1) {\n        return [];\n    }\n    return [$min, $index];\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = 0;\n    my $index = 0;\n    my $i =\
    \ 0;\n    foreach my $node (@$nodes) {\n        if ($node % 2 == 0) {\n      \
    \      if ($min == 0) {\n                $min = $node;\n                $index\
    \ = $i;\n            }\n            elsif ($node < $min) {\n                $min\
    \ = $node;\n                $index = $i;\n            }\n        }\n        $i++;\n\
    \    }\n    if ($min == 0) {\n        return [];\n    }\n    else {\n        return\
    \ [$min, $index];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $index = undef;\n    for\
    \ (my $i = 0; $i < @nodes; $i++) {\n        if ($nodes[$i] % 2 == 0) {\n     \
    \       if (!defined($min) || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $index = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $index];\n    } else {\n        return [];\n    }\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $idx (0 .. $#$nodes) {\n        if ($nodes->[$idx] % 2 ==\
    \ 0) {\n            if (!defined $min_even || $nodes->[$idx] < $min_even) {\n\
    \                $min_even = $nodes->[$idx];\n                $min_even_idx =\
    \ $idx;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $idx (0 .. $#$nodes) {\n        my $node = $nodes->[$idx];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_idx\
    \ = $idx;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_index =\
    \ undef;\n    for (my $i = 0; $i < @nodes; $i++) {\n        if ($nodes[$i] % 2\
    \ == 0) {\n            if (!defined($min_even) || $nodes[$i] < $min_even) {\n\
    \                $min_even = $nodes[$i];\n                $min_even_index = $i;\n\
    \            }\n        }\n    }\n    return defined($min_even) ? [$min_even,\
    \ $min_even_index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_index = undef;\n\
    \    for my $i (0 .. $#$nodes) {\n        my $n = $nodes->[$i];\n        if ($n\
    \ % 2 == 0) {\n            if (!defined $min_even || $n < $min_even) {\n     \
    \           $min_even = $n;\n                $min_index = $i;\n            }\n\
    \        }\n    }\n    if (defined $min_even) {\n        return [$min_even, $min_index];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $i (0 .. $#$nodes) {\n        my $n = $nodes->[$i];\n   \
    \     if ($n % 2 == 0) {\n            if (not defined $min_even or $n < $min_even)\
    \ {\n                $min_even = $n;\n                $min_even_idx = $i;\n  \
    \          }\n        }\n    }\n    if (defined $min_even) {\n        return [$min_even,\
    \ $min_even_idx];\n    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (not defined $min_even or $node\
    \ < $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $min_idx = undef;\n   \
    \ for my $i (0..$#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n            if\
    \ (!defined $min || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min) {\n        return [$min, $min_idx];\n    } else {\n        return [];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $idx (0 .. $#$nodes) {\n        my $node = $nodes->[$idx];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_idx\
    \ = $idx;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_index =\
    \ undef;\n    for (my $i = 0; $i < @nodes; $i++) {\n        if ($nodes[$i] % 2\
    \ == 0) {\n            if (!defined($min_even) || $nodes[$i] < $min_even) {\n\
    \                $min_even = $nodes[$i];\n                $min_even_index = $i;\n\
    \            }\n        }\n    }\n    if (defined($min_even)) {\n        return\
    \ [$min_even, $min_even_index];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $idx (0 .. $#$nodes) {\n        my $node = $nodes->[$idx];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_idx\
    \ = $idx;\n            }\n        }\n    }\n    if (defined $min_even) {\n   \
    \     return [$min_even, $min_even_idx];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my @evens = grep { $_ % 2 == 0 } @$nodes;\n  \
    \  return [] unless @evens;\n    my $min = min @evens;\n    my $idx = firstidx\
    \ { $_ == $min } @$nodes;\n    return [$min, $idx];\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmpem33kul_.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmpem33kul_.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmpem33kul_.pl line 34.\n"
  stdout: ''
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $min_index = undef;\n\
    \    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n        if\
    \ ($node % 2 == 0) {\n            if (!defined $min || $node < $min) {\n     \
    \           $min = $node;\n                $min_index = $i;\n            }\n \
    \       }\n    }\n    return defined $min ? [$min, $min_index] : [];\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $index = undef;\n    for\
    \ (my $i = 0; $i < @nodes; $i++) {\n        if ($nodes[$i] % 2 == 0) {\n     \
    \       if (!defined($min) || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $index = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $index];\n    } else {\n        return [];\n    }\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $smallest_value = undef;\n    my $smallest_index\
    \ = undef;\n    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        my $node\
    \ = $nodes->[$i];\n        if ($node % 2 == 0) {\n            if (!defined $smallest_value)\
    \ {\n                $smallest_value = $node;\n                $smallest_index\
    \ = $i;\n            } elsif ($node < $smallest_value) {\n                $smallest_value\
    \ = $node;\n                $smallest_index = $i;\n            }\n        }\n\
    \    }\n    if (defined $smallest_value) {\n        return [$smallest_value, $smallest_index];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_value = undef;\n    my $min_index = undef;\n\
    \    for my $i (0 .. $#$nodes) {\n        my $value = $nodes->[$i];\n        if\
    \ ($value % 2 == 0) {\n            if (!defined $min_value || $value < $min_value)\
    \ {\n                $min_value = $value;\n                $min_index = $i;\n\
    \            }\n        }\n    }\n    if (defined $min_value) {\n        return\
    \ [$min_value, $min_index];\n    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my ($min, $index) = (undef, undef);\n    for my\
    \ $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0) {\n            if (!defined\
    \ $min || $nodes->[$i] < $min) {\n                $min = $nodes->[$i];\n     \
    \           $index = $i;\n            }\n        }\n    }\n    return defined\
    \ $min ? [$min, $index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n \
    \   my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $min_index = undef;\n \
    \   for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n         \
    \   if (!defined $min || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min) {\n        return [$min, $min_index];\n    } else {\n        return [];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $n = $nodes->[$i];\n \
    \       next if $n % 2;\n        if (!defined $min_even || $n < $min_even) {\n\
    \            $min_even = $n;\n            $min_even_index = $i;\n        }\n \
    \   }\n    return [] unless defined $min_even;\n    return [$min_even, $min_even_index];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        my $node\
    \ = $nodes->[$i];\n        if ($node % 2 == 0) {\n            if (!defined $min_even\
    \ || $node < $min_even) {\n                $min_even = $node;\n              \
    \  $min_even_index = $i;\n            }\n        }\n    }\n    if (defined $min_even)\
    \ {\n        return [$min_even, $min_even_index];\n    } else {\n        return\
    \ [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate =\
    \ \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n       \
    \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = 10001;\n    my $index = -1;\n    for (my\
    \ $i = 0; $i < @nodes; $i++) {\n        if ($nodes[$i] % 2 == 0 && $nodes[$i]\
    \ < $min) {\n            $min = $nodes[$i];\n            $index = $i;\n      \
    \  }\n    }\n    if ($index == -1) {\n        return [];\n    } else {\n     \
    \   return [$min, $index];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $min_index = undef;\n\
    \    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n        if\
    \ ($node % 2 == 0) {\n            if (!defined $min || $node < $min) {\n     \
    \           $min = $node;\n                $min_index = $i;\n            }\n \
    \       }\n    }\n    if (defined $min) {\n        return [$min, $min_index];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (not defined $min_even) {\n   \
    \             $min_even = $node;\n                $min_even_index = $i;\n    \
    \        }\n            elsif ($node < $min_even) {\n                $min_even\
    \ = $node;\n                $min_even_index = $i;\n            }\n        }\n\
    \    }\n    if (defined $min_even) {\n        return [$min_even, $min_even_index];\n\
    \    }\n    else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for (my $i = 0; $i < @nodes; $i++) {\n        if ($nodes[$i] % 2 == 0) {\n\
    \            if (!defined($min_even) || $nodes[$i] < $min_even) {\n          \
    \      $min_even = $nodes[$i];\n                $min_even_idx = $i;\n        \
    \    }\n        }\n    }\n    if (defined($min_even)) {\n        return [$min_even,\
    \ $min_even_idx];\n    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $idx (0 .. $#$nodes) {\n        my $node = $nodes->[$idx];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_idx\
    \ = $idx;\n            }\n        }\n    }\n    if (defined $min_even) {\n   \
    \     return [$min_even, $min_even_idx];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $index = undef;\n    for\
    \ (my $i = 0; $i < @nodes; $i++) {\n        if ($nodes[$i] % 2 == 0) {\n     \
    \       if (!defined($min) || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $index = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $index];\n    } else {\n        return [];\n    }\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($arr) = @_;\n    my $min = -1;\n    my $index = -1;\n    for my $i\
    \ (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $index = $i;\n            }\n        }\n    }\n    return [$min, $index];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1660231760
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my @evens = grep { $_ % 2 == 0 } @$nodes;\n  \
    \  return [] unless @evens;\n    my $min = min @evens;\n    my $idx = firstidx\
    \ { $_ == $min } @$nodes;\n    return [$min, $idx];\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmpem33kul_.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmpem33kul_.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmpem33kul_.pl line 34.\n"
  stdout: ''
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (not defined $min_even or $node\
    \ < $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even_value = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even_value || $node\
    \ < $min_even_value) {\n                $min_even_value = $node;\n           \
    \     $min_even_index = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min_even_value) {\n        return [$min_even_value, $min_even_index];\n   \
    \ } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $min_index = undef;\n\
    \    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        if ($nodes->[$i] %\
    \ 2 == 0) {\n            if (!defined $min) {\n                $min = $nodes->[$i];\n\
    \                $min_index = $i;\n            } elsif ($nodes->[$i] < $min) {\n\
    \                $min = $nodes->[$i];\n                $min_index = $i;\n    \
    \        }\n        }\n    }\n    if (defined $min) {\n        return [$min, $min_index];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (not defined $min_even or $node\
    \ < $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $index = undef;\n    for\
    \ (my $i = 0; $i < @nodes; $i++) {\n        if ($nodes[$i] % 2 == 0) {\n     \
    \       if (!defined($min) || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $index = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $index];\n    } else {\n        return [];\n    }\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $min_idx = undef;\n   \
    \ for my $i (0..$#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n            if\
    \ (!defined $min || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min) {\n        return [$min, $min_idx];\n    } else {\n        return [];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my @evens = grep { $_ % 2 == 0 } @nodes;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $index = first_index {\
    \ $_ == $min } @nodes;\n    return [$min, $index];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmp4qcolu8n.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmp4qcolu8n.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmp4qcolu8n.pl line 34.\n"
  stdout: ''
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = 10001;\n    my $index = -1;\n    for my\
    \ $i (0..$#nodes) {\n        if ($nodes[$i] % 2 == 0 && $nodes[$i] < $min) {\n\
    \            $min = $nodes[$i];\n            $index = $i;\n        }\n    }\n\
    \    if ($index == -1) {\n        return [];\n    } else {\n        return [$min,\
    \ $index];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        if ($nodes->[$i]\
    \ % 2 == 0) {\n            if (!defined $min_even || $nodes->[$i] < $min_even)\
    \ {\n                $min_even = $nodes->[$i];\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i\
    \ (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $idx = $i;\n            }\n        }\n    }\n    return $min == -1 ? []\
    \ : [$min, $idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $min_index = undef;\n\
    \    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n        if\
    \ ($node % 2 == 0) {\n            if (!defined $min) {\n                $min =\
    \ $node;\n                $min_index = $i;\n            } elsif ($node < $min)\
    \ {\n                $min = $node;\n                $min_index = $i;\n       \
    \     }\n        }\n    }\n    if (defined $min) {\n        return [$min, $min_index];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0)\
    \ {\n            if (!defined $min_even || $nodes->[$i] < $min_even) {\n     \
    \           $min_even = $nodes->[$i];\n                $min_even_index = $i;\n\
    \            }\n        }\n    }\n    if (defined $min_even) {\n        return\
    \ [$min_even, $min_even_index];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min   = undef;\n    my $index = undef;\n\
    \    for my $i ( 0 .. $#$nodes ) {\n        if ( $nodes->[$i] % 2 == 0 ) {\n \
    \           if ( !defined $min || $nodes->[$i] < $min ) {\n                $min\
    \   = $nodes->[$i];\n                $index = $i;\n            }\n        }\n\
    \    }\n    return defined $min ? [ $min, $index ] : [];\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my @evens = grep { $_ % 2 == 0 } @nodes;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $index = firstidx { $_\
    \ == $min } @nodes;\n    return [$min, $index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmpzhjirafm.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmpzhjirafm.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmpzhjirafm.pl line 34.\n"
  stdout: ''
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0)\
    \ {\n            if (!defined $min_even || $nodes->[$i] < $min_even) {\n     \
    \           $min_even = $nodes->[$i];\n                $min_even_idx = $i;\n \
    \           }\n        }\n    }\n    if (defined $min_even) {\n        return\
    \ [$min_even, $min_even_idx];\n    } else {\n        return [];\n    }\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n      \
    \  if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $min_index = undef;\n\
    \    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        if ($nodes->[$i] %\
    \ 2 == 0) {\n            if (!defined $min) {\n                $min = $nodes->[$i];\n\
    \                $min_index = $i;\n            } elsif ($nodes->[$i] < $min) {\n\
    \                $min = $nodes->[$i];\n                $min_index = $i;\n    \
    \        }\n        }\n    }\n    if (defined $min) {\n        return [$min, $min_index];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $min_index = undef;\n\
    \    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0) {\n     \
    \       if (!defined $min || $nodes->[$i] < $min) {\n                $min = $nodes->[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min) {\n        return [$min, $min_index];\n    } else {\n        return [];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $min_index = undef;\n\
    \    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        if ($nodes->[$i] %\
    \ 2 == 0) {\n            if (!defined $min || $nodes->[$i] < $min) {\n       \
    \         $min = $nodes->[$i];\n                $min_index = $i;\n           \
    \ }\n        }\n    }\n    if (defined $min) {\n        return [$min, $min_index];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $smallest_even_value = undef;\n    my $smallest_even_value_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0)\
    \ {\n            if (!defined $smallest_even_value || $nodes->[$i] < $smallest_even_value)\
    \ {\n                $smallest_even_value = $nodes->[$i];\n                $smallest_even_value_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $smallest_even_value)\
    \ {\n        return [$smallest_even_value, $smallest_even_value_index];\n    }\
    \ else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0)\
    \ {\n            if (!defined $min_even || $nodes->[$i] < $min_even) {\n     \
    \           $min_even = $nodes->[$i];\n                $min_even_index = $i;\n\
    \            }\n        }\n    }\n    if (defined $min_even) {\n        return\
    \ [$min_even, $min_even_index];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227683
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $idx (0 .. $#$nodes) {\n        my $node = $nodes->[$idx];\n\
    \        next if $node % 2;\n        if (!defined $min_even || $node < $min_even)\
    \ {\n            $min_even = $node;\n            $min_even_idx = $idx;\n     \
    \   }\n    }\n    return defined $min_even ? [$min_even, $min_even_idx] : [];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227683
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0)\
    \ {\n            if (!defined $min_even || $nodes->[$i] < $min_even) {\n     \
    \           $min_even = $nodes->[$i];\n                $min_even_index = $i;\n\
    \            }\n        }\n    }\n    if (defined $min_even) {\n        return\
    \ [$min_even, $min_even_index];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227683
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min = undef;\n    my $min_idx = undef;\n\
    \    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        if ($nodes->[$i] %\
    \ 2 == 0) {\n            if (!defined $min || $nodes->[$i] < $min) {\n       \
    \         $min = $nodes->[$i];\n                $min_idx = $i;\n            }\n\
    \        }\n    }\n    if (defined $min) {\n        return [$min, $min_idx];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n        \
    \    if (!defined $min_even || $nodes[$i] < $min_even) {\n                $min_even\
    \ = $nodes[$i];\n                $min_even_idx = $i;\n            }\n        }\n\
    \    }\n    return defined $min_even ? [$min_even, $min_even_idx] : [];\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n      \
    \  if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = 1e9;\n    my $index = -1;\n    for (my\
    \ $i = 0; $i < @$nodes; $i++) {\n        if ($nodes->[$i] % 2 == 0 && $nodes->[$i]\
    \ < $min) {\n            $min = $nodes->[$i];\n            $index = $i;\n    \
    \    }\n    }\n    return $index == -1 ? [] : [$min, $index];\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n        \
    \    if (!defined $min_even || $nodes[$i] < $min_even) {\n                $min_even\
    \ = $nodes[$i];\n                $min_even_idx = $i;\n            }\n        }\n\
    \    }\n    if (defined $min_even) {\n        return [$min_even, $min_even_idx];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $idx (0 .. $#$nodes) {\n        my $node = $nodes->[$idx];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_idx\
    \ = $idx;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = $nodes->[0];\n    my $min_index = 0;\n\
    \    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0 && $nodes->[$i]\
    \ < $min) {\n            $min = $nodes->[$i];\n            $min_index = $i;\n\
    \        }\n    }\n    return $min % 2 == 0 ? [$min, $min_index] : [];\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n      \
    \  if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $index = undef;\n    for\
    \ my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n            if (not\
    \ defined $min or $nodes[$i] < $min) {\n                $min = $nodes[$i];\n \
    \               $index = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min) {\n        return [$min, $index];\n    } else {\n        return [];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my @evens = grep { $_ % 2 == 0 } @nodes;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $index = first_index {\
    \ $_ == $min } @nodes;\n    return [$min, $index];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmp4qcolu8n.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmp4qcolu8n.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmp4qcolu8n.pl line 34.\n"
  stdout: ''
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $smallest_even = undef;\n    my $smallest_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $smallest_even || $node\
    \ < $smallest_even) {\n                $smallest_even = $node;\n             \
    \   $smallest_even_index = $i;\n            }\n        }\n    }\n    return defined\
    \ $smallest_even ? [$smallest_even, $smallest_even_index] : [];\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my @evens = grep { $_ % 2 == 0 } @nodes;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $index = first_index {\
    \ $_ == $min } @nodes;\n    return [$min, $index];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmp4qcolu8n.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmp4qcolu8n.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmp4qcolu8n.pl line 34.\n"
  stdout: ''
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $index = undef;\n    for\
    \ (my $i = 0; $i < @nodes; $i++) {\n        if ($nodes[$i] % 2 == 0) {\n     \
    \       if (!defined($min) || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $index = $i;\n            }\n        }\n    }\n    return defined($min)\
    \ ? [$min, $index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = $nodes->[0];\n    my $min_index = 0;\n\
    \    my $even = 0;\n    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i]\
    \ % 2 == 0) {\n            $even = 1;\n            if ($nodes->[$i] < $min) {\n\
    \                $min = $nodes->[$i];\n                $min_index = $i;\n    \
    \        }\n        }\n    }\n    return [] unless $even;\n    return [$min, $min_index];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660231760
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my @evens = grep { $_ % 2 == 0 } @$nodes;\n \
    \   return [] unless @evens;\n    my $min = min @evens;\n    my $index = first_index\
    \ { $_ == $min } @$nodes;\n    return [ $min, $index ];\n}\nuse Test::Deep;\n\n\
    \nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmpjw1nwn88.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmpjw1nwn88.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmpjw1nwn88.pl line 34.\n"
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $min_index = undef;\n\
    \    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min || $node < $min)\
    \ {\n                $min = $node;\n                $min_index = $i;\n       \
    \     }\n        }\n    }\n    if (defined $min) {\n        return [$min, $min_index];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $min_idx = undef;\n   \
    \ for my $i (0..$#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n            if\
    \ (!defined $min || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    return defined\
    \ $min ? [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = 10001;\n    my $index = -1;\n    for my\
    \ $i (0..$#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n            if ($nodes[$i]\
    \ < $min) {\n                $min = $nodes[$i];\n                $index = $i;\n\
    \            }\n        }\n    }\n    if ($index == -1) {\n        return [];\n\
    \    } else {\n        return [$min, $index];\n    }\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $idx (0 .. $#nodes) {\n        if ($nodes[$idx] % 2 == 0) {\n    \
    \        if (!defined $min_even) {\n                $min_even = $nodes[$idx];\n\
    \                $min_even_idx = $idx;\n            } elsif ($nodes[$idx] < $min_even)\
    \ {\n                $min_even = $nodes[$idx];\n                $min_even_idx\
    \ = $idx;\n            }\n        }\n    }\n    if (defined $min_even) {\n   \
    \     return [$min_even, $min_even_idx];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_idx\
    \ = $i;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        if ($nodes->[$i]\
    \ % 2 == 0) {\n            if (!defined $min_even || $nodes->[$i] < $min_even)\
    \ {\n                $min_even = $nodes->[$i];\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for (my\
    \ $i = 0; $i < @nodes; $i++) {\n        if ($nodes[$i] % 2 == 0 && ($min == -1\
    \ || $nodes[$i] < $min)) {\n            $min = $nodes[$i];\n            $min_idx\
    \ = $i;\n        }\n    }\n    return $min == -1 ? [] : [$min, $min_idx];\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even_value = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n\
    \            if (not defined $min_even_value or $nodes[$i] < $min_even_value)\
    \ {\n                $min_even_value = $nodes[$i];\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even_value) {\n\
    \        return [$min_even_value, $min_even_index];\n    } else {\n        return\
    \ [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate =\
    \ \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n       \
    \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_index =\
    \ undef;\n    for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n\
    \            if (!defined $min_even || $nodes[$i] < $min_even) {\n           \
    \     $min_even = $nodes[$i];\n                $min_even_index = $i;\n       \
    \     }\n        }\n    }\n    if (defined $min_even) {\n        return [$min_even,\
    \ $min_even_index];\n    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $idx (0 .. $#$nodes) {\n        my $node = $nodes->[$idx];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_idx\
    \ = $idx;\n            }\n        }\n    }\n    if (defined $min_even) {\n   \
    \     return [$min_even, $min_even_idx];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_index =\
    \ undef;\n    for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n\
    \            if (!defined $min_even || $nodes[$i] < $min_even) {\n           \
    \     $min_even = $nodes[$i];\n                $min_even_index = $i;\n       \
    \     }\n        }\n    }\n    return defined $min_even ? [$min_even, $min_even_index]\
    \ : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $min_index = undef;\n \
    \   for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n         \
    \   if (!defined $min || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min) {\n        return [$min, $min_index];\n    } else {\n        return [];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231759
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $min_idx = undef;\n   \
    \ for my $i (0..$#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n            if\
    \ (not defined $min or $nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min) {\n        return [$min, $min_idx];\n    } else {\n        return [];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_index =\
    \ undef;\n    for (my $i = 0; $i < @nodes; $i++) {\n        if ($nodes[$i] % 2\
    \ == 0) {\n            if (!defined($min_even) || $nodes[$i] < $min_even) {\n\
    \                $min_even = $nodes[$i];\n                $min_even_index = $i;\n\
    \            }\n        }\n    }\n    if (defined($min_even)) {\n        return\
    \ [$min_even, $min_even_index];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $idx (0 .. $#nodes) {\n        my $node = $nodes[$idx];\n        if\
    \ ($node % 2 == 0) {\n            if (!defined $min_even || $node < $min_even)\
    \ {\n                $min_even = $node;\n                $min_even_idx = $idx;\n\
    \            }\n        }\n    }\n    if (defined $min_even) {\n        return\
    \ [$min_even, $min_even_idx];\n    } else {\n        return [];\n    }\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n      \
    \  if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_index =\
    \ undef;\n    for (my $i = 0; $i < @nodes; $i++) {\n        if ($nodes[$i] % 2\
    \ == 0) {\n            if (!defined($min_even) || $nodes[$i] < $min_even) {\n\
    \                $min_even = $nodes[$i];\n                $min_even_index = $i;\n\
    \            }\n        }\n    }\n    if (defined($min_even)) {\n        return\
    \ [$min_even, $min_even_index];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        my $node\
    \ = $nodes->[$i];\n        if ($node % 2 == 0) {\n            if (!defined $min_even)\
    \ {\n                $min_even = $node;\n                $min_even_index = $i;\n\
    \            } elsif ($node < $min_even) {\n                $min_even = $node;\n\
    \                $min_even_index = $i;\n            }\n        }\n    }\n    if\
    \ (defined $min_even) {\n        return [$min_even, $min_even_index];\n    } else\
    \ {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n \
    \   for my $i (0 .. $#$nodes) {\n        my $n = $nodes->[$i];\n        if ($n\
    \ % 2 == 0) {\n            if (!defined $min || $n < $min) {\n               \
    \ $min = $n;\n                $min_idx = $i;\n            }\n        }\n    }\n\
    \    return defined $min ? [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $idx (0 .. $#$nodes) {\n        my $node = $nodes->[$idx];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_idx\
    \ = $idx;\n            }\n        }\n    }\n    if (defined $min_even) {\n   \
    \     return [$min_even, $min_even_idx];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0)\
    \ {\n            if (!defined $min_even || $nodes->[$i] < $min_even) {\n     \
    \           $min_even = $nodes->[$i];\n                $min_even_index = $i;\n\
    \            }\n        }\n    }\n    if (defined $min_even) {\n        return\
    \ [$min_even, $min_even_index];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $arr = shift;\n    my $min = undef;\n    my $min_idx = undef;\n  \
    \  for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n           \
    \ if (!defined $min || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    return defined\
    \ $min ? [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even_value = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even_value || $node\
    \ < $min_even_value) {\n                $min_even_value = $node;\n           \
    \     $min_even_index = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min_even_value) {\n        return [$min_even_value, $min_even_index];\n   \
    \ } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even_value = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $value = $nodes->[$i];\n\
    \        if ($value % 2 == 0) {\n            if (!defined $min_even_value || $value\
    \ < $min_even_value) {\n                $min_even_value = $value;\n          \
    \      $min_even_index = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min_even_value) {\n        return [$min_even_value, $min_even_index];\n   \
    \ } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $idx (0 .. $#$nodes) {\n        my $node = $nodes->[$idx];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_idx\
    \ = $idx;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $min_index = undef;\n \
    \   for (my $i = 0; $i < @nodes; $i++) {\n        if ($nodes[$i] % 2 == 0) {\n\
    \            if (!defined($min) || $nodes[$i] < $min) {\n                $min\
    \ = $nodes[$i];\n                $min_index = $i;\n            }\n        }\n\
    \    }\n    if (defined($min)) {\n        return [$min, $min_index];\n    } else\
    \ {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_idx\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_idx];\n    } else {\n        return [];\n   \
    \ }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n \
    \   for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n        if\
    \ ($node % 2 == 0) {\n            if (not defined $min) {\n                $min\
    \ = $node;\n                $min_idx = $i;\n            }\n            elsif ($node\
    \ < $min) {\n                $min = $node;\n                $min_idx = $i;\n \
    \           }\n        }\n    }\n    if (defined $min) {\n        return [$min,\
    \ $min_idx];\n    }\n    else {\n        return [];\n    }\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        if (defined $nodes->[$i]\
    \ && $nodes->[$i] % 2 == 0) {\n            if (!defined $min_even || $nodes->[$i]\
    \ < $min_even) {\n                $min_even = $nodes->[$i];\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $index = undef;\n   \
    \ for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0) {\n        \
    \    if (not defined $min) {\n                $min = $nodes->[$i];\n         \
    \       $index = $i;\n            }\n            elsif ($nodes->[$i] < $min) {\n\
    \                $min = $nodes->[$i];\n                $index = $i;\n        \
    \    }\n        }\n    }\n    if (defined $min) {\n        return [$min, $index];\n\
    \    }\n    else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0)\
    \ {\n            if (!defined $min_even || $nodes->[$i] < $min_even) {\n     \
    \           $min_even = $nodes->[$i];\n                $min_even_index = $i;\n\
    \            }\n        }\n    }\n    if (defined $min_even) {\n        return\
    \ [$min_even, $min_even_index];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227683
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n \
    \   for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n        if\
    \ ($node % 2 == 0) {\n            if (!defined $min || $node < $min) {\n     \
    \           $min = $node;\n                $min_idx = $i;\n            }\n   \
    \     }\n    }\n    if (defined $min) {\n        return [$min, $min_idx];\n  \
    \  } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = -1;\n    my $index = -1;\n    for my $i\
    \ (0..$#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n            if ($min ==\
    \ -1) {\n                $min = $nodes[$i];\n                $index = $i;\n  \
    \          } elsif ($nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $index = $i;\n            }\n        }\n    }\n    if ($min ==\
    \ -1) {\n        return [];\n    } else {\n        return [$min, $index];\n  \
    \  }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0)\
    \ {\n            if (!defined $min_even || $nodes->[$i] < $min_even) {\n     \
    \           $min_even = $nodes->[$i];\n                $min_even_index = $i;\n\
    \            }\n        }\n    }\n    if (defined $min_even) {\n        return\
    \ [$min_even, $min_even_index];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227683
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_index =\
    \ undef;\n    for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n\
    \            if (!defined $min_even || $nodes[$i] < $min_even) {\n           \
    \     $min_even = $nodes[$i];\n                $min_even_index = $i;\n       \
    \     }\n        }\n    }\n    if (defined $min_even) {\n        return [$min_even,\
    \ $min_even_index];\n    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $min_idx = undef;\n   \
    \ for my $i (0..$#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n            if\
    \ (!defined $min || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min) {\n        return [$min, $min_idx];\n    } else {\n        return [];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0)\
    \ {\n            if (!defined $min_even || $nodes->[$i] < $min_even) {\n     \
    \           $min_even = $nodes->[$i];\n                $min_even_index = $i;\n\
    \            }\n        }\n    }\n    return defined $min_even ? [$min_even, $min_even_index]\
    \ : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my @evens = grep { $_ % 2 == 0 } @nodes;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $index = first_index {\
    \ $_ == $min } @nodes;\n    return [$min, $index];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmp4qcolu8n.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmp4qcolu8n.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmp4qcolu8n.pl line 34.\n"
  stdout: ''
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = -1;\n    my $min_index = -1;\n    for\
    \ my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n            if ($min\
    \ == -1 || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n        \
    \        $min_index = $i;\n            }\n        }\n    }\n    return $min ==\
    \ -1 ? [] : [$min, $min_index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_index =\
    \ undef;\n    for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n\
    \            if (!defined $min_even || $nodes[$i] < $min_even) {\n           \
    \     $min_even = $nodes[$i];\n                $min_even_index = $i;\n       \
    \     }\n        }\n    }\n    return defined $min_even ? [$min_even, $min_even_index]\
    \ : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (not defined $min_even or $node\
    \ < $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $smallest_even_value = undef;\n    my $smallest_even_value_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $smallest_even_value)\
    \ {\n                $smallest_even_value = $node;\n                $smallest_even_value_index\
    \ = $i;\n            }\n            elsif ($node < $smallest_even_value) {\n \
    \               $smallest_even_value = $node;\n                $smallest_even_value_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $smallest_even_value)\
    \ {\n        return [$smallest_even_value, $smallest_even_value_index];\n    }\n\
    \    else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = -1;\n    my $min_even_index =\
    \ -1;\n    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        if ($nodes->[$i]\
    \ % 2 == 0) {\n            if ($min_even == -1 || $nodes->[$i] < $min_even) {\n\
    \                $min_even = $nodes->[$i];\n                $min_even_index =\
    \ $i;\n            }\n        }\n    }\n    return $min_even == -1 ? [] : [$min_even,\
    \ $min_even_index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $min_index = undef;\n\
    \    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n        if\
    \ ($node % 2 == 0) {\n            if (!defined $min || $node < $min) {\n     \
    \           $min = $node;\n                $min_index = $i;\n            }\n \
    \       }\n    }\n    if (defined $min) {\n        return [$min, $min_index];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_index =\
    \ undef;\n    for (my $i = 0; $i < @nodes; $i++) {\n        if ($nodes[$i] % 2\
    \ == 0) {\n            if (not defined $min_even) {\n                $min_even\
    \ = $nodes[$i];\n                $min_even_index = $i;\n            }\n      \
    \      elsif ($nodes[$i] < $min_even) {\n                $min_even = $nodes[$i];\n\
    \                $min_even_index = $i;\n            }\n        }\n    }\n    if\
    \ (defined $min_even) {\n        return [$min_even, $min_even_index];\n    }\n\
    \    else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_idx =\
    \ undef;\n    for my $idx (0 .. $#$nodes) {\n        my $node = $nodes->[$idx];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_idx\
    \ = $idx;\n            }\n        }\n    }\n    if (defined $min_even) {\n   \
    \     return [$min_even, $min_even_idx];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $min_index = undef;\n \
    \   for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n         \
    \   if (!defined $min) {\n                $min = $nodes[$i];\n               \
    \ $min_index = $i;\n            }\n            elsif ($nodes[$i] < $min) {\n \
    \               $min = $nodes[$i];\n                $min_index = $i;\n       \
    \     }\n        }\n    }\n    if (defined $min) {\n        return [$min, $min_index];\n\
    \    }\n    else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even_value = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $value = $nodes->[$i];\n\
    \        if ($value % 2 == 0) {\n            if (!defined $min_even_value || $value\
    \ < $min_even_value) {\n                $min_even_value = $value;\n          \
    \      $min_even_index = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min_even_value) {\n        return [$min_even_value, $min_even_index];\n   \
    \ } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my @evens = grep { $_ % 2 == 0 } @nodes;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $index = first_index {\
    \ $_ == $min } @nodes;\n    return [$min, $index];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmp4qcolu8n.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmp4qcolu8n.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmp4qcolu8n.pl line 34.\n"
  stdout: ''
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $min_index = undef;\n \
    \   for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n         \
    \   if (!defined $min || $nodes[$i] < $min) {\n                $min = $nodes[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min) {\n        return [$min, $min_index];\n    } else {\n        return [];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231759
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($arr) = @_;\n    my $min = $arr->[0];\n    my $idx = 0;\n    for\
    \ my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0 && $arr->[$i] < $min)\
    \ {\n            $min = $arr->[$i];\n            $idx = $i;\n        }\n    }\n\
    \    return [$min, $idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    return defined $min_even ? [$min_even,\
    \ $min_even_index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $min_index = undef;\n\
    \    for (my $i = 0; $i < scalar @$nodes; $i++) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min) {\n           \
    \     $min = $node;\n                $min_index = $i;\n            } elsif ($node\
    \ < $min) {\n                $min = $node;\n                $min_index = $i;\n\
    \            }\n        }\n    }\n    if (defined $min) {\n        return [$min,\
    \ $min_index];\n    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\
    \nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my $nodes = shift;\n    my $min = undef;\n    my $min_index = undef;\n\
    \    for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0) {\n     \
    \       if (!defined $min || $nodes->[$i] < $min) {\n                $min = $nodes->[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    return\
    \ defined $min ? [$min, $min_index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my @evens = grep { $_ % 2 == 0 } @nodes;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $index = firstidx { $_\
    \ == $min } @nodes;\n    return [$min, $index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmpzhjirafm.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmpzhjirafm.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmpzhjirafm.pl line 34.\n"
  stdout: ''
  timestamp: 1660231759
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $index = undef;\n   \
    \ for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n        if ($node\
    \ % 2 == 0) {\n            if (not defined $min or $node < $min) {\n         \
    \       $min = $node;\n                $index = $i;\n            }\n        }\n\
    \    }\n    if (defined $min) {\n        return [$min, $index];\n    } else {\n\
    \        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n \
    \   for my $i (0 .. $#$nodes) {\n        if ($nodes->[$i] % 2 == 0) {\n      \
    \      if (!defined $min || $nodes->[$i] < $min) {\n                $min = $nodes->[$i];\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    return defined\
    \ $min ? [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $min_index = undef;\n \
    \   for my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n         \
    \   if (!defined $min) {\n                $min = $nodes[$i];\n               \
    \ $min_index = $i;\n            } elsif ($nodes[$i] < $min) {\n              \
    \  $min = $nodes[$i];\n                $min_index = $i;\n            }\n     \
    \   }\n    }\n    if (defined $min) {\n        return [$min, $min_index];\n  \
    \  } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231759
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my @evens = grep { $_ % 2 == 0 } @nodes;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $index = first_index {\
    \ $_ == $min } @nodes;\n    return [$min, $index];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmp4qcolu8n.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmp4qcolu8n.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmp4qcolu8n.pl line 34.\n"
  stdout: ''
  timestamp: 1660227682
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $index = undef;\n    for\
    \ my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n            if (not\
    \ defined $min or $nodes[$i] < $min) {\n                $min = $nodes[$i];\n \
    \               $index = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min) {\n        return [$min, $index];\n    } else {\n        return [];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min_even = undef;\n    my $min_even_index =\
    \ undef;\n    for my $index (0 .. $#nodes) {\n        my $node = $nodes[$index];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $index;\n            }\n        }\n    }\n    if (defined $min_even) {\n \
    \       return [$min_even, $min_even_index];\n    } else {\n        return [];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my @nodes = @_;\n    my $min = undef;\n    my $index = undef;\n    for\
    \ my $i (0 .. $#nodes) {\n        if ($nodes[$i] % 2 == 0) {\n            if (not\
    \ defined $min or $nodes[$i] < $min) {\n                $min = $nodes[$i];\n \
    \               $index = $i;\n            }\n        }\n    }\n    return defined\
    \ $min ? [$min, $index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n \
    \   my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660231760
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my ($nodes) = @_;\n    my $min_even = undef;\n    my $min_even_index\
    \ = undef;\n    for my $i (0 .. $#$nodes) {\n        my $node = $nodes->[$i];\n\
    \        if ($node % 2 == 0) {\n            if (!defined $min_even || $node <\
    \ $min_even) {\n                $min_even = $node;\n                $min_even_index\
    \ = $i;\n            }\n        }\n    }\n    if (defined $min_even) {\n     \
    \   return [$min_even, $min_even_index];\n    } else {\n        return [];\n \
    \   }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1660227682
