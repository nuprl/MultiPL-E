name: HumanEval_132_is_nested
language: rkt
prompt: "#lang racket\n\n#| Create a function that takes a string as input which contains\
  \ only square brackets.\nThe function should return #t if and only if there is a\
  \ valid subsequence of brackets \nwhere at least one bracket in the subsequence\
  \ is nested.\n>>> (is_nested \"[[]]\")\n#t\n>>> (is_nested \"[]]]]]]][[[[[]\")\n\
  #f\n>>> (is_nested \"[][]\")\n#f\n>>> (is_nested \"[]\")\n#f\n>>> (is_nested \"\
  [[][]]\")\n#t\n>>> (is_nested \"[[]][[\")\n#t|#\n(define (is_nested string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_nested))\n\
  \    (check-equal? (candidate \"[[]]\") #t)\n    (check-equal? (candidate \"[]]]]]]][[[[[]\"\
  ) #f)\n    (check-equal? (candidate \"[][]\") #f)\n    (check-equal? (candidate\
  \ \"[]\") #f)\n    (check-equal? (candidate \"[[[[]]]]\") #t)\n    (check-equal?\
  \ (candidate \"[]]]]]]]]]]\") #f)\n    (check-equal? (candidate \"[][][[]]\") #t)\n\
  \    (check-equal? (candidate \"[[]\") #f)\n    (check-equal? (candidate \"[]]\"\
  ) #f)\n    (check-equal? (candidate \"[[]][[\") #t)\n    (check-equal? (candidate\
  \ \"[[][]]\") #t)\n    (check-equal? (candidate \"\") #f)\n    (check-equal? (candidate\
  \ \"[[[[[[[[\") #f)\n    (check-equal? (candidate \"]]]]]]]]\") #f)\n))\n\n(test-humaneval)"
completions: ["  (define (helper string)\n    (cond [(empty? string) #t]\n       \
    \   [(equal? (first string) \"[\") (helper (rest string))]\n          [(equal?\
    \ (first string) \"]\") (helper (rest string))]\n          [else (is_nested (rest\
    \ string))]))\n  (helper string))\n", "  (define (helper string count)\n    (cond\n\
    \      [(empty? string) (zero? count)]\n      [(equal? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n      [(equal? (first string) #\\]) (and (positive?\
    \ count) (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define\
    \ (is_nested-helper string stack)\n    (cond\n      [(empty? string) (empty? stack)]\n\
    \      [(char=? (first string) #\\[)\n       (is_nested-helper (rest string) (cons\
    \ #\\[ stack))]\n      [(char=? (first string) #\\])\n       (and (not (empty?\
    \ stack))\n            (is_nested-helper (rest string) (rest stack)))]\n     \
    \ [else (is_nested-helper (rest string) stack)]))\n  (is_nested-helper string\
    \ '()))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string) (+\
    \ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first\
    \ string) #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (helper string)\n    (cond\n      [(empty?\
    \ string) #t]\n      [(equal? (first string) \"[\") (helper (rest string))]\n\
    \      [(equal? (first string) \"]\") #f]))\n  (helper (string-&gt;list string)))\n\
    </code>\nI'm not sure how to check if there is a valid subsequence of brackets\
    \ where at least one bracket in the subsequence is nested.\n\n\nA:\n\nYou can\
    \ use a stack to keep track of the open brackets. If you encounter a closing bracket,\
    \ you pop the stack. If the stack is empty, then you know that there is no matching\
    \ open bracket.\n<code>(define (is-nested string)\n  (define (helper string stack)\n\
    \    (cond\n      [(empty? string) (empty? stack)]\n      [(equal? (first string)\
    \ \"[\") (helper (rest string) (cons (first string) stack))]\n      [(equal? (first\
    \ string) \"]\") (and (not (empty? stack)) (helper (rest string) (rest stack)))]))\n\
    \  (helper (string-&gt;list string) '()))\n</code>\n", "  (define (helper string\
    \ count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(string-contains?\
    \ string #\\[) (helper (substring string 1) (+ count 1))]\n      [(string-contains?\
    \ string #\\]) (and (positive? count) (helper (substring string 1) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond [(empty? string) (zero? count)]\n          [(char=?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n       \
    \   [(char=? (first string) #\\]) (and (positive? count) (is_nested-helper (rest\
    \ string) (- count 1)))]\n          [else (is_nested-helper (rest string) count)]))\n\
    \  (is_nested-helper string 0))\n", "  (define (helper string count)\n    (cond\n\
    \      [(empty? string) (zero? count)]\n      [(char=? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive?\
    \ count) (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define\
    \ (helper string)\n    (cond\n      [(empty? string) #t]\n      [(and (char=?\
    \ (first string) #\\[) (char=? (last string) #\\])) (helper (rest (butlast string)))]\n\
    \      [else #f]))\n  (helper string))\n", "  (define (is_nested-helper string\
    \ count)\n    (cond\n      [(empty? string)\n       (zero? count)]\n      [(char=?\
    \ (first string) #\\[)\n       (is_nested-helper (rest string) (+ count 1))]\n\
    \      [(char=? (first string) #\\])\n       (and (positive? count)\n        \
    \    (is_nested-helper (rest string) (- count 1)))]))\n  (is_nested-helper string\
    \ 0))\n", "  (define (is_nested-helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive?\
    \ count) (is_nested-helper (rest string) (- count 1)))]\n      [else (is_nested-helper\
    \ (rest string) count)]))\n  (is_nested-helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (positive? count) (is_nested-helper (rest string)\
    \ (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (is_nested-helper string count)\n    (cond\n     \
    \ [(empty? string) (zero? count)]\n      [(equal? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(equal? (first string) #\\]) (and (positive?\
    \ count) (is_nested-helper (rest string) (- count 1)))]\n      [else (is_nested-helper\
    \ (rest string) count)]))\n  (is_nested-helper string 0))\n", "  (define (helper\
    \ str)\n    (cond [(empty? str) #t]\n          [(char=? (first str) #\\[)\n  \
    \         (if (char=? (last str) #\\])\n               (helper (rest (butlast\
    \ str)))\n               #f)]\n          [else #f]))\n  (helper string))\n", " \
    \ (define (is_nested-helper string count)\n    (cond [(empty? string) (= count\
    \ 0)]\n          [(char=? (first string) #\\[) (is_nested-helper (rest string)\
    \ (+ count 1))]\n          [(char=? (first string) #\\]) (is_nested-helper (rest\
    \ string) (- count 1))]\n          [else (is_nested-helper (rest string) count)]))\n\
    \  (is_nested-helper string 0))\n", "  (define (helper string count)\n    (cond\n\
    \      [(empty? string) (zero? count)]\n      [(char=? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive?\
    \ count) (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define\
    \ (is_nested-helper string count)\n    (cond [(empty? string) (zero? count)]\n\
    \          [(char=? (first string) #\\[) (is_nested-helper (rest string) (+ count\
    \ 1))]\n          [(char=? (first string) #\\]) (and (positive? count) (is_nested-helper\
    \ (rest string) (- count 1)))]\n          [else (is_nested-helper (rest string)\
    \ count)]))\n  (is_nested-helper string 0))\n", "  (define (helper string count)\n\
    \    (cond\n      [(empty? string) (zero? count)]\n      [(char=? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first string) #\\\
    ]) (and (positive? count) (helper (rest string) (- count 1)))]))\n  (helper string\
    \ 0))\n", "  (define (helper string count)\n    (cond [(empty? string) (zero?\
    \ count)]\n          [(char=? (first string) #\\[) (helper (rest string) (+ count\
    \ 1))]\n          [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(equal?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(equal?\
    \ (first string) #\\]) (and (positive? count) (is_nested-helper (rest string)\
    \ (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (if (= count 0) #t #f)]\n      [(string-contains? string \"[\") (helper (substring\
    \ string 1) (+ count 1))]\n      [(string-contains? string \"]\") (helper (substring\
    \ string 1) (- count 1))]))\n  (helper string 0))\n", "  (define (helper str)\n\
    \    (cond\n      [(empty? str) #f]\n      [(string=? (first str) \"[\")\n   \
    \    (if (string=? (last str) \"]\")\n           #t\n           (helper (rest\
    \ (butlast str))))]\n      [else (helper (rest str))]))\n  (helper string))\n",
  "  (define (helper string count)\n    (cond [(empty? string) (zero? count)]\n  \
    \        [(char=? (first string) #\\[) (helper (rest string) (+ count 1))]\n \
    \         [(char=? (first string) #\\]) (and (not (zero? count)) (helper (rest\
    \ string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper string\
    \ count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=? (first\
    \ string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first string)\
    \ #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n  (helper\
    \ string 0))\n", "  (define (helper string)\n    (cond\n      [(empty? string)\
    \ #t]\n      [(string-contains? string \"[\")\n       (if (string-contains? string\
    \ \"]\")\n           (helper (substring string 1 -1))\n           #f)]\n     \
    \ [else #f]))\n  (helper string))\n", "  (define (helper string count)\n    (cond\n\
    \      [(empty? string) (zero? count)]\n      [(char=? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive?\
    \ count) (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define\
    \ (helper string count)\n    (cond [(empty? string) (zero? count)]\n         \
    \ [(char=? (first string) #\\[) (helper (rest string) (+ count 1))]\n        \
    \  [(char=? (first string) #\\]) (and (positive? count) (helper (rest string)\
    \ (- count 1)))]))\n  (helper string 0))\n", "  (define (helper string count)\n\
    \    (cond\n      [(empty? string) (zero? count)]\n      [(string-ref string 0)\
    \ (helper (substring string 1) (add1 count))]\n      [else (helper (substring\
    \ string 1) (sub1 count))]))\n  (helper string 0))\n", "  (define (helper string\
    \ count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(equal? (first\
    \ string) #\\[) (helper (rest string) (+ count 1))]\n      [(equal? (first string)\
    \ #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n  (helper\
    \ string 0))\n", "  (define (is_nested-helper string count)\n    (cond\n     \
    \ [(empty? string) (zero? count)]\n      [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive?\
    \ count) (is_nested-helper (rest string) (- count 1)))]\n      [else (is_nested-helper\
    \ (rest string) count)]))\n  (is_nested-helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond [(empty? string) (zero? count)]\n          [(char=?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n       \
    \   [(char=? (first string) #\\]) (and (positive? count) (is_nested-helper (rest\
    \ string) (- count 1)))]\n          [else (is_nested-helper (rest string) count)]))\n\
    \  (is_nested-helper string 0))\n", "  (define (is_nested-helper string count)\n\
    \    (cond\n      [(empty? string) (= count 0)]\n      [(char=? (first string)\
    \ #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=? (first string)\
    \ #\\]) (and (not (zero? count)) (is_nested-helper (rest string) (- count 1)))]))\n\
    \  (is_nested-helper string 0))\n", "  (define (is_nested-helper string count)\n\
    \    (cond\n      [(empty? string) (zero? count)]\n      [(char=? (first string)\
    \ #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=? (first string)\
    \ #\\]) (and (positive? count) (is_nested-helper (rest string) (- count 1)))]\n\
    \      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper string\
    \ 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string) (+\
    \ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string)\n       (zero? count)]\n  \
    \    [(char=? (first string) #\\[)\n       (is_nested-helper (rest string) (+\
    \ count 1))]\n      [(char=? (first string) #\\])\n       (and (positive? count)\n\
    \            (is_nested-helper (rest string) (- count 1)))]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string) (+\
    \ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(equal?\
    \ (first string) \"[\") (helper (rest string) (+ count 1))]\n      [(equal? (first\
    \ string) \"]\") (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(equal? (first string) \"[\") (helper (rest string)\
    \ (+ count 1))]\n      [(equal? (first string) \"]\") (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond [(empty? string) (zero? count)]\n          [(char=?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n          [(char=?\
    \ (first string) #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(equal? (first string) \"[\") (helper (rest string)\
    \ (+ count 1))]\n      [(equal? (first string) \"]\") (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first\
    \ string) #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (helper string count)\n    (cond [(empty?\
    \ string) (= count 0)]\n          [(char=? (first string) #\\[) (helper (rest\
    \ string) (+ count 1))]\n          [(char=? (first string) #\\]) (and (not (=\
    \ count 0)) (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", " \
    \ (define (helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n\
    \      [(equal? (first string) #\\[) (helper (rest string) (+ count 1))]\n   \
    \   [(equal? (first string) #\\]) (and (positive? count) (helper (rest string)\
    \ (- count 1)))]))\n  (helper string 0))\n", "  (define (helper string count)\n\
    \    (cond\n      [(empty? string) (zero? count)]\n      [(equal? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n      [(equal? (first string) #\\\
    ]) (and (positive? count) (helper (rest string) (- count 1)))]))\n  (helper string\
    \ 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (= count 0)]\n      [(char=? (first string) #\\[) (helper (rest string) (+ count\
    \ 1))]\n      [(char=? (first string) #\\]) (and (not (zero? count)) (helper (rest\
    \ string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper string\
    \ count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(char=? (first\
    \ string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first string)\
    \ #\\]) (and (not (zero? count)) (helper (rest string) (- count 1)))]))\n  (helper\
    \ string 0))\n", "  (define (is_nested-helper string count)\n    (cond [(empty?\
    \ string) (zero? count)]\n          [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n          [(char=? (first string) #\\]) (and (positive?\
    \ count) (is_nested-helper (rest string) (- count 1)))]\n          [else (is_nested-helper\
    \ (rest string) count)]))\n  (is_nested-helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(char=?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first\
    \ string) #\\]) (and (not (zero? count)) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond [(empty? string) (equal? count 0)]\n          [(equal?\
    \ (first string) \"[\") (is_nested-helper (rest string) (+ count 1))]\n      \
    \    [(equal? (first string) \"]\") (is_nested-helper (rest string) (- count 1))]\n\
    \          [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string count)\n    (cond [(empty? string)\
    \ (zero? count)]\n          [(char=? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n          [(char=? (first string) #\\]) (and (positive? count)\
    \ (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (let ([open\
    \ 0]\n        [close 0])\n    (for ([c (in-string string)])\n      (cond\n   \
    \     [(char=? c #\\[) (set! open (+ open 1))]\n        [(char=? c #\\]) (set!\
    \ close (+ close 1))]))\n    (and (> open 0) (> close 0) (> open close))))\n",
  "  (define (helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n\
    \      [(equal? (first string) #\\[) (helper (rest string) (+ count 1))]\n   \
    \   [(equal? (first string) #\\]) (and (positive? count) (helper (rest string)\
    \ (- count 1)))]))\n  (helper string 0))\n", "  (define (helper string count)\n\
    \    (cond\n      [(empty? string) (zero? count)]\n      [(char=? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first string) #\\\
    ]) (and (positive? count) (helper (rest string) (- count 1)))]))\n  (helper string\
    \ 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string) (+\
    \ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (positive? count) (is_nested-helper (rest string)\
    \ (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n```\n\n### Problem 4\n\n```racket\n#lang racket\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(char=?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first\
    \ string) #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n```\n\n### Problem 3\n\n```racket\n#lang racket\n", " \
    \ (define (is_nested-helper string count)\n    (cond\n      [(empty? string) (=\
    \ count 0)]\n      [(char=? (first string) #\\[) (is_nested-helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (not (zero? count))\
    \ (is_nested-helper (rest string) (- count 1)))]))\n  (is_nested-helper string\
    \ 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (zero? count)]\n      [(equal? (first string) #\\[) (helper (rest string) (+\
    \ count 1))]\n      [(equal? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first\
    \ string) #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (positive? count) (is_nested-helper (rest string)\
    \ (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string)\n    (cond\n      [(empty? string)\
    \ #t]\n      [(eq? (first string) #\\[) (helper (rest string))]\n      [(eq? (first\
    \ string) #\\]) (if (empty? (rest string)) #f (helper (rest string)))]))\n  (helper\
    \ string))\n", "  (define (helper string count)\n    (cond [(empty? string) (=\
    \ count 0)]\n          [(char=? (first string) #\\[) (helper (rest string) (+\
    \ count 1))]\n          [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string)\n    (cond\n      [(empty? string) #t]\n      [(eq? (first string) (last\
    \ string)) (helper (rest (butlast string)))]\n      [else #f]))\n  (helper string))\n",
  "  (cond\n    [(empty? string) #f]\n    [(equal? (first string) \"[\")\n     (if\
    \ (equal? (last string) \"]\")\n         #t\n         (is_nested (rest (butlast\
    \ string))))]\n    [else (is_nested (rest string))]))\n</code>\nI'm not sure if\
    \ this is the best way to do it, but it works.\n\n\nA:\n\nI would use a helper\
    \ function that takes a string and a counter. The counter starts at 0, and every\
    \ time you see an opening bracket, you increment the counter. Every time you see\
    \ a closing bracket, you decrement the counter. If the counter is ever negative,\
    \ you know that you have a closing bracket before an opening bracket. If the counter\
    \ is ever positive at the end, you know that you have an opening bracket without\
    \ a closing bracket.\n<code>(define (is-nested str)\n  (define (helper str counter)\n\
    \    (cond\n      [(empty? str) (= counter 0)]\n      [(equal? (first str) \"\
    [\") (helper (rest str) (+ counter 1))]\n      [(equal? (first str) \"]\") (helper\
    \ (rest str) (- counter 1))]\n      [else (helper (rest str) counter)]))\n  (helper\
    \ str 0))\n</code>\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(equal? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(equal? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(char=?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first\
    \ string) #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (is_nested-helper string count)\n    (cond\n\
    \      [(empty? string) (= count 0)]\n      [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (is_nested-helper\
    \ (rest string) (- count 1))]\n      [else (is_nested-helper (rest string) count)]))\n\
    \  (is_nested-helper string 0))\n", "  (define (is_nested-helper string count)\n\
    \    (cond [(empty? string) (zero? count)]\n          [(char=? (first string)\
    \ #\\[) (is_nested-helper (rest string) (+ count 1))]\n          [(char=? (first\
    \ string) #\\]) (and (positive? count) (is_nested-helper (rest string) (- count\
    \ 1)))]\n          [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n```\n\n## Problem 3:\n\n```racket\n#lang racket\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(equal?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(equal? (first\
    \ string) #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string)\n       (zero? count)]\n  \
    \    [(char=? (first string) #\\[)\n       (helper (rest string) (+ count 1))]\n\
    \      [(char=? (first string) #\\])\n       (and (positive? count)\n        \
    \    (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define\
    \ (is_nested-helper string count)\n    (cond [(empty? string) (zero? count)]\n\
    \          [(char=? (first string) #\\[) (is_nested-helper (rest string) (+ count\
    \ 1))]\n          [(char=? (first string) #\\]) (and (positive? count) (is_nested-helper\
    \ (rest string) (- count 1)))]\n          [else (is_nested-helper (rest string)\
    \ count)]))\n  (is_nested-helper string 0))\n", "  (define (helper string count)\n\
    \    (cond\n      [(empty? string) (zero? count)]\n      [(char=? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first string) #\\\
    ]) (and (positive? count) (helper (rest string) (- count 1)))]))\n  (helper string\
    \ 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (zero? count)]\n      [(equal? (first string) #\\[) (helper (rest string) (+\
    \ count 1))]\n      [(equal? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string)\n       (zero? count)]\n  \
    \    [(char=? (first string) #\\[)\n       (is_nested-helper (rest string) (+\
    \ count 1))]\n      [(char=? (first string) #\\])\n       (and (positive? count)\n\
    \            (is_nested-helper (rest string) (- count 1)))]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string count)\n    (cond [(empty? string)\n\
    \           (zero? count)]\n          [(char=? (first string) #\\[)\n        \
    \   (helper (rest string) (+ count 1))]\n          [(char=? (first string) #\\\
    ])\n           (and (positive? count)\n                (helper (rest string) (-\
    \ count 1)))]))\n  (helper string 0))\n", "  (define (helper string count)\n \
    \   (cond\n      [(empty? string) (zero? count)]\n      [(char=? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first string) #\\\
    ]) (and (positive? count) (helper (rest string) (- count 1)))]))\n  (helper string\
    \ 0))\n", "  (define (helper string count)\n    (cond [(empty? string) (zero?\
    \ count)]\n          [(char=? (first string) #\\[) (helper (rest string) (+ count\
    \ 1))]\n          [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(equal?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(equal? (first\
    \ string) #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (if (empty? string)\n        (zero? count)\n        (cond\n\
    \          [(equal? (first string) #\\[)\n           (is_nested-helper (rest string)\
    \ (+ count 1))]\n          [(equal? (first string) #\\])\n           (and (not\
    \ (zero? count))\n                (is_nested-helper (rest string) (- count 1)))]\n\
    \          [else\n           (is_nested-helper (rest string) count)])))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string count)\n    (cond [(empty? string)\
    \ (zero? count)]\n          [(char=? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n          [(char=? (first string) #\\]) (and (positive? count)\
    \ (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define\
    \ (helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n  \
    \    [(equal? (first string) #\\[) (helper (rest string) (+ count 1))]\n     \
    \ [(equal? (first string) #\\]) (and (positive? count) (helper (rest string) (-\
    \ count 1)))]))\n  (helper string 0))\n", "  (define (helper string count)\n \
    \   (cond [(empty? string) (zero? count)]\n          [(char=? (first string) #\\\
    [) (helper (rest string) (+ count 1))]\n          [(char=? (first string) #\\\
    ]) (and (positive? count) (helper (rest string) (- count 1)))]))\n  (helper string\
    \ 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (= count 0)]\n      [(char=? (first string) #\\[) (helper (rest string) (+ count\
    \ 1))]\n      [(char=? (first string) #\\]) (and (not (zero? count)) (helper (rest\
    \ string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper string\
    \ count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=? (first\
    \ string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first string)\
    \ #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n  (helper\
    \ string 0))\n", "  (define (helper string counter)\n    (cond\n      [(empty?\
    \ string) (zero? counter)]\n      [(equal? (first string) #\\[) (helper (rest\
    \ string) (+ counter 1))]\n      [(equal? (first string) #\\]) (and (positive?\
    \ counter) (helper (rest string) (- counter 1)))]))\n  (helper string 0))\n",
  "  (define (helper string count)\n    (cond [(empty? string) (zero? count)]\n  \
    \        [(char=? (first string) #\\[) (helper (rest string) (+ count 1))]\n \
    \         [(char=? (first string) #\\]) (and (positive? count) (helper (rest string)\
    \ (- count 1)))]))\n  (helper string 0))\n", "  (define (helper string counter)\n\
    \    (cond\n      [(empty? string) (zero? counter)]\n      [(equal? (first string)\
    \ #\\[) (helper (rest string) (+ counter 1))]\n      [(equal? (first string) #\\\
    ]) (and (positive? counter) (helper (rest string) (- counter 1)))]))\n  (helper\
    \ string 0))\n", "  (define (is_nested-helper string count)\n    (cond\n     \
    \ [(empty? string) (= count 0)]\n      [(equal? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(equal? (first string) #\\]) (and (not (zero?\
    \ count)) (is_nested-helper (rest string) (- count 1)))]\n      [else (is_nested-helper\
    \ (rest string) count)]))\n  (is_nested-helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first\
    \ string) #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond [(empty? string) (zero? count)]\n          [(equal?\
    \ (first string) \"[\") (helper (rest string) (+ count 1))]\n          [(equal?\
    \ (first string) \"]\") (and (positive? count) (helper (rest string) (- count\
    \ 1)))]))\n  (helper string 0))\n", "  (define (helper string)\n    (cond\n  \
    \    [(empty? string) #t]\n      [(string-contains? string \"][\") #f]\n     \
    \ [(string-contains? string \"[]\") (helper (string-replace string \"[]\" \"\"\
    ))]\n      [else #f]))\n  (helper string))\n", "  (define (helper string count)\n\
    \    (cond\n      [(empty? string) (zero? count)]\n      [(char=? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first string) #\\\
    ]) (and (positive? count) (helper (rest string) (- count 1)))]))\n  (helper string\
    \ 0))\n", "  (define (helper string)\n    (cond\n      [(empty? string) #t]\n\
    \      [(eq? (first string) #\\[) (helper (rest string))]\n      [(eq? (first\
    \ string) #\\]) (if (empty? (rest string)) #f (helper (rest string)))]))\n  (helper\
    \ string))\n", "  (define (helper string count)\n    (cond [(empty? string)\n\
    \           (= count 0)]\n          [(char=? (first string) #\\[)\n          \
    \ (helper (rest string) (+ count 1))]\n          [(char=? (first string) #\\])\n\
    \           (and (not (= count 0))\n                (helper (rest string) (- count\
    \ 1)))]))\n  (helper string 0))\n", "  (define (helper string)\n    (cond [(empty?\
    \ string) '()]\n          [(eq? (first string) #\\[) (cons (first string) (helper\
    \ (rest string)))]\n          [(eq? (first string) #\\]) (if (empty? (helper (rest\
    \ string)))\n                                        #f\n                    \
    \                    (helper (rest string)))]))\n  (if (empty? (helper string))\n\
    \      #f\n      #t))\n", "  (let loop ([string string] [count 0])\n    (cond\
    \ [(empty? string) (zero? count)]\n          [(char=? (first string) #\\[) (loop\
    \ (rest string) (+ count 1))]\n          [(char=? (first string) #\\]) (and (positive?\
    \ count) (loop (rest string) (- count 1)))]\n          [else (loop (rest string)\
    \ count)])))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string) (+\
    \ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(equal?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(equal? (first\
    \ string) #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond [(empty? string) (zero? count)]\n          [(char=?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n          [(char=?\
    \ (first string) #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (not (zero? count))\
    \ (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define\
    \ (helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n  \
    \    [(char=? (first string) #\\[) (helper (rest string) (+ count 1))]\n     \
    \ [(char=? (first string) #\\]) (and (positive? count) (helper (rest string) (-\
    \ count 1)))]))\n  (helper string 0))\n", "  (define (is_nested-helper string\
    \ count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=? (first\
    \ string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (positive? count) (is_nested-helper (rest string)\
    \ (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (zero? count)]\n      [(equal? (first string) #\\[) (helper (rest string) (+\
    \ count 1))]\n      [(equal? (first string) #\\])\n       (and (positive? count)\
    \ (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define\
    \ (is_nested-helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n\
    \      [(char=? (first string) #\\[) (is_nested-helper (rest string) (+ count\
    \ 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (is_nested-helper\
    \ (rest string) (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n\
    \  (is_nested-helper string 0))\n", "  (define (helper string count)\n    (cond\n\
    \      [(empty? string) (= count 0)]\n      [(char=? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (not (zero?\
    \ count)) (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", " \
    \ (define (is_nested-helper string count)\n    (cond\n      [(empty? string) (zero?\
    \ count)]\n      [(equal? (first string) \"[\") (is_nested-helper (rest string)\
    \ (+ count 1))]\n      [(equal? (first string) \"]\") (and (not (zero? count))\
    \ (is_nested-helper (rest string) (- count 1)))]))\n  (is_nested-helper string\
    \ 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string) (+\
    \ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond [(empty? string) (zero? count)]\n          [(equal?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n          [(equal?\
    \ (first string) #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (is_nested-helper string stack)\n    (cond\n\
    \      [(empty? string) (empty? stack)]\n      [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (cons #\\[ stack))]\n      [(char=? (first string) #\\]) (and\
    \ (not (empty? stack)) (is_nested-helper (rest string) (rest stack)))]))\n  (is_nested-helper\
    \ string '()))\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string acc)\n    (cond [(empty? string) (empty? acc)]\n          [(char=? (first\
    \ string) #\\[) (helper (rest string) (cons #\\[ acc))]\n          [(char=? (first\
    \ string) #\\])\n           (and (not (empty? acc))\n                (char=? (first\
    \ acc) #\\[)\n                (helper (rest string) (rest acc)))]\n          [else\
    \ (helper (rest string) acc)]))\n  (helper string '()))\n```\n\n## Day 3\n\n```racket\n\
    #lang racket\n", "  (define (is_nested-helper string count)\n    (cond\n     \
    \ [(empty? string) (zero? count)]\n      [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive?\
    \ count) (is_nested-helper (rest string) (- count 1)))]\n      [else (is_nested-helper\
    \ (rest string) count)]))\n  (is_nested-helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (positive? count) (is_nested-helper (rest string)\
    \ (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (zero? count)]\n      [(equal? (first string) #\\[) (helper (rest string) (+\
    \ count 1))]\n      [(equal? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(char=?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first\
    \ string) #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (not (zero? count)) (is_nested-helper (rest string)\
    \ (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (is_nested-helper string count)\n    (cond\n     \
    \ [(empty? string) (zero? count)]\n      [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive?\
    \ count) (is_nested-helper (rest string) (- count 1)))]\n      [else (is_nested-helper\
    \ (rest string) count)]))\n  (is_nested-helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond [(empty? string) (= count 0)]\n          [(char=? (first\
    \ string) #\\[) (helper (rest string) (+ count 1))]\n          [(char=? (first\
    \ string) #\\]) (and (not (= count 0)) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (is_nested-helper string count)\n    (cond\n\
    \      [(empty? string)\n       (= count 0)]\n      [(char=? (first string) #\\\
    [)\n       (is_nested-helper (rest string) (+ count 1))]\n      [(char=? (first\
    \ string) #\\])\n       (and (positive? count)\n            (is_nested-helper\
    \ (rest string) (- count 1)))]))\n  (is_nested-helper string 0))\n```\n\n## Problem\
    \ 2\n\n```racket\n#lang racket\n", "  (define (helper string count)\n    (cond\n\
    \      [(empty? string) (= count 0)]\n      [(char=? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (not (zero?\
    \ count)) (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", " \
    \ (define (helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n\
    \      [(equal? (first string) #\\[) (helper (rest string) (+ count 1))]\n   \
    \   [(equal? (first string) #\\]) (and (positive? count) (helper (rest string)\
    \ (- count 1)))]))\n  (helper string 0))\n", "  (define (helper string count)\n\
    \    (cond\n      [(empty? string) (zero? count)]\n      [(char=? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first string) #\\\
    ]) (and (positive? count) (helper (rest string) (- count 1)))]))\n  (helper string\
    \ 0))\n", "  (define (helper string count)\n    (cond [(empty? string) (zero?\
    \ count)]\n          [(char=? (first string) #\\[) (helper (rest string) (+ count\
    \ 1))]\n          [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (positive? count) (is_nested-helper (rest string)\
    \ (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string)\n    (cond\n      [(empty? string)\
    \ #t]\n      [(and (equal? (first string) \"[\") (equal? (last string) \"]\"))\
    \ (helper (rest (butlast string)))]\n      [else #f]))\n  (helper string))\n",
  "  (define (helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n\
    \      [(equal? (first string) #\\[) (helper (rest string) (+ count 1))]\n   \
    \   [(equal? (first string) #\\]) (and (positive? count) (helper (rest string)\
    \ (- count 1)))]))\n  (helper string 0))\n", "  (define (is_nested-helper string\
    \ counter)\n    (cond [(empty? string) (zero? counter)]\n          [(char=? (first\
    \ string) #\\[) (is_nested-helper (rest string) (+ counter 1))]\n          [(char=?\
    \ (first string) #\\]) (and (positive? counter) (is_nested-helper (rest string)\
    \ (- counter 1)))]))\n  (is_nested-helper string 0))\n", "  (define (helper string\
    \ count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=? (first\
    \ string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first string)\
    \ #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n  (helper\
    \ string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (zero? count)]\n      [(equal? (first string) #\\[) (helper (rest string) (+\
    \ count 1))]\n      [(equal? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first\
    \ string) #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (is_nested-helper string count)\n    (cond\n\
    \      [(empty? string) (zero? count)]\n      [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive?\
    \ count) (is_nested-helper (rest string) (- count 1)))]\n      [else (is_nested-helper\
    \ (rest string) count)]))\n  (is_nested-helper string 0))\n", "  (let loop ([string\
    \ string] [count 0])\n    (cond [(empty? string) (zero? count)]\n          [(equal?\
    \ (first string) #\\[) (loop (rest string) (+ count 1))]\n          [(equal? (first\
    \ string) #\\]) (and (positive? count) (loop (rest string) (- count 1)))]\n  \
    \        [else (loop (rest string) count)])))\n", "  (define (helper string count)\n\
    \    (cond\n      [(empty? string) (zero? count)]\n      [(equal? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n      [(equal? (first string) #\\\
    ]) (and (positive? count) (helper (rest string) (- count 1)))]))\n  (helper string\
    \ 0))\n", "  (define (is_nested-helper string count)\n    (cond [(empty? string)\
    \ (= count 0)]\n          [(char=? (first string) #\\[) (is_nested-helper (rest\
    \ string) (+ count 1))]\n          [(char=? (first string) #\\]) (and (is-positive?\
    \ count) (is_nested-helper (rest string) (- count 1)))]\n          [else (is_nested-helper\
    \ (rest string) count)]))\n  (is_nested-helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(char=?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first\
    \ string) #\\]) (and (not (zero? count)) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (let loop ([string string] [stack '()])\n    (cond\
    \ [(empty? string) (empty? stack)]\n          [(char=? (first string) #\\[)\n\
    \           (loop (rest string) (cons #\\[ stack))]\n          [(char=? (first\
    \ string) #\\])\n           (and (not (empty? stack))\n                (loop (rest\
    \ string) (rest stack)))]\n          [else (loop (rest string) stack)])))\n",
  "  (define (helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n\
    \      [(equal? (first string) \"[\") (helper (rest string) (+ count 1))]\n  \
    \    [(equal? (first string) \"]\") (and (not (zero? count)) (helper (rest string)\
    \ (- count 1)))]))\n  (helper string 0))\n", "  (define (is_nested-helper string\
    \ count)\n    (cond [(empty? string) (= count 0)]\n          [(char=? (first string)\
    \ #\\[) (is_nested-helper (rest string) (+ count 1))]\n          [(char=? (first\
    \ string) #\\]) (and (not (zero? count)) (is_nested-helper (rest string) (- count\
    \ 1)))]\n          [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string) (+\
    \ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (cond\n    [(empty?\
    \ string) #f]\n    [(equal? (first string) \"[\")\n     (or (is_nested (rest string))\n\
    \         (is_nested (rest (rest string))))]\n    [(equal? (first string) \"]\"\
    )\n     (is_nested (rest string))]))\n", "  (let loop ([string string] [count\
    \ 0])\n    (cond [(empty? string) (zero? count)]\n          [(char=? (first string)\
    \ #\\[) (loop (rest string) (+ count 1))]\n          [(char=? (first string) #\\\
    ]) (and (positive? count) (loop (rest string) (- count 1)))]\n          [else\
    \ (loop (rest string) count)])))\n", "  (define (helper string count)\n    (if\
    \ (empty? string)\n        (zero? count)\n        (if (equal? (first string) #\\\
    [)\n            (helper (rest string) (+ count 1))\n            (if (equal? (first\
    \ string) #\\])\n                (if (zero? count)\n                    #f\n \
    \                   (helper (rest string) (- count 1)))\n                (helper\
    \ (rest string) count)))))\n  (helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (not (zero? count)) (is_nested-helper (rest string)\
    \ (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n", "  (cond\n    [(empty? string) #f]\n    [(equal? (first string)\
    \ \"[\")\n     (cond\n       [(empty? (rest string)) #f]\n       [(equal? (first\
    \ (rest string)) \"]\") #t]\n       [else (is_nested (rest string))])]\n    [else\
    \ (is_nested (rest string))]))\n", "  (define (is_nested-helper string count)\n\
    \    (cond\n      [(empty? string) (zero? count)]\n      [(char=? (first string)\
    \ #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=? (first string)\
    \ #\\]) (and (positive? count) (is_nested-helper (rest string) (- count 1)))]\n\
    \      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper string\
    \ 0))\n", "  (define (helper string)\n    (cond\n      [(empty? string) #t]\n\
    \      [(and (equal? (first string) \"[\") (equal? (last string) \"]\")) (helper\
    \ (rest (butlast string)))]\n      [else #f]))\n  (helper string))\n", "  (define\
    \ (is_nested-helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n\
    \      [(equal? (first string) #\\[) (is_nested-helper (rest string) (+ count\
    \ 1))]\n      [(equal? (first string) #\\]) (and (positive? count) (is_nested-helper\
    \ (rest string) (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n\
    \  (is_nested-helper string 0))\n", "  (define (helper string count)\n    (cond\n\
    \      [(empty? string) (zero? count)]\n      [(char=? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive?\
    \ count) (helper (rest string) (- count 1)))]))\n  (helper string 0))\n```\n\n\
    ## Problem 3\n\n```racket\n#lang racket\n", "  (let loop ([string string] [count\
    \ 0])\n    (cond [(empty? string) (zero? count)]\n          [(char=? (first string)\
    \ #\\[) (loop (rest string) (+ count 1))]\n          [(char=? (first string) #\\\
    ]) (loop (rest string) (- count 1))]\n          [else (loop (rest string) count)])))\n",
  "  (define (is_nested-helper string count)\n    (cond\n      [(empty? string) (=\
    \ count 0)]\n      [(= (first string) #\\[) (is_nested-helper (rest string) (+\
    \ count 1))]\n      [(= (first string) #\\]) (is_nested-helper (rest string) (-\
    \ count 1))]))\n  (is_nested-helper string 0))\n", "  (cond\n    [(empty? string)\
    \ #f]\n    [(string=? string \"[]\") #f]\n    [(string=? string \"[[]]\") #t]\n\
    \    [(string=? string \"[[][]]\") #t]\n    [(string=? string \"[[]][[\") #t]\n\
    \    [(string=? string \"[][]\") #f]\n    [(string=? string \"[]\") #f]\n    [else\
    \ #f]))\n", "  (define (helper string)\n    (cond\n      [(empty? string) #t]\n\
    \      [(equal? (first string) \"[\")\n       (if (equal? (last string) \"]\"\
    )\n           (helper (substring string 1 (- (string-length string) 1)))\n   \
    \        #f)]\n      [else #f]))\n  (helper string))\n```\n\n## Problem 2\n\n\
    ```racket\n#lang racket\n", "  (define (helper string count)\n    (cond\n    \
    \  [(empty? string) (zero? count)]\n      [(equal? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n      [(equal? (first string) #\\]) (and (positive?\
    \ count) (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define\
    \ (helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n  \
    \    [(equal? (first string) #\\[) (helper (rest string) (+ count 1))]\n     \
    \ [(equal? (first string) #\\]) (and (positive? count) (helper (rest string) (-\
    \ count 1)))]))\n  (helper string 0))\n", "  (define (helper string count)\n \
    \   (cond\n      [(empty? string) (zero? count)]\n      [(char=? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first string) #\\\
    ]) (and (positive? count) (helper (rest string) (- count 1)))]))\n  (helper string\
    \ 0))\n", "  (define (is_nested-helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive?\
    \ count) (is_nested-helper (rest string) (- count 1)))]\n      [else (is_nested-helper\
    \ (rest string) count)]))\n  (is_nested-helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(= (first\
    \ string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(= (first\
    \ string) #\\]) (and (is-positive? count) (is_nested-helper (rest string) (- count\
    \ 1)))]\n      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string)\n    (cond\n      [(empty? string)\
    \ #t]\n      [(equal? (first string) \"[\")\n       (if (equal? (first (rest string))\
    \ \"]\")\n           (helper (rest (rest string)))\n           (helper (rest string)))]\n\
    \      [(equal? (first string) \"]\") #f]))\n  (helper string))\n", "  (define\
    \ (helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n  \
    \    [(equal? (first string) #\\[) (helper (rest string) (+ count 1))]\n     \
    \ [(equal? (first string) #\\]) (and (positive? count) (helper (rest string) (-\
    \ count 1)))]))\n  (helper string 0))\n", "  (define (helper string open-brackets)\n\
    \    (cond [(empty? string) (zero? open-brackets)]\n          [(char=? (first\
    \ string) #\\[) (helper (rest string) (+ open-brackets 1))]\n          [(char=?\
    \ (first string) #\\]) (and (positive? open-brackets) (helper (rest string) (-\
    \ open-brackets 1)))]\n          [else (helper (rest string) open-brackets)]))\n\
    \  (helper string 0))\n", "  (let loop ([string string] [count 0])\n    (cond\
    \ [(empty? string) (zero? count)]\n          [(char=? (first string) #\\[) (loop\
    \ (rest string) (+ count 1))]\n          [(char=? (first string) #\\]) (and (positive?\
    \ count) (loop (rest string) (- count 1)))]\n          [else (loop (rest string)\
    \ count)])))\n", "  (let loop ([string string] [count 0])\n    (cond [(empty?\
    \ string) (zero? count)]\n          [(char=? (first string) #\\[) (loop (rest\
    \ string) (+ count 1))]\n          [(char=? (first string) #\\]) (and (positive?\
    \ count) (loop (rest string) (- count 1)))]\n          [else (loop (rest string)\
    \ count)])))\n", "  (define (is_nested-helper string count)\n    (cond [(empty?\
    \ string) (zero? count)]\n          [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n          [(char=? (first string) #\\]) (is_nested-helper\
    \ (rest string) (- count 1))]\n          [else (is_nested-helper (rest string)\
    \ count)]))\n  (is_nested-helper string 0))\n", "  (define (is_nested-helper string\
    \ count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=? (first\
    \ string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (positive? count) (is_nested-helper (rest string)\
    \ (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (is_nested-helper string count)\n    (cond\n     \
    \ [(empty? string) (= count 0)]\n      [(equal? (first string) \"[\") (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(equal? (first string) \"]\") (and (not\
    \ (= count 0)) (is_nested-helper (rest string) (- count 1)))]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (zero? count)]\n      [(equal? (first string) #\\[) (helper (rest string) (+\
    \ count 1))]\n      [(equal? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first\
    \ string) #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (= count 0)]\n      [(char=? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (not (zero? count))\
    \ (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define\
    \ (helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n  \
    \    [(char=? (first string) #\\[) (helper (rest string) (+ count 1))]\n     \
    \ [(char=? (first string) #\\]) (and (positive? count) (helper (rest string) (-\
    \ count 1)))]))\n  (helper string 0))\n", "  (define (helper str count)\n    (cond\n\
    \      [(empty? str) (zero? count)]\n      [(equal? (first str) #\\[) (helper\
    \ (rest str) (+ count 1))]\n      [(equal? (first str) #\\]) (and (positive? count)\
    \ (helper (rest str) (- count 1)))]))\n  (helper (string->list string) 0))\n",
  "  (define (helper string count)\n    (cond\n      [(empty? string) (= count 0)]\n\
    \      [(char=? (first string) #\\[) (helper (rest string) (+ count 1))]\n   \
    \   [(char=? (first string) #\\]) (and (positive? count) (helper (rest string)\
    \ (- count 1)))]))\n  (helper string 0))\n", "  (define (helper string count)\n\
    \    (cond [(empty? string) (zero? count)]\n          [(char=? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n          [(char=? (first string)\
    \ #\\]) (and (not (zero? count)) (helper (rest string) (- count 1)))]))\n  (helper\
    \ string 0))\n", "  (define (helper string)\n    (cond\n      [(empty? string)\
    \ #t]\n      [(equal? (first string) \"[\") (helper (rest string))]\n      [(equal?\
    \ (first string) \"]\") (and (not (empty? string)) (helper (rest string)))]))\n\
    \  (helper (string->list string)))\n", "  (define (helper string count)\n    (cond\
    \ [(empty? string) (zero? count)]\n          [(equal? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n          [(equal? (first string) #\\]) (and (positive?\
    \ count) (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define\
    \ (helper string)\n    (cond [(empty? string) #t]\n          [(equal? (first string)\
    \ \"[\") (helper (rest string))]\n          [(equal? (first string) \"]\") (helper\
    \ (rest string))]\n          [else (and (helper (rest string)) (helper (rest (rest\
    \ string))))]))\n  (helper (string-&gt;list string)))\n</code>\nThe problem is\
    \ that the function is not working properly. For example, when I enter <code>(is_nested\
    \ \"[[]]\")</code> it returns <code>#f</code> instead of <code>#t</code>.\nI'm\
    \ not sure what I'm doing wrong.\n\n\nA:\n\nYour code is not working because you\
    \ are not checking for the correct sequence of brackets.\nYou can use a stack\
    \ to keep track of the brackets.\n<code>(define (is-nested str)\n  (define (helper\
    \ str stack)\n    (cond [(empty? str) (empty? stack)]\n          [(equal? (first\
    \ str) \"[\")\n           (helper (rest str) (cons (first str) stack))]\n    \
    \      [(equal? (first str) \"]\")\n           (and (not (empty? stack))\n   \
    \             (helper (rest str) (rest stack)))]))\n  (helper (string-&gt;list\
    \ str) '()))\n</code>\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (= count 0)]\n      [(char=? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (not (zero? count))\
    \ (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define\
    \ (helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n  \
    \    [(equal? (first string) \"[\") (helper (rest string) (+ count 1))]\n    \
    \  [(equal? (first string) \"]\") (and (positive? count) (helper (rest string)\
    \ (- count 1)))]))\n  (helper string 0))\n", "  (define (helper string count)\n\
    \    (cond\n      [(empty? string) (zero? count)]\n      [(equal? (first string)\
    \ \"[\") (helper (rest string) (+ count 1))]\n      [(equal? (first string) \"\
    ]\") (and (positive? count) (helper (rest string) (- count 1)))]))\n  (helper\
    \ string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (zero? count)]\n      [(char=? (first string) #\\[) (helper (rest string) (+\
    \ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string)\n       (zero? count)]\n  \
    \    [(char=? (first string) #\\[)\n       (helper (rest string) (+ count 1))]\n\
    \      [(char=? (first string) #\\])\n       (and (positive? count)\n        \
    \    (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define\
    \ (helper string)\n    (cond [(empty? string) #t]\n          [(equal? (first string)\
    \ \"[\") (helper (rest string))]\n          [(equal? (first string) \"]\") (and\
    \ (not (empty? string)) (helper (rest string)))]))\n  (helper string))\n", " \
    \ (define (is_nested-helper string count)\n    (cond\n      [(empty? string)\n\
    \       (zero? count)]\n      [(char=? (first string) #\\[)\n       (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\])\n       (and\
    \ (positive? count)\n            (is_nested-helper (rest string) (- count 1)))]))\n\
    \  (is_nested-helper string 0))\n", "  (define (helper string count)\n    (cond\n\
    \      [(empty? string) (= count 0)]\n      [(char=? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (not (zero?\
    \ count)) (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", " \
    \ (define (helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n\
    \      [(char=? (first string) #\\[) (helper (rest string) (+ count 1))]\n   \
    \   [(char=? (first string) #\\]) (and (positive? count) (helper (rest string)\
    \ (- count 1)))]))\n  (helper string 0))\n", "  (define (helper string count)\n\
    \    (cond\n      [(empty? string) (= count 0)]\n      [(char=? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first string) #\\\
    ]) (and (not (zero? count)) (helper (rest string) (- count 1)))]))\n  (helper\
    \ string 0))\n", "  (define (helper string stack)\n    (cond\n      [(empty? string)\
    \ (empty? stack)]\n      [(char=? (first string) #\\[) (helper (rest string) (cons\
    \ #\\[ stack))]\n      [(char=? (first string) #\\]) (and (not (empty? stack))\
    \ (helper (rest string) (rest stack)))]))\n  (helper string '()))\n", "  (define\
    \ (is_nested-helper string stack)\n    (cond\n      [(empty? string) (empty? stack)]\n\
    \      [(char=? (first string) #\\[) (is_nested-helper (rest string) (cons #\\\
    [ stack))]\n      [(char=? (first string) #\\]) (and (not (empty? stack)) (is_nested-helper\
    \ (rest string) (rest stack)))]))\n  (is_nested-helper string '()))\n", "  (define\
    \ (is_nested-helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n\
    \      [(equal? (first string) #\\[) (is_nested-helper (rest string) (+ count\
    \ 1))]\n      [(equal? (first string) #\\]) (and (positive? count) (is_nested-helper\
    \ (rest string) (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n\
    \  (is_nested-helper string 0))\n", "  (define (helper string count)\n    (cond\n\
    \      [(empty? string) (zero? count)]\n      [(char=? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive?\
    \ count) (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define\
    \ (helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n  \
    \    [(char=? (first string) #\\[) (helper (rest string) (+ count 1))]\n     \
    \ [(char=? (first string) #\\]) (and (positive? count) (helper (rest string) (-\
    \ count 1)))]))\n  (helper string 0))\n", "  (define (is_nested-helper string\
    \ count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=? (first\
    \ string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (positive? count) (is_nested-helper (rest string)\
    \ (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
