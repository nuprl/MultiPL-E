name: HumanEval_93_encode
language: rkt
prompt: "#lang racket\n\n#| Write a function that takes a message, and encodes in\
  \ such a \nway that it swaps case of all letters, replaces all vowels in \nthe message\
  \ with the letter that appears 2 places ahead of that \nvowel in the english alphabet.\
  \ \nAssume only letters. \nExamples:\n>>> (encode \"test\")\n\"TGST\"\n>>> (encode\
  \ \"This is a message\")\n\"tHKS KS C MGSSCGG\"|#\n(define (encode message)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encode))\n\
  \    (check-equal? (candidate \"TEST\") \"tgst\")\n    (check-equal? (candidate\
  \ \"Mudasir\") \"mWDCSKR\")\n    (check-equal? (candidate \"YES\") \"ygs\")\n  \
  \  (check-equal? (candidate \"This is a message\") \"tHKS KS C MGSSCGG\")\n    (check-equal?\
  \ (candidate \"I DoNt KnOw WhAt tO WrItE\") \"k dQnT kNqW wHcT Tq wRkTg\")\n))\n\
  \n(test-humaneval)"
completions: ["  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase\
    \ c)\n        (char-downcase c)))\n  (define (encode-char c)\n    (if (or (char=?\
    \ c #\\a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=? c #\\u))\n \
    \       (swap-case (char-upcase c))\n        (swap-case c)))\n  (define (encode-string\
    \ s)\n    (string-map encode-char s))\n  (encode-string message))\n", "  (let\
    \ loop ([message message] [result '()])\n    (cond [(empty? message) (list->string\
    \ (reverse result))]\n          [else\n           (let ([c (first message)])\n\
    \             (cond [(char-alphabetic? c)\n                    (let ([c (char-upcase\
    \ c)])\n                      (cond [(member c '(#\\A #\\E #\\I #\\O #\\U))\n\
    \                             (loop (rest message)\n                         \
    \          (cons (char-downcase (char-upcase (char-next (char-next c)))) result))]\n\
    \                            [else (loop (rest message) (cons c result))]))]\n\
    \                   [else (loop (rest message) (cons c result))]))])))\n", " \
    \ (define (swap-case c)\n    (cond\n      [(char-lower-case? c) (char-upcase c)]\n\
    \      [(char-upper-case? c) (char-downcase c)]\n      [else c]))\n  (define (encode-char\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n  \
    \    [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\\
    U) #\\W]\n      [else c]))\n  (define (encode-message message)\n    (cond\n  \
    \    [(empty? message) empty]\n      [else (cons (encode-char (first message))\n\
    \                  (encode-message (rest message)))]))\n  (define (swap-case-message\
    \ message)\n    (cond\n      [(empty? message) empty]\n      [else (cons (swap-case\
    \ (first message))\n                  (swap-case-message (rest message)))]))\n\
    \  (string-append (swap-case-message message) (encode-message message)))\n", " \
    \ (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else (swap-case\
    \ c)]))\n  (string-map encode-char message))\n", "  (define (swap-case c)\n  \
    \  (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase c)))\n\
    \  (define (encode-char c)\n    (if (member c '(\"a\" \"e\" \"i\" \"o\" \"u\"\
    ))\n        (string-ref \"bcdfghjklmnpqrstvwxyz\" (string-index \"aeiou\" c))\n\
    \        (swap-case c)))\n  (string-map encode-char message))\n", "  (define (swap-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (if (or (char=? c #\\a) (char=? c #\\e)\
    \ (char=? c #\\i) (char=? c #\\o) (char=? c #\\u))\n        (swap-case (char-next\
    \ (char-next c)))\n        (swap-case c)))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n\
    \        (char-upcase c)))\n  (define (vowel? c)\n    (or (char=? c #\\a)\n  \
    \      (char=? c #\\e)\n        (char=? c #\\i)\n        (char=? c #\\o)\n   \
    \     (char=? c #\\u)))\n  (define (encode-char c)\n    (if (vowel? c)\n     \
    \   (swap-case (char-upcase (char+ c 2)))\n        (swap-case c)))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n        (list-ref '(#\\\
    c #\\f #\\j #\\o #\\t) (position c '(#\\a #\\e #\\i #\\o #\\u)))\n        c))\n\
    \  (string-map swap-case (string-map encode-char message)))\n", "  (define (swap-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (cond\n      [(char=? c #\\a) #\\c]\n \
    \     [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\\
    o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=?\
    \ c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n\
    \      [(char=? c #\\U) #\\W]\n      [else (swap-case c)]))\n  (string-map encode-char\
    \ message))\n", "  (string-upcase (string-replace message \"a\" \"c\")\n     \
    \            (string-replace message \"e\" \"g\")\n                 (string-replace\
    \ message \"i\" \"k\")\n                 (string-replace message \"o\" \"q\")\n\
    \                 (string-replace message \"u\" \"w\")))\n", "  (define (swap-case\
    \ letter)\n    (if (char-lower-case? letter)\n        (char-upcase letter)\n \
    \       (char-downcase letter)))\n  (define (replace-vowel letter)\n    (cond\n\
    \      [(char=? letter #\\a) #\\c]\n      [(char=? letter #\\e) #\\g]\n      [(char=?\
    \ letter #\\i) #\\k]\n      [(char=? letter #\\o) #\\q]\n      [(char=? letter\
    \ #\\u) #\\w]\n      [else letter]))\n  (define (encode-letter letter)\n    (replace-vowel\
    \ (swap-case letter)))\n  (string-map encode-letter message))\n", "  (let ([vowels\
    \ (string-&gt;list \"aeiou\")])\n    (string-join\n     (map\n      (lambda (c)\n\
    \        (if (char-alphabetic? c)\n            (if (char-vowel? c)\n         \
    \       (let ([vowel-index (string-index \"aeiou\" (char-downcase c))])\n    \
    \              (if (= vowel-index 4)\n                      (list-ref vowels 0)\n\
    \                      (list-ref vowels (+ vowel-index 2))))\n               \
    \ (if (char-lower-case? c)\n                    (char-upcase c)\n            \
    \        (char-downcase c)))\n            c))\n      (string-&gt;list message)))))\n\
    </code>\nI'm not sure if I'm using the right functions, but I'm trying to use\
    \ <code>string-index</code> to find the index of the vowel in the string <code>\"\
    aeiou\"</code> and then use <code>list-ref</code> to get the character at the\
    \ index of the vowel plus 2.\nI'm not sure if I'm using the right functions, but\
    \ I'm trying to use <code>string-index</code> to find the index of the vowel in\
    \ the string <code>\"aeiou\"</code> and then use <code>list-ref</code> to get\
    \ the character at the index of the vowel plus 2.\nI'm not sure if I'm using the\
    \ right functions, but I'm trying to use <code>string-index</code> to find the\
    \ index of the vowel in the string <code>\"aeiou\"</code> and then use <code>list-ref</code>\
    \ to get the character at the index of the vowel plus 2.\nI'm not sure if I'm\
    \ using the right functions, but I'm trying to use <code>string-index</code> to\
    \ find the index of the vowel in the string <code>\"aeiou\"</code> and then use\
    \ <code>list-ref</code> to get the character at the index of the vowel plus 2.\n\
    I'm not sure if I'm using the right functions, but I'm trying to use <code>string-index</code>\
    \ to find the index of the vowel in the string <code>\"aeiou\"", "  (define (swap-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (cond [(char=? c #\\a) #\\c]\n        \
    \  [(char=? c #\\e) #\\g]\n          [(char=? c #\\i) #\\k]\n          [(char=?\
    \ c #\\o) #\\q]\n          [(char=? c #\\u) #\\w]\n          [(char=? c #\\A)\
    \ #\\C]\n          [(char=? c #\\E) #\\G]\n          [(char=? c #\\I) #\\K]\n\
    \          [(char=? c #\\O) #\\Q]\n          [(char=? c #\\U) #\\W]\n        \
    \  [else (swap-case c)]))\n  (string-map encode-char message))\n", "  (define\
    \ (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n   \
    \     (char-upcase c)))\n  (define (vowel? c)\n    (member c '#(#\\a #\\e #\\\
    i #\\o #\\u)))\n  (define (next-vowel c)\n    (if (vowel? c)\n        (if (char=?\
    \ c #\\u)\n            #\\a\n            (char+ c 1))\n        c))\n  (define\
    \ (next-next-vowel c)\n    (if (vowel? c)\n        (if (char=? c #\\u)\n     \
    \       #\\a\n            (if (char=? c #\\t)\n                #\\e\n        \
    \        (char+ c 2)))\n        c))\n  (define (encode-char c)\n    (next-next-vowel\
    \ (swap-case c)))\n  (define (encode-string s)\n    (string-map encode-char s))\n\
    \  (encode-string message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case char)\n    (if (char-alphabetic? char)\n        (if (char-lower-case?\
    \ char)\n            (char-upcase char)\n            (char-downcase char))\n \
    \       char))\n  (define (encode-char char)\n    (if (char-vowel? char)\n   \
    \     (let ([next-char (char-next char)])\n          (if (char-vowel? next-char)\n\
    \              (char-next next-char)\n              next-char))\n        char))\n\
    \  (define (encode-message message)\n    (if (null? message)\n        '()\n  \
    \      (cons (encode-char (swap-case (car message)))\n              (encode-message\
    \ (cdr message)))))\n  (list->string (encode-message (string->list message))))\n",
  "  (define (encoder message)\n    (cond\n      [(empty? message) empty]\n      [(vowel?\
    \ (first message)) (cons (next-vowel (first message)) (encoder (rest message)))]\n\
    \      [(letter? (first message)) (cons (swap-case (first message)) (encoder (rest\
    \ message)))]\n      [else (encoder (rest message))]))\n  (list->string (encoder\
    \ (string->list message))))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n        (list-ref '(#\\\
    c #\\f #\\j #\\o #\\t)\n                  (position c '(#\\a #\\e #\\i #\\o #\\\
    u)))\n        c))\n  (string-map swap-case (string-map encode-char message)))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case?\
    \ c)\n           (char-upcase c)\n           (char-downcase c))]\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (char-vowel? c)\n        (swap-case (char-next (char-next c)))\n\
    \        (swap-case c)))\n  (string-map encode-char message))\n", "  (string-upcase\
    \ (string-map (lambda (c)\n                               (if (vowel? c)\n   \
    \                                (next-vowel c)\n                            \
    \       c))\n                             message)))\n", "  (let loop ([message\
    \ message]\n             [result '()])\n    (cond [(empty? message) (list->string\
    \ (reverse result))]\n          [(char-alphabetic? (first message))\n        \
    \   (let ([new-char (char-upcase (first message))])\n             (cond [(member\
    \ (first message) '(\"A\" \"E\" \"I\" \"O\" \"U\"))\n                    (loop\
    \ (rest message)\n                          (cons (char-upcase (list-ref \"CDFGHJKLMNPQRSTVWXYZABE\"\
    \n                                                        (+ (char->integer new-char)\
    \ 2)))\n                                result))]\n                   [else (loop\
    \ (rest message)\n                               (cons new-char result))]))]\n\
    \          [else (loop (rest message)\n                      (cons (first message)\
    \ result))])))\n", "  (define (swap-case c)\n    (cond\n      [(char-lower-case?\
    \ c) (char-upcase c)]\n      [(char-upper-case? c) (char-downcase c)]\n      [else\
    \ c]))\n  (define (encode-char c)\n    (cond\n      [(char=? c #\\a) #\\c]\n \
    \     [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\\
    o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=?\
    \ c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n\
    \      [(char=? c #\\U) #\\W]\n      [else c]))\n  (string-map swap-case (string-map\
    \ encode-char message)))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (define (vowel? c)\n      (or (char=? c #\\a)\n          (char=? c #\\\
    e)\n          (char=? c #\\i)\n          (char=? c #\\o)\n          (char=? c\
    \ #\\u)))\n    (define (next-vowel c)\n      (cond ((char=? c #\\a) #\\c)\n  \
    \          ((char=? c #\\e) #\\g)\n            ((char=? c #\\i) #\\k)\n      \
    \      ((char=? c #\\o) #\\q)\n            ((char=? c #\\u) #\\w)))\n    (if (vowel?\
    \ c)\n        (next-vowel c)\n        (swap-case c)))\n  (string-map encode-char\
    \ message))\n</code>\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n\
    \        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n        (list-ref '(#\\\
    c #\\f #\\j #\\o #\\t) (position c '(#\\a #\\e #\\i #\\o #\\u)))\n        c))\n\
    \  (string-map swap-case (string-map encode-char message)))\n", "  (define (swap-case\
    \ c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n       \
    \     (char-upcase c)\n            (char-downcase c))\n        c))\n  (define\
    \ (encode-letter c)\n    (if (char-vowel? c)\n        (let ([vowels (string-&gt;list\
    \ \"aeiou\")])\n          (list-ref vowels (modulo (+ (list-index (char-&gt;integer\
    \ c) vowels) 2) (length vowels))))\n        c))\n  (string-&gt;list (map swap-case\
    \ (map encode-letter (string-&gt;list message)))))\n</code>\n", "  (let ([vowels\
    \ (string-&gt;list \"aeiouAEIOU\")]\n        [alphabet (string-&gt;list \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )])\n    (string-join\n     (map\n      (lambda (x)\n        (if (char-alphabetic?\
    \ x)\n            (if (member x vowels)\n                (list-ref alphabet (+\
    \ (list-index x alphabet 2) 2))\n                (list-ref alphabet (+ (list-index\
    \ x alphabet 2) -2)))\n            x))\n      (string-&gt;list message)))))\n\
    </code>\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase\
    \ c)\n        (char-downcase c)))\n  (define (encode-char c)\n    (define (is-vowel?\
    \ c)\n      (or (char=? c #\\a)\n          (char=? c #\\e)\n          (char=?\
    \ c #\\i)\n          (char=? c #\\o)\n          (char=? c #\\u)))\n    (define\
    \ (next-vowel c)\n      (cond\n        [(char=? c #\\u) #\\a]\n        [(char=?\
    \ c #\\a) #\\e]\n        [(char=? c #\\e) #\\i]\n        [(char=? c #\\i) #\\\
    o]\n        [(char=? c #\\o) #\\u]\n        [else c]))\n    (if (is-vowel? c)\n\
    \        (next-vowel c)\n        (swap-case c)))\n  (define (encode-message message)\n\
    \    (if (empty? message)\n        empty\n        (cons (encode-char (first message))\n\
    \              (encode-message (rest message)))))\n  (encode-message message))\n",
  "  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (define (is-vowel?\
    \ c)\n      (member c '(#\\a #\\e #\\i #\\o #\\u)))\n    (if (is-vowel? c)\n \
    \       (swap-case (char-upcase c))\n        (swap-case c)))\n  (map encode-char\
    \ message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase\
    \ c)\n        (char-upcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else (swap-case\
    \ c)]))\n  (string-map encode-char message))\n", "  (define (swap-case c)\n  \
    \  (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase c)))\n\
    \  (define (encode-char c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n\
    \      [(char=? c #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c\
    \ #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n  \
    \    [(char=? c #\\U) #\\W]\n      [else c]))\n  (define (encode-message message)\n\
    \    (if (empty? message)\n        empty\n        (cons (encode-char (swap-case\
    \ (first message)))\n              (encode-message (rest message)))))\n  (list->string\
    \ (encode-message (string->list message))))\n", "  (define (encode-char c)\n \
    \   (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n    \
    \       (char-upcase c)\n           (char-downcase c))]\n      [(char=? c #\\\
    a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=?\
    \ c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (let loop ([message message]\n             [result\
    \ '()])\n    (cond [(empty? message) (reverse result)]\n          [else (let ([c\
    \ (first message)])\n                  (cond [(char-alphabetic? c)\n         \
    \                (loop (rest message)\n                               (cons (if\
    \ (char-lower-case? c)\n                                         (char-upcase\
    \ c)\n                                         (char-downcase c))\n          \
    \                           result))]\n                        [else (loop (rest\
    \ message)\n                                    (cons c result))]))])))\n", " \
    \ (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (if (or (char=? c\
    \ #\\a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=? c #\\u))\n   \
    \     (swap-case (char-upcase c))\n        (swap-case c)))\n  (string-map encode-char\
    \ message))\n", "  (string-map\n   (lambda (c)\n     (cond\n       [(char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))]\n       [(char-vowel? c)\n        (char-next (char-next\
    \ c))]\n       [else c]))\n   message))\n", "  (define (encode-char c)\n    (cond\n\
    \      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n           (char-upcase\
    \ c)\n           (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n\
    \      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (define (swap-case ch)\n    (if (char-lower-case? ch)\n        (char-upcase ch)\n\
    \        (char-downcase ch)))\n  (define (encode-char ch)\n    (if (char-vowel?\
    \ ch)\n        (swap-case (char-next (char-next ch)))\n        (swap-case ch)))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (if (vowel? c)\n        (swap-case (next-vowel c))\n        (swap-case\
    \ c)))\n  (define (vowel? c)\n    (or (char=? c #\\a)\n        (char=? c #\\e)\n\
    \        (char=? c #\\i)\n        (char=? c #\\o)\n        (char=? c #\\u)))\n\
    \  (define (next-vowel c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n\
    \      [(char=? c #\\u) #\\w]\n      [else #\\a]))\n  (string-map encode-char\
    \ message))\n", "  (define (swap-case c)\n    (if (char-upper-case? c)\n     \
    \   (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char c)\n\
    \    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n     \
    \ [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u)\
    \ #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=?\
    \ c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n\
    \      [else c]))\n  (map (lambda (c) (encode-char (swap-case c))) message))\n",
  "  (define (swap-case letter)\n    (if (char-alphabetic? letter)\n        (if (char-lower-case?\
    \ letter)\n            (char-upcase letter)\n            (char-downcase letter))\n\
    \        letter))\n  (define (encode-letter letter)\n    (define (vowel? letter)\n\
    \      (or (char=? letter #\\a)\n          (char=? letter #\\e)\n          (char=?\
    \ letter #\\i)\n          (char=? letter #\\o)\n          (char=? letter #\\u)))\n\
    \    (if (vowel? letter)\n        (swap-case (char-upcase letter))\n        (swap-case\
    \ letter)))\n  (define (encode-message message)\n    (if (empty? message)\n  \
    \      empty\n        (cons (encode-letter (first message))\n              (encode-message\
    \ (rest message)))))\n  (encode-message message))\n", "  (define (swap-case c)\n\
    \    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (define (vowel? c)\n      (or (char=? c\
    \ #\\a)\n          (char=? c #\\e)\n          (char=? c #\\i)\n          (char=?\
    \ c #\\o)\n          (char=? c #\\u)))\n    (define (next-char c)\n      (integer->char\
    \ (+ (char->integer c) 1)))\n    (define (next-next-char c)\n      (integer->char\
    \ (+ (char->integer c) 2)))\n    (if (vowel? c)\n        (next-next-char c)\n\
    \        (swap-case c)))\n  (define (encode-message message)\n    (if (empty?\
    \ message)\n        empty\n        (cons (encode-char (first message))\n     \
    \         (encode-message (rest message)))))\n  (encode-message message))\n",
  "  (let loop ([message message]\n             [result '()])\n    (cond [(empty?\
    \ message) (list->string (reverse result))]\n          [(char-alphabetic? (first\
    \ message))\n           (let ([char (first message)])\n             (cond [(char-lower-case?\
    \ char)\n                    (loop (rest message)\n                          (cons\
    \ (char-upcase char) result))]\n                   [(char-upper-case? char)\n\
    \                    (loop (rest message)\n                          (cons (char-downcase\
    \ char) result))]))]\n          [(char-vowel? (first message))\n           (let\
    \ ([char (first message)])\n             (loop (rest message)\n              \
    \     (cons (next-vowel char) result)))]\n          [else (loop (rest message)\n\
    \                      (cons (first message) result))])))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (define (next-char c)\n \
    \        (cond\n           [(char=? c #\\z) #\\a]\n           [(char=? c #\\Z)\
    \ #\\A]\n           [else (char+ c 1)]))\n       (define (next-next-char c)\n\
    \         (define (next-char c)\n           (cond\n             [(char=? c #\\\
    z) #\\a]\n             [(char=? c #\\Z) #\\A]\n             [else (char+ c 1)]))\n\
    \         (next-char (next-char c)))\n       (define (is-vowel? c)\n         (or\
    \ (char-ci=? c #\\a)\n             (char-ci=? c #\\e)\n             (char-ci=?\
    \ c #\\i)\n             (char-ci=? c #\\o)\n             (char-ci=? c #\\u)))\n\
    \       (cond\n         [(is-vowel? c) (next-next-char c)]\n         [(char-lower-case?\
    \ c) (char-upcase c)]\n         [(char-upper-case? c) (char-downcase c)]\n   \
    \      [else c])]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (string-map (lambda (c)\n                (if (char-alphabetic? c)\n        \
    \            (if (char-lower-case? c)\n                        (char-upcase c)\n\
    \                        (char-downcase c))\n                    c))\n       \
    \       message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (define (is-vowel?\
    \ c)\n      (or (char=? c #\\a)\n          (char=? c #\\e)\n          (char=?\
    \ c #\\i)\n          (char=? c #\\o)\n          (char=? c #\\u)))\n    (if (is-vowel?\
    \ c)\n        (swap-case (char-upcase c))\n        (swap-case c)))\n  (string-map\
    \ encode-char message))\n", "  (let loop ([message message]\n             [result\
    \ '()])\n    (cond [(empty? message) (reverse result)]\n          [else (let ([c\
    \ (first message)])\n                  (loop (rest message)\n                \
    \        (cons (cond [(char-alphabetic? c)\n                                 \
    \    (cond [(char-lower-case? c)\n                                           \
    \ (char-upcase c)]\n                                           [(char-upper-case?\
    \ c)\n                                            (char-downcase c)])]\n     \
    \                               [(char-vowel? c)\n                           \
    \          (cond [(char=? c #\\a)\n                                          \
    \  #\\c]\n                                           [(char=? c #\\e)\n      \
    \                                      #\\g]\n                               \
    \            [(char=? c #\\i)\n                                            #\\\
    k]\n                                           [(char=? c #\\o)\n            \
    \                                #\\q]\n                                     \
    \      [(char=? c #\\u)\n                                            #\\w])]\n\
    \                                    [else c])\n                             \
    \ result)))))))\n", "  (define (swap-case c)\n    (if (char-alphabetic? c)\n \
    \       (if (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))\n        c))\n  (define (encode-char c)\n    (if (char-vowel? c)\n     \
    \   (char-next (char-next c))\n        c))\n  (string-map swap-case (string-map\
    \ encode-char message)))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (encode-char c)\n    (if (char-vowel?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase (char-next (char-next\
    \ c)))\n            (char-downcase (char-next (char-next c))))\n        c))\n\
    \  (string-map swap-case (string-map encode-char message)))\n", "  (define (swap-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (if (member c '(\"a\" \"e\" \"i\" \"o\"\
    \ \"u\"))\n        (list-ref '(\"c\" \"f\" \"j\" \"n\" \"r\") (index-of c '(\"\
    a\" \"e\" \"i\" \"o\" \"u\")))\n        (swap-case c)))\n  (string-join (map encode-char\
    \ (string->list message))))\n", "  (string-map\n   (lambda (c)\n     (cond\n \
    \      [(char-alphabetic? c)\n        (let ([new-c (char-upcase c)])\n       \
    \   (cond\n            [(char=? new-c #\\A) #\\C]\n            [(char=? new-c\
    \ #\\E) #\\G]\n            [(char=? new-c #\\I) #\\K]\n            [(char=? new-c\
    \ #\\O) #\\Q]\n            [(char=? new-c #\\U) #\\W]\n            [else (char-downcase\
    \ (char+ new-c 2))]))]\n       [else c]))\n   message))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n\
    \           (char-upcase c)\n           (char-downcase c))]\n      [(char=? c\
    \ #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n  \
    \    [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (next-vowel\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [else c]))\n  (define (encode-char c)\n    (cond\n      [(char-vowel?\
    \ c) (next-vowel c)]\n      [else (swap-case c)]))\n  (string-map encode-char\
    \ message))\n", "  (letrec ([vowels (list #\\a #\\e #\\i #\\o #\\u)]\n       \
    \    [next-vowel (lambda (c)\n                         (cond [(member c vowels)\n\
    \                                (cond [(= c #\\u) #\\a]\n                   \
    \                   [else (next-vowel (char-upcase c))])]\n                  \
    \             [else c]))])\n    (string-map next-vowel (string-upcase message))))\n",
  "  (define (encode-char c)\n    (cond [(char-alphabetic? c)\n           (if (char-lower-case?\
    \ c)\n               (char-upcase c)\n               (char-downcase c))]\n   \
    \       [(char=? c #\\a) #\\c]\n          [(char=? c #\\e) #\\g]\n          [(char=?\
    \ c #\\i) #\\k]\n          [(char=? c #\\o) #\\q]\n          [(char=? c #\\u)\
    \ #\\w]\n          [else c]))\n  (string-map encode-char message))\n", "  (define\
    \ (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n   \
    \     (char-upcase c)))\n  (define (encode-char c)\n    (if (member c '(\"a\"\
    \ \"e\" \"i\" \"o\" \"u\"))\n        (list-ref '(\"c\" \"f\" \"j\" \"n\" \"r\"\
    ) (index-of c '(\"a\" \"e\" \"i\" \"o\" \"u\")))\n        (swap-case c)))\n  (string-join\
    \ (map encode-char (string->list message))))\n", "  (define (swap-case c)\n  \
    \  (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase c)))\n\
    \  (define (vowel? c)\n    (member c '#(#\\a #\\e #\\i #\\o #\\u)))\n  (define\
    \ (encode-char c)\n    (if (vowel? c)\n        (char-succ (char-succ c))\n   \
    \     (swap-case c)))\n  (string-map encode-char message))\n", "  (define (swap-case\
    \ c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c)))\n  (define (swap-vowel c)\n    (cond\n      [(char=? c #\\a) #\\c]\n  \
    \    [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\\
    o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n  (define (encode-char\
    \ c)\n    (swap-case (swap-vowel c)))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n\
    \        (char-upcase c)))\n  (define (encode-char c)\n    (let ((vowels (string-&gt;list\
    \ \"aeiou\"))\n          (alphabet (string-&gt;list \"abcdefghijklmnopqrstuvwxyz\"\
    )))\n      (if (member c vowels)\n          (list-ref alphabet (+ (list-index\
    \ c vowels) 2))\n          (swap-case c))))\n  (string-&gt;list (map encode-char\
    \ (string-&gt;list message))))\n</code>\nI'm not sure if this is the best way\
    \ to do this, but it works.\n\n\nA:\n\nI think your code is pretty good.  I would\
    \ make a few changes:\n\nI would use <code>string-ci=?</code> instead of <code>char=?</code>\
    \ when comparing characters.  This way you don't have to worry about case.\nI\
    \ would use <code>char-alphabetic?</code> instead of <code>char-upper-case?</code>\
    \ to determine if a character is a letter.\nI would use <code>string-downcase</code>\
    \ instead of <code>char-downcase</code> and <code>string-upcase</code> instead\
    \ of <code>char-upcase</code>.  This way you don't have to worry about converting\
    \ between strings and characters.\nI would use <code>string-ref</code> instead\
    \ of <code>list-ref</code> when looking up a character in a string.\nI would use\
    \ <code>string-index</code> instead of <code>list-index</code> when looking up\
    \ the index of a character in a string.\nI would use <code>string-append</code>\
    \ instead of <code>string-&gt;list</code> and <code>list-&gt;string</code>.  This\
    \ way you don't have to worry about converting between strings and lists.\n\n\
    Here is my version of your code:\n<code>(define (encode message)\n  (define (swap-case\
    \ c)\n    (", "  (let ([message (string-upcase message)])\n    (for/fold ([encoded-message\
    \ \"\"]) ([char (in-string message)])\n      (cond\n        [(char-vowel? char)\
    \ (string-append encoded-message (char-next (char-next char)))]\n        [else\
    \ (string-append encoded-message char)]))))\n", "  (define (swap-case c)\n   \
    \ (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase c)))\n\
    \  (define (encode-char c)\n    (if (member c '(\"a\" \"e\" \"i\" \"o\" \"u\"\
    ))\n        (string-ref \"bcdfghjklmnpqrstvwxyz\"\n                    (modulo\
    \ (+ (string-index \"aeiou\" c) 2) 5))\n        (swap-case c)))\n  (string-join\
    \ (map encode-char (string->list message))))\n", "  (define (swap-case c)\n  \
    \  (if (char-upcase? c)\n        (char-downcase c)\n        (char-upcase c)))\n\
    \  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (swap-case\
    \ c)]\n      [(char=? c #\\a)\n       #\\c]\n      [(char=? c #\\e)\n       #\\\
    g]\n      [(char=? c #\\i)\n       #\\k]\n      [(char=? c #\\o)\n       #\\q]\n\
    \      [(char=? c #\\u)\n       #\\w]\n      [else\n       c]))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n        (list-ref '(#\\\
    c #\\f #\\j #\\o #\\t) (position c '(#\\a #\\e #\\i #\\o #\\u)))\n        c))\n\
    \  (string-map swap-case (string-map encode-char message)))\n", "  (define (swap-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (if (char-vowel? c)\n        (swap-case\
    \ (char-next (char-next c)))\n        (swap-case c)))\n  (string-map encode-char\
    \ message))\n", "  (string-map\n   (lambda (c)\n     (cond\n       [(char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))]\n       [(char=? c #\\a) #\\c]\n       [(char=? c #\\\
    e) #\\g]\n       [(char=? c #\\i) #\\k]\n       [(char=? c #\\o) #\\q]\n     \
    \  [(char=? c #\\u) #\\w]\n       [else c]))\n   message))\n", "  (define (swap-case\
    \ c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c)))\n  (define (encode-char c)\n    (define (next-vowel c)\n      (cond\n \
    \       [(char=? c #\\a) #\\c]\n        [(char=? c #\\e) #\\g]\n        [(char=?\
    \ c #\\i) #\\k]\n        [(char=? c #\\o) #\\q]\n        [(char=? c #\\u) #\\\
    w]\n        [else c]))\n    (if (char-vowel? c)\n        (next-vowel c)\n    \
    \    (swap-case c)))\n  (string-map encode-char message))\n", "  (define (swap-case\
    \ c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c)))\n  (define (vowel? c)\n    (member c '(#\\a #\\e #\\i #\\o #\\u)))\n  (define\
    \ (encode-char c)\n    (if (vowel? c)\n        (list-ref '(#\\c #\\d #\\f #\\\
    g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\y #\\\
    z)\n                  (modulo (+ (char-&gt;integer c) 2) 26))\n        (swap-case\
    \ c)))\n  (string-&gt;list (string-map encode-char message)))\n</code>\n", " \
    \ (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (define (vowel? c)\n\
    \      (member c '(#\\a #\\e #\\i #\\o #\\u)))\n    (define (next-vowel c)\n \
    \     (cond\n        [(vowel? c) (next-vowel (char+ c 1))]\n        [else c]))\n\
    \    (define (next-next-vowel c)\n      (cond\n        [(vowel? c) (next-next-vowel\
    \ (char+ c 2))]\n        [else c]))\n    (cond\n      [(vowel? c) (next-next-vowel\
    \ c)]\n      [else (swap-case c)]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-upcase? c)\n        (char-downcase c)\n\
    \        (char-upcase c)))\n  (define (vowel? c)\n    (member c '#(#\\a #\\e #\\\
    i #\\o #\\u)))\n  (define (next-vowel c)\n    (cond\n      [(char=? c #\\a) #\\\
    e]\n      [(char=? c #\\e) #\\i]\n      [(char=? c #\\i) #\\o]\n      [(char=?\
    \ c #\\o) #\\u]\n      [(char=? c #\\u) #\\a]))\n  (define (encode-char c)\n \
    \   (if (vowel? c)\n        (next-vowel c)\n        (swap-case c)))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (define (is-vowel? c)\n      (or (char=? c #\\a)\n          (char=?\
    \ c #\\e)\n          (char=? c #\\i)\n          (char=? c #\\o)\n          (char=?\
    \ c #\\u)))\n    (define (next-vowel c)\n      (cond\n        [(char=? c #\\a)\
    \ #\\c]\n        [(char=? c #\\e) #\\g]\n        [(char=? c #\\i) #\\k]\n    \
    \    [(char=? c #\\o) #\\q]\n        [(char=? c #\\u) #\\w]\n        [else c]))\n\
    \    (if (is-vowel? c)\n        (next-vowel c)\n        (swap-case c)))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (or (char=? c #\\a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\\
    o) (char=? c #\\u))\n        (swap-case (char-next (char-next c)))\n        (swap-case\
    \ c)))\n  (string-map encode-char message))\n", "  (define (encode-char c)\n \
    \   (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n    \
    \       (char-upcase c)\n           (char-downcase c))]\n      [(char=? c #\\\
    a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=?\
    \ c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (let ([vowels '(#\\a #\\e #\\i #\\o #\\u)])\n \
    \   (for/list ([c (in-string message)])\n      (cond\n        [(char-alphabetic?\
    \ c)\n         (char-upcase c)]\n        [(member c vowels)\n         (list-ref\
    \ vowels (+ (position c vowels) 2))]\n        [else c]))))\n", "  (string-map\n\
    \   (lambda (c)\n     (cond\n       [(char-ci=? c #\\a) #\\c]\n       [(char-ci=?\
    \ c #\\e) #\\g]\n       [(char-ci=? c #\\i) #\\k]\n       [(char-ci=? c #\\o)\
    \ #\\q]\n       [(char-ci=? c #\\u) #\\w]\n       [(char-ci=? c #\\y) #\\a]\n\
    \       [(char-ci=? c #\\A) #\\C]\n       [(char-ci=? c #\\E) #\\G]\n       [(char-ci=?\
    \ c #\\I) #\\K]\n       [(char-ci=? c #\\O) #\\Q]\n       [(char-ci=? c #\\U)\
    \ #\\W]\n       [(char-ci=? c #\\Y) #\\A]\n       [else (char-upcase c)]))\n \
    \  message))\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n    \
    \    (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char c)\n\
    \    (if (or (char=? c #\\a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=?\
    \ c #\\u))\n        (swap-case (char-upcase c))\n        (swap-case c)))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (member c '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n        (list-ref '(\"\
    c\" \"f\" \"j\" \"n\" \"r\") (index-of c '(\"a\" \"e\" \"i\" \"o\" \"u\")))\n\
    \        (swap-case c)))\n  (string-join (map encode-char (string->list message))))\n",
  "  (string-map\n   (lambda (c)\n     (cond\n       [(char-alphabetic? c)\n     \
    \   (if (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))]\n       [(char-vowel? c)\n        (char-next (char-next c))]\n       [else\
    \ c]))\n   message))\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n\
    \        (char-upcase c)\n        (char-downcase c)))\n  (define (swap-vowel c)\n\
    \    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n     \
    \ [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u)\
    \ #\\w]\n      [else c]))\n  (define (encode-char c)\n    (swap-case (swap-vowel\
    \ c)))\n  (string-map encode-char message))\n", "  (define (swap-case c)\n   \
    \ (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase c)))\n\
    \  (define (encode-char c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n\
    \      [(char=? c #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c\
    \ #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n  \
    \    [(char=? c #\\U) #\\W]\n      [else (swap-case c)]))\n  (string-map encode-char\
    \ message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (encode-char c)\n    (define (is-vowel? c)\n      (member c '(#\\a #\\\
    e #\\i #\\o #\\u)))\n    (define (next-vowel c)\n      (cond\n        [(char=?\
    \ c #\\u) #\\a]\n        [else (char-upcase (char+ c 1))]))\n    (cond\n     \
    \ [(char-alphabetic? c)\n       (if (is-vowel? c)\n           (next-vowel c)\n\
    \           (char-upcase c))]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n\
    \        (char-upcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else (swap-case\
    \ c)]))\n  (string-map encode-char message))\n", "  (define (swap-case c)\n  \
    \  (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase c)))\n\
    \  (define (swap-vowel c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n  \
    \      (list-ref '(#\\c #\\d #\\f #\\g #\\h) (- (char-ci&gt;=? c #\\a) 2))\n \
    \       c))\n  (string-&gt;list (string-map swap-case (string-map swap-vowel message))))\n\
    </code>\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase\
    \ c)\n        (char-downcase c)))\n  (define (encode-char c)\n    (cond\n    \
    \  [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\\
    i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=?\
    \ c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n\
    \      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else c]))\n\
    \  (define (encode-string s)\n    (string-map encode-char s))\n  (define (swap-case-string\
    \ s)\n    (string-map swap-case s))\n  (string-append (swap-case-string (substring\
    \ message 0 1))\n                 (encode-string (substring message 1))))\n</code>\n",
  "  (let ([message (string-&gt;list message)])\n    (for/list ([letter message])\n\
    \      (cond\n        [(char-alphabetic? letter)\n         (let ([letter (char-upcase\
    \ letter)])\n           (cond\n             [(member letter '(\"A\" \"E\" \"I\"\
    \ \"O\" \"U\"))\n              (let ([letter (string-&gt;list letter)])\n    \
    \            (list-ref (list-ref (list-ref (list \"B\" \"C\" \"D\" \"F\" \"G\"\
    \ \"H\" \"J\" \"K\" \"L\" \"M\" \"N\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"V\" \"W\"\
    \ \"X\" \"Y\" \"Z\")\n                                              (add1 (list-index\
    \ (list \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\"\
    \ \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\"\
    \ \"Z\")\n                                                                (list-ref\
    \ letter 0))))\n                                     0)\n                    \
    \                0)])\n             [else\n              (let ([letter (string-&gt;list\
    \ letter)])\n                (list-ref (list-ref (list-ref (list \"C\" \"D\" \"\
    E\" \"F\" \"G\" \"H\" \"J\" \"K\" \"L\" \"M\" \"N\" \"P\" \"Q\" \"R\" \"S\" \"\
    T\" \"V\" \"W\" \"X\" \"Y\" \"Z\" \"A\" \"B\")\n                             \
    \                 (add1 (list-index (list \"A\" \"B\" \"C\" \"D\" \"E\" \"F\"\
    \ \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\
    \ \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\")\n                               \
    \                                 (list-ref letter 0))))\n                   \
    \                  0)\n                                    0)]))]\n        [else",
  "  (let loop ([message message]\n             [result '()])\n    (cond\n      [(empty?\
    \ message) (reverse result)]\n      [else\n       (let ([c (first message)])\n\
    \         (loop (rest message)\n               (cons (if (char-alphabetic? c)\n\
    \                         (if (char-lower-case? c)\n                         \
    \    (char-upcase c)\n                             (char-downcase c))\n      \
    \                   c)\n                     result)))])))\n", "  (define (swap-case\
    \ c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c)))\n  (define (encode-char c)\n    (if (or (char=? c #\\a) (char=? c #\\e)\
    \ (char=? c #\\i) (char=? c #\\o) (char=? c #\\u))\n        (swap-case (char-next\
    \ (char-next c)))\n        (swap-case c)))\n  (string-map encode-char message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case?\
    \ c)\n           (char-upcase c)\n           (char-downcase c))]\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n  \
    \    [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\\
    U) #\\W]\n      [else c]))\n  (define (encode-message message)\n    (if (empty?\
    \ message)\n        empty\n        (cons (encode-char (first message))\n     \
    \         (encode-message (rest message)))))\n  (define (swap-case-message message)\n\
    \    (if (empty? message)\n        empty\n        (cons (swap-case (first message))\n\
    \              (swap-case-message (rest message)))))\n  (swap-case-message (encode-message\
    \ message)))\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n    \
    \    (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char c)\n\
    \    (if (char-vowel? c)\n        (char-next (char-next c))\n        (swap-case\
    \ c)))\n  (string-map encode-char message))\n", "  (define (swap-case c)\n   \
    \ (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase c)))\n\
    \  (define (encode-char c)\n    (define (vowel? c)\n      (member c '(#\\a #\\\
    e #\\i #\\o #\\u)))\n    (define (next-vowel c)\n      (if (vowel? c)\n      \
    \    (if (char=? c #\\u)\n              #\\a\n              (char+ c 2))\n   \
    \       c))\n    (swap-case (next-vowel c)))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (if (member c '(#\\\
    a #\\e #\\i #\\o #\\u))\n        (list-ref '(#\\c #\\f #\\j #\\o #\\t)\n     \
    \             (position c '(#\\a #\\e #\\i #\\o #\\u)))\n        c))\n  (string-map\
    \ swap-case (string-map encode-char message)))\n", "  (define (swap-case c)\n\
    \    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (cond\n      [(char=? c #\\a) #\\c]\n \
    \     [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\\
    o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=?\
    \ c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n\
    \      [(char=? c #\\U) #\\W]\n      [else c]))\n  (define (encode-string s)\n\
    \    (if (empty? s)\n        empty\n        (cons (encode-char (first s)) (encode-string\
    \ (rest s)))))\n  (define (swap-case-string s)\n    (if (empty? s)\n        empty\n\
    \        (cons (swap-case (first s)) (swap-case-string (rest s)))))\n  (string-append\
    \ (encode-string (swap-case-string message))))\n", "  (define (swap-case c)\n\
    \    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c)))\n  (define (encode-char c)\n    (cond\n      [(or (char=? c #\\a) (char=?\
    \ c #\\A)) (swap-case #\\c)]\n      [(or (char=? c #\\e) (char=? c #\\E)) (swap-case\
    \ #\\g)]\n      [(or (char=? c #\\i) (char=? c #\\I)) (swap-case #\\k)]\n    \
    \  [(or (char=? c #\\o) (char=? c #\\O)) (swap-case #\\m)]\n      [(or (char=?\
    \ c #\\u) (char=? c #\\U)) (swap-case #\\q)]\n      [else (swap-case c)]))\n \
    \ (string-map encode-char message))\n", "  (define (encode-char c)\n    (cond\n\
    \      [(char-alphabetic? c)\n       (if (char-upper-case? c)\n           (char-downcase\
    \ c)\n           (char-upcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n\
    \      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (string-upcase message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n  \
    \    [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\\
    U) #\\W]\n      [else (swap-case c)]))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n\
    \        (char-upcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else (swap-case\
    \ c)]))\n  (string-map encode-char message))\n", "  (define (swap-case c)\n  \
    \  (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase c)))\n\
    \  (define (encode-char c)\n    (if (member c '(\"a\" \"e\" \"i\" \"o\" \"u\"\
    ))\n        (string-ref \"cdfghjklmnpqrstvwxyzab\" (string-index \"aeiou\" c))\n\
    \        (swap-case c)))\n  (string-map encode-char message))\n", "  (let loop\
    \ ([message message]\n             [result '()])\n    (cond [(empty? message)\
    \ (reverse result)]\n          [else (let ([c (first message)])\n            \
    \      (cond [(char-alphabetic? c)\n                         (loop (rest message)\n\
    \                               (cons (if (char-lower-case? c)\n             \
    \                            (char-upcase c)\n                               \
    \          (char-downcase c))\n                                     result))]\n\
    \                        [else (loop (rest message)\n                        \
    \            (cons c result))]))])))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n        (list-ref '(#\\\
    c #\\f #\\j #\\o #\\t)\n                  (position c '(#\\a #\\e #\\i #\\o #\\\
    u)))\n        c))\n  (string-map swap-case\n              (string-map encode-char\
    \ message)))\n", "  (define (swap-case c)\n    (if (char-upper-case? c)\n    \
    \    (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char c)\n\
    \    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n     \
    \ [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u)\
    \ #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=?\
    \ c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n\
    \      [else (swap-case c)]))\n  (string-map encode-char message))\n", "  (define\
    \ (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n     \
    \   (char-downcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else (swap-case\
    \ c)]))\n  (string-map encode-char message))\n", "  (define (encode-char c)\n\
    \    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n   \
    \        (char-upcase c)\n           (char-downcase c))]\n      [(char=? c #\\\
    a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=?\
    \ c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (define (is-vowel? c)\n      (or (char=? c #\\a)\n          (char=?\
    \ c #\\e)\n          (char=? c #\\i)\n          (char=? c #\\o)\n          (char=?\
    \ c #\\u)))\n    (define (next-vowel c)\n      (cond ((char=? c #\\a) #\\c)\n\
    \            ((char=? c #\\e) #\\g)\n            ((char=? c #\\i) #\\k)\n    \
    \        ((char=? c #\\o) #\\q)\n            ((char=? c #\\u) #\\w)))\n    (if\
    \ (is-vowel? c)\n        (next-vowel c)\n        (swap-case c)))\n  (string-map\
    \ encode-char message))\n", "  (for/list ([c (in-string message)])\n    (cond\n\
    \      [(char-alphabetic? c)\n       (cond\n         [(char-lower-case? c)\n \
    \         (char-upcase c)]\n         [(char-upper-case? c)\n          (char-downcase\
    \ c)])]\n      [(char-vowel? c)\n       (char-upcase (char-next (char-next c)))]\n\
    \      [else c])))\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n\
    \        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (char-vowel? c)\n        (swap-case (char-next (char-next c)))\n\
    \        (swap-case c)))\n  (string-map encode-char message))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n\
    \           (char-upcase c)\n           (char-downcase c))]\n      [(char=? c\
    \ #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n  \
    \    [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (encode-char c)\n    (define\
    \ (is-vowel? c)\n      (member c '(#\\a #\\e #\\i #\\o #\\u)))\n    (define (is-upper?\
    \ c)\n      (char-upper-case? c))\n    (define (is-lower? c)\n      (char-lower-case?\
    \ c))\n    (define (swap-case c)\n      (if (is-upper? c)\n          (char-downcase\
    \ c)\n          (char-upcase c)))\n    (define (next-vowel c)\n      (define (next-vowel-helper\
    \ c)\n        (cond\n          [(is-vowel? c) c]\n          [else (next-vowel-helper\
    \ (char+ c 1))]))\n      (next-vowel-helper (char+ c 1)))\n    (define (next-next-vowel\
    \ c)\n      (define (next-next-vowel-helper c)\n        (cond\n          [(is-vowel?\
    \ c) c]\n          [else (next-next-vowel-helper (char+ c 1))]))\n      (next-next-vowel-helper\
    \ (char+ c 2)))\n    (cond\n      [(is-vowel? c) (next-next-vowel c)]\n      [else\
    \ (swap-case c)]))\n  (define (encode-helper message)\n    (cond\n      [(empty?\
    \ message) empty]\n      [else (cons (encode-char (first message))\n         \
    \         (encode-helper (rest message)))]))\n  (encode-helper message))\n", " \
    \ (let ([vowels \"aeiou\"])\n    (for/list ([c (in-string message)])\n      (cond\n\
    \        [(char-alphabetic? c)\n         (if (char-ci=? c #\\a)\n            \
    \ #\\c\n             (if (char-ci=? c #\\e)\n                 #\\g\n         \
    \        (if (char-ci=? c #\\i)\n                     #\\k\n                 \
    \    (if (char-ci=? c #\\o)\n                         #\\m\n                 \
    \        (if (char-ci=? c #\\u)\n                             #\\w\n         \
    \                    (char-upcase c))))))]\n        [else c]))))\n", "  (define\
    \ (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n     \
    \   (char-downcase c)))\n  (define (swap-vowel c)\n    (cond\n      [(char=? c\
    \ #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n  \
    \    [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (define (encoder c)\n    (swap-case (swap-vowel c)))\n  (string-map encoder\
    \ message))\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n     \
    \   (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char c)\n\
    \    (if (or (char=? c #\\a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=?\
    \ c #\\u))\n        (swap-case (char-upcase c))\n        (swap-case c)))\n  (define\
    \ (encode-vowel c)\n    (if (or (char=? c #\\a) (char=? c #\\e) (char=? c #\\\
    i) (char=? c #\\o) (char=? c #\\u))\n        (swap-case (char-upcase c))\n   \
    \     (swap-case c)))\n  (define (encode-message message)\n    (if (empty? message)\n\
    \        empty\n        (cons (encode-char (first message)) (encode-message (rest\
    \ message)))))\n  (define (encode-vowels message)\n    (if (empty? message)\n\
    \        empty\n        (cons (encode-vowel (first message)) (encode-vowels (rest\
    \ message)))))\n  (string-append (encode-message message) (encode-vowels message)))\n",
  "  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (vowel-shift c)\n    (define (next-vowel\
    \ c)\n      (if (char=? c #\\u)\n          #\\a\n          (if (char=? c #\\e)\n\
    \              #\\i\n              (if (char=? c #\\i)\n                  #\\\
    o\n                  (if (char=? c #\\o)\n                      #\\u\n       \
    \               (if (char=? c #\\a)\n                          #\\e\n        \
    \                  c))))))\n    (if (char-alphabetic? c)\n        (if (or (char=?\
    \ c #\\a)\n                (char=? c #\\e)\n                (char=? c #\\i)\n\
    \                (char=? c #\\o)\n                (char=? c #\\u))\n         \
    \   (next-vowel c)\n            c)\n        c))\n  (define (encode-char c)\n \
    \   (vowel-shift (swap-case c)))\n  (string-map encode-char message))\n", "  (define\
    \ (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n     \
    \   (char-downcase c)))\n  (define (encode-char c)\n    (define (is-vowel? c)\n\
    \      (member c '(#\\a #\\e #\\i #\\o #\\u)))\n    (define (next-vowel c)\n \
    \     (cond ((equal? c #\\u) #\\a)\n            (else (char+ c 1))))\n    (if\
    \ (is-vowel? c)\n        (next-vowel (next-vowel c))\n        (swap-case c)))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (cond [(char=? c #\\a) #\\c]\n          [(char=? c #\\e) #\\g]\n   \
    \       [(char=? c #\\i) #\\k]\n          [(char=? c #\\o) #\\q]\n          [(char=?\
    \ c #\\u) #\\w]\n          [(char=? c #\\A) #\\C]\n          [(char=? c #\\E)\
    \ #\\G]\n          [(char=? c #\\I) #\\K]\n          [(char=? c #\\O) #\\Q]\n\
    \          [(char=? c #\\U) #\\W]\n          [else (swap-case c)]))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-upcase? c)\n\
    \        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (cond\n      [(char-vowel? c)\n       (swap-case (char-next (char-next\
    \ c)))]\n      [else\n       (swap-case c)]))\n  (string-map encode-char message))\n",
  "  (string-map\n   (lambda (c)\n     (cond\n       [(char-alphabetic? c)\n     \
    \   (if (char-upper-case? c)\n            (char-downcase c)\n            (char-upcase\
    \ c))]\n       [(char-vowel? c)\n        (char-next (char-next c))]\n       [else\
    \ c]))\n   message))\n", "  (define (swap-case c)\n    (if (char-upper-case? c)\n\
    \        (char-downcase c)\n        (char-upcase c)))\n  (define (vowel? c)\n\
    \    (or (char=? c #\\a)\n        (char=? c #\\e)\n        (char=? c #\\i)\n \
    \       (char=? c #\\o)\n        (char=? c #\\u)))\n  (define (encode-char c)\n\
    \    (if (vowel? c)\n        (swap-case (char-upcase c))\n        (swap-case c)))\n\
    \  (define (encode-char-2 c)\n    (if (vowel? c)\n        (swap-case (char-upcase\
    \ c))\n        (swap-case c)))\n  (define (encode-char-3 c)\n    (if (vowel? c)\n\
    \        (swap-case (char-upcase c))\n        (swap-case c)))\n  (define (encode-char-4\
    \ c)\n    (if (vowel? c)\n        (swap-case (char-upcase c))\n        (swap-case\
    \ c)))\n  (define (encode-char-5 c)\n    (if (vowel? c)\n        (swap-case (char-upcase\
    \ c))\n        (swap-case c)))\n  (define (encode-char-6 c)\n    (if (vowel? c)\n\
    \        (swap-case (char-upcase c))\n        (swap-case c)))\n  (define (encode-char-7\
    \ c)\n    (if (vowel? c)\n        (swap-case (char-upcase c))\n        (swap-case\
    \ c)))\n  (define (encode-char-8 c)\n    (if (vowel? c)\n        (swap-case (char-upcase\
    \ c))\n        (swap-case c)))\n  (define (encode-char-9 c)\n    (if (vowel? c)\n\
    \        (sw", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase\
    \ c)\n        (char-upcase c)))\n  (define (next-vowel c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c) (swap-case\
    \ c)]\n      [(char-vowel? c) (next-vowel c)]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (member c '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n        (list-ref '(\"\
    c\" \"f\" \"j\" \"n\" \"r\") (index-of c '(\"a\" \"e\" \"i\" \"o\" \"u\")))\n\
    \        (swap-case c)))\n  (string-join (map encode-char (string->list message))))\n",
  "  (define (encoder c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case?\
    \ c)\n           (char-upcase c)\n           (char-downcase c))]\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encoder message))\n", "  (define (encode-char c)\n    (cond\n \
    \     [(char-alphabetic? c)\n       (if (char-lower-case? c)\n           (char-upcase\
    \ c)\n           (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n\
    \      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (cond\n      [(char-lower-case? c) (char-upcase c)]\n\
    \      [(char-upper-case? c) (char-downcase c)]\n      [else c]))\n  (define (encode-char\
    \ c)\n    (define (is-vowel? c)\n      (member c '(#\\a #\\e #\\i #\\o #\\u)))\n\
    \    (define (next-vowel c)\n      (cond\n        [(equal? c #\\u) #\\a]\n   \
    \     [else (next-char c)]))\n    (cond\n      [(is-vowel? c) (next-vowel (next-vowel\
    \ c))]\n      [else c]))\n  (define (encode-word word)\n    (map (\u03BB (c) (encode-char\
    \ (swap-case c))) word))\n  (define (encode-words words)\n    (map encode-word\
    \ words))\n  (string-join (encode-words (string-split message)) \"\"))\n", " \
    \ (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-vowel? c)\n        (char-next (char-next\
    \ c))\n        c))\n  (string-map swap-case (string-map encode-char message)))\n",
  "  (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-vowel? c)\n        (let ([vowels \"\
    aeiou\"])\n          (string-ref vowels\n                      (modulo (+ (string-index\
    \ vowels (char-downcase c)) 2)\n                              (string-length vowels))))\n\
    \        c))\n  (string-map swap-case\n              (string-map encode-char message)))\n",
  "  (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n\
    \        (char-upcase c)))\n  (define (encode-char c)\n    (if (member c '(#\\\
    a #\\e #\\i #\\o #\\u))\n        (string-ref \"bcdfghjklmnpqrstvwxyz\" (char->integer\
    \ c))\n        (swap-case c)))\n  (string-map encode-char message))\n", "  (define\
    \ (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n     \
    \   (char-downcase c)))\n  (define (encode-char c)\n    (cond [(char=? c #\\a)\
    \ #\\c]\n          [(char=? c #\\e) #\\g]\n          [(char=? c #\\i) #\\k]\n\
    \          [(char=? c #\\o) #\\q]\n          [(char=? c #\\u) #\\w]\n        \
    \  [(char=? c #\\A) #\\C]\n          [(char=? c #\\E) #\\G]\n          [(char=?\
    \ c #\\I) #\\K]\n          [(char=? c #\\O) #\\Q]\n          [(char=? c #\\U)\
    \ #\\W]\n          [else (swap-case c)]))\n  (string-map encode-char message))\n",
  "  (define (next-char c)\n    (integer->char (+ (char->integer c) 1)))\n  (define\
    \ (next-next-char c)\n    (integer->char (+ (char->integer c) 2)))\n  (define\
    \ (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n   \
    \     (char-upcase c)))\n  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (cond\n         [(char-vowel? c)\n          (next-next-char c)]\n\
    \         [else\n          (swap-case c)])]\n      [else\n       c]))\n  (string-map\
    \ encode-char message))\n", "  (let ([vowels (string-&gt;list \"aeiou\")])\n \
    \   (string-join\n     (map\n      (lambda (c)\n        (if (char-alphabetic?\
    \ c)\n            (let ([new-char (char-upcase c)])\n              (if (member\
    \ (char-downcase c) vowels)\n                  (let ([new-char (char-upcase (char-next\
    \ (char-next c)))]\n                        [new-char (if (char-alphabetic? new-char)\n\
    \                                      new-char\n                            \
    \          (char-upcase (char-next new-char)))])\n                    new-char)\n\
    \                  new-char))\n            c))\n      (string-&gt;list message)))))\n\
    </code>\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase\
    \ c)\n        (char-downcase c)))\n  (define (encode-char c)\n    (if (vowel?\
    \ c)\n        (encode-vowel c)\n        (swap-case c)))\n  (define (encode-vowel\
    \ c)\n    (define (next-vowel c)\n      (if (vowel? c)\n          (next-vowel\
    \ (next-char c))\n          c))\n    (define (next-char c)\n      (integer->char\
    \ (+ (char->integer c) 1)))\n    (next-vowel (next-char c)))\n  (define (vowel?\
    \ c)\n    (member c '(#\\a #\\e #\\i #\\o #\\u)))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (next-vowel c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (define (encode-char c)\n    (if (char-vowel? c)\n        (next-vowel c)\n\
    \        (swap-case c)))\n  (string-map encode-char message))\n", "  (define (swap-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (vowel-shift c)\n    (define (vowel? c)\n      (member c '(#\\\
    a #\\e #\\i #\\o #\\u)))\n    (if (vowel? c)\n        (define (next-vowel c)\n\
    \          (if (char=? c #\\u)\n              #\\a\n              (char+ c 1)))\n\
    \        (next-vowel (next-vowel c))))\n  (define (encode-char c)\n    (if (char-alphabetic?\
    \ c)\n        (vowel-shift (swap-case c))\n        c))\n  (string-map encode-char\
    \ message))\n", "  (define (swap-case c)\n    (if (char-alphabetic? c)\n     \
    \   (if (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))\n        c))\n  (define (replace-vowel c)\n    (cond\n      ((char=? c #\\\
    a) #\\c)\n      ((char=? c #\\e) #\\g)\n      ((char=? c #\\i) #\\k)\n      ((char=?\
    \ c #\\o) #\\q)\n      ((char=? c #\\u) #\\y)\n      (else c)))\n  (string-map\
    \ (lambda (c) (replace-vowel (swap-case c))) message))\n", "  (define (swap-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (define (is-vowel? c)\n      (member c\
    \ '(#\\a #\\e #\\i #\\o #\\u)))\n    (if (is-vowel? c)\n        (let ((next-vowel\
    \ (modulo (+ (char-downcase c) 2) 5)))\n          (list-ref '(#\\c #\\d #\\e #\\\
    f #\\g) next-vowel))\n        (swap-case c)))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-vowel? c)\n        (char-next (char-next\
    \ c))\n        c))\n  (string-map swap-case (string-map encode-char message)))\n",
  "  (string-upcase message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (next-vowel\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [else c]))\n  (define (encode-char c)\n    (cond\n      [(char-vowel?\
    \ c) (next-vowel c)]\n      [else (swap-case c)]))\n  (string-map encode-char\
    \ message))\n", "  (string-map (lambda (c)\n                (cond\n          \
    \        [(char-alphabetic? c)\n                   (if (char-lower-case? c)\n\
    \                       (char-upcase c)\n                       (char-downcase\
    \ c))]\n                  [(char-vowel? c)\n                   (char-next (char-next\
    \ c))]\n                  [else c]))\n              message))\n", "  (string-map\
    \ \n   (lambda (c)\n     (cond\n       [(char-alphabetic? c)\n        (if (char-upper-case?\
    \ c)\n            (char-downcase c)\n            (char-upcase c))]\n       [(char=?\
    \ c #\\a) #\\c]\n       [(char=? c #\\e) #\\g]\n       [(char=? c #\\i) #\\k]\n\
    \       [(char=? c #\\o) #\\q]\n       [(char=? c #\\u) #\\w]\n       [else c]))\n\
    \   message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (string-map (lambda (c)\n                (cond\n                  [(char-alphabetic?\
    \ c)\n                   (if (char-lower-case? c)\n                       (char-upcase\
    \ c)\n                       (char-downcase c))]\n                  [(char-vowel?\
    \ c)\n                   (char-next (char-next c))]\n                  [else c]))\n\
    \              message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (member c '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n        (list-ref (list\
    \ \"c\" \"d\" \"f\" \"g\" \"h\") (sub1 (string-index c \"aeiou\")))\n        (swap-case\
    \ c)))\n  (string-join (map encode-char (string-&gt;list message))))\n</code>\n",
  "  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (next-vowel c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (define (encode-char c)\n    (cond\n      [(char-vowel? c) (next-vowel c)]\n\
    \      [else (swap-case c)]))\n  (string-map encode-char message))\n", "  (define\
    \ (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n     \
    \   (char-downcase c)))\n  (define (encode-char c)\n    (if (member c '(\"a\"\
    \ \"e\" \"i\" \"o\" \"u\"))\n        (string-ref \"cdfghjklmnpqrstvwxyzab\" (string-index\
    \ \"aeiou\" c))\n        (swap-case c)))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else (swap-case\
    \ c)]))\n  (string-map encode-char message))\n", "  (define (swap-case char)\n\
    \    (if (char-lower-case? char)\n        (char-upcase char)\n        (char-downcase\
    \ char)))\n  (define (encode-char char)\n    (define (is-vowel? char)\n      (or\
    \ (char=? char #\\a)\n          (char=? char #\\e)\n          (char=? char #\\\
    i)\n          (char=? char #\\o)\n          (char=? char #\\u)))\n    (define\
    \ (next-vowel char)\n      (cond ((char=? char #\\a) #\\c)\n            ((char=?\
    \ char #\\e) #\\g)\n            ((char=? char #\\i) #\\k)\n            ((char=?\
    \ char #\\o) #\\q)\n            ((char=? char #\\u) #\\w)))\n    (if (is-vowel?\
    \ char)\n        (next-vowel char)\n        (swap-case char)))\n  (map encode-char\
    \ (string->list message)))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if\
    \ (char-lower-case? c)\n           (char-upcase c)\n           (char-downcase\
    \ c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=?\
    \ c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n\
    \      [else c]))\n  (string-map encode-char message))\n", "  (define (swap-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (next-vowel c)\n    (cond\n      [(char=? c #\\a) #\\c]\n  \
    \    [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\\
    o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n  (define (encode-char\
    \ c)\n    (cond\n      [(char-vowel? c) (next-vowel c)]\n      [else (swap-case\
    \ c)]))\n  (string-map encode-char message))\n", "  (define (swap-case c)\n  \
    \  (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase c)))\n\
    \  (define (encode-char c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n\
    \      [(char=? c #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c\
    \ #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n  \
    \    [(char=? c #\\U) #\\W]\n      [else c]))\n  (define (encode-string s)\n \
    \   (if (empty? s)\n        empty\n        (cons (encode-char (first s))\n   \
    \           (encode-string (rest s)))))\n  (define (swap-case-string s)\n    (if\
    \ (empty? s)\n        empty\n        (cons (swap-case (first s))\n           \
    \   (swap-case-string (rest s)))))\n  (encode-string (swap-case-string message)))\n",
  "  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (if (member c '(#\\\
    a #\\e #\\i #\\o #\\u))\n        (list-ref '(#\\c #\\f #\\j #\\o #\\t) (position\
    \ c '(#\\a #\\e #\\i #\\o #\\u)))\n        c))\n  (string-map swap-case (string-map\
    \ encode-char message)))\n", "  (define (swap-case letter)\n    (if (char-upcase?\
    \ letter)\n        (char-downcase letter)\n        (char-upcase letter)))\n  (define\
    \ (encode-letter letter)\n    (cond\n      ((char-ci=? letter #\\a) #\\c)\n  \
    \    ((char-ci=? letter #\\e) #\\g)\n      ((char-ci=? letter #\\i) #\\k)\n  \
    \    ((char-ci=? letter #\\o) #\\q)\n      ((char-ci=? letter #\\u) #\\w)\n  \
    \    ((char-ci=? letter #\\y) #\\a)\n      (else (swap-case letter))))\n  (define\
    \ (encode-message message)\n    (if (empty? message)\n        empty\n        (cons\
    \ (encode-letter (first message))\n              (encode-message (rest message)))))\n\
    \  (encode-message message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n  \
    \    [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\\
    U) #\\W]\n      [else c]))\n  (define (encode-string s)\n    (if (empty? s)\n\
    \        empty\n        (cons (encode-char (first s))\n              (encode-string\
    \ (rest s)))))\n  (define (swap-case-string s)\n    (if (empty? s)\n        empty\n\
    \        (cons (swap-case (first s))\n              (swap-case-string (rest s)))))\n\
    \  (string-append (encode-string (swap-case-string message))))\n", "  (define\
    \ (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n     \
    \   (char-downcase c)))\n  (define (encode-char c)\n    (if (or (char=? c #\\\
    a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=? c #\\u))\n        (swap-case\
    \ (char-upcase c))\n        (swap-case c)))\n  (define (encode-string s)\n   \
    \ (if (string-empty? s)\n        \"\"\n        (string-append (string (encode-char\
    \ (string-ref s 0)))\n                       (encode-string (substring s 1)))))\n\
    \  (encode-string message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (cond\n      [(char-lower-case? c) (char-upcase c)]\n\
    \      [(char-upper-case? c) (char-downcase c)]\n      [else c]))\n  (define (encode-char\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n  \
    \    [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\\
    U) #\\W]\n      [else c]))\n  (string-map encode-char (string-map swap-case message)))\n",
  "  (define (swap-case ch)\n    (if (char-lower-case? ch)\n        (char-upcase ch)\n\
    \        (char-downcase ch)))\n  (define (encode-char ch)\n    (cond\n      [(char=?\
    \ ch #\\a) #\\c]\n      [(char=? ch #\\e) #\\g]\n      [(char=? ch #\\i) #\\k]\n\
    \      [(char=? ch #\\o) #\\q]\n      [(char=? ch #\\u) #\\w]\n      [(char=?\
    \ ch #\\A) #\\C]\n      [(char=? ch #\\E) #\\G]\n      [(char=? ch #\\I) #\\K]\n\
    \      [(char=? ch #\\O) #\\Q]\n      [(char=? ch #\\U) #\\W]\n      [else (swap-case\
    \ ch)]))\n  (string-map encode-char message))\n", "  (define (encode-char c)\n\
    \    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n   \
    \        (char-upcase c)\n           (char-downcase c))]\n      [(char=? c #\\\
    a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=?\
    \ c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (let ([vowels (string-&gt;list \"aeiou\")])\n      (if (member c vowels)\n\
    \          (list-ref vowels (+ (position c vowels) 2))\n          (swap-case c))))\n\
    \  (list-&gt;string (map encode-char (string-&gt;list message))))\n", "  (let\
    \ loop ([message message]\n             [result '()])\n    (cond [(empty? message)\
    \ (list->string (reverse result))]\n          [(char-alphabetic? (first message))\n\
    \           (let ([char (first message)])\n             (loop (rest message)\n\
    \                   (cons (if (char-lower-case? char)\n                      \
    \       (char-upcase char)\n                             (char-downcase char))\n\
    \                         result)))]\n          [else (loop (rest message)\n \
    \                     (cons (first message)\n                            result))])))\n",
  "  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else c]))\n\
    \  (define (encode-message message)\n    (if (empty? message)\n        empty\n\
    \        (cons (encode-char (swap-case (first message)))\n              (encode-message\
    \ (rest message)))))\n  (list->string (encode-message (string->list message))))\n",
  "  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (next-vowel c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (define (encode-char c)\n    (cond\n      [(char-vowel? c) (next-vowel c)]\n\
    \      [else (swap-case c)]))\n  (string-map encode-char message))\n", "  (define\
    \ (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n     \
    \   (char-downcase c)))\n  (define (encode-char c)\n    (if (char-vowel? c)\n\
    \        (swap-case (char-next (char-next c)))\n        (swap-case c)))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n  \
    \    [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\\
    U) #\\W]\n      [else (swap-case c)]))\n  (string-map encode-char message))\n",
  "  (let loop ([message message]\n             [result '()])\n    (cond\n      [(empty?\
    \ message) (list->string (reverse result))]\n      [(char-alphabetic? (first message))\n\
    \       (let ([c (first message)])\n         (loop (rest message)\n          \
    \     (cons (if (char-lower-case? c)\n                         (char-upcase c)\n\
    \                         (char-downcase c))\n                     result)))]\n\
    \      [else (loop (rest message)\n                  (cons (first message)\n \
    \                       result))])))\n", "  (string-map (lambda (c)\n        \
    \        (if (char-alphabetic? c)\n                    (if (char-lower-case? c)\n\
    \                        (char-upcase c)\n                        (char-downcase\
    \ c))\n                    c))\n              message))\n", "  (define (swap-case\
    \ c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n       \
    \     (char-upcase c)\n            (char-downcase c))\n        c))\n  (define\
    \ (encode-char c)\n    (if (char-vowel? c)\n        (char-next (char-next c))\n\
    \        c))\n  (string-map swap-case (string-map encode-char message)))\n", " \
    \ (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else c]))\n\
    \  (define (encode-string s)\n    (if (string-empty? s)\n        \"\"\n      \
    \  (string-append (encode-char (string-ref s 0))\n                       (encode-string\
    \ (substring s 1)))))\n  (encode-string (string-map swap-case message)))\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if\
    \ (char-lower-case? c)\n           (char-upcase c)\n           (char-downcase\
    \ c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=?\
    \ c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n\
    \      [else c]))\n  (string-map encode-char message))\n", "  (string-map\n  \
    \ (lambda (c)\n     (cond\n       [(char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))]\n       [(char-vowel?\
    \ c)\n        (char-next (char-next c))]\n       [else c]))\n   message))\n",
  "  (define (swap-case c)\n    (if (char-upcase? c)\n        (char-downcase c)\n\
    \        (char-upcase c)))\n  (define (encode-char c)\n    (if (vowel? c)\n  \
    \      (encode-vowel c)\n        (swap-case c)))\n  (define (encode-vowel c)\n\
    \    (define (next-vowel c)\n      (cond\n        [(char=? c #\\u) #\\a]\n   \
    \     [(char=? c #\\e) #\\i]\n        [(char=? c #\\i) #\\o]\n        [(char=?\
    \ c #\\o) #\\u]\n        [(char=? c #\\a) #\\e]\n        [else (error 'encode-vowel\
    \ \"bad vowel\")]))\n    (next-vowel (next-vowel c)))\n  (define (vowel? c)\n\
    \    (or (char=? c #\\a)\n        (char=? c #\\e)\n        (char=? c #\\i)\n \
    \       (char=? c #\\o)\n        (char=? c #\\u)))\n  (string-map encode-char\
    \ message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (if (member c '(#\\\
    a #\\e #\\i #\\o #\\u))\n        (list-ref '(#\\c #\\f #\\j #\\o #\\t) (position\
    \ c '(#\\a #\\e #\\i #\\o #\\u)))\n        c))\n  (string-map swap-case (string-map\
    \ encode-char message)))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase\
    \ c)\n        (char-upcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else (swap-case\
    \ c)]))\n  (string-map encode-char message))\n", "  (string-map (lambda (c)\n\
    \                (if (char-alphabetic? c)\n                    (if (vowel? c)\n\
    \                        (next-vowel c)\n                        (swap-case c))\n\
    \                    c))\n              message))\n", "  (define (swap-case c)\n\
    \    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c)))\n  (define (encode-char c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\\
    u))\n        (list-ref '(#\\c #\\f #\\j #\\o #\\t) (position c '(#\\a #\\e #\\\
    i #\\o #\\u)))\n        c))\n  (string-map swap-case (string-map encode-char message)))\n",
  "  (define (encode-char c)\n    (define (is-vowel? c)\n      (or (char=? c #\\a)\n\
    \          (char=? c #\\e)\n          (char=? c #\\i)\n          (char=? c #\\\
    o)\n          (char=? c #\\u)))\n    (define (swap-case c)\n      (if (char-upper-case?\
    \ c)\n          (char-downcase c)\n          (char-upcase c)))\n    (define (next-vowel\
    \ c)\n      (cond\n        [(char=? c #\\a) #\\c]\n        [(char=? c #\\e) #\\\
    g]\n        [(char=? c #\\i) #\\k]\n        [(char=? c #\\o) #\\q]\n        [(char=?\
    \ c #\\u) #\\w]\n        [else c]))\n    (if (is-vowel? c)\n        (next-vowel\
    \ c)\n        (swap-case c)))\n  (string-map encode-char message))\n```\n\n##\
    \ Day 4\n\n### Problem\n\nWrite a function that takes a message and a key, and\
    \ encodes the message using the key.\n\nThe key is a list of numbers.\n\nThe encoding\
    \ works by taking the first number in the key, and using it as the number of characters\
    \ to skip.\n\nThen, the second number in the key is used as the number of characters\
    \ to take.\n\nThis is repeated until the end of the key.\n\nIf the end of the\
    \ key is reached, start again from the beginning.\n\nExamples:\n\n```racket\n\
    >>> (encode \"This is a message\" '(1 2 3))\n\"hsi  etTi sats!\"\n>>> (encode\
    \ \"This is a message\" '(2 1))\n\"hsi  etTi sats!\"\n>>> (encode \"This is a\
    \ message\" '(3 2 1))\n\"s eT ashi tist!\"\n```\n\n### Solution\n\n```racket\n\
    #lang racket\n", "  (string-map\n   (lambda (c)\n     (cond\n       [(char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))]\n       [(char-vowel? c)\n        (char-next (char-next\
    \ c))]\n       [else c]))\n   message))\n", "  (define (encode-char c)\n    (cond\n\
    \      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n           (char-upcase\
    \ c)\n           (char-downcase c))]\n      [(char=? c #\\a)\n       #\\c]\n \
    \     [(char=? c #\\e)\n       #\\g]\n      [(char=? c #\\i)\n       #\\k]\n \
    \     [(char=? c #\\o)\n       #\\q]\n      [(char=? c #\\u)\n       #\\w]\n \
    \     [else c]))\n  (string-map encode-char message))\n", "  (let ([message (string-upcase\
    \ message)])\n    (for/fold ([encoded-message \"\"]) ([c (in-string message)])\n\
    \      (cond\n        [(char-alphabetic? c)\n         (cond\n           [(member\
    \ c '(\"A\" \"E\" \"I\" \"O\" \"U\"))\n            (string-append encoded-message\
    \ (string (char-upcase (+ c 2))))]\n           [else\n            (string-append\
    \ encoded-message (string c))])]\n        [else\n         (string-append encoded-message\
    \ (string c))]))))\n", "  (define (swap-case c)\n    (if (char-alphabetic? c)\n\
    \        (if (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))\n        c))\n  (define (encode-char c)\n    (define (is-vowel? c)\n   \
    \   (member c '(#\\a #\\e #\\i #\\o #\\u)))\n    (if (is-vowel? c)\n        (define\
    \ (next-vowel c)\n          (define (next-char c)\n            (integer->char\
    \ (+ (char->integer c) 1)))\n          (if (is-vowel? (next-char c))\n       \
    \       (next-char c)\n              (next-vowel (next-char c))))\n        c))\n\
    \  (define (encode-message message)\n    (if (empty? message)\n        '()\n \
    \       (cons (encode-char (swap-case (first message)))\n              (encode-message\
    \ (rest message)))))\n  (list->string (encode-message (string->list message))))\n",
  "  (string-map\n   (lambda (c)\n     (cond\n       [(char-alphabetic? c)\n     \
    \   (if (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))]\n       [(char-vowel? c)\n        (char-next (char-next c))]\n       [else\
    \ c]))\n   message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if\
    \ (char-lower-case? c)\n           (char-upcase c)\n           (char-downcase\
    \ c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=?\
    \ c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n\
    \      [else c]))\n  (string-map encode-char message))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n\
    \           (char-upcase c)\n           (char-downcase c))]\n      [(char=? c\
    \ #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n  \
    \    [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (char-vowel? c)\n        (swap-case (char-next (char-next c)))\n\
    \        (swap-case c)))\n  (string-map encode-char message))\n", "  (define (swap-case\
    \ c)\n    (cond\n      [(char-lower-case? c) (char-upcase c)]\n      [(char-upper-case?\
    \ c) (char-downcase c)]\n      [else c]))\n  (define (encode-char c)\n    (cond\n\
    \      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c\
    \ #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n  \
    \    [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\\
    I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else\
    \ c]))\n  (string-map swap-case (string-map encode-char message)))\n", "  (define\
    \ (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case?\
    \ c)\n           (char-upcase c)\n           (char-downcase c))]\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (swap-vowel c)\n    (if (char-alphabetic?\
    \ c)\n        (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n            (char-downcase\
    \ (char+ c 2))\n            c)\n        c))\n  (string-map swap-vowel (string-map\
    \ swap-case message)))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n  \
    \    [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\\
    U) #\\W]\n      [else (swap-case c)]))\n  (string-map encode-char message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-upper-case?\
    \ c)\n           (char-downcase c)\n           (char-upcase c))]\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (let ([vowels (list #\\a #\\e #\\\
    i #\\o #\\u)])\n    (string-map\n     (lambda (c)\n       (cond\n         [(char-alphabetic?\
    \ c)\n          (char-upcase c)]\n         [(member c vowels)\n          (char-upcase\
    \ (list-ref vowels (modulo (+ 2 (list-index c vowels)) 5)))]\n         [else\n\
    \          c]))\n     message)))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (encode-char c)\n    (if (char-vowel?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase (char-next (char-next\
    \ c)))\n            (char-downcase (char-next (char-next c))))\n        c))\n\
    \  (string-map swap-case (string-map encode-char message)))\n", "  (define (next-vowel\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [else c]))\n  (define (swap-case c)\n    (cond\n      [(char-lower-case?\
    \ c) (char-upcase c)]\n      [(char-upper-case? c) (char-downcase c)]\n      [else\
    \ c]))\n  (define (encode-char c)\n    (cond\n      [(char-vowel? c) (next-vowel\
    \ c)]\n      [else (swap-case c)]))\n  (string-map encode-char message))\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if\
    \ (char-lower-case? c)\n           (char-upcase c)\n           (char-downcase\
    \ c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=?\
    \ c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n\
    \      [else c]))\n  (string-map encode-char message))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n\
    \           (char-upcase c)\n           (char-downcase c))]\n      [(char=? c\
    \ #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n  \
    \    [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (encode-char c)\n    (cond\n\
    \      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n           (char-upcase\
    \ c)\n           (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n\
    \      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
