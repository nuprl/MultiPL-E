name: HumanEval_136_largest_smallest_integers
language: rkt
prompt: "#lang racket\n\n#| Create a function that returns a list (a, b), where 'a'\
  \ is\nthe largest of negative integers, and 'b' is the smallest\nof positive integers\
  \ in a list.\nIf there is no negative or positive integers, return them as #f.\n\
  Examples:\n>>> (largest_smallest_integers (list 2 4 1 3 5 7))\n(list #f 1)\n>>>\
  \ (largest_smallest_integers (list ))\n(list #f #f)\n>>> (largest_smallest_integers\
  \ (list 0))\n(list #f #f)|#\n(define (largest_smallest_integers lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_smallest_integers))\n\
  \    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))\n    (check-equal?\
  \ (candidate (list 2 4 1 3 5 7 0)) (list #f 1))\n    (check-equal? (candidate (list\
  \ 1 3 2 4 5 6 -2)) (list -2 1))\n    (check-equal? (candidate (list 4 5 3 6 2 7\
  \ -7)) (list -7 2))\n    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list\
  \ -9 2))\n    (check-equal? (candidate (list )) (list #f #f))\n    (check-equal?\
  \ (candidate (list 0)) (list #f #f))\n    (check-equal? (candidate (list -1 -3 -5\
  \ -6)) (list -1 #f))\n    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1\
  \ #f))\n    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))\n    (check-equal?\
  \ (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))\n))\n\n(test-humaneval)"
completions: ["  (define (largest_smallest_integers_iter lst largest smallest)\n \
    \   (cond\n      [(empty? lst) (list largest smallest)]\n      [(and (positive?\
    \ (first lst)) (or (not smallest) (< (first lst) smallest)))\n       (largest_smallest_integers_iter\
    \ (rest lst) largest (first lst))]\n      [(and (negative? (first lst)) (or (not\
    \ largest) (> (first lst) largest)))\n       (largest_smallest_integers_iter (rest\
    \ lst) (first lst) smallest)]\n      [else (largest_smallest_integers_iter (rest\
    \ lst) largest smallest)]))\n  (largest_smallest_integers_iter lst #f #f))\n",
  "  (define (largest_negative lst)\n    (cond\n      [(null? lst) #f]\n      [(and\
    \ (negative? (car lst)) (not (null? (cdr lst))))\n       (if (negative? (cadr\
    \ lst))\n           (largest_negative (cdr lst))\n           (car lst))]\n   \
    \   [(negative? (car lst)) (car lst)]\n      [else (largest_negative (cdr lst))]))\n\
    \  (define (smallest_positive lst)\n    (cond\n      [(null? lst) #f]\n      [(and\
    \ (positive? (car lst)) (not (null? (cdr lst))))\n       (if (positive? (cadr\
    \ lst))\n           (smallest_positive (cdr lst))\n           (car lst))]\n  \
    \    [(positive? (car lst)) (car lst)]\n      [else (smallest_positive (cdr lst))]))\n\
    \  (list (largest_negative lst) (smallest_positive lst)))\n", "  (define (largest_smallest_integers_iter\
    \ lst largest smallest)\n    (cond [(empty? lst) (list largest smallest)]\n  \
    \        [(and (negative? (first lst))\n                (or (not (number? largest))\n\
    \                    (< (first lst) largest)))\n           (largest_smallest_integers_iter\
    \ (rest lst) (first lst) smallest)]\n          [(and (positive? (first lst))\n\
    \                (or (not (number? smallest))\n                    (> (first lst)\
    \ smallest)))\n           (largest_smallest_integers_iter (rest lst) largest (first\
    \ lst))]\n          [else (largest_smallest_integers_iter (rest lst) largest smallest)]))\n\
    \  (largest_smallest_integers_iter lst #f #f))\n", "  (define (largest_smallest_integers_helper\
    \ lst largest smallest)\n    (cond [(empty? lst) (list largest smallest)]\n  \
    \        [(and (positive? (first lst)) (or (not (positive? smallest)) (< (first\
    \ lst) smallest)))\n           (largest_smallest_integers_helper (rest lst) largest\
    \ (first lst))]\n          [(and (negative? (first lst)) (or (not (negative? largest))\
    \ (> (first lst) largest)))\n           (largest_smallest_integers_helper (rest\
    \ lst) (first lst) smallest)]\n          [else (largest_smallest_integers_helper\
    \ (rest lst) largest smallest)]))\n  (largest_smallest_integers_helper lst #f\
    \ #f))\n", "  (define (largest-smallest-integers-helper lst largest smallest)\n\
    \    (cond\n      [(null? lst) (list largest smallest)]\n      [(and (positive?\
    \ (car lst)) (not smallest)) (largest-smallest-integers-helper (cdr lst) largest\
    \ (car lst))]\n      [(and (positive? (car lst)) (< (car lst) smallest)) (largest-smallest-integers-helper\
    \ (cdr lst) largest (car lst))]\n      [(and (negative? (car lst)) (not largest))\
    \ (largest-smallest-integers-helper (cdr lst) (car lst) smallest)]\n      [(and\
    \ (negative? (car lst)) (> (car lst) largest)) (largest-smallest-integers-helper\
    \ (cdr lst) (car lst) smallest)]\n      [else (largest-smallest-integers-helper\
    \ (cdr lst) largest smallest)]))\n  (largest-smallest-integers-helper lst #f #f))\n",
  "  (define (largest_negative_integer lst)\n    (cond\n      [(empty? lst) #f]\n\
    \      [(and (negative? (first lst)) (not (negative? (first (rest lst))))) (first\
    \ lst)]\n      [else (largest_negative_integer (rest lst))]))\n  (define (smallest_positive_integer\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst))\
    \ (not (positive? (first (rest lst))))) (first lst)]\n      [else (smallest_positive_integer\
    \ (rest lst))]))\n  (list (largest_negative_integer lst) (smallest_positive_integer\
    \ lst)))\n", "  (let ((negatives (filter (lambda (x) (< x 0)) lst))\n        (positives\
    \ (filter (lambda (x) (> x 0)) lst)))\n    (if (empty? negatives)\n        (list\
    \ #f (min positives))\n        (if (empty? positives)\n            (list (max\
    \ negatives) #f)\n            (list (max negatives) (min positives))))))\n", " \
    \ (define (largest_negative lst)\n    (cond\n      [(empty? lst) #f]\n      [(negative?\
    \ (first lst)) (max (first lst) (largest_negative (rest lst)))]\n      [else (largest_negative\
    \ (rest lst))]))\n  (define (smallest_positive lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(positive? (first lst)) (min (first lst) (smallest_positive\
    \ (rest lst)))]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (largest-negative lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(and (negative? (first lst))\n            (or\
    \ (not (negative? (second lst)))\n                (negative? (first lst))))\n\
    \       (first lst)]\n      [else (largest-negative (rest lst))]))\n  (define\
    \ (smallest-positive lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (positive?\
    \ (first lst))\n            (or (not (positive? (second lst)))\n             \
    \   (positive? (first lst))))\n       (first lst)]\n      [else (smallest-positive\
    \ (rest lst))]))\n  (list (largest-negative lst) (smallest-positive lst)))\n",
  "  (cond\n    [(empty? lst) (list #f #f)]\n    [(and (positive? (first lst)) (negative?\
    \ (first lst))) (list (first lst) (first lst))]\n    [(positive? (first lst))\
    \ (cons (first lst) (largest_smallest_integers (rest lst)))]\n    [(negative?\
    \ (first lst)) (cons (first lst) (largest_smallest_integers (rest lst)))]\n  \
    \  [else (largest_smallest_integers (rest lst))]))\n", "  (define (largest_smallest_integers_helper\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (positive? (first lst)) (or (not smallest) (< (first lst) smallest)))\n\
    \       (largest_smallest_integers_helper (rest lst) largest (first lst))]\n \
    \     [(and (negative? (first lst)) (or (not largest) (> (first lst) largest)))\n\
    \       (largest_smallest_integers_helper (rest lst) (first lst) smallest)]\n\
    \      [else (largest_smallest_integers_helper (rest lst) largest smallest)]))\n\
    \  (largest_smallest_integers_helper lst #f #f))\n", "  (cond\n    [(empty? lst)\
    \ (list #f #f)]\n    [(and (positive? (first lst)) (negative? (first lst))) (list\
    \ #f #f)]\n    [(positive? (first lst)) (list #f (first lst))]\n    [(negative?\
    \ (first lst)) (list (first lst) #f)]\n    [else (largest_smallest_integers (rest\
    \ lst))]))\n", "  (define (largest-negative lst)\n    (cond\n      [(empty? lst)\
    \ #f]\n      [(and (negative? (first lst))\n            (or (not (negative? (second\
    \ lst)))\n                (not (number? (second lst)))))\n       (first lst)]\n\
    \      [else (largest-negative (rest lst))]))\n  (define (smallest-positive lst)\n\
    \    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst))\n   \
    \         (or (not (positive? (second lst)))\n                (not (number? (second\
    \ lst)))))\n       (first lst)]\n      [else (smallest-positive (rest lst))]))\n\
    \  (list (largest-negative lst) (smallest-positive lst)))\n", "  (define (largest_smallest_integers_iter\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (positive? (first lst))\n            (or (not (positive? smallest))\n\
    \                (< (first lst) smallest)))\n       (largest_smallest_integers_iter\
    \ (rest lst) largest (first lst))]\n      [(and (negative? (first lst))\n    \
    \        (or (not (negative? largest))\n                (> (first lst) largest)))\n\
    \       (largest_smallest_integers_iter (rest lst) (first lst) smallest)]\n  \
    \    [else (largest_smallest_integers_iter (rest lst) largest smallest)]))\n \
    \ (largest_smallest_integers_iter lst #f #f))\n", "  (define (largest_negative_integer\
    \ lst)\n    (cond ((null? lst) #f)\n          ((and (integer? (car lst)) (< (car\
    \ lst) 0))\n           (max (car lst) (largest_negative_integer (cdr lst))))\n\
    \          (else (largest_negative_integer (cdr lst)))))\n  (define (smallest_positive_integer\
    \ lst)\n    (cond ((null? lst) #f)\n          ((and (integer? (car lst)) (> (car\
    \ lst) 0))\n           (min (car lst) (smallest_positive_integer (cdr lst))))\n\
    \          (else (smallest_positive_integer (cdr lst)))))\n  (list (largest_negative_integer\
    \ lst) (smallest_positive_integer lst)))\n", "  (let ([negs (filter (lambda (x)\
    \ (negative? x)) lst)]\n        [pos (filter (lambda (x) (positive? x)) lst)])\n\
    \    (if (empty? negs)\n        (list #f (apply min pos))\n        (if (empty?\
    \ pos)\n            (list (apply max negs) #f)\n            (list (apply max negs)\
    \ (apply min pos))))))\n", "  (define (largest_negative lst)\n    (cond\n    \
    \  [(null? lst) #f]\n      [(and (negative? (car lst))\n            (or (not (negative?\
    \ (cadr lst)))\n                (negative? (cadr lst))))\n       (largest_negative\
    \ (cdr lst))]\n      [(and (negative? (car lst))\n            (not (negative?\
    \ (cadr lst))))\n       (car lst)]\n      [else (largest_negative (cdr lst))]))\n\
    \  (define (smallest_positive lst)\n    (cond\n      [(null? lst) #f]\n      [(and\
    \ (positive? (car lst))\n            (or (not (positive? (cadr lst)))\n      \
    \          (positive? (cadr lst))))\n       (smallest_positive (cdr lst))]\n \
    \     [(and (positive? (car lst))\n            (not (positive? (cadr lst))))\n\
    \       (car lst)]\n      [else (smallest_positive (cdr lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (largest_smallest_integers-helper\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(negative? (first lst))\n       (largest_smallest_integers-helper (rest\
    \ lst) (first lst) smallest)]\n      [(positive? (first lst))\n       (largest_smallest_integers-helper\
    \ (rest lst) largest (first lst))]\n      [else (largest_smallest_integers-helper\
    \ (rest lst) largest smallest)]))\n  (largest_smallest_integers-helper lst #f\
    \ #f))\n", "  (define (helper lst largest smallest)\n    (cond\n      [(null?\
    \ lst) (list largest smallest)]\n      [(and (not (negative? (car lst))) (not\
    \ (positive? (car lst)))) (helper (cdr lst) largest smallest)]\n      [(and (not\
    \ (negative? (car lst))) (positive? (car lst))) (helper (cdr lst) largest (car\
    \ lst))]\n      [(and (negative? (car lst)) (not (positive? (car lst)))) (helper\
    \ (cdr lst) (car lst) smallest)]\n      [(and (negative? (car lst)) (positive?\
    \ (car lst))) (helper (cdr lst) (car lst) smallest)]))\n  (helper lst #f #f))\n",
  "  (define (helper lst largest smallest)\n    (cond\n      [(empty? lst) (list largest\
    \ smallest)]\n      [(and (negative? (first lst)) (or (not largest) (&gt; (first\
    \ lst) largest)))\n       (helper (rest lst) (first lst) smallest)]\n      [(and\
    \ (positive? (first lst)) (or (not smallest) (&lt; (first lst) smallest)))\n \
    \      (helper (rest lst) largest (first lst))]\n      [else (helper (rest lst)\
    \ largest smallest)]))\n  (helper lst #f #f))\n</code>\nI'm not sure if I'm doing\
    \ it right, but I'm trying to use the helper function to keep track of the largest\
    \ and smallest integers.\nI'm not sure if I'm doing it right, but I'm trying to\
    \ use the helper function to keep track of the largest and smallest integers.\n\
    I'm not sure if I'm doing it right, but I'm trying to use the helper function\
    \ to keep track of the largest and smallest integers.\nI'm not sure if I'm doing\
    \ it right, but I'm trying to use the helper function to keep track of the largest\
    \ and smallest integers.\nI'm not sure if I'm doing it right, but I'm trying to\
    \ use the helper function to keep track of the largest and smallest integers.\n\
    I'm not sure if I'm doing it right, but I'm trying to use the helper function\
    \ to keep track of the largest and smallest integers.\nI'm not sure if I'm doing\
    \ it right, but I'm trying to use the helper function to keep track of the largest\
    \ and smallest integers.\nI'm not sure if I'm doing it right, but I'm trying to\
    \ use the helper function to keep track of the largest and smallest integers.\n\
    I'm not sure if I'm doing it right, but I'm trying to use the helper function\
    \ to keep track of the largest and smallest integers.\nI'm not sure if I'm doing\
    \ it right, but I'm trying to use the helper function to keep track of the largest\
    \ and smallest integers.\nI'm not sure if I'm doing it right, but I'm trying to\
    \ use the helper function to keep track of the largest and smallest integers.\n\
    I'm not sure if I'm doing it right, but I'm trying to use the helper", "  (define\
    \ (largest-neg lst)\n    (cond\n      [(null? lst) #f]\n      [(and (number? (car\
    \ lst)) (< (car lst) 0))\n       (max (car lst) (largest-neg (cdr lst)))]\n  \
    \    [else (largest-neg (cdr lst))]))\n  (define (smallest-pos lst)\n    (cond\n\
    \      [(null? lst) #f]\n      [(and (number? (car lst)) (> (car lst) 0))\n  \
    \     (min (car lst) (smallest-pos (cdr lst)))]\n      [else (smallest-pos (cdr\
    \ lst))]))\n  (list (largest-neg lst) (smallest-pos lst)))\n", "  (define (largest_smallest_integers_helper\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (negative? (first lst)) (or (not (number? largest)) (&gt; (first\
    \ lst) largest)))\n       (largest_smallest_integers_helper (rest lst) (first\
    \ lst) smallest)]\n      [(and (positive? (first lst)) (or (not (number? smallest))\
    \ (&lt; (first lst) smallest)))\n       (largest_smallest_integers_helper (rest\
    \ lst) largest (first lst))]\n      [else (largest_smallest_integers_helper (rest\
    \ lst) largest smallest)]))\n  (largest_smallest_integers_helper lst #f #f))\n\
    </code>\nI'm not sure if I'm doing this right. I'm trying to do it recursively.\n\
    The problem is that I'm not sure if I'm doing it right.\nI'm trying to do it recursively.\n\
    I'm not sure if I'm doing this right.\nI'm trying to do it recursively.\nI'm not\
    \ sure if I'm doing this right.\nI'm trying to do it recursively.\nI'm not sure\
    \ if I'm doing this right.\nI'm trying to do it recursively.\nI'm not sure if\
    \ I'm doing this right.\nI'm trying to do it recursively.\nI'm not sure if I'm\
    \ doing this right.\nI'm trying to do it recursively.\nI'm not sure if I'm doing\
    \ this right.\nI'm trying to do it recursively.\nI'm not sure if I'm doing this\
    \ right.\nI'm trying to do it recursively.\nI'm not sure if I'm doing this right.\n\
    I'm trying to do it recursively.\nI'm not sure if I'm doing this right.\nI'm trying\
    \ to do it recursively.\nI'm not sure if I'm doing this right.\nI'm trying to\
    \ do it recursively.\nI'm not sure if I'm doing this right.\nI'm trying to do\
    \ it recursively.\nI'm not sure if I'm doing this right.\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative? (first lst))\n\
    \            (or (not (negative? (second lst)))\n                (negative? (second\
    \ lst))))\n       (largest_negative (cons (first lst) (rest (rest lst))))]\n \
    \     [else (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n\
    \    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst))\n   \
    \         (or (not (positive? (second lst)))\n                (positive? (second\
    \ lst))))\n       (smallest_positive (cons (first lst) (rest (rest lst))))]\n\
    \      [else (smallest_positive (rest lst))]))\n  (list (largest_negative lst)\
    \ (smallest_positive lst)))\n", "  (define (helper lst neg pos)\n    (cond\n \
    \     [(empty? lst) (list neg pos)]\n      [(and (negative? (first lst)) (or (not\
    \ neg) (&lt; (first lst) neg)))\n       (helper (rest lst) (first lst) pos)]\n\
    \      [(and (positive? (first lst)) (or (not pos) (&gt; (first lst) pos)))\n\
    \       (helper (rest lst) neg (first lst))]\n      [else (helper (rest lst) neg\
    \ pos)]))\n  (helper lst #f #f))\n</code>\n", "  (define (helper lst pos neg)\n\
    \    (cond\n      [(empty? lst) (list pos neg)]\n      [(positive? (first lst))\
    \ (helper (rest lst) (first lst) neg)]\n      [(negative? (first lst)) (helper\
    \ (rest lst) pos (first lst))]\n      [else (helper (rest lst) pos neg)]))\n \
    \ (helper lst #f #f))\n", "  (define (largest_negative lst)\n    (cond\n     \
    \ [(null? lst) #f]\n      [(and (negative? (car lst)) (not (null? (cdr lst))))\n\
    \       (if (negative? (car (cdr lst)))\n           (largest_negative (cdr lst))\n\
    \           (car lst))]\n      [(negative? (car lst)) (car lst)]\n      [else\
    \ (largest_negative (cdr lst))]))\n  (define (smallest_positive lst)\n    (cond\n\
    \      [(null? lst) #f]\n      [(and (positive? (car lst)) (not (null? (cdr lst))))\n\
    \       (if (positive? (car (cdr lst)))\n           (smallest_positive (cdr lst))\n\
    \           (car lst))]\n      [(positive? (car lst)) (car lst)]\n      [else\
    \ (smallest_positive (cdr lst))]))\n  (list (largest_negative lst) (smallest_positive\
    \ lst)))\n", "  (define (largest_smallest_integers_helper lst largest smallest)\n\
    \    (cond\n      [(empty? lst) (list largest smallest)]\n      [(and (negative?\
    \ (first lst)) (or (not (number? largest)) (&gt; (first lst) largest)))\n    \
    \   (largest_smallest_integers_helper (rest lst) (first lst) smallest)]\n    \
    \  [(and (positive? (first lst)) (or (not (number? smallest)) (&lt; (first lst)\
    \ smallest)))\n       (largest_smallest_integers_helper (rest lst) largest (first\
    \ lst))]\n      [else (largest_smallest_integers_helper (rest lst) largest smallest)]))\n\
    \  (largest_smallest_integers_helper lst #f #f))\n</code>\nI'm not sure if this\
    \ is the best way to do it, but it seems to work.\n\n\nA:\n\nI think you're over-complicating\
    \ things. You can use <code>foldl</code> to iterate over the list and keep track\
    \ of the largest negative and smallest positive numbers. If the list is empty,\
    \ return <code>#f</code> for both values.\n<code>(define (largest-smallest-integers\
    \ lst)\n  (if (empty? lst)\n      (list #f #f)\n      (foldl (lambda (x acc)\n\
    \               (let ((largest (car acc))\n                     (smallest (cadr\
    \ acc)))\n                 (cond\n                   [(negative? x)\n        \
    \            (if (or (not (number? largest))\n                            (&gt;\
    \ x largest))\n                        (list x smallest)\n                   \
    \     acc)]\n                   [(positive? x)\n                    (if (or (not\
    \ (number? smallest))\n                            (&lt; x smallest))\n      \
    \                  (list largest x)\n                        acc)]\n         \
    \          [else acc])))\n             (list #f #f)\n             lst)))\n</code>\n",
  "  (define (largest_smallest_integers_helper lst largest smallest)\n    (cond [(empty?\
    \ lst) (list largest smallest)]\n          [(and (negative? (first lst)) (or (not\
    \ (number? largest)) (&gt; (first lst) largest)))\n           (largest_smallest_integers_helper\
    \ (rest lst) (first lst) smallest)]\n          [(and (positive? (first lst)) (or\
    \ (not (number? smallest)) (&lt; (first lst) smallest)))\n           (largest_smallest_integers_helper\
    \ (rest lst) largest (first lst))]\n          [else (largest_smallest_integers_helper\
    \ (rest lst) largest smallest)]))\n  (largest_smallest_integers_helper lst #f\
    \ #f))\n</code>\nI'm not sure if I'm doing it right, but I'm getting an error:\n\
    <code>largest_smallest_integers.rkt:10:0: largest_smallest_integers_helper: undefined;\n\
    \ cannot reference an identifier before its definition\n</code>\nI'm not sure\
    \ what I'm doing wrong.\n\n\nA:\n\nYou can't define a function inside another\
    \ function in Racket.\nYou can define a function inside a <code>let</code> expression,\
    \ but that's not what you want here.\nYou can define a function inside a <code>letrec</code>\
    \ expression, but that's not what you want here either.\nYou can define a function\
    \ inside a <code>letrec*</code> expression, but that's not what you want here\
    \ either.\nYou can define a function inside a <code>let*</code> expression, but\
    \ that's not what you want here either.\nYou can define a function inside a <code>letrec*</code>\
    \ expression, but that's not what you want here either.\nYou can define a function\
    \ inside a <code>let-values</code> expression, but that's not what you want here\
    \ either.\nYou can define a function inside a <code>let*-values</code> expression,\
    \ but that's not what you want here either.\nYou can define a function inside\
    \ a <code>letrec-values</code> expression, but that's not what", "  (define (largest_smallest_integers_iter\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (positive? (first lst)) (or (not (positive? smallest)) (< (first\
    \ lst) smallest)))\n       (largest_smallest_integers_iter (rest lst) largest\
    \ (first lst))]\n      [(and (negative? (first lst)) (or (not (negative? largest))\
    \ (> (first lst) largest)))\n       (largest_smallest_integers_iter (rest lst)\
    \ (first lst) smallest)]\n      [else (largest_smallest_integers_iter (rest lst)\
    \ largest smallest)]))\n  (largest_smallest_integers_iter lst #f #f))\n", "  (let\
    \ ([negs (filter (lambda (x) (< x 0)) lst)]\n        [pos (filter (lambda (x)\
    \ (> x 0)) lst)])\n    (if (empty? negs)\n        (list #f (min pos))\n      \
    \  (if (empty? pos)\n            (list (max negs) #f)\n            (list (max\
    \ negs) (min pos))))))\n", "  (define (largest_negative_integer lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(and (negative? (first lst))\n            (or\
    \ (not (negative? (second lst)))\n                (empty? (rest lst)))) (first\
    \ lst)]\n      [else (largest_negative_integer (rest lst))]))\n  (define (smallest_positive_integer\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst))\n\
    \            (or (not (positive? (second lst)))\n                (empty? (rest\
    \ lst)))) (first lst)]\n      [else (smallest_positive_integer (rest lst))]))\n\
    \  (list (largest_negative_integer lst)\n        (smallest_positive_integer lst)))\n",
  "  (define (helper lst neg pos)\n    (cond\n      [(empty? lst) (list neg pos)]\n\
    \      [(and (negative? (first lst)) (or (not neg) (&lt; (first lst) neg)))\n\
    \       (helper (rest lst) (first lst) pos)]\n      [(and (positive? (first lst))\
    \ (or (not pos) (&gt; (first lst) pos)))\n       (helper (rest lst) neg (first\
    \ lst))]\n      [else (helper (rest lst) neg pos)]))\n  (helper lst #f #f))\n\
    </code>\n", "  (define (largest_negative lst)\n    (cond\n      [(empty? lst)\
    \ #f]\n      [(negative? (first lst)) (max (first lst) (largest_negative (rest\
    \ lst)))]\n      [else (largest_negative (rest lst))]))\n  (define (smallest_positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(positive? (first lst)) (min\
    \ (first lst) (smallest_positive (rest lst)))]\n      [else (smallest_positive\
    \ (rest lst))]))\n  (list (largest_negative lst) (smallest_positive lst)))\n",
  "  (let ([negs (filter negative? lst)]\n        [pos (filter positive? lst)])\n\
    \    (if (empty? negs)\n        (list #f (min pos))\n        (list (max negs)\
    \ (if (empty? pos) #f (min pos))))))\n", "  (define (largest_smallest_integers_iter\
    \ lst largest smallest)\n    (cond\n      [(null? lst) (list largest smallest)]\n\
    \      [(and (positive? (car lst)) (or (not (positive? smallest)) (< (car lst)\
    \ smallest)))\n       (largest_smallest_integers_iter (cdr lst) largest (car lst))]\n\
    \      [(and (negative? (car lst)) (or (not (negative? largest)) (> (car lst)\
    \ largest)))\n       (largest_smallest_integers_iter (cdr lst) (car lst) smallest)]\n\
    \      [else (largest_smallest_integers_iter (cdr lst) largest smallest)]))\n\
    \  (largest_smallest_integers_iter lst #f #f))\n", "  (define (helper lst neg\
    \ pos)\n    (cond\n      [(empty? lst) (list neg pos)]\n      [(negative? (first\
    \ lst)) (helper (rest lst) (first lst) pos)]\n      [(positive? (first lst)) (helper\
    \ (rest lst) neg (first lst))]\n      [else (helper (rest lst) neg pos)]))\n \
    \ (helper lst #f #f))\n", "  (let ((negatives (filter (lambda (x) (< x 0)) lst))\n\
    \        (positives (filter (lambda (x) (> x 0)) lst)))\n    (list (if (empty?\
    \ negatives) #f (apply max negatives))\n          (if (empty? positives) #f (apply\
    \ min positives)))))\n", "  (define (helper lst neg pos)\n    (cond\n      [(empty?\
    \ lst) (list neg pos)]\n      [(and (negative? (first lst)) (or (not neg) (< (first\
    \ lst) neg)))\n       (helper (rest lst) (first lst) pos)]\n      [(and (positive?\
    \ (first lst)) (or (not pos) (> (first lst) pos)))\n       (helper (rest lst)\
    \ neg (first lst))]\n      [else (helper (rest lst) neg pos)]))\n  (helper lst\
    \ #f #f))\n", "  (define (largest_negative lst)\n    (cond\n      [(null? lst)\
    \ #f]\n      [(and (negative? (car lst)) (not (null? (cdr lst))))\n       (if\
    \ (negative? (car (cdr lst)))\n           (largest_negative (cdr lst))\n     \
    \      (car lst))]\n      [(negative? (car lst)) (car lst)]\n      [else (largest_negative\
    \ (cdr lst))]))\n  (define (smallest_positive lst)\n    (cond\n      [(null? lst)\
    \ #f]\n      [(and (positive? (car lst)) (not (null? (cdr lst))))\n       (if\
    \ (positive? (car (cdr lst)))\n           (smallest_positive (cdr lst))\n    \
    \       (car lst))]\n      [(positive? (car lst)) (car lst)]\n      [else (smallest_positive\
    \ (cdr lst))]))\n  (list (largest_negative lst) (smallest_positive lst)))\n",
  "  (let ([negatives (filter (lambda (x) (< x 0)) lst)]\n        [positives (filter\
    \ (lambda (x) (> x 0)) lst)])\n    (list (if (empty? negatives) #f (apply max\
    \ negatives))\n          (if (empty? positives) #f (apply min positives)))))\n",
  "  (define (helper lst largest smallest)\n    (cond [(empty? lst) (list largest\
    \ smallest)]\n          [(and (negative? (first lst))\n                (or (not\
    \ (number? largest))\n                    (< (first lst) largest)))\n        \
    \   (helper (rest lst) (first lst) smallest)]\n          [(and (positive? (first\
    \ lst))\n                (or (not (number? smallest))\n                    (>\
    \ (first lst) smallest)))\n           (helper (rest lst) largest (first lst))]\n\
    \          [else (helper (rest lst) largest smallest)]))\n  (helper lst #f #f))\n",
  "  (define (largest_negative lst)\n    (cond\n      [(empty? lst) #f]\n      [(negative?\
    \ (first lst)) (max (first lst) (largest_negative (rest lst)))]\n      [else (largest_negative\
    \ (rest lst))]))\n  (define (smallest_positive lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(positive? (first lst)) (min (first lst) (smallest_positive\
    \ (rest lst)))]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (helper lst neg pos)\n    (cond\
    \ [(empty? lst) (list neg pos)]\n          [(negative? (first lst)) (helper (rest\
    \ lst) (first lst) pos)]\n          [(positive? (first lst)) (helper (rest lst)\
    \ neg (first lst))]\n          [else (helper (rest lst) neg pos)]))\n  (helper\
    \ lst #f #f))\n", "  (let ([negatives (filter (lambda (x) (< x 0)) lst)]\n   \
    \     [positives (filter (lambda (x) (> x 0)) lst)])\n    (if (empty? negatives)\n\
    \        (if (empty? positives)\n            (list #f #f)\n            (list #f\
    \ (min positives)))\n        (if (empty? positives)\n            (list (max negatives)\
    \ #f)\n            (list (max negatives) (min positives))))))\n", "  (define (largest_smallest_integers_iter\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (positive? (first lst)) (or (not (positive? smallest)) (&lt; (first\
    \ lst) smallest)))\n       (largest_smallest_integers_iter (rest lst) largest\
    \ (first lst))]\n      [(and (negative? (first lst)) (or (not (negative? largest))\
    \ (&gt; (first lst) largest)))\n       (largest_smallest_integers_iter (rest lst)\
    \ (first lst) smallest)]\n      [else (largest_smallest_integers_iter (rest lst)\
    \ largest smallest)]))\n  (largest_smallest_integers_iter lst #f #f))\n", "  (define\
    \ (largest_negative lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative?\
    \ (first lst)) (not (negative? (second lst)))) (first lst)]\n      [else (largest_negative\
    \ (rest lst))]))\n  (define (smallest_positive lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(and (positive? (first lst)) (not (positive? (second lst))))\
    \ (first lst)]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (largest_smallest_integers_iter\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(< (first lst) 0) (largest_smallest_integers_iter (rest lst) (first lst)\
    \ smallest)]\n      [(> (first lst) 0) (largest_smallest_integers_iter (rest lst)\
    \ largest (first lst))]\n      [else (largest_smallest_integers_iter (rest lst)\
    \ largest smallest)]))\n  (largest_smallest_integers_iter lst #f #f))\n", "  (let\
    \ ([neg-lst (filter (lambda (x) (< x 0)) lst)]\n        [pos-lst (filter (lambda\
    \ (x) (> x 0)) lst)])\n    (if (empty? neg-lst)\n        (list #f (min pos-lst))\n\
    \        (if (empty? pos-lst)\n            (list (max neg-lst) #f)\n         \
    \   (list (max neg-lst) (min pos-lst))))))\n", "  (define (largest_negative lst)\n\
    \    (if (null? lst)\n        #f\n        (if (and (integer? (car lst)) (negative?\
    \ (car lst)))\n            (if (and (integer? (cadr lst)) (negative? (cadr lst)))\n\
    \                (if (< (car lst) (cadr lst))\n                    (largest_negative\
    \ (cdr lst))\n                    (car lst))\n                (car lst))\n   \
    \         (largest_negative (cdr lst)))))\n  (define (smallest_positive lst)\n\
    \    (if (null? lst)\n        #f\n        (if (and (integer? (car lst)) (positive?\
    \ (car lst)))\n            (if (and (integer? (cadr lst)) (positive? (cadr lst)))\n\
    \                (if (< (car lst) (cadr lst))\n                    (car lst)\n\
    \                    (smallest_positive (cdr lst)))\n                (car lst))\n\
    \            (smallest_positive (cdr lst)))))\n  (list (largest_negative lst)\
    \ (smallest_positive lst)))\n", "  (define (largest_negative lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(and (negative? (first lst))\n            (or\
    \ (not (negative? (second lst)))\n                (empty? (rest lst)))) (first\
    \ lst)]\n      [else (largest_negative (rest lst))]))\n  (define (smallest_positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst))\n\
    \            (or (not (positive? (second lst)))\n                (empty? (rest\
    \ lst)))) (first lst)]\n      [else (smallest_positive (rest lst))]))\n  (list\
    \ (largest_negative lst) (smallest_positive lst)))\n", "  (let* ([negative-integers\
    \ (filter (lambda (x) (negative? x)) lst)]\n         [positive-integers (filter\
    \ (lambda (x) (positive? x)) lst)])\n    (list (if (empty? negative-integers)\
    \ #f (apply max negative-integers))\n          (if (empty? positive-integers)\
    \ #f (apply min positive-integers)))))\n", "  (let ([neg (filter (lambda (x) (<\
    \ x 0)) lst)]\n        [pos (filter (lambda (x) (> x 0)) lst)])\n    (if (empty?\
    \ neg)\n        (list #f (min pos))\n        (if (empty? pos)\n            (list\
    \ (max neg) #f)\n            (list (max neg) (min pos))))))\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative? (first lst))\
    \ (not (negative? (first (rest lst))))) (first lst)]\n      [else (largest_negative\
    \ (rest lst))]))\n  (define (smallest_positive lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(and (positive? (first lst)) (not (positive? (first (rest lst)))))\
    \ (first lst)]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (largest_negative lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(and (negative? (first lst)) (not (positive?\
    \ (first lst))))\n       (max (first lst) (largest_negative (rest lst)))]\n  \
    \    [else (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n\
    \    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst)) (not\
    \ (negative? (first lst))))\n       (min (first lst) (smallest_positive (rest\
    \ lst)))]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (helper lst neg pos)\n    (cond\
    \ [(empty? lst) (list neg pos)]\n          [(and (positive? (first lst)) (not\
    \ pos)) (helper (rest lst) neg (first lst))]\n          [(and (negative? (first\
    \ lst)) (not neg)) (helper (rest lst) (first lst) pos)]\n          [(and (positive?\
    \ (first lst)) (< (first lst) pos)) (helper (rest lst) neg (first lst))]\n   \
    \       [(and (negative? (first lst)) (> (first lst) neg)) (helper (rest lst)\
    \ (first lst) pos)]\n          [else (helper (rest lst) neg pos)]))\n  (helper\
    \ lst #f #f))\n", "  (define (largest_negative lst)\n    (cond\n      [(null?\
    \ lst) #f]\n      [(and (negative? (car lst))\n            (or (not (negative?\
    \ (cadr lst)))\n                (negative? (cadr lst))))\n       (largest_negative\
    \ (cdr lst))]\n      [else (car lst)]))\n  (define (smallest_positive lst)\n \
    \   (cond\n      [(null? lst) #f]\n      [(and (positive? (car lst))\n       \
    \     (or (not (positive? (cadr lst)))\n                (positive? (cadr lst))))\n\
    \       (smallest_positive (cdr lst))]\n      [else (car lst)]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (helper lst largest smallest)\n\
    \    (cond\n      [(empty? lst) (list largest smallest)]\n      [(and (positive?\
    \ (first lst)) (or (not (positive? smallest)) (< (first lst) smallest)))\n   \
    \    (helper (rest lst) largest (first lst))]\n      [(and (negative? (first lst))\
    \ (or (not (negative? largest)) (> (first lst) largest)))\n       (helper (rest\
    \ lst) (first lst) smallest)]\n      [else (helper (rest lst) largest smallest)]))\n\
    \  (helper lst #f #f))\n", "  (define (helper lst min max)\n    (cond\n      [(empty?\
    \ lst) (list max min)]\n      [(and (positive? (first lst)) (not min)) (helper\
    \ (rest lst) (first lst) max)]\n      [(and (negative? (first lst)) (not max))\
    \ (helper (rest lst) min (first lst))]\n      [(and (positive? (first lst)) (<\
    \ (first lst) min)) (helper (rest lst) (first lst) max)]\n      [(and (negative?\
    \ (first lst)) (> (first lst) max)) (helper (rest lst) min (first lst))]\n   \
    \   [else (helper (rest lst) min max)]))\n  (helper lst #f #f))\n", "  (define\
    \ (largest-negative lst)\n    (cond\n      [(empty? lst) #f]\n      [(< (first\
    \ lst) 0) (max (first lst) (largest-negative (rest lst)))]\n      [else (largest-negative\
    \ (rest lst))]))\n  (define (smallest-positive lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(> (first lst) 0) (min (first lst) (smallest-positive (rest\
    \ lst)))]\n      [else (smallest-positive (rest lst))]))\n  (list (largest-negative\
    \ lst) (smallest-positive lst)))\n", "  (define (largest_smallest_integers_helper\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (positive? (first lst)) (or (not (positive? smallest)) (< (first\
    \ lst) smallest)))\n       (largest_smallest_integers_helper (rest lst) largest\
    \ (first lst))]\n      [(and (negative? (first lst)) (or (not (negative? largest))\
    \ (> (first lst) largest)))\n       (largest_smallest_integers_helper (rest lst)\
    \ (first lst) smallest)]\n      [else (largest_smallest_integers_helper (rest\
    \ lst) largest smallest)]))\n  (largest_smallest_integers_helper lst #f #f))\n",
  "  (define (helper lst a b)\n    (cond\n      [(empty? lst) (list a b)]\n      [(and\
    \ (negative? (first lst)) (or (not a) (&lt; (first lst) a)))\n       (helper (rest\
    \ lst) (first lst) b)]\n      [(and (positive? (first lst)) (or (not b) (&gt;\
    \ (first lst) b)))\n       (helper (rest lst) a (first lst))]\n      [else (helper\
    \ (rest lst) a b)]))\n  (helper lst #f #f))\n</code>\n", "  (let ([negatives (filter\
    \ (lambda (x) (< x 0)) lst)]\n        [positives (filter (lambda (x) (> x 0))\
    \ lst)])\n    (if (or (empty? negatives) (empty? positives))\n        (list #f\
    \ #f)\n        (list (apply max negatives) (apply min positives)))))\n", "  (define\
    \ (largest_smallest_integers_iter lst largest smallest)\n    (cond [(empty? lst)\
    \ (list largest smallest)]\n          [(and (positive? (first lst)) (or (not (positive?\
    \ smallest)) (&lt; (first lst) smallest)))\n           (largest_smallest_integers_iter\
    \ (rest lst) largest (first lst))]\n          [(and (negative? (first lst)) (or\
    \ (not (negative? largest)) (&gt; (first lst) largest)))\n           (largest_smallest_integers_iter\
    \ (rest lst) (first lst) smallest)]\n          [else (largest_smallest_integers_iter\
    \ (rest lst) largest smallest)]))\n  (largest_smallest_integers_iter lst #f #f))\n\
    </code>\n", "  (let ([neg (filter (lambda (x) (< x 0)) lst)]\n        [pos (filter\
    \ (lambda (x) (> x 0)) lst)])\n    (if (empty? neg)\n        (if (empty? pos)\n\
    \            (list #f #f)\n            (list #f (min pos)))\n        (if (empty?\
    \ pos)\n            (list (max neg) #f)\n            (list (max neg) (min pos))))))\n",
  "  (define (largest_negative lst)\n    (cond\n      [(empty? lst) #f]\n      [(and\
    \ (negative? (first lst)) (not (negative? (second lst)))) (first lst)]\n     \
    \ [else (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n\
    \    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst)) (not\
    \ (positive? (second lst)))) (first lst)]\n      [else (smallest_positive (rest\
    \ lst))]))\n  (list (largest_negative lst) (smallest_positive lst)))\n", "  (define\
    \ (largest_negative lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative?\
    \ (first lst)) (or (not (negative? (second lst))) (empty? (rest lst)))) (first\
    \ lst)]\n      [else (largest_negative (rest lst))]))\n  (define (smallest_positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst))\
    \ (or (not (positive? (second lst))) (empty? (rest lst)))) (first lst)]\n    \
    \  [else (smallest_positive (rest lst))]))\n  (list (largest_negative lst) (smallest_positive\
    \ lst)))\n", "  (define (helper lst neg-max pos-min)\n    (cond\n      [(empty?\
    \ lst) (list neg-max pos-min)]\n      [(and (negative? (first lst)) (or (not neg-max)\
    \ (&gt; (first lst) neg-max)))\n       (helper (rest lst) (first lst) pos-min)]\n\
    \      [(and (positive? (first lst)) (or (not pos-min) (&lt; (first lst) pos-min)))\n\
    \       (helper (rest lst) neg-max (first lst))]\n      [else (helper (rest lst)\
    \ neg-max pos-min)]))\n  (helper lst #f #f))\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative? (first lst))\
    \ (not (negative? (first (rest lst))))) (first lst)]\n      [else (largest_negative\
    \ (rest lst))]))\n  (define (smallest_positive lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(and (positive? (first lst)) (not (positive? (first (rest lst)))))\
    \ (first lst)]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (largest_negative lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(negative? (first lst)) (max (first lst) (largest_negative\
    \ (rest lst)))]\n      [else (largest_negative (rest lst))]))\n  (define (smallest_positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(positive? (first lst)) (min\
    \ (first lst) (smallest_positive (rest lst)))]\n      [else (smallest_positive\
    \ (rest lst))]))\n  (list (largest_negative lst) (smallest_positive lst)))\n",
  "  (define (helper lst max min)\n    (cond\n      [(empty? lst) (list max min)]\n\
    \      [(and (positive? (first lst)) (or (not (positive? min)) (< (first lst)\
    \ min)))\n       (helper (rest lst) max (first lst))]\n      [(and (negative?\
    \ (first lst)) (or (not (negative? max)) (> (first lst) max)))\n       (helper\
    \ (rest lst) (first lst) min)]\n      [else (helper (rest lst) max min)]))\n \
    \ (helper lst #f #f))\n", "  (define (largest_negative_integer lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(and (negative? (first lst)) (not (negative?\
    \ (first (rest lst))))) (first lst)]\n      [else (largest_negative_integer (rest\
    \ lst))]))\n  (define (smallest_positive_integer lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(and (positive? (first lst)) (not (positive? (first (rest lst)))))\
    \ (first lst)]\n      [else (smallest_positive_integer (rest lst))]))\n  (list\
    \ (largest_negative_integer lst) (smallest_positive_integer lst)))\n", "  (define\
    \ (largest_negative lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative?\
    \ (first lst))\n            (or (not (negative? (second lst)))\n             \
    \   (negative? (second lst))))\n       (largest_negative (rest lst))]\n      [else\
    \ (first lst)]))\n  (define (smallest_positive lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(and (positive? (first lst))\n            (or (not (positive?\
    \ (second lst)))\n                (positive? (second lst))))\n       (smallest_positive\
    \ (rest lst))]\n      [else (first lst)]))\n  (list (largest_negative lst) (smallest_positive\
    \ lst)))\n", "  (define (helper lst neg-max pos-min)\n    (cond\n      [(empty?\
    \ lst) (list neg-max pos-min)]\n      [(and (positive? (first lst)) (negative?\
    \ neg-max))\n       (helper (rest lst) neg-max (first lst))]\n      [(and (negative?\
    \ (first lst)) (positive? pos-min))\n       (helper (rest lst) (first lst) pos-min)]\n\
    \      [else (helper (rest lst) neg-max pos-min)]))\n  (helper lst #f #f))\n",
  "  (define (helper lst smallest largest)\n    (cond\n      [(empty? lst) (list largest\
    \ smallest)]\n      [(and (negative? (first lst)) (or (not largest) (&gt; (first\
    \ lst) largest)))\n       (helper (rest lst) smallest (first lst))]\n      [(and\
    \ (positive? (first lst)) (or (not smallest) (&lt; (first lst) smallest)))\n \
    \      (helper (rest lst) (first lst) largest)]\n      [else (helper (rest lst)\
    \ smallest largest)]))\n  (helper lst #f #f))\n</code>\n", "  (define (largest_negative_integer\
    \ lst)\n    (cond ((null? lst) #f)\n          ((and (integer? (car lst)) (< (car\
    \ lst) 0))\n           (max (car lst) (largest_negative_integer (cdr lst))))\n\
    \          (else (largest_negative_integer (cdr lst)))))\n  (define (smallest_positive_integer\
    \ lst)\n    (cond ((null? lst) #f)\n          ((and (integer? (car lst)) (> (car\
    \ lst) 0))\n           (min (car lst) (smallest_positive_integer (cdr lst))))\n\
    \          (else (smallest_positive_integer (cdr lst)))))\n  (list (largest_negative_integer\
    \ lst) (smallest_positive_integer lst)))\n", "  (define (helper lst largest smallest)\n\
    \    (cond\n      [(empty? lst) (list largest smallest)]\n      [(and (positive?\
    \ (first lst)) (not smallest)) (helper (rest lst) largest (first lst))]\n    \
    \  [(and (negative? (first lst)) (not largest)) (helper (rest lst) (first lst)\
    \ smallest)]\n      [(and (positive? (first lst)) (< (first lst) smallest)) (helper\
    \ (rest lst) largest (first lst))]\n      [(and (negative? (first lst)) (> (first\
    \ lst) largest)) (helper (rest lst) (first lst) smallest)]\n      [else (helper\
    \ (rest lst) largest smallest)]))\n  (helper lst #f #f))\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative? (first lst))\
    \ (or (not (negative? (second lst))) (empty? (rest lst)))) (first lst)]\n    \
    \  [else (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n\
    \    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst)) (or (not\
    \ (positive? (second lst))) (empty? (rest lst)))) (first lst)]\n      [else (smallest_positive\
    \ (rest lst))]))\n  (list (largest_negative lst) (smallest_positive lst)))\n",
  "  (let ([neg-lst (filter (lambda (x) (negative? x)) lst)]\n        [pos-lst (filter\
    \ (lambda (x) (positive? x)) lst)])\n    (if (empty? neg-lst)\n        (list #f\
    \ (min pos-lst))\n        (if (empty? pos-lst)\n            (list (max neg-lst)\
    \ #f)\n            (list (max neg-lst) (min pos-lst))))))\n", "  (define (helper\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (positive? (first lst)) (or (not (positive? smallest)) (< (first\
    \ lst) smallest)))\n       (helper (rest lst) largest (first lst))]\n      [(and\
    \ (negative? (first lst)) (or (not (negative? largest)) (> (first lst) largest)))\n\
    \       (helper (rest lst) (first lst) smallest)]\n      [else (helper (rest lst)\
    \ largest smallest)]))\n  (helper lst #f #f))\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative? (first lst))\
    \ (not (negative? (first (rest lst))))) (first lst)]\n      [else (largest_negative\
    \ (rest lst))]))\n  (define (smallest_positive lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(and (positive? (first lst)) (not (positive? (first (rest lst)))))\
    \ (first lst)]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (largest_negative_integer lst)\n\
    \    (cond\n      [(empty? lst) #f]\n      [(and (negative? (first lst))\n   \
    \         (or (not (negative? (second lst)))\n                (empty? (rest lst))))\
    \ (first lst)]\n      [else (largest_negative_integer (rest lst))]))\n  (define\
    \ (smallest_positive_integer lst)\n    (cond\n      [(empty? lst) #f]\n      [(and\
    \ (positive? (first lst))\n            (or (not (positive? (second lst)))\n  \
    \              (empty? (rest lst)))) (first lst)]\n      [else (smallest_positive_integer\
    \ (rest lst))]))\n  (list (largest_negative_integer lst)\n        (smallest_positive_integer\
    \ lst)))\n", "  (define (largest_negative lst)\n    (cond\n      [(empty? lst)\
    \ #f]\n      [(and (negative? (first lst))\n            (or (not (negative? (second\
    \ lst)))\n                (largest_negative (rest lst))))\n       (first lst)]\n\
    \      [else (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n\
    \    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst))\n   \
    \         (or (not (positive? (second lst)))\n                (smallest_positive\
    \ (rest lst))))\n       (first lst)]\n      [else (smallest_positive (rest lst))]))\n\
    \  (list (largest_negative lst) (smallest_positive lst)))\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [(and (negative? (car lst)) (not\
    \ (null? (cdr lst))))\n       (if (negative? (car (cdr lst)))\n           (largest_negative\
    \ (cdr lst))\n           (car lst))]\n      [(negative? (car lst)) (car lst)]\n\
    \      [else (largest_negative (cdr lst))]))\n  (define (smallest_positive lst)\n\
    \    (cond\n      [(null? lst) #f]\n      [(and (positive? (car lst)) (not (null?\
    \ (cdr lst))))\n       (if (positive? (car (cdr lst)))\n           (smallest_positive\
    \ (cdr lst))\n           (car lst))]\n      [(positive? (car lst)) (car lst)]\n\
    \      [else (smallest_positive (cdr lst))]))\n  (list (largest_negative lst)\
    \ (smallest_positive lst)))\n", "  (define (largest_smallest_integers_helper lst\
    \ largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (positive? (first lst)) (or (not (positive? smallest)) (< (first\
    \ lst) smallest)))\n       (largest_smallest_integers_helper (rest lst) largest\
    \ (first lst))]\n      [(and (negative? (first lst)) (or (not (negative? largest))\
    \ (> (first lst) largest)))\n       (largest_smallest_integers_helper (rest lst)\
    \ (first lst) smallest)]\n      [else (largest_smallest_integers_helper (rest\
    \ lst) largest smallest)]))\n  (largest_smallest_integers_helper lst #f #f))\n",
  "  (define (largest_negative lst)\n    (cond\n      [(null? lst) #f]\n      [(and\
    \ (negative? (car lst)) (not (negative? (cadr lst)))) (car lst)]\n      [else\
    \ (largest_negative (cdr lst))]))\n  (define (smallest_positive lst)\n    (cond\n\
    \      [(null? lst) #f]\n      [(and (positive? (car lst)) (not (positive? (cadr\
    \ lst)))) (car lst)]\n      [else (smallest_positive (cdr lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (largest_negative_integer lst)\n\
    \    (cond\n      [(empty? lst) #f]\n      [(and (negative? (first lst))\n   \
    \         (or (not (negative? (second lst)))\n                (negative? (first\
    \ lst))))\n       (largest_negative_integer (cons (first lst) (rest lst)))]\n\
    \      [else (largest_negative_integer (rest lst))]))\n  (define (smallest_positive_integer\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst))\n\
    \            (or (not (positive? (second lst)))\n                (positive? (first\
    \ lst))))\n       (smallest_positive_integer (cons (first lst) (rest lst)))]\n\
    \      [else (smallest_positive_integer (rest lst))]))\n  (list (largest_negative_integer\
    \ lst) (smallest_positive_integer lst)))\n", "  (define (helper lst)\n    (if\
    \ (null? lst)\n        (list #f #f)\n        (let* ([n (car lst)]\n          \
    \     [r (helper (cdr lst))]\n               [a (car r)]\n               [b (cadr\
    \ r)])\n          (cond\n            [(and (integer? n) (positive? n))\n     \
    \        (if (and (integer? b) (positive? b))\n                 (if (< n b)\n\
    \                     (list a n)\n                     (list a b))\n         \
    \        (list a n))]\n            [(and (integer? n) (negative? n))\n       \
    \      (if (and (integer? a) (negative? a))\n                 (if (> n a)\n  \
    \                   (list n b)\n                     (list a b))\n           \
    \      (list n b))]\n            [else (list a b)])\n          )\n        )\n\
    \    )\n  (helper lst)\n  )\n", "  (define (largest_negative lst)\n    (cond ((null?\
    \ lst) #f)\n          ((and (number? (car lst)) (< (car lst) 0))\n           (max\
    \ (car lst) (largest_negative (cdr lst))))\n          (else (largest_negative\
    \ (cdr lst)))))\n  (define (smallest_positive lst)\n    (cond ((null? lst) #f)\n\
    \          ((and (number? (car lst)) (> (car lst) 0))\n           (min (car lst)\
    \ (smallest_positive (cdr lst))))\n          (else (smallest_positive (cdr lst)))))\n\
    \  (list (largest_negative lst) (smallest_positive lst)))\n", "  (define (largest_smallest_integers_iter\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (positive? (first lst)) (or (not (positive? smallest)) (< (first\
    \ lst) smallest)))\n       (largest_smallest_integers_iter (rest lst) largest\
    \ (first lst))]\n      [(and (negative? (first lst)) (or (not (negative? largest))\
    \ (> (first lst) largest)))\n       (largest_smallest_integers_iter (rest lst)\
    \ (first lst) smallest)]\n      [else (largest_smallest_integers_iter (rest lst)\
    \ largest smallest)]))\n  (largest_smallest_integers_iter lst #f #f))\n", "  (define\
    \ (largest_negative lst)\n    (cond ((null? lst) #f)\n          ((and (negative?\
    \ (car lst)) (not (null? (cdr lst))))\n           (if (negative? (car (cdr lst)))\n\
    \               (largest_negative (cdr lst))\n               (car lst)))\n   \
    \       ((negative? (car lst)) (car lst))\n          (else #f)))\n  (define (smallest_positive\
    \ lst)\n    (cond ((null? lst) #f)\n          ((and (positive? (car lst)) (not\
    \ (null? (cdr lst))))\n           (if (positive? (car (cdr lst)))\n          \
    \     (smallest_positive (cdr lst))\n               (car lst)))\n          ((positive?\
    \ (car lst)) (car lst))\n          (else #f)))\n  (list (largest_negative lst)\
    \ (smallest_positive lst)))\n", "  (define (largest_negative lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(and (negative? (first lst)) (not (negative?\
    \ (first (rest lst))))) (first lst)]\n      [else (largest_negative (rest lst))]))\n\
    \  (define (smallest_positive lst)\n    (cond\n      [(empty? lst) #f]\n     \
    \ [(and (positive? (first lst)) (not (positive? (first (rest lst))))) (first lst)]\n\
    \      [else (smallest_positive (rest lst))]))\n  (list (largest_negative lst)\
    \ (smallest_positive lst)))\n", "  (define (largest_negative lst)\n    (cond ((null?\
    \ lst) #f)\n          ((and (negative? (car lst)) (not (negative? (cadr lst))))\
    \ (car lst))\n          (else (largest_negative (cdr lst)))))\n  (define (smallest_positive\
    \ lst)\n    (cond ((null? lst) #f)\n          ((and (positive? (car lst)) (not\
    \ (positive? (cadr lst)))) (car lst))\n          (else (smallest_positive (cdr\
    \ lst)))))\n  (list (largest_negative lst) (smallest_positive lst)))\n", "  (define\
    \ (largest_negative lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative?\
    \ (first lst))\n            (or (not (negative? (second lst)))\n             \
    \   (negative? (first lst))\n                (positive? (second lst))))\n    \
    \   (first lst)]\n      [else (largest_negative (rest lst))]))\n  (define (smallest_positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst))\n\
    \            (or (not (positive? (second lst)))\n                (positive? (first\
    \ lst))\n                (negative? (second lst))))\n       (first lst)]\n   \
    \   [else (smallest_positive (rest lst))]))\n  (list (largest_negative lst) (smallest_positive\
    \ lst)))\n", "  (let ([negatives (filter (lambda (x) (< x 0)) lst)]\n        [positives\
    \ (filter (lambda (x) (> x 0)) lst)])\n    (list (if (empty? negatives) #f (apply\
    \ max negatives))\n          (if (empty? positives) #f (apply min positives)))))\n",
  "  (define (largest_smallest_integers_helper lst largest smallest)\n    (cond\n\
    \      [(empty? lst) (list largest smallest)]\n      [(and (positive? (first lst))\
    \ (not smallest))\n       (largest_smallest_integers_helper (rest lst) largest\
    \ (first lst))]\n      [(and (negative? (first lst)) (not largest))\n       (largest_smallest_integers_helper\
    \ (rest lst) (first lst) smallest)]\n      [(and (positive? (first lst)) (< (first\
    \ lst) smallest))\n       (largest_smallest_integers_helper (rest lst) largest\
    \ (first lst))]\n      [(and (negative? (first lst)) (> (first lst) largest))\n\
    \       (largest_smallest_integers_helper (rest lst) (first lst) smallest)]\n\
    \      [else (largest_smallest_integers_helper (rest lst) largest smallest)]))\n\
    \  (largest_smallest_integers_helper lst #f #f))\n", "  (define (helper lst max\
    \ min)\n    (cond\n      [(empty? lst) (list max min)]\n      [(and (positive?\
    \ (first lst)) (not min)) (helper (rest lst) max (first lst))]\n      [(and (negative?\
    \ (first lst)) (not max)) (helper (rest lst) (first lst) min)]\n      [(and (positive?\
    \ (first lst)) (< (first lst) min)) (helper (rest lst) max (first lst))]\n   \
    \   [(and (negative? (first lst)) (> (first lst) max)) (helper (rest lst) (first\
    \ lst) min)]\n      [else (helper (rest lst) max min)]))\n  (helper lst #f #f))\n",
  "  (define (helper lst largest smallest)\n    (cond\n      [(empty? lst) (list largest\
    \ smallest)]\n      [(and (positive? (first lst)) (or (not (positive? smallest))\
    \ (< (first lst) smallest)))\n       (helper (rest lst) largest (first lst))]\n\
    \      [(and (negative? (first lst)) (or (not (negative? largest)) (> (first lst)\
    \ largest)))\n       (helper (rest lst) (first lst) smallest)]\n      [else (helper\
    \ (rest lst) largest smallest)]))\n  (helper lst #f #f))\n", "  (define (helper\
    \ lst min max)\n    (cond\n      [(empty? lst) (list max min)]\n      [(and (positive?\
    \ (first lst)) (not min)) (helper (rest lst) (first lst) max)]\n      [(and (negative?\
    \ (first lst)) (not max)) (helper (rest lst) min (first lst))]\n      [(and (positive?\
    \ (first lst)) (< (first lst) min)) (helper (rest lst) (first lst) max)]\n   \
    \   [(and (negative? (first lst)) (> (first lst) max)) (helper (rest lst) min\
    \ (first lst))]\n      [else (helper (rest lst) min max)]))\n  (helper lst #f\
    \ #f))\n", "  (define (helper lst acc)\n    (cond\n      [(empty? lst) acc]\n\
    \      [(and (positive? (first lst)) (not (positive? (second lst))))\n       (helper\
    \ (rest lst) (cons (first lst) acc))]\n      [(and (negative? (first lst)) (not\
    \ (negative? (second lst))))\n       (helper (rest lst) (cons (first lst) acc))]\n\
    \      [else (helper (rest lst) acc)]))\n  (define (helper2 lst acc)\n    (cond\n\
    \      [(empty? lst) acc]\n      [(and (positive? (first lst)) (not (positive?\
    \ (second lst))))\n       (helper2 (rest lst) (cons (first lst) acc))]\n     \
    \ [(and (negative? (first lst)) (not (negative? (second lst))))\n       (helper2\
    \ (rest lst) (cons (first lst) acc))]\n      [else (helper2 (rest lst) acc)]))\n\
    \  (list (first (helper lst '())) (first (helper2 lst '()))))\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative? (first lst))\
    \ (not (negative? (first (rest lst))))) (first lst)]\n      [else (largest_negative\
    \ (rest lst))]))\n  (define (smallest_positive lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(and (positive? (first lst)) (not (positive? (first (rest lst)))))\
    \ (first lst)]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (helper lst)\n    (cond\n    \
    \  [(empty? lst) (list #f #f)]\n      [(and (positive? (first lst)) (negative?\
    \ (second lst)))\n       (list (second lst) (first lst))]\n      [(and (negative?\
    \ (first lst)) (positive? (second lst)))\n       (list (first lst) (second lst))]\n\
    \      [else (helper (rest lst))]))\n  (helper lst))\n", "  (define (helper lst\
    \ largest smallest)\n    (cond\n      [(null? lst) (list largest smallest)]\n\
    \      [(and (not (integer? (car lst))) (not (integer? (cdr lst)))) (list #f #f)]\n\
    \      [(and (not (integer? (car lst))) (integer? (cdr lst))) (helper (cdr lst)\
    \ largest (car lst))]\n      [(and (integer? (car lst)) (not (integer? (cdr lst))))\
    \ (helper (cdr lst) (car lst) smallest)]\n      [(and (integer? (car lst)) (integer?\
    \ (cdr lst))) (helper (cdr lst) (car lst) smallest)]))\n  (helper lst #f #f))\n",
  "  (define (is-positive? n)\n    (and (integer? n) (> n 0)))\n  (define (is-negative?\
    \ n)\n    (and (integer? n) (< n 0)))\n  (define (largest-negative lst)\n    (cond\n\
    \      [(null? lst) #f]\n      [(is-negative? (car lst)) (max (car lst) (largest-negative\
    \ (cdr lst)))]\n      [else (largest-negative (cdr lst))]))\n  (define (smallest-positive\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [(is-positive? (car lst)) (min\
    \ (car lst) (smallest-positive (cdr lst)))]\n      [else (smallest-positive (cdr\
    \ lst))]))\n  (list (largest-negative lst) (smallest-positive lst)))\n", "  (define\
    \ (largest_smallest_integers_helper lst largest smallest)\n    (cond\n      [(empty?\
    \ lst) (list largest smallest)]\n      [(and (positive? (first lst)) (or (not\
    \ (positive? smallest)) (< (first lst) smallest)))\n       (largest_smallest_integers_helper\
    \ (rest lst) largest (first lst))]\n      [(and (negative? (first lst)) (or (not\
    \ (negative? largest)) (> (first lst) largest)))\n       (largest_smallest_integers_helper\
    \ (rest lst) (first lst) smallest)]\n      [else (largest_smallest_integers_helper\
    \ (rest lst) largest smallest)]))\n  (largest_smallest_integers_helper lst #f\
    \ #f))\n", "  (define (largest_smallest_integers_iter lst largest smallest)\n\
    \    (cond\n      [(empty? lst) (list largest smallest)]\n      [(< (first lst)\
    \ 0)\n       (largest_smallest_integers_iter (rest lst) (first lst) smallest)]\n\
    \      [(> (first lst) 0)\n       (largest_smallest_integers_iter (rest lst) largest\
    \ (first lst))]\n      [else (largest_smallest_integers_iter (rest lst) largest\
    \ smallest)]))\n  (largest_smallest_integers_iter lst #f #f))\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative? (first lst))\
    \ (not (negative? (first (rest lst))))) (first lst)]\n      [else (largest_negative\
    \ (rest lst))]))\n  (define (smallest_positive lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(and (positive? (first lst)) (not (positive? (first (rest lst)))))\
    \ (first lst)]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (let ([negatives (filter (lambda (x) (<\
    \ x 0)) lst)]\n        [positives (filter (lambda (x) (> x 0)) lst)])\n    (if\
    \ (empty? negatives)\n        (list #f (min positives))\n        (if (empty? positives)\n\
    \            (list (max negatives) #f)\n            (list (max negatives) (min\
    \ positives))))))\n", "  (define (helper lst max min)\n    (cond [(empty? lst)\
    \ (list max min)]\n          [(and (negative? (first lst)) (or (not max) (&gt;\
    \ (first lst) max)))\n           (helper (rest lst) (first lst) min)]\n      \
    \    [(and (positive? (first lst)) (or (not min) (&lt; (first lst) min)))\n  \
    \         (helper (rest lst) max (first lst))]\n          [else (helper (rest\
    \ lst) max min)]))\n  (helper lst #f #f))\n", "  (define (largest_negative_integer\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative? (first lst))\n\
    \            (or (not (negative? (second lst)))\n                (largest_negative_integer\
    \ (rest lst))))\n       (first lst)]\n      [else (largest_negative_integer (rest\
    \ lst))]))\n  (define (smallest_positive_integer lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(and (positive? (first lst))\n            (or (not (positive?\
    \ (second lst)))\n                (smallest_positive_integer (rest lst))))\n \
    \      (first lst)]\n      [else (smallest_positive_integer (rest lst))]))\n \
    \ (list (largest_negative_integer lst)\n        (smallest_positive_integer lst)))\n",
  "  (define (helper lst largest smallest)\n    (cond\n      [(null? lst) (list largest\
    \ smallest)]\n      [(and (positive? (car lst)) (or (not (positive? smallest))\
    \ (< (car lst) smallest)))\n       (helper (cdr lst) largest (car lst))]\n   \
    \   [(and (negative? (car lst)) (or (not (negative? largest)) (> (car lst) largest)))\n\
    \       (helper (cdr lst) (car lst) smallest)]\n      [else (helper (cdr lst)\
    \ largest smallest)]))\n  (helper lst #f #f))\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [(and (negative? (car lst)) (or\
    \ (null? (cdr lst)) (positive? (cadr lst)))) (car lst)]\n      [else (largest_negative\
    \ (cdr lst))]))\n  (define (smallest_positive lst)\n    (cond\n      [(null? lst)\
    \ #f]\n      [(and (positive? (car lst)) (or (null? (cdr lst)) (negative? (cadr\
    \ lst)))) (car lst)]\n      [else (smallest_positive (cdr lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (find-largest-negative lst)\n\
    \    (cond\n      [(null? lst) #f]\n      [(and (number? (car lst))\n        \
    \    (negative? (car lst)))\n       (max (car lst) (find-largest-negative (cdr\
    \ lst)))]\n      [else (find-largest-negative (cdr lst))]))\n  (define (find-smallest-positive\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [(and (number? (car lst))\n \
    \           (positive? (car lst)))\n       (min (car lst) (find-smallest-positive\
    \ (cdr lst)))]\n      [else (find-smallest-positive (cdr lst))]))\n  (list (find-largest-negative\
    \ lst)\n        (find-smallest-positive lst)))\n", "  (let ([negatives (filter\
    \ negative? lst)]\n        [positives (filter positive? lst)])\n    (if (empty?\
    \ negatives)\n        (list #f (min positives))\n        (if (empty? positives)\n\
    \            (list (max negatives) #f)\n            (list (max negatives) (min\
    \ positives))))))\n", "  (define (find-largest-negative lst)\n    (cond\n    \
    \  [(empty? lst) #f]\n      [(and (negative? (first lst)) (not (negative? (second\
    \ lst)))) (first lst)]\n      [else (find-largest-negative (rest lst))]))\n  (define\
    \ (find-smallest-positive lst)\n    (cond\n      [(empty? lst) #f]\n      [(and\
    \ (positive? (first lst)) (not (positive? (second lst)))) (first lst)]\n     \
    \ [else (find-smallest-positive (rest lst))]))\n  (list (find-largest-negative\
    \ lst) (find-smallest-positive lst)))\n", "  (define (largest_smallest_integers_helper\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (negative? (first lst)) (or (not (number? largest)) (&gt; (first\
    \ lst) largest)))\n       (largest_smallest_integers_helper (rest lst) (first\
    \ lst) smallest)]\n      [(and (positive? (first lst)) (or (not (number? smallest))\
    \ (&lt; (first lst) smallest)))\n       (largest_smallest_integers_helper (rest\
    \ lst) largest (first lst))]\n      [else (largest_smallest_integers_helper (rest\
    \ lst) largest smallest)]))\n  (largest_smallest_integers_helper lst #f #f))\n\
    </code>\n", "  (let ([negs (filter (lambda (x) (negative? x)) lst)]\n        [pos\
    \ (filter (lambda (x) (positive? x)) lst)])\n    (if (empty? negs)\n        (list\
    \ #f (min pos))\n        (list (max negs) (if (empty? pos) #f (min pos))))))\n",
  "  (define (largest_negative lst)\n    (cond\n      [(empty? lst) #f]\n      [(and\
    \ (negative? (first lst))\n            (or (not (negative? (first (rest lst))))\n\
    \                (not (negative? (first (rest (rest lst)))))))\n       (first\
    \ lst)]\n      [else (largest_negative (rest lst))]))\n  (define (smallest_positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst))\n\
    \            (or (not (positive? (first (rest lst))))\n                (not (positive?\
    \ (first (rest (rest lst)))))))\n       (first lst)]\n      [else (smallest_positive\
    \ (rest lst))]))\n  (list (largest_negative lst) (smallest_positive lst)))\n",
  "  (define (helper lst)\n    (cond\n      [(empty? lst) (list #f #f)]\n      [(and\
    \ (positive? (first lst)) (negative? (second lst))) (list (second lst) (first\
    \ lst))]\n      [(and (negative? (first lst)) (positive? (second lst))) (list\
    \ (first lst) (second lst))]\n      [(and (positive? (first lst)) (positive? (second\
    \ lst))) (list #f (first lst))]\n      [(and (negative? (first lst)) (negative?\
    \ (second lst))) (list (first lst) #f)]\n      [(and (positive? (first lst)) (zero?\
    \ (second lst))) (list #f (first lst))]\n      [(and (negative? (first lst)) (zero?\
    \ (second lst))) (list (first lst) #f)]\n      [(and (zero? (first lst)) (positive?\
    \ (second lst))) (list #f (second lst))]\n      [(and (zero? (first lst)) (negative?\
    \ (second lst))) (list (second lst) #f)]\n      [(and (zero? (first lst)) (zero?\
    \ (second lst))) (list #f #f)]))\n  (helper lst))\n", "  (define (largest_smallest_integers_iter\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (negative? (first lst)) (or (not largest) (&gt; (first lst) largest)))\n\
    \       (largest_smallest_integers_iter (rest lst) (first lst) smallest)]\n  \
    \    [(and (positive? (first lst)) (or (not smallest) (&lt; (first lst) smallest)))\n\
    \       (largest_smallest_integers_iter (rest lst) largest (first lst))]\n   \
    \   [else (largest_smallest_integers_iter (rest lst) largest smallest)]))\n  (largest_smallest_integers_iter\
    \ lst #f #f))\n</code>\n", "  (define (helper lst largest smallest)\n    (cond\
    \ [(empty? lst) (list largest smallest)]\n          [(and (positive? (first lst))\
    \ (or (not (positive? smallest)) (< (first lst) smallest)))\n           (helper\
    \ (rest lst) largest (first lst))]\n          [(and (negative? (first lst)) (or\
    \ (not (negative? largest)) (> (first lst) largest)))\n           (helper (rest\
    \ lst) (first lst) smallest)]\n          [else (helper (rest lst) largest smallest)]))\n\
    \  (helper lst #f #f))\n", "  (define (largest_smallest_helper lst largest smallest)\n\
    \    (cond [(empty? lst) (list largest smallest)]\n          [(and (negative?\
    \ (first lst)) (or (not (number? largest)) (&gt; (first lst) largest)))\n    \
    \       (largest_smallest_helper (rest lst) (first lst) smallest)]\n         \
    \ [(and (positive? (first lst)) (or (not (number? smallest)) (&lt; (first lst)\
    \ smallest)))\n           (largest_smallest_helper (rest lst) largest (first lst))]\n\
    \          [else (largest_smallest_helper (rest lst) largest smallest)]))\n  (largest_smallest_helper\
    \ lst #f #f))\n</code>\n", "  (define (helper lst neg pos)\n    (cond\n      [(empty?\
    \ lst) (list neg pos)]\n      [(and (negative? (first lst))\n            (or (not\
    \ neg) (< (first lst) neg)))\n       (helper (rest lst) (first lst) pos)]\n  \
    \    [(and (positive? (first lst))\n            (or (not pos) (> (first lst) pos)))\n\
    \       (helper (rest lst) neg (first lst))]\n      [else (helper (rest lst) neg\
    \ pos)]))\n  (helper lst #f #f))\n", "  (define (largest_smallest_integers_helper\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (negative? (first lst)) (or (not (number? largest)) (&gt; (first\
    \ lst) largest)))\n       (largest_smallest_integers_helper (rest lst) (first\
    \ lst) smallest)]\n      [(and (positive? (first lst)) (or (not (number? smallest))\
    \ (&lt; (first lst) smallest)))\n       (largest_smallest_integers_helper (rest\
    \ lst) largest (first lst))]\n      [else (largest_smallest_integers_helper (rest\
    \ lst) largest smallest)]))\n  (largest_smallest_integers_helper lst #f #f))\n\
    </code>\n", "  (define (largest_negative lst)\n    (cond\n      [(empty? lst)\
    \ #f]\n      [(< (first lst) 0) (max (first lst) (largest_negative (rest lst)))]\n\
    \      [else (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n\
    \    (cond\n      [(empty? lst) #f]\n      [(> (first lst) 0) (min (first lst)\
    \ (smallest_positive (rest lst)))]\n      [else (smallest_positive (rest lst))]))\n\
    \  (list (largest_negative lst) (smallest_positive lst)))\n", "  (define (helper\
    \ lst a b)\n    (cond\n      [(empty? lst) (list a b)]\n      [(and (positive?\
    \ (first lst)) (or (not b) (< (first lst) b)))\n       (helper (rest lst) a (first\
    \ lst))]\n      [(and (negative? (first lst)) (or (not a) (> (first lst) a)))\n\
    \       (helper (rest lst) (first lst) b)]\n      [else (helper (rest lst) a b)]))\n\
    \  (helper lst #f #f))\n", "  (define (helper lst largest smallest)\n    (cond\n\
    \      [(empty? lst) (list largest smallest)]\n      [(positive? (first lst))\n\
    \       (if (or (negative? smallest)\n               (< (first lst) smallest))\n\
    \           (helper (rest lst) largest (first lst))\n           (helper (rest\
    \ lst) largest smallest))]\n      [(negative? (first lst))\n       (if (or (positive?\
    \ largest)\n               (> (first lst) largest))\n           (helper (rest\
    \ lst) (first lst) smallest)\n           (helper (rest lst) largest smallest))]\n\
    \      [else (helper (rest lst) largest smallest)]))\n  (helper lst #f #f))\n",
  "  (let ([negs (filter (lambda (x) (< x 0)) lst)]\n        [pos (filter (lambda\
    \ (x) (> x 0)) lst)])\n    (if (empty? negs)\n        (list #f (min pos))\n  \
    \      (if (empty? pos)\n            (list (max negs) #f)\n            (list (max\
    \ negs) (min pos))))))\n", "  (define (largest_negative lst)\n    (cond\n    \
    \  [(null? lst) #f]\n      [(and (negative? (car lst)) (not (null? (cdr lst))))\n\
    \       (max (car lst) (largest_negative (cdr lst)))]\n      [(negative? (car\
    \ lst)) (car lst)]\n      [else (largest_negative (cdr lst))]))\n  (define (smallest_positive\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [(and (positive? (car lst)) (not\
    \ (null? (cdr lst))))\n       (min (car lst) (smallest_positive (cdr lst)))]\n\
    \      [(positive? (car lst)) (car lst)]\n      [else (smallest_positive (cdr\
    \ lst))]))\n  (list (largest_negative lst) (smallest_positive lst)))\n", "  (cond\
    \ [(empty? lst) (list #f #f)]\n        [(and (positive? (first lst)) (negative?\
    \ (first lst))) (list #f #f)]\n        [(positive? (first lst)) (list #f (first\
    \ lst))]\n        [(negative? (first lst)) (list (first lst) #f)]))\n", "  (define\
    \ (largest_smallest_integers_helper lst largest smallest)\n    (cond ((null? lst)\
    \ (list largest smallest))\n          ((and (positive? (car lst)) (or (not (positive?\
    \ smallest)) (< (car lst) smallest)))\n           (largest_smallest_integers_helper\
    \ (cdr lst) largest (car lst)))\n          ((and (negative? (car lst)) (or (not\
    \ (negative? largest)) (> (car lst) largest)))\n           (largest_smallest_integers_helper\
    \ (cdr lst) (car lst) smallest))\n          (else (largest_smallest_integers_helper\
    \ (cdr lst) largest smallest))))\n  (largest_smallest_integers_helper lst #f #f))\n",
  "  (define (largest_smallest_integers_iter lst largest smallest)\n    (cond\n  \
    \    [(empty? lst) (list largest smallest)]\n      [(and (positive? (first lst))\
    \ (not smallest))\n       (largest_smallest_integers_iter (rest lst) largest (first\
    \ lst))]\n      [(and (negative? (first lst)) (not largest))\n       (largest_smallest_integers_iter\
    \ (rest lst) (first lst) smallest)]\n      [(and (positive? (first lst)) (< (first\
    \ lst) smallest))\n       (largest_smallest_integers_iter (rest lst) largest (first\
    \ lst))]\n      [(and (negative? (first lst)) (> (first lst) largest))\n     \
    \  (largest_smallest_integers_iter (rest lst) (first lst) smallest)]\n      [else\
    \ (largest_smallest_integers_iter (rest lst) largest smallest)]))\n  (largest_smallest_integers_iter\
    \ lst #f #f))\n", "  (define (largest_negative lst)\n    (cond\n      [(null?\
    \ lst) #f]\n      [(and (negative? (car lst)) (not (null? (cdr lst))))\n     \
    \  (if (negative? (cadr lst))\n           (largest_negative (cdr lst))\n     \
    \      (car lst))]\n      [(negative? (car lst)) (car lst)]\n      [else (largest_negative\
    \ (cdr lst))]))\n  (define (smallest_positive lst)\n    (cond\n      [(null? lst)\
    \ #f]\n      [(and (positive? (car lst)) (not (null? (cdr lst))))\n       (if\
    \ (positive? (cadr lst))\n           (smallest_positive (cdr lst))\n         \
    \  (car lst))]\n      [(positive? (car lst)) (car lst)]\n      [else (smallest_positive\
    \ (cdr lst))]))\n  (list (largest_negative lst) (smallest_positive lst)))\n",
  "  (define (helper lst neg pos)\n    (cond\n      [(empty? lst) (list neg pos)]\n\
    \      [(and (not (negative? (first lst))) (not (positive? (first lst)))) (helper\
    \ (rest lst) neg pos)]\n      [(negative? (first lst)) (helper (rest lst) (first\
    \ lst) pos)]\n      [(positive? (first lst)) (helper (rest lst) neg (first lst))]))\n\
    \  (helper lst #f #f))\n", "  (define (largest_smallest_integers_iter lst largest\
    \ smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n      [(and\
    \ (negative? (first lst)) (or (not largest) (&gt; (first lst) largest)))\n   \
    \    (largest_smallest_integers_iter (rest lst) (first lst) smallest)]\n     \
    \ [(and (positive? (first lst)) (or (not smallest) (&lt; (first lst) smallest)))\n\
    \       (largest_smallest_integers_iter (rest lst) largest (first lst))]\n   \
    \   [else (largest_smallest_integers_iter (rest lst) largest smallest)]))\n  (largest_smallest_integers_iter\
    \ lst #f #f))\n</code>\n", "  (define (largest_negative lst)\n    (cond\n    \
    \  [(empty? lst) #f]\n      [(and (negative? (first lst)) (not (negative? (first\
    \ (rest lst))))) (first lst)]\n      [else (largest_negative (rest lst))]))\n\
    \  (define (smallest_positive lst)\n    (cond\n      [(empty? lst) #f]\n     \
    \ [(and (positive? (first lst)) (not (positive? (first (rest lst))))) (first lst)]\n\
    \      [else (smallest_positive (rest lst))]))\n  (list (largest_negative lst)\
    \ (smallest_positive lst)))\n", "  (define (find-largest-negative lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(and (negative? (first lst))\n            (not\
    \ (negative? (second lst)))) (first lst)]\n      [else (find-largest-negative\
    \ (rest lst))]))\n  (define (find-smallest-positive lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(and (positive? (first lst))\n            (not (positive? (second\
    \ lst)))) (first lst)]\n      [else (find-smallest-positive (rest lst))]))\n \
    \ (list (find-largest-negative lst) (find-smallest-positive lst)))\n", "  (define\
    \ (helper lst max min)\n    (cond\n      [(empty? lst) (list max min)]\n     \
    \ [(and (positive? (first lst)) (or (not (positive? min)) (< (first lst) min)))\n\
    \       (helper (rest lst) max (first lst))]\n      [(and (negative? (first lst))\
    \ (or (not (negative? max)) (> (first lst) max)))\n       (helper (rest lst) (first\
    \ lst) min)]\n      [else (helper (rest lst) max min)]))\n  (helper lst #f #f))\n",
  "  (let ([negs (filter (lambda (x) (< x 0)) lst)]\n        [pos (filter (lambda\
    \ (x) (> x 0)) lst)])\n    (if (null? negs)\n        (list #f (apply min pos))\n\
    \        (if (null? pos)\n            (list (apply max negs) #f)\n           \
    \ (list (apply max negs) (apply min pos))))))\n", "  (define (helper lst neg-max\
    \ pos-min)\n    (cond\n      [(empty? lst) (list neg-max pos-min)]\n      [(and\
    \ (negative? (first lst)) (or (not neg-max) (&gt; (first lst) neg-max)))\n   \
    \    (helper (rest lst) (first lst) pos-min)]\n      [(and (positive? (first lst))\
    \ (or (not pos-min) (&lt; (first lst) pos-min)))\n       (helper (rest lst) neg-max\
    \ (first lst))]\n      [else (helper (rest lst) neg-max pos-min)]))\n  (helper\
    \ lst #f #f))\n", "  (define (helper lst largest smallest)\n    (cond\n      [(empty?\
    \ lst) (list largest smallest)]\n      [(and (negative? (first lst))\n       \
    \     (or (not (number? largest))\n                (&lt; (first lst) largest)))\n\
    \       (helper (rest lst) (first lst) smallest)]\n      [(and (positive? (first\
    \ lst))\n            (or (not (number? smallest))\n                (&gt; (first\
    \ lst) smallest)))\n       (helper (rest lst) largest (first lst))]\n      [else\
    \ (helper (rest lst) largest smallest)]))\n  (helper lst #f #f))\n</code>\n",
  "  (define (largest_smallest_helper lst largest smallest)\n    (cond\n      [(empty?\
    \ lst) (list largest smallest)]\n      [(and (negative? (first lst)) (or (not\
    \ largest) (&gt; (first lst) largest)))\n       (largest_smallest_helper (rest\
    \ lst) (first lst) smallest)]\n      [(and (positive? (first lst)) (or (not smallest)\
    \ (&lt; (first lst) smallest)))\n       (largest_smallest_helper (rest lst) largest\
    \ (first lst))]\n      [else (largest_smallest_helper (rest lst) largest smallest)]))\n\
    \  (largest_smallest_helper lst #f #f))\n</code>\nI'm not sure if I'm doing it\
    \ right, but I'm getting the following error:\n<code>largest_smallest_integers.rkt:14:6:\
    \ largest_smallest_integers: undefined;\n cannot reference an identifier before\
    \ its definition\n</code>\nI'm not sure what I'm doing wrong.\n\n\nA:\n\nYou're\
    \ missing the <code>define</code> keyword before the function name. It should\
    \ be:\n<code>(define (largest_smallest_integers lst)\n  ...)\n</code>\n", "  (define\
    \ (is-negative? n)\n    (and (number? n) (< n 0)))\n  (define (is-positive? n)\n\
    \    (and (number? n) (> n 0)))\n  (define (is-zero? n)\n    (and (number? n)\
    \ (= n 0)))\n  (define (is-integer? n)\n    (and (number? n) (integer? n)))\n\
    \  (define (is-non-zero-integer? n)\n    (and (is-integer? n) (not (is-zero? n))))\n\
    \  (define (is-non-zero-integer-list? lst)\n    (and (list? lst)\n         (for/and\
    \ ([n lst]) (is-non-zero-integer? n))))\n  (define (is-non-zero-integer-list-with-zero?\
    \ lst)\n    (and (list? lst)\n         (for/and ([n lst]) (or (is-non-zero-integer?\
    \ n) (is-zero? n)))))\n  (define (is-non-zero-integer-list-with-zero-and-non-integer?\
    \ lst)\n    (and (list? lst)\n         (for/and ([n lst]) (or (is-non-zero-integer?\
    \ n) (is-zero? n) (not (is-integer? n))))))\n  (define (is-non-zero-integer-list-with-zero-and-non-integer-and-non-number?\
    \ lst)\n    (and (list? lst)\n         (for/and ([n lst]) (or (is-non-zero-integer?\
    \ n) (is-zero? n) (not (is-integer? n)) (not (number? n))))))\n  (define (is-non-zero-integer-list-with-zero-and-non-integer-and-non-number-and-non-list?\
    \ lst)\n    (and (list? lst)\n         (for/and ([n lst]) (or (is-non-zero-integer?\
    \ n) (is-zero? n) (not (is-integer? n)) (not (number?", "  (cond\n    [(empty?\
    \ lst) (list #f #f)]\n    [(and (positive? (first lst)) (negative? (first lst)))\
    \ (list #f #f)]\n    [(positive? (first lst)) (list #f (first lst))]\n    [(negative?\
    \ (first lst)) (list (first lst) #f)]\n    [else (list #f #f)]))\n", "  (define\
    \ (largest_negative lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative?\
    \ (first lst)) (not (negative? (second lst)))) (first lst)]\n      [else (largest_negative\
    \ (rest lst))]))\n  (define (smallest_positive lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(and (positive? (first lst)) (not (positive? (second lst))))\
    \ (first lst)]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (cond\n    [(empty? lst) (list #f #f)]\n\
    \    [(and (positive? (first lst)) (negative? (first lst))) (list #f #f)]\n  \
    \  [(positive? (first lst)) (list (first lst) (first lst))]\n    [(negative? (first\
    \ lst)) (list (first lst) (first lst))]\n    [else (largest_smallest_integers\
    \ (rest lst))]))\n", "  (if (empty? lst)\n      (list #f #f)\n      (let ([negatives\
    \ (filter (lambda (x) (&lt; x 0)) lst)]\n            [positives (filter (lambda\
    \ (x) (&gt; x 0)) lst)])\n        (list (if (empty? negatives)\n             \
    \     #f\n                  (apply max negatives))\n              (if (empty?\
    \ positives)\n                  #f\n                  (apply min positives))))))\n\
    </code>\n", "  (define (loop lst largest smallest)\n    (cond [(empty? lst) (list\
    \ largest smallest)]\n          [(and (negative? (first lst)) (or (not (number?\
    \ largest)) (> (first lst) largest)))\n           (loop (rest lst) (first lst)\
    \ smallest)]\n          [(and (positive? (first lst)) (or (not (number? smallest))\
    \ (< (first lst) smallest)))\n           (loop (rest lst) largest (first lst))]\n\
    \          [else (loop (rest lst) largest smallest)]))\n  (loop lst #f #f))\n",
  "  (define (largest_smallest_integers_iter lst max min)\n    (cond\n      [(empty?\
    \ lst) (list max min)]\n      [(and (positive? (first lst)) (or (not (positive?\
    \ min)) (< (first lst) min)))\n       (largest_smallest_integers_iter (rest lst)\
    \ max (first lst))]\n      [(and (negative? (first lst)) (or (not (negative? max))\
    \ (> (first lst) max)))\n       (largest_smallest_integers_iter (rest lst) (first\
    \ lst) min)]\n      [else (largest_smallest_integers_iter (rest lst) max min)]))\n\
    \  (largest_smallest_integers_iter lst #f #f))\n", "  (define (helper lst largest\
    \ smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n      [(and\
    \ (positive? (first lst)) (or (not (positive? smallest)) (< (first lst) smallest)))\n\
    \       (helper (rest lst) largest (first lst))]\n      [(and (negative? (first\
    \ lst)) (or (not (negative? largest)) (> (first lst) largest)))\n       (helper\
    \ (rest lst) (first lst) smallest)]\n      [else (helper (rest lst) largest smallest)]))\n\
    \  (helper lst #f #f))\n", "  (define (largest_negative lst)\n    (cond [(null?\
    \ lst) #f]\n          [(and (negative? (car lst))\n                (or (not (negative?\
    \ (cadr lst)))\n                    (> (car lst) (cadr lst))))\n           (car\
    \ lst)]\n          [else (largest_negative (cdr lst))]))\n  (define (smallest_positive\
    \ lst)\n    (cond [(null? lst) #f]\n          [(and (positive? (car lst))\n  \
    \              (or (not (positive? (cadr lst)))\n                    (< (car lst)\
    \ (cadr lst))))\n           (car lst)]\n          [else (smallest_positive (cdr\
    \ lst))]))\n  (list (largest_negative lst) (smallest_positive lst)))\n", "  (cond\n\
    \    [(empty? lst) (list #f #f)]\n    [(and (positive? (first lst)) (negative?\
    \ (first lst))) (list #f #f)]\n    [(positive? (first lst)) (list #f (first lst))]\n\
    \    [(negative? (first lst)) (list (first lst) #f)]\n    [else (list #f #f)]))\n",
  "  (define (helper lst a b)\n    (cond [(empty? lst) (list a b)]\n          [(and\
    \ (positive? (first lst)) (not b)) (helper (rest lst) a (first lst))]\n      \
    \    [(and (negative? (first lst)) (not a)) (helper (rest lst) (first lst) b)]\n\
    \          [(and (positive? (first lst)) (< b (first lst))) (helper (rest lst)\
    \ a (first lst))]\n          [(and (negative? (first lst)) (> a (first lst)))\
    \ (helper (rest lst) (first lst) b)]\n          [else (helper (rest lst) a b)]))\n\
    \  (helper lst #f #f))\n", "  (define (helper lst min max)\n    (cond\n      [(empty?\
    \ lst) (list max min)]\n      [(and (negative? (first lst)) (or (not max) (&gt;\
    \ (first lst) max)))\n       (helper (rest lst) min (first lst))]\n      [(and\
    \ (positive? (first lst)) (or (not min) (&lt; (first lst) min)))\n       (helper\
    \ (rest lst) (first lst) max)]\n      [else (helper (rest lst) min max)]))\n \
    \ (helper lst #f #f))\n", "  (define (largest_negative lst)\n    (cond ((null?\
    \ lst) #f)\n          ((and (negative? (car lst))\n                (or (not (negative?\
    \ (cadr lst)))\n                    (negative? (car lst))\n                  \
    \  (and (negative? (cadr lst))\n                         (< (car lst) (cadr lst)))))\n\
    \           (car lst))\n          (else (largest_negative (cdr lst)))))\n  (define\
    \ (smallest_positive lst)\n    (cond ((null? lst) #f)\n          ((and (positive?\
    \ (car lst))\n                (or (not (positive? (cadr lst)))\n             \
    \       (positive? (car lst))\n                    (and (positive? (cadr lst))\n\
    \                         (> (car lst) (cadr lst)))))\n           (car lst))\n\
    \          (else (smallest_positive (cdr lst)))))\n  (list (largest_negative lst)\
    \ (smallest_positive lst)))\n", "  (define (helper lst)\n    (cond\n      [(null?\
    \ lst) (list #f #f)]\n      [(and (positive? (car lst)) (negative? (cadr lst)))\
    \ (list (cadr lst) (car lst))]\n      [(and (negative? (car lst)) (positive? (cadr\
    \ lst))) (list (car lst) (cadr lst))]\n      [else (helper (cdr lst))]))\n  (helper\
    \ lst))\n", "  (define (largest_negative_integer lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(and (negative? (first lst))\n            (or (not (negative?\
    \ (second lst)))\n                (empty? (rest lst)))) (first lst)]\n      [else\
    \ (largest_negative_integer (rest lst))]))\n  (define (smallest_positive_integer\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst))\n\
    \            (or (not (positive? (second lst)))\n                (empty? (rest\
    \ lst)))) (first lst)]\n      [else (smallest_positive_integer (rest lst))]))\n\
    \  (list (largest_negative_integer lst)\n        (smallest_positive_integer lst)))\n",
  "  (define (helper lst largest smallest)\n    (cond [(empty? lst) (list largest\
    \ smallest)]\n          [(and (positive? (first lst)) (or (not (positive? smallest))\
    \ (< (first lst) smallest)))\n           (helper (rest lst) largest (first lst))]\n\
    \          [(and (negative? (first lst)) (or (not (negative? largest)) (> (first\
    \ lst) largest)))\n           (helper (rest lst) (first lst) smallest)]\n    \
    \      [else (helper (rest lst) largest smallest)]))\n  (helper lst #f #f))\n",
  "  (cond\n    [(empty? lst) (list #f #f)]\n    [(empty? (filter negative? lst))\
    \ (list #f (min (filter positive? lst)))]\n    [(empty? (filter positive? lst))\
    \ (list (max (filter negative? lst)) #f)]\n    [else (list (max (filter negative?\
    \ lst)) (min (filter positive? lst)))]))\n", "  (let ([negs (filter (lambda (x)\
    \ (negative? x)) lst)]\n        [pos (filter (lambda (x) (positive? x)) lst)])\n\
    \    (if (empty? negs)\n        (list #f (min pos))\n        (list (max negs)\
    \ (if (empty? pos) #f (min pos))))))\n", "  (define (largest_negative lst)\n \
    \   (cond\n      [(empty? lst) #f]\n      [(and (negative? (first lst)) (not (negative?\
    \ (second lst)))) (first lst)]\n      [else (largest_negative (rest lst))]))\n\
    \  (define (smallest_positive lst)\n    (cond\n      [(empty? lst) #f]\n     \
    \ [(and (positive? (first lst)) (not (positive? (second lst)))) (first lst)]\n\
    \      [else (smallest_positive (rest lst))]))\n  (list (largest_negative lst)\
    \ (smallest_positive lst)))\n", "  (define (find-largest-negative lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(and (negative? (first lst))\n            (or\
    \ (not (negative? (second lst)))\n                (find-largest-negative (rest\
    \ lst))))\n       (first lst)]\n      [else (find-largest-negative (rest lst))]))\n\
    \  (define (find-smallest-positive lst)\n    (cond\n      [(empty? lst) #f]\n\
    \      [(and (positive? (first lst))\n            (or (not (positive? (second\
    \ lst)))\n                (find-smallest-positive (rest lst))))\n       (first\
    \ lst)]\n      [else (find-smallest-positive (rest lst))]))\n  (list (find-largest-negative\
    \ lst)\n        (find-smallest-positive lst)))\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(negative? (first lst)) (max\
    \ (first lst) (largest_negative (rest lst)))]\n      [else (largest_negative (rest\
    \ lst))]))\n  (define (smallest_positive lst)\n    (cond\n      [(empty? lst)\
    \ #f]\n      [(positive? (first lst)) (min (first lst) (smallest_positive (rest\
    \ lst)))]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (largest_negatives lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(and (negative? (first lst)) (not (negative?\
    \ (rest lst)))) (first lst)]\n      [else (largest_negatives (rest lst))]))\n\
    \  (define (smallest_positives lst)\n    (cond\n      [(empty? lst) #f]\n    \
    \  [(and (positive? (first lst)) (not (positive? (rest lst)))) (first lst)]\n\
    \      [else (smallest_positives (rest lst))]))\n  (list (largest_negatives lst)\
    \ (smallest_positives lst)))\n", "  (let ([neg-lst (filter (lambda (x) (< x 0))\
    \ lst)]\n        [pos-lst (filter (lambda (x) (> x 0)) lst)])\n    (if (empty?\
    \ neg-lst)\n        (list #f (min pos-lst))\n        (if (empty? pos-lst)\n  \
    \          (list (max neg-lst) #f)\n            (list (max neg-lst) (min pos-lst))))))\n",
  "  (define (largest_smallest_integers_helper lst largest smallest)\n    (cond\n\
    \      [(empty? lst) (list largest smallest)]\n      [(and (negative? (first lst))\
    \ (or (not (number? largest)) (&gt; (first lst) largest)))\n       (largest_smallest_integers_helper\
    \ (rest lst) (first lst) smallest)]\n      [(and (positive? (first lst)) (or (not\
    \ (number? smallest)) (&lt; (first lst) smallest)))\n       (largest_smallest_integers_helper\
    \ (rest lst) largest (first lst))]\n      [else (largest_smallest_integers_helper\
    \ (rest lst) largest smallest)]))\n  (largest_smallest_integers_helper lst #f\
    \ #f))\n</code>\n", "  (let ([negs (filter (lambda (x) (negative? x)) lst)]\n\
    \        [pos (filter (lambda (x) (positive? x)) lst)])\n    (if (empty? negs)\n\
    \        (list #f (min pos))\n        (list (max negs) (if (empty? pos) #f (min\
    \ pos))))))\n", "  (define (largest_negative lst)\n    (cond ((null? lst) #f)\n\
    \          ((and (negative? (car lst)) (not (negative? (cadr lst)))) (car lst))\n\
    \          (else (largest_negative (cdr lst)))))\n  (define (smallest_positive\
    \ lst)\n    (cond ((null? lst) #f)\n          ((and (positive? (car lst)) (not\
    \ (positive? (cadr lst)))) (car lst))\n          (else (smallest_positive (cdr\
    \ lst)))))\n  (list (largest_negative lst) (smallest_positive lst)))\n", "  (define\
    \ (helper lst)\n    (cond\n      [(empty? lst) (list #f #f)]\n      [(and (positive?\
    \ (first lst)) (negative? (first lst))) (list (first lst) (first lst))]\n    \
    \  [(negative? (first lst)) (list (first lst) (second lst))]\n      [(positive?\
    \ (first lst)) (list (first lst) (second lst))]\n      [else (helper (rest lst))]))\n\
    \  (helper lst))\n", "  (define (find-largest-negative lst)\n    (cond [(empty?\
    \ lst) #f]\n          [(and (negative? (first lst))\n                (or (not\
    \ (negative? (second lst)))\n                    (negative? (first lst))))\n \
    \          (first lst)]\n          [else (find-largest-negative (rest lst))]))\n\
    \  (define (find-smallest-positive lst)\n    (cond [(empty? lst) #f]\n       \
    \   [(and (positive? (first lst))\n                (or (not (positive? (second\
    \ lst)))\n                    (positive? (first lst))))\n           (first lst)]\n\
    \          [else (find-smallest-positive (rest lst))]))\n  (list (find-largest-negative\
    \ lst) (find-smallest-positive lst)))\n", "  (define (helper lst min max)\n  \
    \  (cond [(empty? lst) (list max min)]\n          [(and (positive? (first lst))\
    \ (not min)) (helper (rest lst) (first lst) max)]\n          [(and (negative?\
    \ (first lst)) (not max)) (helper (rest lst) min (first lst))]\n          [(and\
    \ (positive? (first lst)) (< (first lst) min)) (helper (rest lst) (first lst)\
    \ max)]\n          [(and (negative? (first lst)) (> (first lst) max)) (helper\
    \ (rest lst) min (first lst))]\n          [else (helper (rest lst) min max)]))\n\
    \  (helper lst #f #f))\n", "  (define (largest_smallest_integers_helper lst largest\
    \ smallest)\n    (cond\n      [(null? lst) (list largest smallest)]\n      [(and\
    \ (not (null? largest)) (not (null? smallest)) (and (< (car lst) 0) (> (car lst)\
    \ largest)))\n       (largest_smallest_integers_helper (cdr lst) (car lst) smallest)]\n\
    \      [(and (not (null? largest)) (not (null? smallest)) (and (> (car lst) 0)\
    \ (< (car lst) smallest)))\n       (largest_smallest_integers_helper (cdr lst)\
    \ largest (car lst))]\n      [(and (null? largest) (< (car lst) 0))\n       (largest_smallest_integers_helper\
    \ (cdr lst) (car lst) smallest)]\n      [(and (null? smallest) (> (car lst) 0))\n\
    \       (largest_smallest_integers_helper (cdr lst) largest (car lst))]\n    \
    \  [else (largest_smallest_integers_helper (cdr lst) largest smallest)]))\n  (largest_smallest_integers_helper\
    \ lst #f #f))\n", "  (define (largest_smallest_integers-helper lst largest smallest)\n\
    \    (cond\n      [(empty? lst) (list largest smallest)]\n      [(and (positive?\
    \ (first lst)) (or (not (positive? smallest)) (< (first lst) smallest)))\n   \
    \    (largest_smallest_integers-helper (rest lst) largest (first lst))]\n    \
    \  [(and (negative? (first lst)) (or (not (negative? largest)) (> (first lst)\
    \ largest)))\n       (largest_smallest_integers-helper (rest lst) (first lst)\
    \ smallest)]\n      [else (largest_smallest_integers-helper (rest lst) largest\
    \ smallest)]))\n  (largest_smallest_integers-helper lst #f #f))\n", "  (define\
    \ (largest_negative lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative?\
    \ (first lst)) (not (negative? (first (rest lst))))) (first lst)]\n      [else\
    \ (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(and (positive? (first lst)) (not (positive?\
    \ (first (rest lst))))) (first lst)]\n      [else (smallest_positive (rest lst))]))\n\
    \  (list (largest_negative lst) (smallest_positive lst)))\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative? (first lst))\
    \ (not (negative? (second lst)))) (first lst)]\n      [else (largest_negative\
    \ (rest lst))]))\n  (define (smallest_positive lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(and (positive? (first lst)) (not (positive? (second lst))))\
    \ (first lst)]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (largest_negative lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(and (negative? (first lst)) (not (negative?\
    \ (second lst)))) (first lst)]\n      [else (largest_negative (rest lst))]))\n\
    \  (define (smallest_positive lst)\n    (cond\n      [(empty? lst) #f]\n     \
    \ [(and (positive? (first lst)) (not (positive? (second lst)))) (first lst)]\n\
    \      [else (smallest_positive (rest lst))]))\n  (list (largest_negative lst)\
    \ (smallest_positive lst)))\n", "  (define (helper lst largest smallest)\n   \
    \ (cond\n      [(empty? lst) (list largest smallest)]\n      [(and (positive?\
    \ (first lst)) (not smallest)) (helper (rest lst) largest (first lst))]\n    \
    \  [(and (negative? (first lst)) (not largest)) (helper (rest lst) (first lst)\
    \ smallest)]\n      [(and (positive? (first lst)) (< (first lst) smallest)) (helper\
    \ (rest lst) largest (first lst))]\n      [(and (negative? (first lst)) (> (first\
    \ lst) largest)) (helper (rest lst) (first lst) smallest)]\n      [else (helper\
    \ (rest lst) largest smallest)]))\n  (helper lst #f #f))\n", "  (cond\n    [(empty?\
    \ lst) (list #f #f)]\n    [(and (positive? (first lst)) (negative? (first lst)))\
    \ (list #f #f)]\n    [(positive? (first lst)) (list (first lst) (first lst))]\n\
    \    [(negative? (first lst)) (list (first lst) (first lst))]\n    [else (list\
    \ #f #f)]))\n", "  (define (largest_negative lst)\n    (cond\n      [(empty? lst)\
    \ #f]\n      [(negative? (first lst)) (max (first lst) (largest_negative (rest\
    \ lst)))]\n      [else (largest_negative (rest lst))]))\n  (define (smallest_positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(positive? (first lst)) (min\
    \ (first lst) (smallest_positive (rest lst)))]\n      [else (smallest_positive\
    \ (rest lst))]))\n  (list (largest_negative lst) (smallest_positive lst)))\n",
  "  (define (largest_negative_integer lst)\n    (cond\n      [(empty? lst) #f]\n\
    \      [(and (negative? (first lst))\n            (or (not (negative? (second\
    \ lst)))\n                (empty? (rest lst)))) (first lst)]\n      [else (largest_negative_integer\
    \ (rest lst))]))\n  (define (smallest_positive_integer lst)\n    (cond\n     \
    \ [(empty? lst) #f]\n      [(and (positive? (first lst))\n            (or (not\
    \ (positive? (second lst)))\n                (empty? (rest lst)))) (first lst)]\n\
    \      [else (smallest_positive_integer (rest lst))]))\n  (list (largest_negative_integer\
    \ lst)\n        (smallest_positive_integer lst)))\n", "  (define (largest_smallest_integers_helper\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (positive? (first lst)) (or (not (positive? smallest)) (< (first\
    \ lst) smallest)))\n       (largest_smallest_integers_helper (rest lst) largest\
    \ (first lst))]\n      [(and (negative? (first lst)) (or (not (negative? largest))\
    \ (> (first lst) largest)))\n       (largest_smallest_integers_helper (rest lst)\
    \ (first lst) smallest)]\n      [else (largest_smallest_integers_helper (rest\
    \ lst) largest smallest)]))\n  (largest_smallest_integers_helper lst #f #f))\n",
  "  (define (largest_negative lst)\n    (cond\n      [(null? lst) #f]\n      [(and\
    \ (negative? (car lst)) (or (not (negative? (cadr lst))) (null? (cdr lst)))) (car\
    \ lst)]\n      [else (largest_negative (cdr lst))]))\n  (define (smallest_positive\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [(and (positive? (car lst)) (or\
    \ (not (positive? (cadr lst))) (null? (cdr lst)))) (car lst)]\n      [else (smallest_positive\
    \ (cdr lst))]))\n  (list (largest_negative lst) (smallest_positive lst)))\n",
  "  (define (helper lst)\n    (cond\n      [(empty? lst) (list #f #f)]\n      [(and\
    \ (negative? (first lst)) (not (positive? (first lst))))\n       (list (first\
    \ lst) #f)]\n      [(and (positive? (first lst)) (not (negative? (first lst))))\n\
    \       (list #f (first lst))]\n      [else (helper (rest lst))]))\n  (helper\
    \ lst))\n", "  (define (largest_negative lst)\n    (cond\n      [(empty? lst)\
    \ #f]\n      [(< (first lst) 0) (max (first lst) (largest_negative (rest lst)))]\n\
    \      [else (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n\
    \    (cond\n      [(empty? lst) #f]\n      [(> (first lst) 0) (min (first lst)\
    \ (smallest_positive (rest lst)))]\n      [else (smallest_positive (rest lst))]))\n\
    \  (list (largest_negative lst) (smallest_positive lst)))\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative? (first lst))\n\
    \            (or (not (negative? (second lst)))\n                (negative? (first\
    \ lst))\n                (not (negative? (second lst)))))\n       (first lst)]\n\
    \      [else (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n\
    \    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst))\n   \
    \         (or (not (positive? (second lst)))\n                (positive? (first\
    \ lst))\n                (not (positive? (second lst)))))\n       (first lst)]\n\
    \      [else (smallest_positive (rest lst))]))\n  (list (largest_negative lst)\
    \ (smallest_positive lst)))\n", "  (define (largest_smallest_integers_iter lst\
    \ largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (negative? (first lst)) (or (not largest) (&gt; (first lst) largest)))\n\
    \       (largest_smallest_integers_iter (rest lst) (first lst) smallest)]\n  \
    \    [(and (positive? (first lst)) (or (not smallest) (&lt; (first lst) smallest)))\n\
    \       (largest_smallest_integers_iter (rest lst) largest (first lst))]\n   \
    \   [else (largest_smallest_integers_iter (rest lst) largest smallest)]))\n  (largest_smallest_integers_iter\
    \ lst #f #f))\n</code>\nI'm not sure if I'm doing this right. I'm not sure if\
    \ I'm using the <code>cond</code> correctly. I'm not sure if I'm using the <code>or</code>\
    \ correctly. I'm not sure if I'm using the <code>and</code> correctly. I'm not\
    \ sure if I'm using the <code>&gt;</code> and <code>&lt;</code> correctly. I'm\
    \ not sure if I'm using the <code>first</code> and <code>rest</code> correctly.\
    \ I'm not sure if I'm using the <code>empty?</code> correctly. I'm not sure if\
    \ I'm using the <code>negative?</code> and <code>positive?</code> correctly. I'm\
    \ not sure if I'm using the <code>list</code> correctly. I'm not sure if I'm using\
    \ the <code>define</code> correctly. I'm not sure if I'm using the <code>lambda</code>\
    \ correctly. I'm not sure if I'm using the <code>let</code> correctly. I'm not\
    \ sure if I'm using the <code>let*</code> correctly. I'm not sure if I'm using\
    \ the <code>letrec</code> correctly. I'm not sure if I'm using the <code>letrec*</code>\
    \ correctly. I'm not sure if I'm using the <code>let-values</code> correctly.\
    \ I'm not sure if I'm", "  (define (largest_negative lst)\n    (cond\n      [(empty?\
    \ lst) #f]\n      [(and (negative? (first lst))\n            (or (not (negative?\
    \ (second lst)))\n                (negative? (first lst))))\n       (first lst)]\n\
    \      [else (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n\
    \    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst))\n   \
    \         (or (not (positive? (second lst)))\n                (positive? (first\
    \ lst))))\n       (first lst)]\n      [else (smallest_positive (rest lst))]))\n\
    \  (list (largest_negative lst) (smallest_positive lst)))\n", "  (define (largest_smallest_integers_helper\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (positive? (first lst)) (or (not (positive? smallest)) (< (first\
    \ lst) smallest)))\n       (largest_smallest_integers_helper (rest lst) largest\
    \ (first lst))]\n      [(and (negative? (first lst)) (or (not (negative? largest))\
    \ (> (first lst) largest)))\n       (largest_smallest_integers_helper (rest lst)\
    \ (first lst) smallest)]\n      [else (largest_smallest_integers_helper (rest\
    \ lst) largest smallest)]))\n  (largest_smallest_integers_helper lst #f #f))\n",
  "  (define (helper lst largest smallest)\n    (cond\n      [(empty? lst) (list largest\
    \ smallest)]\n      [(and (negative? (first lst)) (or (not largest) (&gt; (first\
    \ lst) largest)))\n       (helper (rest lst) (first lst) smallest)]\n      [(and\
    \ (positive? (first lst)) (or (not smallest) (&lt; (first lst) smallest)))\n \
    \      (helper (rest lst) largest (first lst))]\n      [else (helper (rest lst)\
    \ largest smallest)]))\n  (helper lst #f #f))\n</code>\n", "  (let ([negs (filter\
    \ (lambda (x) (< x 0)) lst)]\n        [pos (filter (lambda (x) (> x 0)) lst)])\n\
    \    (if (empty? negs)\n        (list #f (first pos))\n        (if (empty? pos)\n\
    \            (list (first negs) #f)\n            (list (first negs) (first pos))))))\n",
  "  (define (helper lst acc)\n    (if (null? lst)\n        acc\n        (let ([x\
    \ (car lst)])\n          (if (and (integer? x) (not (zero? x)))\n            \
    \  (if (positive? x)\n                  (if (or (not (cdr acc))\n            \
    \              (< x (cadr acc)))\n                      (helper (cdr lst) (cons\
    \ (car acc) x))\n                      (helper (cdr lst) acc))\n             \
    \     (if (or (not (car acc))\n                          (> x (car acc)))\n  \
    \                    (helper (cdr lst) (cons x (cadr acc)))\n                \
    \      (helper (cdr lst) acc)))\n              (helper (cdr lst) acc))))))\n \
    \ (helper lst (list #f #f)))\n", "  (define (helper lst)\n    (if (null? lst)\n\
    \        (list #f #f)\n        (let* ([x (car lst)]\n               [xs (cdr lst)]\n\
    \               [r (helper xs)]\n               [a (car r)]\n               [b\
    \ (cadr r)])\n          (if (and (integer? x) (positive? x))\n              (if\
    \ (and (integer? b) (positive? b))\n                  (if (< x b)\n          \
    \            (list a x)\n                      (list a b))\n                 \
    \ (list a x))\n              (if (and (integer? x) (negative? x))\n          \
    \        (if (and (integer? a) (negative? a))\n                      (if (> x\
    \ a)\n                          (list x b)\n                          (list a\
    \ b))\n                      (list x b))\n                  (list a b))))))\n\
    \  (helper lst))\n", "  (define (helper lst neg pos)\n    (cond\n      [(empty?\
    \ lst) (list neg pos)]\n      [(and (negative? (first lst)) (or (not neg) (< (first\
    \ lst) neg)))\n       (helper (rest lst) (first lst) pos)]\n      [(and (positive?\
    \ (first lst)) (or (not pos) (> (first lst) pos)))\n       (helper (rest lst)\
    \ neg (first lst))]\n      [else (helper (rest lst) neg pos)]))\n  (helper lst\
    \ #f #f))\n", "  (define (largest_smallest_integers_iter lst largest smallest)\n\
    \    (cond [(empty? lst) (list largest smallest)]\n          [(and (positive?\
    \ (first lst)) (not smallest)) (largest_smallest_integers_iter (rest lst) largest\
    \ (first lst))]\n          [(and (negative? (first lst)) (not largest)) (largest_smallest_integers_iter\
    \ (rest lst) (first lst) smallest)]\n          [(and (positive? (first lst)) (<\
    \ (first lst) smallest)) (largest_smallest_integers_iter (rest lst) largest (first\
    \ lst))]\n          [(and (negative? (first lst)) (> (first lst) largest)) (largest_smallest_integers_iter\
    \ (rest lst) (first lst) smallest)]\n          [else (largest_smallest_integers_iter\
    \ (rest lst) largest smallest)]))\n  (largest_smallest_integers_iter lst #f #f))\n",
  "  (define (helper lst neg pos)\n    (cond\n      [(empty? lst) (list neg pos)]\n\
    \      [(and (positive? (first lst)) (not pos)) (helper (rest lst) neg (first\
    \ lst))]\n      [(and (negative? (first lst)) (not neg)) (helper (rest lst) (first\
    \ lst) pos)]\n      [(and (positive? (first lst)) (< (first lst) pos)) (helper\
    \ (rest lst) neg (first lst))]\n      [(and (negative? (first lst)) (> (first\
    \ lst) neg)) (helper (rest lst) (first lst) pos)]\n      [else (helper (rest lst)\
    \ neg pos)]))\n  (helper lst #f #f))\n", "  (let ([negatives (filter (lambda (x)\
    \ (< x 0)) lst)]\n        [positives (filter (lambda (x) (> x 0)) lst)])\n   \
    \ (if (empty? negatives)\n        (list #f (min positives))\n        (if (empty?\
    \ positives)\n            (list (max negatives) #f)\n            (list (max negatives)\
    \ (min positives))))))\n", "  (define (largest_negative lst)\n    (cond\n    \
    \  [(empty? lst) #f]\n      [(and (negative? (first lst)) (not (negative? (second\
    \ lst)))) (first lst)]\n      [else (largest_negative (rest lst))]))\n  (define\
    \ (smallest_positive lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (positive?\
    \ (first lst)) (not (positive? (second lst)))) (first lst)]\n      [else (smallest_positive\
    \ (rest lst))]))\n  (list (largest_negative lst) (smallest_positive lst)))\n",
  "  (define (helper lst a b)\n    (cond\n      [(empty? lst) (list a b)]\n      [(and\
    \ (positive? (first lst)) (not b)) (helper (rest lst) a (first lst))]\n      [(and\
    \ (negative? (first lst)) (not a)) (helper (rest lst) (first lst) b)]\n      [(and\
    \ (positive? (first lst)) (< (first lst) b)) (helper (rest lst) a (first lst))]\n\
    \      [(and (negative? (first lst)) (> (first lst) a)) (helper (rest lst) (first\
    \ lst) b)]\n      [else (helper (rest lst) a b)]))\n  (helper lst #f #f))\n",
  "  (define (largest_smallest_integers-iter lst largest smallest)\n    (cond [(empty?\
    \ lst) (list largest smallest)]\n          [(and (positive? (first lst)) (or (not\
    \ (positive? smallest)) (< (first lst) smallest)))\n           (largest_smallest_integers-iter\
    \ (rest lst) largest (first lst))]\n          [(and (negative? (first lst)) (or\
    \ (not (negative? largest)) (> (first lst) largest)))\n           (largest_smallest_integers-iter\
    \ (rest lst) (first lst) smallest)]\n          [else (largest_smallest_integers-iter\
    \ (rest lst) largest smallest)]))\n  (largest_smallest_integers-iter lst #f #f))\n",
  "  (cond\n    [(empty? lst) (list #f #f)]\n    [(and (positive? (first lst)) (negative?\
    \ (first lst))) (list #f #f)]\n    [(positive? (first lst)) (list (first lst)\
    \ (first lst))]\n    [(negative? (first lst)) (list (first lst) (first lst))]\n\
    \    [else (list #f #f)]))\n", "  (define (helper lst a b)\n    (cond\n      [(empty?\
    \ lst) (list a b)]\n      [(and (negative? (first lst)) (or (not a) (< (first\
    \ lst) a)))\n       (helper (rest lst) (first lst) b)]\n      [(and (positive?\
    \ (first lst)) (or (not b) (> (first lst) b)))\n       (helper (rest lst) a (first\
    \ lst))]\n      [else (helper (rest lst) a b)]))\n  (helper lst #f #f))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
