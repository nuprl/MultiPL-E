completions:
- "  let count = 0;\n  let row = grid.length;\n  let col = grid[0].length;\n  let\
  \ max = 0;\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < col; j++)\
  \ {\n      if (grid[i][j] === 1) {\n        max = Math.max(max, j);\n      }\n \
  \   }\n  }\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < col; j++)\
  \ {\n      if (grid[i][j] === 1) {\n        if (j === max) {\n          count +=\
  \ capacity;\n        } else {\n          count += 1;\n        }\n      }\n    }\n\
  \  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   max = Math.max(...grid[i]);\n    if (max > 0) {\n      count += max;\n    }\n\
  \  }\n  return count * capacity;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let row_sum = row.reduce((a, b) => a + b, 0);\n        if\
  \ (row_sum > capacity) {\n            result += row_sum - capacity;\n        }\n\
  \    }\n    return result;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
  \    }\n    count = 0;\n  }\n  return max * capacity;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] == 1) {\n      \
  \          count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++)\
  \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
  \ === 1) {\n                count++;\n            }\n        }\n        if (count\
  \ > max) {\n            max = count;\n        }\n        count = 0;\n    }\n   \
  \ return max * capacity;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  // your code here\n  return 0;\n}\n\nexport { max_fill };"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           grid[i][j] = 0;\n                count++;\n                for (let\
  \ k = 0; k < capacity; k++) {\n                    if (i + k < grid.length && grid[i\
  \ + k][j] === 1) {\n                        grid[i + k][j] = 0;\n              \
  \          count++;\n                    }\n                    if (j + k < grid[i].length\
  \ && grid[i][j + k] === 1) {\n                        grid[i][j + k] = 0;\n    \
  \                    count++;\n                    }\n                }\n      \
  \      }\n        }\n    }\n    return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
  \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0],\
  \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0,\
  \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
  \ 0, 0]], 5));"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
  \    let row_sum = row.reduce((acc, curr) => acc + curr, 0);\n    if (row_sum >\
  \ capacity) {\n      count += row_sum - capacity;\n    }\n  }\n  return count;\n\
  }\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
  \ = 0;\n        count++;\n        let k = i;\n        while (k > 0 && grid[k - 1][j]\
  \ === 1) {\n          grid[k - 1][j] = 0;\n          k--;\n        }\n      }\n\
  \    }\n  }\n  return count;\n}\n"
- "    // your code here\n    let count = 0;\n    let max = 0;\n    let min = 0;\n\
  \    let max_index = 0;\n    let min_index = 0;\n    for (let i = 0; i < grid.length;\
  \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
  \ === 1) {\n                count++;\n            }\n        }\n        if (count\
  \ > max) {\n            max = count;\n            max_index = i;\n        }\n  \
  \      if (count < min) {\n            min = count;\n            min_index = i;\n\
  \        }\n        count = 0;\n    }\n    if (max === 0) {\n        return 0;\n\
  \    }\n    return max * capacity - min * capacity;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let count = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
  \    let max = 0;\n    for (let i = 0; i < row; i++) {\n        for (let j = 0;\
  \ j < col; j++) {\n            if (grid[i][j] === 1) {\n                max = Math.max(max,\
  \ j);\n            }\n        }\n    }\n    for (let i = 0; i < row; i++) {\n  \
  \      for (let j = 0; j < col; j++) {\n            if (grid[i][j] === 1) {\n  \
  \              count += capacity;\n            }\n            if (j === max) {\n\
  \                count += capacity;\n            }\n        }\n    }\n    return\
  \ count;\n}\n"
- "  let count = 0;\n  let row = grid.length;\n  let col = grid[0].length;\n  let\
  \ max = 0;\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < col; j++)\
  \ {\n      if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n    max =\
  \ Math.max(max, count);\n    count = 0;\n  }\n  return max * capacity;\n}\n"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        max = Math.max(max, j);\n      }\n    }\n  }\n  for (let i = 0; i < grid.length;\
  \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
  \ 1) {\n        count += capacity;\n      }\n      if (j === max) {\n        count\
  \ += capacity;\n      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count++;\n                grid[i][j] = 0;\n                for (let\
  \ k = i + 1; k < grid.length; k++) {\n                    if (grid[k][j] === 1)\
  \ {\n                        grid[k][j] = 0;\n                    }\n          \
  \      }\n            }\n        }\n    }\n    return count * capacity;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
  \    let row_count = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j]\
  \ === 1) {\n        row_count++;\n      }\n    }\n    count += Math.ceil(row_count\
  \ / capacity);\n  }\n  return count;\n}\n"
- "    let count = 0;\n    let max_count = 0;\n    let max_row = 0;\n    let max_col\
  \ = 0;\n    let max_row_count = 0;\n    let max_col_count = 0;\n    let max_row_col_count\
  \ = 0;\n    let max_col_row_count = 0;\n    let max_row_col_row_count = 0;\n   \
  \ let max_col_row_col_count = 0;\n    let max_row_col_row_col_count = 0;\n    let\
  \ max_col_row_col_row_count = 0;\n    let max_row_col_row_col_row_count = 0;\n \
  \   let max_col_row_col_row_col_count = 0;\n    let max_row_col_row_col_row_col_count\
  \ = 0;\n    let max_col_row_col_row_col_row_count = 0;\n    let max_row_col_row_col_row_col_row_count\
  \ = 0;\n    let max_col_row_col_row_col_row_col_count = 0;\n    let max_row_col_row_col_row_col_row_col_count\
  \ = 0;\n    let max_col_row_col_row_col_row_col_row_count = 0;\n    let max_row_col_row_col_row_col_row_col_row_count\
  \ = 0;\n    let max_col_row_col_row_col_row_col_row_col_count = 0;\n    let max_row_col_row_col_row_col_row_col_row_col_count\
  \ = 0;\n    let max_col_row_col_row_col_row_col_row_col_row_count = 0;\n    let\
  \ max_row_col_row_col_row_col_row_col_row_col_row_count = 0;\n    let max_col_row_col_row_col_row_col_row_col_row_col_count\
  \ = 0;\n    let max_row_col_row_col_row_col"
- "  let total = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
  \    let row_total = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j]\
  \ === 1) {\n        row_total += 1;\n      }\n    }\n    total += Math.ceil(row_total\
  \ / capacity);\n  }\n  return total;\n}\n"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
  \    }\n    count = 0;\n  }\n  return max * capacity;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  let row = grid.length;\n  let col = grid[0].length;\n  let\
  \ max = 0;\n  let max_index = 0;\n  let max_row = 0;\n  let max_col = 0;\n  let\
  \ max_count = 0;\n  let max_row_count = 0;\n  let max_col_count = 0;\n  let max_row_index\
  \ = 0;\n  let max_col_index = 0;\n  let max_row_index_count = 0;\n  let max_col_index_count\
  \ = 0;\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < col; j++) {\n\
  \      if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n  }\n  while (count\
  \ > 0) {\n    for (let i = 0; i < row; i++) {\n      for (let j = 0; j < col; j++)\
  \ {\n        if (grid[i][j] === 1) {\n          max_row_count++;\n        }\n  \
  \    }\n      if (max_row_count > max_row) {\n        max_row = max_row_count;\n\
  \        max_row_index = i;\n      }\n      max_row_count = 0;\n    }\n    for (let\
  \ i = 0; i < col; i++) {\n      for (let j = 0; j < row; j++) {\n        if (grid[j][i]\
  \ === 1) {\n          max_col_count++;\n        }\n      }\n      if (max_col_count\
  \ > max_col) {\n        max_col = max_col_count;\n        max_col_index = i;\n \
  \     }\n      max_col_count = 0;\n    }\n    if (max_row > max_col) {\n      max\
  \ = max_row;\n      max_index = max_row_index;\n      max_count = max_row_index_count;\n\
  \    } else {\n      max = max_col;\n      max_index = max_col_index;\n      max_count\
  \ ="
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
  \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n"
- "    let count = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
  \    let bucket = capacity;\n    for (let i = 0; i < row; i++) {\n        for (let\
  \ j = 0; j < col; j++) {\n            if (grid[i][j] === 1) {\n                if\
  \ (bucket > 0) {\n                    bucket--;\n                    grid[i][j]\
  \ = 0;\n                } else {\n                    bucket = capacity;\n     \
  \               count++;\n                    j--;\n                }\n        \
  \    }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0],\
  \ [0, 0, 0]], 5));"
- "    let count = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
  \    let buckets = new Array(row).fill(0);\n    let i = 0;\n    while (i < col)\
  \ {\n        for (let j = 0; j < row; j++) {\n            if (grid[j][i] === 1)\
  \ {\n                buckets[j]++;\n                if (buckets[j] > capacity) {\n\
  \                    return -1;\n                }\n            }\n        }\n \
  \       count++;\n        i++;\n    }\n    return count;\n}\n"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        max = Math.max(max, j);\n      }\n    }\n  }\n  for (let i = 0; i < grid.length;\
  \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
  \ 1) {\n        count++;\n        grid[i][j] = 0;\n      }\n    }\n    if (i < grid.length\
  \ - 1) {\n      for (let j = 0; j < grid[i].length; j++) {\n        if (grid[i][j]\
  \ === 0 && grid[i + 1][j] === 1) {\n          count++;\n          grid[i + 1][j]\
  \ = 0;\n        }\n      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   let row = grid[i];\n    let sum = 0;\n    for (let j = 0; j < row.length; j++)\
  \ {\n      sum += row[j];\n    }\n    if (sum > max) {\n      max = sum;\n    }\n\
  \  }\n  count = max * capacity;\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += 1;\n\
  \      }\n    }\n  }\n  return count * capacity;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  let max = 0;\n  let max_index = 0;\n  for (let i = 0; i < grid.length;\
  \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
  \ 1) {\n        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
  \      max_index = i;\n    }\n    count = 0;\n  }\n  return max * capacity;\n}\n"
- "    let count = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
  \    let visited = new Array(row).fill(0).map(() => new Array(col).fill(false));\n\
  \    let queue = [];\n    for (let i = 0; i < row; i++) {\n        for (let j =\
  \ 0; j < col; j++) {\n            if (grid[i][j] === 1 && !visited[i][j]) {\n  \
  \              queue.push([i, j]);\n                visited[i][j] = true;\n    \
  \            while (queue.length) {\n                    let [x, y] = queue.shift();\n\
  \                    if (grid[x][y] === 1) {\n                        grid[x][y]\
  \ = 0;\n                        count++;\n                    }\n              \
  \      if (x - 1 >= 0 && grid[x - 1][y] === 1 && !visited[x - 1][y]) {\n       \
  \                 queue.push([x - 1, y]);\n                        visited[x - 1][y]\
  \ = true;\n                    }\n                    if (x + 1 < row && grid[x\
  \ + 1][y] === 1 && !visited[x + 1][y]) {\n                        queue.push([x\
  \ + 1, y]);\n                        visited[x + 1][y] = true;\n               \
  \     }\n                    if (y - 1 >= 0 && grid[x][y - 1] === 1 && !visited[x][y\
  \ - 1]) {\n                        queue.push([x, y - 1]);\n                   \
  \     visited[x][y - 1] = true;\n                    }\n                    if (y\
  \ + 1 < col && grid[x][y + 1] === 1 && !visited[x][y + 1]) {\n                 \
  \       queue.push([x, y + 1]);\n                        visited[x][y + 1] = true;\n\
  \                    }\n                }\n            }\n        }\n    }\n   \
  \ return count / capacity;\n}\n"
- "    let total = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let row_total = 0;\n        for (let j = 0; j < row.length;\
  \ j++) {\n            let cell = row[j];\n            if (cell === 1) {\n      \
  \          row_total += 1;\n            }\n        }\n        total += Math.ceil(row_total\
  \ / capacity);\n    }\n    return total;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let filled = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                filled++;\n            }\n\
  \        }\n        if (filled > 0) {\n            count += Math.ceil(filled / capacity);\n\
  \        }\n    }\n    return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let sum = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            sum += row[j];\n        }\n        count += Math.ceil(sum / capacity);\n\
  \    }\n    return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
  \    let row_sum = row.reduce((a, b) => a + b, 0);\n    if (row_sum > capacity)\
  \ {\n      result += row_sum - capacity;\n    }\n  }\n  return result;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let filled = 0;\n        for (let j = 0; j < row.length; j++)\
  \ {\n            if (row[j] === 1) {\n                filled++;\n            }\n\
  \        }\n        if (filled > 0) {\n            count += Math.ceil(filled / capacity);\n\
  \        }\n    }\n    return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
  \    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n\
  \            if (grid[i][j] === 1) {\n                grid[i][j] = 0;\n        \
  \        count++;\n                let k = i;\n                while (k < row &&\
  \ grid[k][j] === 0) {\n                    grid[k][j] = 1;\n                   \
  \ k++;\n                }\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0],\
  \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0,\
  \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
  \ 0, 0]], 5));"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           grid[i][j] = 0;\n                count += capacity;\n            }\n\
  \        }\n    }\n    return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  // your code here\n  return 0;\n}\n\nexport { max_fill };"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  // your code goes here\n  let count = 0;\n  let max = 0;\n  let maxRow = 0;\n\
  \  let maxCol = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j =\
  \ 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
  \      }\n    }\n    if (count > max) {\n      max = count;\n      maxRow = i;\n\
  \    }\n    count = 0;\n  }\n  for (let i = 0; i < grid[maxRow].length; i++) {\n\
  \    if (grid[maxRow][i] === 1) {\n      count++;\n    }\n  }\n  if (count > max)\
  \ {\n    max = count;\n    maxCol = 1;\n  }\n  count = 0;\n  if (maxCol === 1) {\n\
  \    for (let i = 0; i < grid.length; i++) {\n      if (grid[i][maxRow] === 1) {\n\
  \        count++;\n      }\n    }\n  } else {\n    for (let i = 0; i < grid[maxRow].length;\
  \ i++) {\n      if (grid[maxRow][i] === 1) {\n        count++;\n      }\n    }\n\
  \  }\n  return count * capacity;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1,\
  \ 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0],\
  \ [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]],\
  \ 5));"
- "  let count = 0;\n  let max = 0;\n  let maxRow = 0;\n  for (let i = 0; i < grid.length;\
  \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
  \ 1) {\n        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
  \      maxRow = i;\n    }\n    count = 0;\n  }\n  return max * capacity;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
  \    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n       \
  \ count += capacity;\n      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "  let count = 0;\n  let max = 0;\n  let max_index = 0;\n  for (let i = 0; i < grid.length;\
  \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
  \ 1) {\n        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
  \      max_index = i;\n    }\n    count = 0;\n  }\n  return max * capacity;\n}\n"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
  \    }\n    count = 0;\n  }\n  return max * capacity;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let count = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
  \    let max = 0;\n    for (let i = 0; i < row; i++) {\n        for (let j = 0;\
  \ j < col; j++) {\n            if (grid[i][j] === 1) {\n                max = Math.max(max,\
  \ j);\n            }\n        }\n    }\n    for (let i = 0; i < row; i++) {\n  \
  \      for (let j = 0; j < col; j++) {\n            if (grid[i][j] === 1) {\n  \
  \              count += capacity - j;\n            }\n        }\n    }\n    return\
  \ count;\n}\n"
- "    let count = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
  \    let max = 0;\n    for (let i = 0; i < row; i++) {\n        for (let j = 0;\
  \ j < col; j++) {\n            if (grid[i][j] === 1) {\n                count++;\n\
  \            }\n        }\n        if (count > max) {\n            max = count;\n\
  \        }\n        count = 0;\n    }\n    return max * capacity;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
  \    }\n    count = 0;\n  }\n  return max * capacity;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
  \ = 0;\n        count++;\n        let bucket = capacity;\n        while (bucket\
  \ > 0) {\n          if (i - 1 >= 0 && grid[i - 1][j] === 1) {\n            grid[i\
  \ - 1][j] = 0;\n            bucket--;\n          }\n          if (i + 1 < grid.length\
  \ && grid[i + 1][j] === 1) {\n            grid[i + 1][j] = 0;\n            bucket--;\n\
  \          }\n          if (j - 1 >= 0 && grid[i][j - 1] === 1) {\n            grid[i][j\
  \ - 1] = 0;\n            bucket--;\n          }\n          if (j + 1 < grid[i].length\
  \ && grid[i][j + 1] === 1) {\n            grid[i][j + 1] = 0;\n            bucket--;\n\
  \          }\n        }\n      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
  \    }\n    count = 0;\n  }\n  return max * capacity;\n}\n"
- "    let result = 0;\n    let max_row = 0;\n    let max_col = 0;\n    let max_row_index\
  \ = 0;\n    let max_col_index = 0;\n    for (let i = 0; i < grid.length; i++) {\n\
  \        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
  \ === 1) {\n                max_row++;\n            }\n        }\n        if (max_row\
  \ > max_row_index) {\n            max_row_index = max_row;\n        }\n        max_row\
  \ = 0;\n    }\n    for (let i = 0; i < grid[0].length; i++) {\n        for (let\
  \ j = 0; j < grid.length; j++) {\n            if (grid[j][i] === 1) {\n        \
  \        max_col++;\n            }\n        }\n        if (max_col > max_col_index)\
  \ {\n            max_col_index = max_col;\n        }\n        max_col = 0;\n   \
  \ }\n    result = max_row_index * capacity + max_col_index * capacity;\n    return\
  \ result;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
  \    let row_count = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j]\
  \ === 1) {\n        row_count++;\n      }\n    }\n    if (row_count > 0) {\n   \
  \   count += Math.ceil(row_count / capacity);\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
  \    }\n    count = 0;\n  }\n  return max * capacity;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0],\
  \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0,\
  \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
  \ 0, 0]], 5));"
- "    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++)\
  \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
  \ === 1) {\n                count++;\n            }\n        }\n        if (count\
  \ > max) {\n            max = count;\n        }\n        count = 0;\n    }\n   \
  \ return max * capacity;\n}\n"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
  \    }\n    count = 0;\n  }\n  return max * capacity;\n}\n"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           result += capacity;\n                grid[i][j] = 0;\n            }\n\
  \        }\n    }\n    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0],\
  \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0,\
  \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
  \ 0, 0]], 5));"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        max += capacity;\n      }\n    }\n  }\n  for (let i = 0; i < grid.length;\
  \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
  \ 1) {\n        count += capacity;\n        if (count === max) {\n          return\
  \ i + 1;\n        }\n      }\n    }\n  }\n  return 0;\n}\n"
- "    let count = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
  \    let max = 0;\n    for (let i = 0; i < row; i++) {\n        for (let j = 0;\
  \ j < col; j++) {\n            if (grid[i][j] === 1) {\n                count++;\n\
  \            }\n        }\n        if (count > max) {\n            max = count;\n\
  \        }\n        count = 0;\n    }\n    return max * capacity;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++)\
  \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
  \ === 1) {\n                count++;\n            }\n        }\n        if (count\
  \ > max) {\n            max = count;\n        }\n        count = 0;\n    }\n   \
  \ return max * capacity;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0],\
  \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0,\
  \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
  \ 0, 0]], 5));"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
  \    let bucket = capacity;\n    for (let j = 0; j < row.length; j++) {\n      if\
  \ (row[j] === 1) {\n        if (bucket === 0) {\n          count++;\n          bucket\
  \ = capacity;\n        }\n        bucket--;\n      }\n    }\n    if (bucket < capacity)\
  \ {\n      count++;\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
  \ = 0;\n        count++;\n        let bucket = capacity;\n        while (bucket\
  \ > 0) {\n          if (i > 0 && grid[i - 1][j] === 1) {\n            grid[i - 1][j]\
  \ = 0;\n            bucket--;\n          }\n          if (i < grid.length - 1 &&\
  \ grid[i + 1][j] === 1) {\n            grid[i + 1][j] = 0;\n            bucket--;\n\
  \          }\n          if (j > 0 && grid[i][j - 1] === 1) {\n            grid[i][j\
  \ - 1] = 0;\n            bucket--;\n          }\n          if (j < grid[i].length\
  \ - 1 && grid[i][j + 1] === 1) {\n            grid[i][j + 1] = 0;\n            bucket--;\n\
  \          }\n        }\n      }\n    }\n  }\n  return count;\n}\n"
- "  let result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j =\
  \ 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result +=\
  \ capacity;\n      }\n    }\n  }\n  return result;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
  \    let bucket = capacity;\n    for (let j = 0; j < row.length; j++) {\n      if\
  \ (row[j] === 1) {\n        if (bucket > 0) {\n          bucket--;\n        } else\
  \ {\n          count++;\n          bucket = capacity - 1;\n        }\n      }\n\
  \    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  let row = grid.length;\n  let col = grid[0].length;\n  let\
  \ max = 0;\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < col; j++)\
  \ {\n      if (grid[i][j] > max) {\n        max = grid[i][j];\n      }\n    }\n\
  \  }\n  for (let k = 0; k < max; k++) {\n    for (let i = 0; i < row; i++) {\n \
  \     for (let j = 0; j < col; j++) {\n        if (grid[i][j] > 0) {\n         \
  \ grid[i][j]--;\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
  \    let row_sum = row.reduce((a, b) => a + b, 0);\n    if (row_sum > 0) {\n   \
  \   count += Math.ceil(row_sum / capacity);\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    const row = grid[i];\n\
  \    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n       \
  \ count += capacity;\n      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0],\
  \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0,\
  \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
  \ 0, 0]], 5));"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n                for (let k = i + 1; k < grid.length;\
  \ k++) {\n                    if (grid[k][j] === 1) {\n                        count\
  \ += capacity;\n                    } else {\n                        break;\n \
  \                   }\n                }\n            }\n        }\n    }\n    return\
  \ count;\n}\n"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
  \    }\n    count = 0;\n  }\n  return max * capacity;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n                grid[i][j] = 0;\n            }\n\
  \        }\n    }\n    return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
  \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n\n\
  console.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
  \    }\n    count = 0;\n  }\n  return max * capacity;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
  \ = 0;\n        count++;\n        if (i - 1 >= 0 && grid[i - 1][j] === 1) {\n  \
  \        grid[i - 1][j] = 0;\n          count++;\n        }\n        if (i + 1 <\
  \ grid.length && grid[i + 1][j] === 1) {\n          grid[i + 1][j] = 0;\n      \
  \    count++;\n        }\n        if (j - 1 >= 0 && grid[i][j - 1] === 1) {\n  \
  \        grid[i][j - 1] = 0;\n          count++;\n        }\n        if (j + 1 <\
  \ grid[i].length && grid[i][j + 1] === 1) {\n          grid[i][j + 1] = 0;\n   \
  \       count++;\n        }\n      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           grid[i][j] = 0;\n                count++;\n                let bucket\
  \ = capacity;\n                while (bucket > 0) {\n                    if (i -\
  \ 1 >= 0 && grid[i - 1][j] === 1) {\n                        grid[i - 1][j] = 0;\n\
  \                        bucket--;\n                    }\n                    if\
  \ (i + 1 < grid.length && grid[i + 1][j] === 1) {\n                        grid[i\
  \ + 1][j] = 0;\n                        bucket--;\n                    }\n     \
  \               if (j - 1 >= 0 && grid[i][j - 1] === 1) {\n                    \
  \    grid[i][j - 1] = 0;\n                        bucket--;\n                  \
  \  }\n                    if (j + 1 < grid[i].length && grid[i][j + 1] === 1) {\n\
  \                        grid[i][j + 1] = 0;\n                        bucket--;\n\
  \                    }\n                }\n            }\n        }\n    }\n   \
  \ return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  let bucket = capacity;\n  for (let i = 0; i < grid.length;\
  \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
  \ 1) {\n        if (bucket > 0) {\n          bucket--;\n          grid[i][j] = 0;\n\
  \        } else {\n          bucket = capacity;\n          count++;\n          bucket--;\n\
  \          grid[i][j] = 0;\n        }\n      }\n    }\n  }\n  return count;\n}\n\
  \nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           result += capacity;\n                grid[i][j] = 0;\n            }\n\
  \        }\n    }\n    return result;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  let row = grid.length;\n  let col = grid[0].length;\n  let\
  \ bucket = capacity;\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j <\
  \ col; j++) {\n      if (grid[i][j] === 1) {\n        if (bucket > 0) {\n      \
  \    bucket--;\n          grid[i][j] = 0;\n        } else {\n          bucket =\
  \ capacity;\n          count++;\n          bucket--;\n          grid[i][j] = 0;\n\
  \        }\n      }\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "  // your code here\n  return 0;\n}\n\nexport { max_fill };"
- "    let count = 0;\n    let max = 0;\n    let max_index = 0;\n    for (let i =\
  \ 0; i < grid.length; i++) {\n        max = 0;\n        max_index = 0;\n       \
  \ for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] > max)\
  \ {\n                max = grid[i][j];\n                max_index = j;\n       \
  \     }\n        }\n        for (let j = 0; j < grid[i].length; j++) {\n       \
  \     if (grid[i][j] < max) {\n                count += max - grid[i][j];\n    \
  \            grid[i][j] = max;\n            }\n        }\n        for (let j = 0;\
  \ j < grid[i].length; j++) {\n            if (grid[i][j] > 0) {\n              \
  \  count += capacity;\n                grid[i][j] = 0;\n            }\n        }\n\
  \    }\n    return count;\n}\n"
- "    let count = 0;\n    let row = 0;\n    let col = 0;\n    let max = 0;\n    let\
  \ maxRow = 0;\n    let maxCol = 0;\n    while (true) {\n        max = 0;\n     \
  \   maxRow = 0;\n        maxCol = 0;\n        for (row = 0; row < grid.length; row++)\
  \ {\n            for (col = 0; col < grid[row].length; col++) {\n              \
  \  if (grid[row][col] > max) {\n                    max = grid[row][col];\n    \
  \                maxRow = row;\n                    maxCol = col;\n            \
  \    }\n            }\n        }\n        if (max === 0) {\n            break;\n\
  \        }\n        for (row = 0; row < grid.length; row++) {\n            for (col\
  \ = 0; col < grid[row].length; col++) {\n                if (grid[row][col] > 0)\
  \ {\n                    grid[row][col] -= capacity;\n                    if (grid[row][col]\
  \ < 0) {\n                        grid[row][col] = 0;\n                    }\n \
  \                   count++;\n                }\n            }\n        }\n    }\n\
  \    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1,\
  \ 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1],\
  \ [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let bucket = capacity;\n        for (let j = 0; j < row.length;\
  \ j++) {\n            if (row[j] === 1) {\n                if (bucket > 0) {\n \
  \                   bucket--;\n                } else {\n                    count++;\n\
  \                    bucket = capacity - 1;\n                }\n            }\n\
  \        }\n    }\n    return count;\n}\n"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let row_sum = row.reduce((a, b) => a + b, 0);\n        if\
  \ (row_sum > capacity) {\n            result += row_sum - capacity;\n        }\n\
  \    }\n    return result;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count++;\n                grid[i][j] = 0;\n                if (i + 1\
  \ < grid.length) {\n                    grid[i + 1][j] = 1;\n                }\n\
  \            }\n        }\n    }\n    return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
  \ = 0;\n        count++;\n        for (let k = 1; k <= capacity; k++) {\n      \
  \    if (i + k < grid.length && grid[i + k][j] === 1) {\n            grid[i + k][j]\
  \ = 0;\n            count++;\n          }\n          if (j + k < grid[i].length\
  \ && grid[i][j + k] === 1) {\n            grid[i][j + k] = 0;\n            count++;\n\
  \          }\n        }\n      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0],\
  \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0,\
  \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
  \ 0, 0]], 5));"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
  \ = 0;\n        count++;\n        for (let k = i + 1; k < grid.length; k++) {\n\
  \          if (grid[k][j] === 1) {\n            grid[k][j] = 0;\n            count++;\n\
  \          }\n        }\n      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n                grid[i][j] = 0;\n            }\n\
  \        }\n    }\n    return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++)\
  \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
  \ === 1) {\n                max = Math.max(max, j);\n            }\n        }\n\
  \    }\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j <\
  \ grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                count\
  \ += 1;\n            }\n        }\n        if (max === 0) {\n            break;\n\
  \        }\n        max -= 1;\n    }\n    return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0],\
  \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0,\
  \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
  \ 0, 0]], 5));"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        max = Math.max(max, j);\n      }\n    }\n  }\n  for (let i = 0; i < grid.length;\
  \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
  \ 1) {\n        count += capacity;\n      }\n      if (j === max) {\n        count\
  \ -= capacity;\n      }\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let times = 0;\n  let wells = grid.length;\n  let units = grid[0].length;\n \
  \ let buckets = new Array(wells).fill(0);\n  let filled = new Array(wells).fill(0);\n\
  \  let empty = 0;\n  let filled_wells = 0;\n  while (filled_wells < wells) {\n \
  \   for (let i = 0; i < wells; i++) {\n      if (filled[i] < units) {\n        buckets[i]++;\n\
  \        if (buckets[i] === capacity) {\n          buckets[i] = 0;\n          filled[i]++;\n\
  \          if (filled[i] === units) {\n            filled_wells++;\n          }\n\
  \        }\n      }\n    }\n    times++;\n  }\n  return times;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   let row = grid[i];\n    for (let j = 0; j < row.length; j++) {\n      if (row[j]\
  \ === 1) {\n        count++;\n      }\n    }\n    max = Math.max(max, count);\n\
  \    count = 0;\n  }\n  return max * capacity;\n}\n\nconsole.log(max_fill([[0, 0,\
  \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "    let count = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
  \    let max = 0;\n    for (let i = 0; i < row; i++) {\n        for (let j = 0;\
  \ j < col; j++) {\n            if (grid[i][j] === 1) {\n                count++;\n\
  \            }\n        }\n        if (count > max) {\n            max = count;\n\
  \        }\n        count = 0;\n    }\n    return max * capacity;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
  \    }\n    count = 0;\n  }\n  return max * capacity;\n}\n"
- "    let count = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
  \    let wells = [];\n    for (let i = 0; i < row; i++) {\n        wells.push([]);\n\
  \        for (let j = 0; j < col; j++) {\n            wells[i].push(grid[i][j]);\n\
  \        }\n    }\n    for (let i = 0; i < row; i++) {\n        for (let j = 0;\
  \ j < col; j++) {\n            if (wells[i][j] === 1) {\n                wells[i][j]\
  \ = 0;\n                count++;\n                let bucket = capacity;\n     \
  \           while (bucket > 0) {\n                    if (i > 0 && wells[i - 1][j]\
  \ === 1) {\n                        wells[i - 1][j] = 0;\n                     \
  \   bucket--;\n                    }\n                    if (i < row - 1 && wells[i\
  \ + 1][j] === 1) {\n                        wells[i + 1][j] = 0;\n             \
  \           bucket--;\n                    }\n                    if (j > 0 && wells[i][j\
  \ - 1] === 1) {\n                        wells[i][j - 1] = 0;\n                \
  \        bucket--;\n                    }\n                    if (j < col - 1 &&\
  \ wells[i][j + 1] === 1) {\n                        wells[i][j + 1] = 0;\n     \
  \                   bucket--;\n                    }\n                }\n      \
  \      }\n        }\n    }\n    return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++)\
  \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
  \ === 1) {\n                max = Math.max(max, j);\n            }\n        }\n\
  \    }\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j <\
  \ grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                count++;\n\
  \                grid[i][j] = 0;\n            }\n        }\n        if (i === grid.length\
  \ - 1) {\n            break;\n        }\n        for (let j = 0; j < grid[i].length;\
  \ j++) {\n            if (grid[i][j] === 0 && grid[i + 1][j] === 1) {\n        \
  \        count++;\n                grid[i + 1][j] = 0;\n            }\n        }\n\
  \        for (let j = grid[i].length - 1; j >= 0; j--) {\n            if (grid[i][j]\
  \ === 0 && grid[i + 1][j] === 1) {\n                count++;\n                grid[i\
  \ + 1][j] = 0;\n            }\n        }\n    }\n    return count;\n}\n"
- "  let count = 0;\n  let row = 0;\n  let col = 0;\n  let row_len = grid.length;\n\
  \  let col_len = grid[0].length;\n  let row_max = 0;\n  let col_max = 0;\n  let\
  \ row_max_index = 0;\n  let col_max_index = 0;\n  let row_max_count = 0;\n  let\
  \ col_max_count = 0;\n  let row_max_count_index = 0;\n  let col_max_count_index\
  \ = 0;\n  let row_max_count_index_2 = 0;\n  let col_max_count_index_2 = 0;\n  let\
  \ row_max_count_2 = 0;\n  let col_max_count_2 = 0;\n  let row_max_count_index_3\
  \ = 0;\n  let col_max_count_index_3 = 0;\n  let row_max_count_3 = 0;\n  let col_max_count_3\
  \ = 0;\n  let row_max_count_index_4 = 0;\n  let col_max_count_index_4 = 0;\n  let\
  \ row_max_count_4 = 0;\n  let col_max_count_4 = 0;\n  let row_max_count_index_5\
  \ = 0;\n  let col_max_count_index_5 = 0;\n  let row_max_count_5 = 0;\n  let col_max_count_5\
  \ = 0;\n  let row_max_count_index_6 = 0;\n  let col_max_count_index_6 = 0;\n  let\
  \ row_max_count_6 = 0;\n  let col_max_count_6 = 0;\n  let row_max_count_index_7\
  \ = 0;\n  let col_max_count_index_7 = 0;\n  let row_max_count_7 = 0;\n  let col_max_count_7\
  \ = 0;\n  let row_max_count_index_8 = 0;\n  let col_max_count_index_8 = 0;\n  let\
  \ row_max_count_8 = 0;"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
  \ = 0;\n        count++;\n        if (capacity > 1) {\n          for (let k = i\
  \ + 1; k < grid.length; k++) {\n            if (grid[k][j] === 1) {\n          \
  \    grid[k][j] = 0;\n              count++;\n            }\n          }\n     \
  \   }\n      }\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0],\
  \ [0, 0, 0]], 5));"
- "    let result = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
  \    let i = 0;\n    let j = 0;\n    while (i < row) {\n        j = 0;\n       \
  \ while (j < col) {\n            if (grid[i][j] === 1) {\n                result\
  \ += capacity;\n                let k = i + 1;\n                while (k < row &&\
  \ grid[k][j] === 1) {\n                    grid[k][j] = 0;\n                   \
  \ k++;\n                }\n            }\n            j++;\n        }\n        i++;\n\
  \    }\n    return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
  \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
  \ 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let rowCount = 0;\n        for (let j = 0; j < row.length;\
  \ j++) {\n            if (row[j] === 1) {\n                rowCount++;\n       \
  \     }\n        }\n        count += Math.ceil(rowCount / capacity);\n    }\n  \
  \  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
  \ = 0;\n        count++;\n        if (i > 0 && grid[i - 1][j] === 1) {\n       \
  \   grid[i - 1][j] = 0;\n          count++;\n        }\n        if (j > 0 && grid[i][j\
  \ - 1] === 1) {\n          grid[i][j - 1] = 0;\n          count++;\n        }\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n\nexport { max_fill }"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
  \    }\n    count = 0;\n  }\n  return max * capacity;\n}\n\nconsole.log(max_fill([[0,\
  \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
  \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
  \ 0], [0, 0, 0]], 5));"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let bucket = capacity;\n        for (let j = 0; j < row.length;\
  \ j++) {\n            if (row[j] === 1) {\n                if (bucket > 0) {\n \
  \                   bucket--;\n                } else {\n                    count++;\n\
  \                    bucket = capacity - 1;\n                }\n            }\n\
  \        }\n    }\n    return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
  \ = 0;\n        count++;\n        let bucket = capacity;\n        while (bucket\
  \ > 0) {\n          if (i - 1 >= 0 && grid[i - 1][j] === 1) {\n            grid[i\
  \ - 1][j] = 0;\n            bucket--;\n          }\n          if (i + 1 < grid.length\
  \ && grid[i + 1][j] === 1) {\n            grid[i + 1][j] = 0;\n            bucket--;\n\
  \          }\n          if (j - 1 >= 0 && grid[i][j - 1] === 1) {\n            grid[i][j\
  \ - 1] = 0;\n            bucket--;\n          }\n          if (j + 1 < grid[i].length\
  \ && grid[i][j + 1] === 1) {\n            grid[i][j + 1] = 0;\n            bucket--;\n\
  \          }\n        }\n      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    let max = 0;\n    let min = 0;\n    for (let i = 0; i <\
  \ grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n    \
  \        if (grid[i][j] === 1) {\n                max = Math.max(max, i);\n    \
  \            min = Math.min(min, i);\n            }\n        }\n    }\n    for (let\
  \ i = min; i <= max; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
  \            if (grid[i][j] === 1) {\n                count++;\n            }\n\
  \        }\n    }\n    return count * capacity;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           grid[i][j] = 0;\n                count++;\n                let bucket\
  \ = capacity;\n                while (bucket > 0) {\n                    if (i >\
  \ 0 && grid[i - 1][j] === 1) {\n                        grid[i - 1][j] = 0;\n  \
  \                      bucket--;\n                    }\n                    if\
  \ (i < grid.length - 1 && grid[i + 1][j] === 1) {\n                        grid[i\
  \ + 1][j] = 0;\n                        bucket--;\n                    }\n     \
  \               if (j > 0 && grid[i][j - 1] === 1) {\n                        grid[i][j\
  \ - 1] = 0;\n                        bucket--;\n                    }\n        \
  \            if (j < grid[i].length - 1 && grid[i][j + 1] === 1) {\n           \
  \             grid[i][j + 1] = 0;\n                        bucket--;\n         \
  \           }\n                }\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
  \    }\n    count = 0;\n  }\n  return max * capacity;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let total = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
  \    let row_total = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j]\
  \ === 1) {\n        row_total += 1;\n      }\n    }\n    total += Math.ceil(row_total\
  \ / capacity);\n  }\n  return total;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  let max = 0;\n  let max_index = 0;\n  for (let i = 0; i < grid.length;\
  \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
  \ 1) {\n        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
  \      max_index = i;\n    }\n    count = 0;\n  }\n  if (max === 0) {\n    return\
  \ 0;\n  }\n  let bucket_count = 0;\n  let bucket_capacity = capacity;\n  for (let\
  \ i = 0; i < grid[max_index].length; i++) {\n    if (grid[max_index][i] === 1) {\n\
  \      bucket_count++;\n      bucket_capacity--;\n      if (bucket_capacity ===\
  \ 0) {\n        bucket_count++;\n        bucket_capacity = capacity;\n      }\n\
  \    }\n  }\n  return bucket_count;\n}\n"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
  \ = grid[i];\n        let well = row.reduce((acc, curr) => acc + curr, 0);\n   \
  \     if (well > capacity) {\n            result += well - capacity;\n        }\n\
  \    }\n    return result;\n}\n"
- "  // TODO: Implement the function here\n  return 0;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
  \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
  \ = 0;\n        count++;\n        for (let k = i; k < grid.length; k++) {\n    \
  \      if (grid[k][j] === 1) {\n            grid[k][j] = 0;\n            count++;\n\
  \          }\n        }\n      }\n    }\n  }\n  return count;\n}\n"
- "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           result += capacity;\n                for (let k = i + 1; k < grid.length;\
  \ k++) {\n                    if (grid[k][j] === 1) {\n                        result\
  \ += capacity;\n                    } else {\n                        break;\n \
  \                   }\n                }\n            }\n        }\n    }\n    return\
  \ result;\n}\n"
- "  // your code here\n  return 0;\n}\n\nexport { max_fill };"
- "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
  \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
  \        max = Math.max(max, j);\n      }\n    }\n  }\n  for (let i = 0; i < grid.length;\
  \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
  \ 1) {\n        count += capacity;\n      }\n      if (j === max) {\n        count\
  \ += capacity;\n      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
  \      }\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           grid[i][j] = 0;\n                count++;\n                let bucket\
  \ = capacity;\n                while (bucket > 0) {\n                    if (i -\
  \ 1 >= 0 && grid[i - 1][j] === 1) {\n                        grid[i - 1][j] = 0;\n\
  \                        bucket--;\n                    }\n                    if\
  \ (i + 1 < grid.length && grid[i + 1][j] === 1) {\n                        grid[i\
  \ + 1][j] = 0;\n                        bucket--;\n                    }\n     \
  \               if (j - 1 >= 0 && grid[i][j - 1] === 1) {\n                    \
  \    grid[i][j - 1] = 0;\n                        bucket--;\n                  \
  \  }\n                    if (j + 1 < grid[i].length && grid[i][j + 1] === 1) {\n\
  \                        grid[i][j + 1] = 0;\n                        bucket--;\n\
  \                    }\n                }\n            }\n        }\n    }\n   \
  \ return count;\n}\n"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
  \    let row_count = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j]\
  \ === 1) {\n        row_count++;\n      }\n    }\n    count += Math.ceil(row_count\
  \ / capacity);\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0,\
  \ 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0],\
  \ [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]],\
  \ 5));"
- "  let count = 0;\n  let row = grid.length;\n  let col = grid[0].length;\n  let\
  \ total = row * col;\n  let filled = 0;\n  let i = 0;\n  let j = 0;\n  while (filled\
  \ < total) {\n    if (grid[i][j] === 1) {\n      grid[i][j] = 0;\n      filled++;\n\
  \    }\n    j++;\n    if (j === col) {\n      j = 0;\n      i++;\n    }\n    if\
  \ (i === row) {\n      i = 0;\n      count++;\n    }\n  }\n  return count;\n}\n"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n"
- "  let count = 0;\n  let max = 0;\n  let bucket = 0;\n  for (let i = 0; i < grid.length;\
  \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
  \ 1) {\n        bucket++;\n      }\n    }\n    if (bucket > max) {\n      max =\
  \ bucket;\n    }\n    bucket = 0;\n  }\n  count = max * capacity;\n  return count;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
  \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
  \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
  }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
  \ 0, 0], [0, 0, 0]], 5));"
- "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
  \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
  \ = 0;\n        count++;\n        for (let k = 0; k < capacity; k++) {\n       \
  \   if (i + k < grid.length && grid[i + k][j] === 1) {\n            grid[i + k][j]\
  \ = 0;\n            count++;\n          }\n          if (j + k < grid[i].length\
  \ && grid[i][j + k] === 1) {\n            grid[i][j + k] = 0;\n            count++;\n\
  \          }\n        }\n      }\n    }\n  }\n  return count;\n}\n"
language: ts
name: HumanEval_115_max_fill
prompt: "// @ts-nocheck\n\n//You are given a rectangular grid of wells. Each row represents\
  \ a single well,\n// and each 1 in a row represents a single unit of water.\n//\
  \ Each well has a corresponding bucket that can be used to extract water from it,\
  \ \n// and all buckets have the same capacity.\n// Your task is to use the buckets\
  \ to empty the wells.\n// Output the number of times you need to lower the buckets.\n\
  // Example 1:\n// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n\
  // 6\n// Example 2:\n// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1],\
  \ [0, 1, 1, 1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0, 0, 0], [0, 0, 0]],\
  \ 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length\
  \ <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1\
  \ <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number\
  \ {\n"
stop_tokens:
- '

  function '
- '

  /*'
- '

  //'
- '

  class'
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0,\
  \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0,\
  \ 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n\
  }\n\ntest();"
