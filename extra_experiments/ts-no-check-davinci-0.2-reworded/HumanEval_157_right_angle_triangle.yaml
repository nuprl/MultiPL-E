completions:
- "    if (a > b && a > c) {\n        return Math.pow(a, 2) === Math.pow(b, 2) + Math.pow(c,\
  \ 2);\n    } else if (b > a && b > c) {\n        return Math.pow(b, 2) === Math.pow(a,\
  \ 2) + Math.pow(c, 2);\n    } else {\n        return Math.pow(c, 2) === Math.pow(a,\
  \ 2) + Math.pow(b, 2);\n    }\n}\n"
- "    let sides = [a, b, c].sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    let [x, y, z]\
  \ = sides;\n    return x * x + y * y === z * z;\n}\n"
- '    return (a ** 2 + b ** 2 === c ** 2) || (a ** 2 + c ** 2 === b ** 2) || (b **
  2 + c ** 2 === a ** 2);

  }

  '
- "    let max = Math.max(a, b, c);\n    let sum = a + b + c - max;\n    return max\
  \ * max === sum * sum;\n}\n"
- "    let max = Math.max(a, b, c);\n    let min = Math.min(a, b, c);\n    let mid\
  \ = a + b + c - max - min;\n    return max * max === min * min + mid * mid;\n}\n"
- "    // your code here\n    return false;\n}\n"
- "    if (a > b && a > c) {\n        return a * a == b * b + c * c;\n    } else if\
  \ (b > a && b > c) {\n        return b * b == a * a + c * c;\n    } else {\n   \
  \     return c * c == a * a + b * b;\n    }\n}\n"
- "    let sides: number[] = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return\
  \ Math.pow(sides[0], 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- '    return (Math.pow(a, 2) + Math.pow(b, 2) == Math.pow(c, 2)) || (Math.pow(a,
  2) + Math.pow(c, 2) == Math.pow(b, 2)) || (Math.pow(b, 2) + Math.pow(c, 2) == Math.pow(a,
  2));

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    // your code here\n    return false;\n}\n"
- "    let hyp: number = Math.max(a, b, c);\n    let other: number = Math.min(a, b,\
  \ c);\n    let last: number = a + b + c - hyp - other;\n    return hyp * hyp ===\
  \ other * other + last * last;\n}\n"
- "    // return true if the three sides form a right-angled triangle, false otherwise\n\
  \    return (a * a + b * b === c * c) || (a * a + c * c === b * b) || (b * b + c\
  \ * c === a * a);\n}\n"
- '    return a ** 2 + b ** 2 === c ** 2;

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    let max = Math.max(a, b, c);\n    let min = Math.min(a, b, c);\n    let mid\
  \ = a + b + c - max - min;\n    return max * max === min * min + mid * mid;\n}\n"
- '    return a * a + b * b === c * c;

  }

  '
- '    return Math.pow(a, 2) + Math.pow(b, 2) === Math.pow(c, 2);

  }

  '
- "    let sides = [a, b, c].sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    let arr = [a, b, c];\n    arr.sort((a, b) => a - b);\n    return arr[0] **\
  \ 2 + arr[1] ** 2 === arr[2] ** 2;\n}\n"
- "    if (a > b && a > c) {\n        return a * a === b * b + c * c;\n    } else\
  \ if (b > a && b > c) {\n        return b * b === a * a + c * c;\n    } else {\n\
  \        return c * c === a * a + b * b;\n    }\n}\n"
- '    return a*a + b*b == c*c;

  }

  '
- "    // TODO: implement this function\n    return false;\n}\n"
- "    let max = Math.max(a, b, c);\n    let sum = a + b + c - max;\n    return max\
  \ * max === sum * sum;\n}\n"
- '    return (a * a + b * b === c * c) || (a * a + c * c === b * b) || (b * b + c
  * c === a * a);

  }

  '
- '    return a * a + b * b === c * c || a * a + c * c === b * b || b * b + c * c
  === a * a;

  }

  '
- '    return a * a + b * b === c * c;

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    let arr = [a, b, c].sort((a, b) => a - b);\n    return Math.pow(arr[0], 2)\
  \ + Math.pow(arr[1], 2) === Math.pow(arr[2], 2);\n}\n"
- "    let sides = [a, b, c];\n    let hypotenuse = Math.max(...sides);\n    let catheti\
  \ = sides.filter(side => side !== hypotenuse);\n    let sumOfSquares = catheti.reduce((acc,\
  \ side) => acc + Math.pow(side, 2), 0);\n    return Math.pow(hypotenuse, 2) ===\
  \ sumOfSquares;\n}\n"
- "    let max: number = Math.max(a, b, c);\n    let sum: number = a + b + c - max;\n\
  \    return max * max === sum * sum;\n}\n"
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return sides[0]\
  \ ** 2 + sides[1] ** 2 === sides[2] ** 2;\n}\n"
- "    // your code here\n    return false;\n}\n"
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- '    return (a*a + b*b == c*c) || (a*a + c*c == b*b) || (b*b + c*c == a*a);

  }

  '
- "    // TODO: Implement me!\n    return false;\n}\n"
- "    if (a > b && a > c) {\n        return Math.pow(a, 2) === Math.pow(b, 2) + Math.pow(c,\
  \ 2);\n    } else if (b > a && b > c) {\n        return Math.pow(b, 2) === Math.pow(a,\
  \ 2) + Math.pow(c, 2);\n    } else {\n        return Math.pow(c, 2) === Math.pow(a,\
  \ 2) + Math.pow(b, 2);\n    }\n}\n"
- '    return Math.pow(a, 2) + Math.pow(b, 2) === Math.pow(c, 2);

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    let result: boolean = false;\n    if (a * a + b * b == c * c) {\n        result\
  \ = true;\n    }\n    return result;\n}\n"
- '    return a*a + b*b == c*c || a*a + c*c == b*b || b*b + c*c == a*a;

  }

  '
- "    // TODO: implement this function\n    return false;\n}\n"
- "    // your code here\n    return false;\n}\n"
- '    return (a*a + b*b == c*c) || (a*a + c*c == b*b) || (b*b + c*c == a*a);

  }

  '
- "    if (a == 0 || b == 0 || c == 0) {\n        return false;\n    }\n    let max\
  \ = Math.max(a, b, c);\n    let sum = a + b + c;\n    if (max == a) {\n        return\
  \ Math.pow(a, 2) == Math.pow(b, 2) + Math.pow(c, 2);\n    } else if (max == b) {\n\
  \        return Math.pow(b, 2) == Math.pow(a, 2) + Math.pow(c, 2);\n    } else {\n\
  \        return Math.pow(c, 2) == Math.pow(a, 2) + Math.pow(b, 2);\n    }\n}\n"
- "    let arr: number[] = [a, b, c];\n    arr.sort((a, b) => a - b);\n    return\
  \ arr[0] ** 2 + arr[1] ** 2 === arr[2] ** 2;\n}\n"
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    let arr = [a, b, c].sort((a, b) => a - b);\n    return arr[0] * arr[0] + arr[1]\
  \ * arr[1] === arr[2] * arr[2];\n}\n"
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- "    let sides = [a, b, c].sort();\n    return sides[0] ** 2 + sides[1] ** 2 ===\
  \ sides[2] ** 2;\n}\n"
- '    return (a * a + b * b === c * c) || (a * a + c * c === b * b) || (b * b + c
  * c === a * a);

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- '    return a*a + b*b == c*c;

  }

  '
- '    return a*a + b*b == c*c;

  }

  '
- "    let hypotenuse = Math.max(a, b, c);\n    let cathetus1 = Math.min(a, b, c);\n\
  \    let cathetus2 = a + b + c - hypotenuse - cathetus1;\n    return Math.pow(hypotenuse,\
  \ 2) === Math.pow(cathetus1, 2) + Math.pow(cathetus2, 2);\n}\n"
- "    // Your code here\n    return false;\n}\n"
- '    return a * a + b * b === c * c || a * a + c * c === b * b || b * b + c * c
  === a * a;

  }

  '
- "    let sides = [a, b, c];\n    sides.sort();\n    return sides[0] ** 2 + sides[1]\
  \ ** 2 === sides[2] ** 2;\n}\n"
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- '    return a * a + b * b === c * c;

  }

  '
- "    const sides = [a, b, c].sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- '    return (a * a + b * b === c * c || a * a + c * c === b * b || b * b + c * c
  === a * a);

  }

  '
- '    return a * a + b * b === c * c || a * a + c * c === b * b || b * b + c * c
  === a * a;

  }

  '
- "    if (a * a + b * b == c * c) {\n        return true;\n    }\n    if (a * a +\
  \ c * c == b * b) {\n        return true;\n    }\n    if (b * b + c * c == a * a)\
  \ {\n        return true;\n    }\n    return false;\n}\n"
- "    let arr = [a, b, c];\n    arr.sort((a, b) => a - b);\n    return arr[0] **\
  \ 2 + arr[1] ** 2 === arr[2] ** 2;\n}\n"
- '    return a * a + b * b === c * c;

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    let arr = [a, b, c];\n    arr.sort((a, b) => a - b);\n    return arr[0] **\
  \ 2 + arr[1] ** 2 === arr[2] ** 2;\n}\n"
- "    if (a > b && a > c) {\n        return a * a === b * b + c * c;\n    } else\
  \ if (b > a && b > c) {\n        return b * b === a * a + c * c;\n    } else {\n\
  \        return c * c === a * a + b * b;\n    }\n}\n"
- "    let max = Math.max(a, b, c);\n    let sum = a + b + c - max;\n    return max\
  \ * max === sum * sum;\n}\n"
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- '    return a * a + b * b === c * c;

  }

  '
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- "    let sides = [a, b, c].sort((a, b) => a - b);\n    return sides[0] ** 2 + sides[1]\
  \ ** 2 === sides[2] ** 2;\n}\n"
- "    // TODO: implement this function\n    return false;\n}\n"
- "    // TODO: implement this function\n    return false;\n}\n"
- "    if (a > b && a > c) {\n        return Math.pow(a, 2) === Math.pow(b, 2) + Math.pow(c,\
  \ 2);\n    } else if (b > a && b > c) {\n        return Math.pow(b, 2) === Math.pow(a,\
  \ 2) + Math.pow(c, 2);\n    } else {\n        return Math.pow(c, 2) === Math.pow(a,\
  \ 2) + Math.pow(b, 2);\n    }\n}\n"
- "    let sides: number[] = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return\
  \ Math.pow(sides[0], 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return sides[0]\
  \ ** 2 + sides[1] ** 2 === sides[2] ** 2;\n}\n"
- '    return a * a + b * b === c * c || a * a + c * c === b * b || b * b + c * c
  === a * a;

  }

  '
- "    let arr = [a, b, c].sort((a, b) => a - b);\n    return arr[0] ** 2 + arr[1]\
  \ ** 2 === arr[2] ** 2;\n}\n"
- '    return a * a + b * b === c * c;

  }

  '
- "    let sides = [a, b, c].sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- "    let max = Math.max(a, b, c);\n    let sum = a + b + c - max;\n    return max\
  \ * max === sum * sum;\n}\n"
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- '    return (a*a + b*b == c*c) || (a*a + c*c == b*b) || (b*b + c*c == a*a);

  }

  '
- "    // TODO: implement the function\n    return false;\n}\n"
- "    if (a > b && a > c) {\n        return a * a === b * b + c * c;\n    } else\
  \ if (b > a && b > c) {\n        return b * b === a * a + c * c;\n    } else {\n\
  \        return c * c === a * a + b * b;\n    }\n}\n"
- '    return (a*a + b*b == c*c) || (a*a + c*c == b*b) || (b*b + c*c == a*a);

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    let max = Math.max(a, b, c);\n    let sum = a + b + c - max;\n    return max\
  \ * max === sum * sum;\n}\n"
- '    return (a ** 2 + b ** 2 === c ** 2) || (a ** 2 + c ** 2 === b ** 2) || (b **
  2 + c ** 2 === a ** 2);

  }

  '
- '    return a * a + b * b === c * c || a * a + c * c === b * b || b * b + c * c
  === a * a;

  }

  '
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return sides[0]\
  \ ** 2 + sides[1] ** 2 === sides[2] ** 2;\n}\n"
- "    let sides = [a, b, c].sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- "    let sides = [a, b, c].sort((a, b) => a - b);\n    return sides[0] ** 2 + sides[1]\
  \ ** 2 === sides[2] ** 2;\n}\n"
- "    if (a > b && a > c) {\n        return a * a === b * b + c * c;\n    } else\
  \ if (b > a && b > c) {\n        return b * b === a * a + c * c;\n    } else {\n\
  \        return c * c === a * a + b * b;\n    }\n}\n"
- "    // your code here\n    return false;\n}\n"
- '    return a * a + b * b === c * c || a * a + c * c === b * b || b * b + c * c
  === a * a;

  }

  '
- "    let result: boolean = false;\n    if (a * a + b * b == c * c) {\n        result\
  \ = true;\n    }\n    return result;\n}\n"
- "    if (a > b && a > c) {\n        return a * a === b * b + c * c;\n    } else\
  \ if (b > a && b > c) {\n        return b * b === a * a + c * c;\n    } else {\n\
  \        return c * c === a * a + b * b;\n    }\n}\n"
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    const sides = [a, b, c].sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- "    let arr = [a, b, c];\n    arr.sort((a, b) => a - b);\n    let [a, b, c] = arr;\n\
  \    return a * a + b * b === c * c;\n}\n"
- '    return a * a + b * b === c * c || a * a + c * c === b * b || b * b + c * c
  === a * a;

  }

  '
- "    // Your code here\n    return false;\n}\n"
- '    return (a ** 2 + b ** 2 === c ** 2) || (a ** 2 + c ** 2 === b ** 2) || (b **
  2 + c ** 2 === a ** 2);

  }

  '
- "    let max: number = Math.max(a, b, c);\n    let sum: number = a + b + c - max;\n\
  \    return max * max === sum * sum;\n}\n"
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return sides[0]\
  \ ** 2 + sides[1] ** 2 === sides[2] ** 2;\n}\n"
- "    let sides = [a, b, c].sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- "    if (a * a + b * b == c * c) {\n        return true;\n    }\n    if (a * a +\
  \ c * c == b * b) {\n        return true;\n    }\n    if (b * b + c * c == a * a)\
  \ {\n        return true;\n    }\n    return false;\n}\n"
- "    let arr = [a, b, c];\n    arr.sort((a, b) => a - b);\n    return Math.pow(arr[0],\
  \ 2) + Math.pow(arr[1], 2) === Math.pow(arr[2], 2);\n}\n"
- '    return (a*a + b*b == c*c) || (a*a + c*c == b*b) || (b*b + c*c == a*a);

  }

  '
- "    // Your code here\n    return false;\n}\n"
- '    return a*a + b*b == c*c;

  }

  '
- '    return a * a + b * b === c * c || a * a + c * c === b * b || b * b + c * c
  === a * a;

  }

  '
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- '    return a * a + b * b === c * c || a * a + c * c === b * b || b * b + c * c
  === a * a;

  }

  '
- "    // your code here\n    return false;\n}\n"
- '    return (a*a + b*b === c*c) || (a*a + c*c === b*b) || (b*b + c*c === a*a);

  }

  '
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    let [x, y, z]\
  \ = sides;\n    return x * x + y * y === z * z;\n}\n"
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- '    return (a*a + b*b == c*c) || (a*a + c*c == b*b) || (b*b + c*c == a*a);

  }

  '
- '    return (a * a + b * b === c * c) || (a * a + c * c === b * b) || (b * b + c
  * c === a * a);

  }

  '
- '    return (a*a + b*b === c*c) || (a*a + c*c === b*b) || (b*b + c*c === a*a);

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    // TODO: implement this function\n    return false;\n}\n"
- '    return (a*a + b*b == c*c) || (a*a + c*c == b*b) || (b*b + c*c == a*a);

  }

  '
- "    // TODO: implement this function\n    return false;\n}\n"
- "    if (a * a + b * b == c * c) {\n        return true;\n    }\n    if (a * a +\
  \ c * c == b * b) {\n        return true;\n    }\n    if (b * b + c * c == a * a)\
  \ {\n        return true;\n    }\n    return false;\n}\n"
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    // your code here\n    return false;\n}\n"
- "    let sides = [a, b, c];\n    sides.sort();\n    if (sides[0] * sides[0] + sides[1]\
  \ * sides[1] == sides[2] * sides[2]) {\n        return true;\n    }\n    return\
  \ false;\n}\n"
- "    if (a > b && a > c) {\n        return Math.pow(a, 2) === Math.pow(b, 2) + Math.pow(c,\
  \ 2);\n    } else if (b > a && b > c) {\n        return Math.pow(b, 2) === Math.pow(a,\
  \ 2) + Math.pow(c, 2);\n    } else {\n        return Math.pow(c, 2) === Math.pow(a,\
  \ 2) + Math.pow(b, 2);\n    }\n}\n"
- "    let max = Math.max(a, b, c);\n    let sum = a + b + c - max;\n    return max\
  \ * max === sum * sum;\n}\n"
- "    // Your code here\n    return false;\n}\n"
- '    return (a**2 + b**2 === c**2) || (a**2 + c**2 === b**2) || (b**2 + c**2 ===
  a**2);

  }

  '
- "    // TODO\n    return false;\n}\n"
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- "    if (a > b && a > c) {\n        return Math.pow(a, 2) === Math.pow(b, 2) + Math.pow(c,\
  \ 2);\n    } else if (b > a && b > c) {\n        return Math.pow(b, 2) === Math.pow(a,\
  \ 2) + Math.pow(c, 2);\n    } else {\n        return Math.pow(c, 2) === Math.pow(a,\
  \ 2) + Math.pow(b, 2);\n    }\n}\n"
- "    if (a > b && a > c) {\n        return a * a === b * b + c * c;\n    }\n   \
  \ if (b > a && b > c) {\n        return b * b === a * a + c * c;\n    }\n    if\
  \ (c > a && c > b) {\n        return c * c === a * a + b * b;\n    }\n    return\
  \ false;\n}\n"
- '    return a * a + b * b === c * c || a * a + c * c === b * b || b * b + c * c
  === a * a;

  }

  '
- "    let a2 = a * a;\n    let b2 = b * b;\n    let c2 = c * c;\n    if (a2 + b2\
  \ == c2 || b2 + c2 == a2 || c2 + a2 == b2) {\n        return true;\n    }\n    return\
  \ false;\n}\n"
- '    return (a ** 2 + b ** 2 === c ** 2) || (a ** 2 + c ** 2 === b ** 2) || (b **
  2 + c ** 2 === a ** 2);

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- '    return (a * a + b * b === c * c) || (a * a + c * c === b * b) || (b * b + c
  * c === a * a);

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    if (a > b && a > c) {\n        return a * a === b * b + c * c;\n    } else\
  \ if (b > a && b > c) {\n        return b * b === a * a + c * c;\n    } else {\n\
  \        return c * c === a * a + b * b;\n    }\n}\n"
- '    return (a**2 + b**2 == c**2) || (a**2 + c**2 == b**2) || (b**2 + c**2 == a**2);

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    let max = Math.max(a, b, c);\n    let sum = a + b + c - max;\n    return max\
  \ * max === sum * sum;\n}\n"
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return sides[0]\
  \ ** 2 + sides[1] ** 2 === sides[2] ** 2;\n}\n"
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    // your code here\n    return false;\n}\n"
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- "    let max = Math.max(a, b, c);\n    let sum = a + b + c - max;\n    return max\
  \ * max === sum * sum;\n}\n"
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- "    // TODO: implement this function\n    return false;\n}\n"
- "    let arr = [a, b, c];\n    arr.sort((a, b) => a - b);\n    return arr[0] **\
  \ 2 + arr[1] ** 2 === arr[2] ** 2;\n}\n"
- '    return a * a + b * b === c * c;

  }

  '
- '    return a**2 + b**2 === c**2;

  }

  '
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    let [x, y, z]\
  \ = sides;\n    return x * x + y * y === z * z;\n}\n"
- "    // TODO: implement this function\n    return false;\n}\n"
- '    return Math.pow(a, 2) + Math.pow(b, 2) === Math.pow(c, 2);

  }

  '
- "    // your code here\n    return false;\n}\n"
- "    let a2 = a * a;\n    let b2 = b * b;\n    let c2 = c * c;\n    return (a2 +\
  \ b2 == c2 || a2 + c2 == b2 || b2 + c2 == a2);\n}\n"
- '    return a * a + b * b === c * c;

  }

  '
- "    let max = Math.max(a, b, c);\n    let min = Math.min(a, b, c);\n    let mid\
  \ = a + b + c - max - min;\n    return max * max === min * min + mid * mid;\n}\n"
- "    let sides = [a, b, c].sort((a, b) => a - b);\n    return sides[0] ** 2 + sides[1]\
  \ ** 2 === sides[2] ** 2;\n}\n"
- "    if (a > b && a > c) {\n        return Math.pow(a, 2) === Math.pow(b, 2) + Math.pow(c,\
  \ 2);\n    } else if (b > a && b > c) {\n        return Math.pow(b, 2) === Math.pow(a,\
  \ 2) + Math.pow(c, 2);\n    } else {\n        return Math.pow(c, 2) === Math.pow(a,\
  \ 2) + Math.pow(b, 2);\n    }\n}\n"
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- '    return (a*a + b*b == c*c) || (a*a + c*c == b*b) || (b*b + c*c == a*a);

  }

  '
- "    let max = Math.max(a, b, c);\n    let sum = a + b + c - max;\n    return max\
  \ * max === sum * sum;\n}\n"
- "    if (a * a + b * b == c * c) {\n        return true;\n    }\n    else if (a\
  \ * a + c * c == b * b) {\n        return true;\n    }\n    else if (b * b + c *\
  \ c == a * a) {\n        return true;\n    }\n    else {\n        return false;\n\
  \    }\n}\n"
- '    return (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c *
  c == a * a);

  }

  '
- '    return a ** 2 + b ** 2 === c ** 2;

  }

  '
- '    return a * a + b * b === c * c;

  }

  '
- '    return (a*a + b*b == c*c) || (a*a + c*c == b*b) || (b*b + c*c == a*a);

  }

  '
- "    let result: boolean = false;\n    let sides: number[] = [a, b, c];\n    sides.sort((a,\
  \ b) => a - b);\n    if (Math.pow(sides[0], 2) + Math.pow(sides[1], 2) === Math.pow(sides[2],\
  \ 2)) {\n        result = true;\n    }\n    return result;\n}\n"
- "    let sides = [a, b, c];\n    sides.sort((a, b) => a - b);\n    return Math.pow(sides[0],\
  \ 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}\n"
- '    return (a ** 2 + b ** 2 === c ** 2) || (a ** 2 + c ** 2 === b ** 2) || (b **
  2 + c ** 2 === a ** 2);

  }

  '
language: ts
name: HumanEval_157_right_angle_triangle
prompt: "// @ts-nocheck\n\n//Given the lengths of the three sides of a triangle. Return\
  \ true if the three\n// sides form a right-angled triangle, false otherwise.\n//\
  \ A right-angled triangle is a triangle in which one angle is right angle or \n\
  // 90 degree.\n// Example:\n// >>> right_angle_triangle(3, 4, 5)\n// true\n// >>>\
  \ right_angle_triangle(1, 2, 3)\n// false\nfunction right_angle_triangle(a: number,\
  \ b: number, c: number): boolean {\n"
stop_tokens:
- '

  function '
- '

  /*'
- '

  //'
- '

  class'
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = right_angle_triangle;\n  assert.deepEqual(candidate(3,\
  \ 4, 5),true);\n  assert.deepEqual(candidate(1, 2, 3),false);\n  assert.deepEqual(candidate(10,\
  \ 6, 8),true);\n  assert.deepEqual(candidate(2, 2, 2),false);\n  assert.deepEqual(candidate(7,\
  \ 24, 25),true);\n  assert.deepEqual(candidate(10, 5, 7),false);\n  assert.deepEqual(candidate(5,\
  \ 12, 13),true);\n  assert.deepEqual(candidate(15, 8, 17),true);\n  assert.deepEqual(candidate(48,\
  \ 55, 73),true);\n  assert.deepEqual(candidate(1, 1, 1),false);\n  assert.deepEqual(candidate(2,\
  \ 2, 10),false);\n}\n\ntest();"
