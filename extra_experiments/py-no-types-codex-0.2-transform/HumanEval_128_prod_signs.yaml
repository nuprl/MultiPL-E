name: HumanEval_128_prod_signs
language: notypes.py
prompt: "def prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers\
  \ and you need to return\n    sum of magnitudes of integers multiplied by product\
  \ of all signs\n    of each number in the array, represented by 1, -1 or 0.\n  \
  \  Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2,\
  \ -4])\n    9\n    >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    None\n\
  \    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([1, 2, 2, -4]) == -9\n    assert\
  \ candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n\
  \    assert candidate([]) == None\n    assert candidate([2, 4, 1, 2, -1, -1, 9])\
  \ == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1,\
  \ 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\ndef test_check():\n\
  \    check(prod_signs)\n\ntest_check()\n"
completions: ["    if not arr:\n        return None\n    return sum(map(abs, arr))\
    \ * reduce(lambda x, y: x * y, map(lambda x: 1 if x > 0 else -1 if x < 0 else\
    \ 0, arr))\n\n", "    if not arr:\n        return None\n    prod = 1\n    sum_\
    \ = 0\n    for num in arr:\n        if num == 0:\n            continue\n     \
    \   sum_ += abs(num)\n        prod *= num / abs(num)\n    return sum_ * prod\n\
    \n", "    if not arr:\n        return None\n    prod = 1\n    sum_ = 0\n    for\
    \ i in arr:\n        if i > 0:\n            prod *= 1\n        elif i < 0:\n \
    \           prod *= -1\n        else:\n            prod *= 0\n        sum_ +=\
    \ abs(i)\n    return sum_ * prod\n\n", "    if not arr:\n        return None\n\
    \    else:\n        return sum(abs(x) for x in arr) * reduce(lambda x, y: x *\
    \ y, [1 if x > 0 else -1 if x < 0 else 0 for x in arr])\n\n", "    if not arr:\n\
    \        return None\n    prod = 1\n    sum_magn = 0\n    for num in arr:\n  \
    \      if num > 0:\n            prod *= 1\n        elif num < 0:\n           \
    \ prod *= -1\n        else:\n            prod *= 0\n        sum_magn += abs(num)\n\
    \    return sum_magn * prod\n\n", "    if not arr:\n        return None\n    prod\
    \ = 1\n    sum_ = 0\n    for i in arr:\n        if i > 0:\n            prod *=\
    \ 1\n        elif i < 0:\n            prod *= -1\n        else:\n            prod\
    \ *= 0\n        sum_ += abs(i)\n    return sum_ * prod\n\n", "    if not arr:\n\
    \        return None\n    prod = 1\n    sum_magn = 0\n    for num in arr:\n  \
    \      if num > 0:\n            prod *= 1\n        elif num < 0:\n           \
    \ prod *= -1\n        else:\n            prod *= 0\n        sum_magn += abs(num)\n\
    \    return sum_magn * prod\n\n", "    if not arr:\n        return None\n    else:\n\
    \        return sum(map(abs, arr)) * reduce(lambda x, y: x * y, map(lambda x:\
    \ 1 if x > 0 else -1 if x < 0 else 0, arr))\n\n", "    if not arr:\n        return\
    \ None\n    return sum(abs(x) for x in arr) * reduce(lambda x, y: x * y, (1 if\
    \ x > 0 else -1 if x < 0 else 0 for x in arr))\n\n", "    if not arr:\n      \
    \  return None\n    return sum(map(abs, arr)) * reduce(lambda x, y: x * y, map(sign,\
    \ arr))\n\n", "    if not arr:\n        return None\n    prod = 1\n    sum_ =\
    \ 0\n    for i in arr:\n        if i < 0:\n            prod *= -1\n        elif\
    \ i == 0:\n            prod = 0\n        sum_ += abs(i)\n    return sum_ * prod\n\
    \n", "    if not arr:\n        return None\n    prod = 1\n    sum_ = 0\n    for\
    \ i in arr:\n        if i > 0:\n            prod *= 1\n        elif i < 0:\n \
    \           prod *= -1\n        else:\n            prod *= 0\n        sum_ +=\
    \ abs(i)\n    return sum_ * prod\n\n", "    if not arr:\n        return None\n\
    \    prod = 1\n    sum_ = 0\n    for i in arr:\n        if i > 0:\n          \
    \  prod *= 1\n        elif i < 0:\n            prod *= -1\n        else:\n   \
    \         prod *= 0\n        sum_ += abs(i)\n    return sum_ * prod\n\n", "  \
    \  if not arr:\n        return None\n    return sum(abs(i) for i in arr) * reduce(lambda\
    \ x, y: x * y, (1 if i >= 0 else -1 for i in arr))\n\n", "    if not arr:\n  \
    \      return None\n    prod = 1\n    sum_ = 0\n    for i in arr:\n        if\
    \ i > 0:\n            prod *= 1\n        elif i < 0:\n            prod *= -1\n\
    \        else:\n            prod *= 0\n        sum_ += abs(i)\n    return sum_\
    \ * prod\n\n", "    if not arr:\n        return None\n    return sum(abs(x) for\
    \ x in arr) * reduce(lambda x, y: x * y, (1 if x >= 0 else -1 if x < 0 else 0\
    \ for x in arr))\n\n", "    if not arr:\n        return None\n    prod = 1\n \
    \   sum_ = 0\n    for i in arr:\n        if i == 0:\n            prod = 0\n  \
    \          break\n        elif i > 0:\n            prod *= 1\n        else:\n\
    \            prod *= -1\n        sum_ += abs(i)\n    return sum_ * prod\n\n",
  "    if not arr:\n        return None\n    prod = 1\n    sum_ = 0\n    for i in\
    \ arr:\n        if i > 0:\n            prod *= 1\n        elif i < 0:\n      \
    \      prod *= -1\n        else:\n            prod *= 0\n        sum_ += abs(i)\n\
    \    return sum_ * prod\n\n", "    if not arr:\n        return None\n    prod\
    \ = 1\n    sum_magn = 0\n    for num in arr:\n        if num > 0:\n          \
    \  prod *= 1\n        elif num < 0:\n            prod *= -1\n        else:\n \
    \           prod *= 0\n        sum_magn += abs(num)\n    return sum_magn * prod\n\
    \n", "    if not arr:\n        return None\n    prod = 1\n    sum_ = 0\n    for\
    \ num in arr:\n        if num > 0:\n            prod *= 1\n        elif num <\
    \ 0:\n            prod *= -1\n        else:\n            prod *= 0\n        sum_\
    \ += abs(num)\n    return sum_ * prod\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
