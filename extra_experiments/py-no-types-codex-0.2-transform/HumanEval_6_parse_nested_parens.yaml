name: HumanEval_6_parse_nested_parens
language: notypes.py
prompt: "def parse_nested_parens(paren_string):\n    \"\"\" Input to this function\
  \ is a string represented multiple groups for nested parentheses separated by spaces.\n\
  \    For each of the group, output the deepest level of nesting of parentheses.\n\
  \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n \
  \   >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n \
  \   \"\"\"\n"
tests: "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
  \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
  \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
  \ntest_check()\n"
completions: ["    paren_groups = paren_string.split(' ')\n    max_nesting = []\n\
    \    for paren_group in paren_groups:\n        max_nesting.append(parse_parens(paren_group))\n\
    \    return max_nesting\n\n", "    # TODO: Implement this function\n    pass\n\
    \n", "    paren_groups = paren_string.split(' ')\n    max_nesting = []\n    for\
    \ group in paren_groups:\n        max_nesting.append(max_nesting_level(group))\n\
    \    return max_nesting\n\n", "    return [parse_parens(paren_string) for paren_string\
    \ in paren_string.split()]\n\n", "    return [parse_parens(paren_string) for paren_string\
    \ in paren_string.split()]\n\n", "    return [max_nesting_parens(paren_string)\
    \ for paren_string in paren_string.split()]\n\n", "    paren_groups = paren_string.split()\n\
    \    return [max_nested_parens(group) for group in paren_groups]\n\n", "    paren_groups\
    \ = paren_string.split()\n    return [max_nesting_level(group) for group in paren_groups]\n\
    \n", "    paren_groups = paren_string.split()\n    max_nesting = []\n    for group\
    \ in paren_groups:\n        max_nesting.append(max_nesting_parens(group))\n  \
    \  return max_nesting\n\n", "    # TODO: Implement this function\n    pass\n\n",
  "    paren_list = paren_string.split()\n    max_nesting = []\n    for paren in paren_list:\n\
    \        max_nesting.append(max_nesting_parens(paren))\n    return max_nesting\n\
    \n", "    paren_groups = paren_string.split(' ')\n    max_nesting = []\n    for\
    \ group in paren_groups:\n        max_nesting.append(find_max_nesting(group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for paren_group in paren_groups:\n        max_nesting.append(get_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    paren_list = paren_string.split()\n    paren_depth\
    \ = []\n    for paren in paren_list:\n        paren_depth.append(paren_depth_helper(paren))\n\
    \    return paren_depth\n\n", "    paren_list = paren_string.split(' ')\n    return\
    \ [max_nesting_parens(paren) for paren in paren_list]\n\n", "    paren_groups\
    \ = paren_string.split()\n    max_nesting = []\n    for group in paren_groups:\n\
    \        max_nesting.append(max_nesting_parens(group))\n    return max_nesting\n\
    \n", "    paren_string = paren_string.strip()\n    paren_groups = paren_string.split('\
    \ ')\n    max_nesting = []\n    for paren_group in paren_groups:\n        max_nesting.append(parse_parens(paren_group))\n\
    \    return max_nesting\n\n", "    paren_list = paren_string.split()\n    max_nesting\
    \ = []\n    for paren in paren_list:\n        max_nesting.append(max_nesting_parens(paren))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for group in paren_groups:\n        max_nesting.append(find_max_nesting(group))\n\
    \    return max_nesting\n\n", "    return [paren_string.count('(') - paren_string.count(')')]\n\
    \n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
