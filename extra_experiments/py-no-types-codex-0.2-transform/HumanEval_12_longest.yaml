name: HumanEval_12_longest
language: notypes.py
prompt: "def longest(strings):\n    \"\"\" Out of list of strings, return the longest\
  \ one. Return the first one in case of multiple\n    strings of the same length.\
  \ Return None in case the input list is empty.\n    >>> longest([])\n    None\n\
  \    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n\
  \    'ccc'\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x',\
  \ 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc'])\
  \ == 'zzzz'\n\ndef test_check():\n    check(longest)\n\ntest_check()\n"
completions: ["    if not strings:\n        return None\n    return max(strings, key=len)\n\
    \n", "    if not strings:\n        return None\n    longest_string = strings[0]\n\
    \    for string in strings:\n        if len(string) > len(longest_string):\n \
    \           longest_string = string\n    return longest_string\n\n", "    if not\
    \ strings:\n        return None\n    return max(strings, key=len)\n\n", "    if\
    \ not strings:\n        return None\n    longest_string = strings[0]\n    for\
    \ string in strings:\n        if len(string) > len(longest_string):\n        \
    \    longest_string = string\n    return longest_string\n\n", "    if not strings:\n\
    \        return None\n    return max(strings, key=len)\n\n", "    if len(strings)\
    \ == 0:\n        return None\n    else:\n        longest = strings[0]\n      \
    \  for s in strings:\n            if len(s) > len(longest):\n                longest\
    \ = s\n        return longest\n\n", "    if not strings:\n        return None\n\
    \    longest_string = strings[0]\n    for string in strings:\n        if len(string)\
    \ > len(longest_string):\n            longest_string = string\n    return longest_string\n\
    \n", "    if not strings:\n        return None\n    return max(strings, key=len)\n\
    \n", "    if not strings:\n        return None\n    else:\n        return reduce(lambda\
    \ a, b: a if len(a) > len(b) else b, strings)\n\n", "    if not strings:\n   \
    \     return None\n    else:\n        return max(strings, key=len)\n\n", "   \
    \ if not strings:\n        return None\n    return max(strings, key=len)\n\n",
  "    if not strings:\n        return None\n    longest_string = strings[0]\n   \
    \ for string in strings:\n        if len(string) > len(longest_string):\n    \
    \        longest_string = string\n    return longest_string\n\n", "    if len(strings)\
    \ == 0:\n        return None\n    else:\n        return max(strings, key=len)\n\
    \n", "    if not strings:\n        return None\n    longest_string = strings[0]\n\
    \    for string in strings:\n        if len(string) > len(longest_string):\n \
    \           longest_string = string\n    return longest_string\n\n", "    if not\
    \ strings:\n        return None\n    else:\n        return max(strings, key=len)\n\
    \n", "    if len(strings) == 0:\n        return None\n    else:\n        longest\
    \ = strings[0]\n        for string in strings:\n            if len(string) > len(longest):\n\
    \                longest = string\n        return longest\n\n", "    if not strings:\n\
    \        return None\n    else:\n        return max(strings, key=len)\n\n", " \
    \   if not strings:\n        return None\n    return max(strings, key=len)\n\n",
  "    if len(strings) == 0:\n        return None\n    else:\n        longest = strings[0]\n\
    \        for string in strings:\n            if len(string) > len(longest):\n\
    \                longest = string\n        return longest\n\n", "    if not strings:\n\
    \        return None\n    longest_string = strings[0]\n    for string in strings:\n\
    \        if len(string) > len(longest_string):\n            longest_string = string\n\
    \    return longest_string\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
