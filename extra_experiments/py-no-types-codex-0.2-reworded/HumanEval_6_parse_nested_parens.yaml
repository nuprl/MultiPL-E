name: HumanEval_6_parse_nested_parens
language: notypes.py
prompt: "def parse_nested_parens(paren_string):\n    \"\"\" Input to this function\
  \ is a string represented multiple groups for nested parentheses separated by spaces.\n\
  \    For each of the group, output the deepest level of nesting of parentheses.\n\
  \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n \
  \   >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n \
  \   \"\"\"\n"
tests: "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
  \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
  \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
  \ntest_check()\n"
completions: ["    paren_groups = paren_string.split(' ')\n    max_nesting = []\n\
    \    for paren_group in paren_groups:\n        max_nesting.append(parse_parens(paren_group))\n\
    \    return max_nesting\n\n", "    # TODO: Implement this function\n    pass\n\
    \n", "    paren_groups = paren_string.split(' ')\n    max_nesting = []\n    for\
    \ group in paren_groups:\n        max_nesting.append(max_nesting_level(group))\n\
    \    return max_nesting\n\n", "    return [parse_parens(paren_string) for paren_string\
    \ in paren_string.split()]\n\n", "    return [parse_parens(paren_string) for paren_string\
    \ in paren_string.split()]\n\n", "    return [max_nesting_parens(paren_string)\
    \ for paren_string in paren_string.split()]\n\n", "    paren_groups = paren_string.split()\n\
    \    return [max_nested_parens(group) for group in paren_groups]\n\n", "    paren_groups\
    \ = paren_string.split()\n    return [max_nesting_level(group) for group in paren_groups]\n\
    \n", "    paren_groups = paren_string.split()\n    max_nesting = []\n    for group\
    \ in paren_groups:\n        max_nesting.append(max_nesting_parens(group))\n  \
    \  return max_nesting\n\n", "    # TODO: Implement this function\n    pass\n\n",
  "    paren_list = paren_string.split()\n    max_nesting = []\n    for paren in paren_list:\n\
    \        max_nesting.append(max_nesting_parens(paren))\n    return max_nesting\n\
    \n", "    paren_groups = paren_string.split(' ')\n    max_nesting = []\n    for\
    \ group in paren_groups:\n        max_nesting.append(find_max_nesting(group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for paren_group in paren_groups:\n        max_nesting.append(get_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    paren_list = paren_string.split()\n    paren_depth\
    \ = []\n    for paren in paren_list:\n        paren_depth.append(paren_depth_helper(paren))\n\
    \    return paren_depth\n\n", "    paren_list = paren_string.split(' ')\n    return\
    \ [max_nesting_parens(paren) for paren in paren_list]\n\n", "    paren_groups\
    \ = paren_string.split()\n    max_nesting = []\n    for group in paren_groups:\n\
    \        max_nesting.append(max_nesting_parens(group))\n    return max_nesting\n\
    \n", "    paren_string = paren_string.strip()\n    paren_groups = paren_string.split('\
    \ ')\n    max_nesting = []\n    for paren_group in paren_groups:\n        max_nesting.append(parse_parens(paren_group))\n\
    \    return max_nesting\n\n", "    paren_list = paren_string.split()\n    max_nesting\
    \ = []\n    for paren in paren_list:\n        max_nesting.append(max_nesting_parens(paren))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for group in paren_groups:\n        max_nesting.append(find_max_nesting(group))\n\
    \    return max_nesting\n\n", "    return [paren_string.count('(') - paren_string.count(')')]\n\
    \n", "    # TODO: Implement this function\n    pass\n\n", "    paren_groups =\
    \ paren_string.split(' ')\n    return [max_nested_parens(group) for group in paren_groups]\n\
    \n", "    paren_list = paren_string.split()\n    return [max_nested_parens(paren)\
    \ for paren in paren_list]\n\n", "    paren_list = paren_string.split()\n    max_depth\
    \ = []\n    for paren in paren_list:\n        depth = 0\n        max_depth_so_far\
    \ = 0\n        for char in paren:\n            if char == '(':\n             \
    \   depth += 1\n                max_depth_so_far = max(max_depth_so_far, depth)\n\
    \            elif char == ')':\n                depth -= 1\n        max_depth.append(max_depth_so_far)\n\
    \    return max_depth\n\n", "    # TODO: implement this function\n    pass\n\n",
  "    return [max_nested_parens(paren_string) for paren_string in paren_string.split()]\n\
    \n", "    paren_groups = paren_string.split(' ')\n    max_nesting = []\n    for\
    \ paren_group in paren_groups:\n        max_nesting.append(get_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    return\
    \ [max_nested_parens(paren_group) for paren_group in paren_groups]\n\n", "   \
    \ paren_groups = paren_string.split()\n    max_nesting = []\n    for paren_group\
    \ in paren_groups:\n        max_nesting.append(max_nesting_level(paren_group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split(' ')\n  \
    \  return [max_nested_parens(group) for group in paren_groups]\n\n", "    result\
    \ = []\n    for paren_group in paren_string.split():\n        result.append(parse_parens(paren_group))\n\
    \    return result\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for group in paren_groups:\n        max_nesting.append(find_max_nesting(group))\n\
    \    return max_nesting\n\n", "    return [max_nested_parens(paren_string) for\
    \ paren_string in paren_string.split()]\n\n", "    paren_groups = paren_string.split()\n\
    \    max_nesting = []\n    for paren_group in paren_groups:\n        max_nesting.append(get_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    # TODO: Implement this function\n    pass\n\
    \n", "    paren_groups = paren_string.split(' ')\n    max_nesting = []\n    for\
    \ group in paren_groups:\n        max_nesting.append(get_max_nesting(group))\n\
    \    return max_nesting\n\n", "    return [max_nested_parens(paren_group) for\
    \ paren_group in paren_string.split()]\n\n", "    paren_groups = paren_string.split()\n\
    \    return [max_nested_parens(group) for group in paren_groups]\n\n", "    paren_groups\
    \ = paren_string.split()\n    max_nesting = []\n    for paren_group in paren_groups:\n\
    \        max_nesting.append(get_max_nesting(paren_group))\n    return max_nesting\n\
    \n", "    return [max_nested_parens(paren_string) for paren_string in paren_string.split()]\n\
    \n", "    paren_groups = paren_string.split(' ')\n    max_nesting = []\n    for\
    \ paren_group in paren_groups:\n        max_nesting.append(find_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    paren_string = paren_string.replace(' ', '')\n\
    \    max_nesting = 0\n    current_nesting = 0\n    result = []\n    for char in\
    \ paren_string:\n        if char == '(':\n            current_nesting += 1\n \
    \           max_nesting = max(max_nesting, current_nesting)\n        elif char\
    \ == ')':\n            current_nesting -= 1\n        else:\n            result.append(max_nesting)\n\
    \            max_nesting = 0\n            current_nesting = 0\n    result.append(max_nesting)\n\
    \    return result\n\n", "    return [max_nested_parens(paren_string) for paren_string\
    \ in paren_string.split()]\n\n", "    paren_list = paren_string.split(' ')\n \
    \   max_nesting = []\n    for paren in paren_list:\n        max_nesting.append(get_max_nesting(paren))\n\
    \    return max_nesting\n\n", "    paren_list = paren_string.split()\n    max_nesting\
    \ = []\n    for paren in paren_list:\n        max_nesting.append(max_nesting_parens(paren))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split(' ')\n  \
    \  return [max_nested_parens(group) for group in paren_groups]\n\n", "    return\
    \ [max_nested_parens(paren_string) for paren_string in paren_string.split()]\n\
    \n", "    paren_list = paren_string.split()\n    return [max_nested_parens(paren)\
    \ for paren in paren_list]\n\n", "    paren_groups = paren_string.split()\n  \
    \  return [max_nested_parens(group) for group in paren_groups]\n\n", "    paren_groups\
    \ = paren_string.split(' ')\n    max_nesting = []\n    for group in paren_groups:\n\
    \        max_nesting.append(find_max_nesting(group))\n    return max_nesting\n\
    \n", "    paren_list = paren_string.split()\n    return [max_nested_parens(paren_group)\
    \ for paren_group in paren_list]\n\n", "    paren_groups = paren_string.split()\n\
    \    max_nesting = []\n    for paren_group in paren_groups:\n        max_nesting.append(find_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    # TODO: Implement this function\n    return\
    \ []\n\n", "    paren_list = paren_string.split(' ')\n    return [max_nested_parens(paren)\
    \ for paren in paren_list]\n\n", "    paren_groups = paren_string.split(' ')\n\
    \    max_nesting = []\n    for paren_group in paren_groups:\n        max_nesting.append(parse_parens(paren_group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split(' ')\n  \
    \  max_nesting = []\n    for group in paren_groups:\n        max_nesting.append(find_max_nesting(group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split(' ')\n  \
    \  return [max_nested_parens(group) for group in paren_groups]\n\n", "    # TODO:\
    \ Implement this function\n    pass\n\n", "    paren_list = paren_string.split()\n\
    \    max_depth = []\n    for paren in paren_list:\n        depth = 0\n       \
    \ max_depth_so_far = 0\n        for c in paren:\n            if c == '(':\n  \
    \              depth += 1\n                max_depth_so_far = max(max_depth_so_far,\
    \ depth)\n            elif c == ')':\n                depth -= 1\n        max_depth.append(max_depth_so_far)\n\
    \    return max_depth\n\n", "    paren_list = paren_string.split()\n    max_depth\
    \ = []\n    for paren in paren_list:\n        depth = 0\n        max_depth_so_far\
    \ = 0\n        for char in paren:\n            if char == '(':\n             \
    \   depth += 1\n                max_depth_so_far = max(max_depth_so_far, depth)\n\
    \            elif char == ')':\n                depth -= 1\n        max_depth.append(max_depth_so_far)\n\
    \    return max_depth\n\n", "    paren_groups = paren_string.split(' ')\n    return\
    \ [max_nested_parens(group) for group in paren_groups]\n\n", "    paren_groups\
    \ = paren_string.split(' ')\n    max_nesting = []\n    for paren_group in paren_groups:\n\
    \        max_nesting.append(find_max_nesting(paren_group))\n    return max_nesting\n\
    \n", "    # TODO: Write your code here\n    pass\n\n", "    # TODO: complete this\
    \ function\n    pass\n\n", "    paren_groups = paren_string.split()\n    max_depth\
    \ = []\n    for group in paren_groups:\n        depth = 0\n        max_depth_group\
    \ = 0\n        for char in group:\n            if char == '(':\n             \
    \   depth += 1\n                max_depth_group = max(max_depth_group, depth)\n\
    \            elif char == ')':\n                depth -= 1\n        max_depth.append(max_depth_group)\n\
    \    return max_depth\n\n", "    paren_list = paren_string.split(' ')\n    max_nesting\
    \ = []\n    for paren in paren_list:\n        max_nesting.append(get_max_nesting(paren))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    return\
    \ [max_nested_parens(group) for group in paren_groups]\n\n", "    paren_list =\
    \ paren_string.split(' ')\n    output = []\n    for paren in paren_list:\n   \
    \     output.append(max_nested_parens(paren))\n    return output\n\n", "    paren_groups\
    \ = paren_string.split()\n    max_nesting = []\n    for group in paren_groups:\n\
    \        max_nesting.append(max_nesting_parens(group))\n    return max_nesting\n\
    \n", "    paren_groups = paren_string.split()\n    max_nesting = []\n    for paren_group\
    \ in paren_groups:\n        max_nesting.append(parse_parens(paren_group))\n  \
    \  return max_nesting\n\n", "    paren_list = paren_string.split()\n    max_depth\
    \ = []\n    for paren in paren_list:\n        depth = 0\n        max_depth_so_far\
    \ = 0\n        for char in paren:\n            if char == '(':\n             \
    \   depth += 1\n                max_depth_so_far = max(max_depth_so_far, depth)\n\
    \            elif char == ')':\n                depth -= 1\n        max_depth.append(max_depth_so_far)\n\
    \    return max_depth\n", "    # TODO: implement this function\n    pass\n", " \
    \   paren_string = paren_string.strip()\n    paren_groups = paren_string.split('\
    \ ')\n    max_nesting = []\n    for paren_group in paren_groups:\n        max_nesting.append(find_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split(' ')\n  \
    \  max_nesting = []\n    for group in paren_groups:\n        max_nesting.append(get_max_nesting(group))\n\
    \    return max_nesting\n\n", "    paren_list = paren_string.split()\n    max_levels\
    \ = []\n    for paren in paren_list:\n        level = 0\n        max_level = 0\n\
    \        for char in paren:\n            if char == '(':\n                level\
    \ += 1\n                if level > max_level:\n                    max_level =\
    \ level\n            elif char == ')':\n                level -= 1\n        max_levels.append(max_level)\n\
    \    return max_levels\n\n", "    return [max_nested_parens(paren_string) for\
    \ paren_string in paren_string.split()]\n\n", "    paren_groups = paren_string.split()\n\
    \    max_nesting = []\n    for paren_group in paren_groups:\n        max_nesting.append(get_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    return\
    \ [max_nested_parens(group) for group in paren_groups]\n\n", "    paren_list =\
    \ paren_string.split(' ')\n    return [max_nested_parens(paren) for paren in paren_list]\n",
  "    paren_list = paren_string.split(' ')\n    max_nesting = []\n    for paren in\
    \ paren_list:\n        max_nesting.append(get_max_nesting(paren))\n    return\
    \ max_nesting\n\n", "    output = []\n    for paren_group in paren_string.split():\n\
    \        max_nesting = 0\n        current_nesting = 0\n        for paren in paren_group:\n\
    \            if paren == '(':\n                current_nesting += 1\n        \
    \        max_nesting = max(max_nesting, current_nesting)\n            elif paren\
    \ == ')':\n                current_nesting -= 1\n        output.append(max_nesting)\n\
    \    return output\n\n", "    return [max_nested_parens(paren_string) for paren_string\
    \ in paren_string.split()]\n\n", "    max_depth = 0\n    current_depth = 0\n \
    \   result = []\n    for char in paren_string:\n        if char == '(':\n    \
    \        current_depth += 1\n            max_depth = max(max_depth, current_depth)\n\
    \        elif char == ')':\n            current_depth -= 1\n        elif char\
    \ == ' ':\n            result.append(max_depth)\n            max_depth = 0\n \
    \           current_depth = 0\n    result.append(max_depth)\n    return result\n\
    \n", "    paren_groups = paren_string.split()\n    max_depth = []\n    for paren_group\
    \ in paren_groups:\n        depth = 0\n        max_depth_so_far = 0\n        for\
    \ paren in paren_group:\n            if paren == '(':\n                depth +=\
    \ 1\n                max_depth_so_far = max(max_depth_so_far, depth)\n       \
    \     elif paren == ')':\n                depth -= 1\n        max_depth.append(max_depth_so_far)\n\
    \    return max_depth\n\n", "    paren_groups = paren_string.split(' ')\n    max_nesting\
    \ = []\n    for group in paren_groups:\n        max_nesting.append(get_max_nesting(group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    return\
    \ [max_nested_parens(group) for group in paren_groups]\n\n", "    paren_groups\
    \ = paren_string.split()\n    return [max_nesting_level(paren_group) for paren_group\
    \ in paren_groups]\n\n", "    paren_list = paren_string.split()\n    max_nesting\
    \ = []\n    for paren in paren_list:\n        max_nesting.append(max_nesting_parens(paren))\n\
    \    return max_nesting\n\n", "    return [max_nested_parens(paren_string) for\
    \ paren_string in paren_string.split()]\n\n", "    # TODO: implement this function\n\
    \    pass\n", "    paren_list = paren_string.split()\n    return [paren_depth(paren)\
    \ for paren in paren_list]\n", "    return [max_nested_parens(paren_string) for\
    \ paren_string in paren_string.split()]\n\n", "    paren_groups = paren_string.split()\n\
    \    max_nesting = []\n    for paren_group in paren_groups:\n        max_nesting.append(max_nesting_level(paren_group))\n\
    \    return max_nesting\n\n", "    paren_list = paren_string.split(' ')\n    max_nesting\
    \ = []\n    for paren in paren_list:\n        max_nesting.append(max_nesting_parens(paren))\n\
    \    return max_nesting\n\n", "    # TODO: Implement this function\n    pass\n\
    \n", "    paren_list = paren_string.split(' ')\n    return [max_nested_parens(paren)\
    \ for paren in paren_list]\n\n", "    paren_groups = paren_string.split()\n  \
    \  max_nesting = []\n    for paren_group in paren_groups:\n        max_nesting.append(parse_nested_parens_helper(paren_group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for paren_group in paren_groups:\n        max_nesting.append(get_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    max_depth\
    \ = []\n    for group in paren_groups:\n        depth = 0\n        max_depth_in_group\
    \ = 0\n        for char in group:\n            if char == '(':\n             \
    \   depth += 1\n                max_depth_in_group = max(max_depth_in_group, depth)\n\
    \            elif char == ')':\n                depth -= 1\n        max_depth.append(max_depth_in_group)\n\
    \    return max_depth\n\n", "    paren_list = paren_string.split()\n    max_nesting\
    \ = []\n    for paren in paren_list:\n        max_nesting.append(get_max_nesting(paren))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split(' ')\n  \
    \  return [max_nesting_level(paren_group) for paren_group in paren_groups]\n\n",
  "    paren_groups = paren_string.split()\n    max_nesting = []\n    for group in\
    \ paren_groups:\n        max_nesting.append(max_nesting_parens(group))\n    return\
    \ max_nesting\n\n", "    paren_groups = paren_string.split(' ')\n    deepest_levels\
    \ = []\n    for group in paren_groups:\n        deepest_levels.append(find_deepest_level(group))\n\
    \    return deepest_levels\n\n", "    # TODO: implement this function\n    pass\n\
    \n", "    paren_groups = paren_string.split()\n    max_nesting = []\n    for group\
    \ in paren_groups:\n        max_nesting.append(max_nesting_parens(group))\n  \
    \  return max_nesting\n\n", "    paren_list = paren_string.split()\n    return\
    \ [max_level_of_nesting(paren) for paren in paren_list]\n\n", "    paren_list\
    \ = paren_string.split()\n    max_nesting = []\n    for paren in paren_list:\n\
    \        max_nesting.append(get_max_nesting(paren))\n    return max_nesting\n\n",
  "    paren_groups = paren_string.split()\n    return [max_nested_parens(group) for\
    \ group in paren_groups]\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for paren_group in paren_groups:\n        max_nesting.append(find_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    paren_list = paren_string.split()\n    max_depth\
    \ = []\n    for paren in paren_list:\n        depth = 0\n        max_depth_so_far\
    \ = 0\n        for char in paren:\n            if char == '(':\n             \
    \   depth += 1\n                max_depth_so_far = max(max_depth_so_far, depth)\n\
    \            elif char == ')':\n                depth -= 1\n        max_depth.append(max_depth_so_far)\n\
    \    return max_depth\n\n", "    paren_groups = paren_string.split(' ')\n    max_nesting\
    \ = []\n    for paren_group in paren_groups:\n        max_nesting.append(parse_parens(paren_group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    max_depth\
    \ = []\n    for paren_group in paren_groups:\n        depth = 0\n        max_depth_in_group\
    \ = 0\n        for paren in paren_group:\n            if paren == '(':\n     \
    \           depth += 1\n                max_depth_in_group = max(max_depth_in_group,\
    \ depth)\n            elif paren == ')':\n                depth -= 1\n       \
    \ max_depth.append(max_depth_in_group)\n    return max_depth\n\n", "    paren_groups\
    \ = paren_string.split()\n    return [max_nested_parens(paren_group) for paren_group\
    \ in paren_groups]\n\n", "    paren_list = paren_string.split()\n    max_nesting\
    \ = []\n    for paren in paren_list:\n        max_nesting.append(find_max_nesting(paren))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split(' ')\n  \
    \  return [max_nested_parens(group) for group in paren_groups]\n\n", "    groups\
    \ = paren_string.split()\n    return [max_nesting(group) for group in groups]\n\
    \n", "    paren_list = paren_string.split(' ')\n    max_depth = []\n    for paren\
    \ in paren_list:\n        max_depth.append(find_max_depth(paren))\n    return\
    \ max_depth\n\n", "    paren_groups = paren_string.split(' ')\n    return [max_nested_parens(group)\
    \ for group in paren_groups]\n\n", "    paren_list = paren_string.split()\n  \
    \  max_depth = []\n    for paren in paren_list:\n        max_depth.append(max_nested_parens(paren))\n\
    \    return max_depth\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for group in paren_groups:\n        max_nesting.append(parse_nested_parens_helper(group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for paren_group in paren_groups:\n        max_nesting.append(max_nesting_parens(paren_group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    return\
    \ [max_nesting_level(group) for group in paren_groups]\n\n", "    paren_groups\
    \ = paren_string.split(' ')\n    max_depth = []\n    for group in paren_groups:\n\
    \        depth = 0\n        max_depth_so_far = 0\n        for paren in group:\n\
    \            if paren == '(':\n                depth += 1\n                max_depth_so_far\
    \ = max(max_depth_so_far, depth)\n            elif paren == ')':\n           \
    \     depth -= 1\n        max_depth.append(max_depth_so_far)\n    return max_depth\n\
    \n", "    paren_groups = paren_string.split()\n    return [max_nested_parens(group)\
    \ for group in paren_groups]\n\n", "    paren_list = paren_string.split()\n  \
    \  max_depth = []\n    for paren in paren_list:\n        depth = 0\n        max_depth_so_far\
    \ = 0\n        for char in paren:\n            if char == '(':\n             \
    \   depth += 1\n                max_depth_so_far = max(max_depth_so_far, depth)\n\
    \            elif char == ')':\n                depth -= 1\n        max_depth.append(max_depth_so_far)\n\
    \    return max_depth\n\n", "    paren_list = paren_string.split(' ')\n    return\
    \ [max_nesting_parens(paren) for paren in paren_list]\n\n", "    result = []\n\
    \    for paren_group in paren_string.split():\n        max_level = 0\n       \
    \ current_level = 0\n        for paren in paren_group:\n            if paren ==\
    \ '(':\n                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            elif paren == ')':\n                current_level\
    \ -= 1\n        result.append(max_level)\n    return result\n\n", "    paren_groups\
    \ = paren_string.split()\n    max_depth = []\n    for group in paren_groups:\n\
    \        depth = 0\n        max_depth_in_group = 0\n        for char in group:\n\
    \            if char == '(':\n                depth += 1\n                max_depth_in_group\
    \ = max(max_depth_in_group, depth)\n            elif char == ')':\n          \
    \      depth -= 1\n        max_depth.append(max_depth_in_group)\n    return max_depth\n\
    \n", "    paren_groups = paren_string.split(' ')\n    return [parse_nested_parens_helper(paren_group)\
    \ for paren_group in paren_groups]\n\n", "    # TODO: Implement this function\n\
    \    pass\n\n", "    paren_groups = paren_string.split()\n    return [max_nested_parens(group)\
    \ for group in paren_groups]\n\n", "    paren_groups = paren_string.split(' ')\n\
    \    max_levels = []\n    for paren_group in paren_groups:\n        max_level\
    \ = 0\n        level = 0\n        for char in paren_group:\n            if char\
    \ == '(':\n                level += 1\n                max_level = max(max_level,\
    \ level)\n            elif char == ')':\n                level -= 1\n        max_levels.append(max_level)\n\
    \    return max_levels\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for paren_group in paren_groups:\n        max_nesting.append(get_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    return\
    \ [max_nesting_level(group) for group in paren_groups]\n\n", "    paren_groups\
    \ = paren_string.split()\n    max_nesting = []\n    for group in paren_groups:\n\
    \        max_nesting.append(find_max_nesting(group))\n    return max_nesting\n\
    \n", "    paren_groups = paren_string.split(' ')\n    return [max_nesting_level(group)\
    \ for group in paren_groups]\n\n", "    groups = paren_string.split(' ')\n   \
    \ max_depth = []\n    for group in groups:\n        depth = 0\n        max_depth_in_group\
    \ = 0\n        for char in group:\n            if char == '(':\n             \
    \   depth += 1\n                max_depth_in_group = max(max_depth_in_group, depth)\n\
    \            elif char == ')':\n                depth -= 1\n        max_depth.append(max_depth_in_group)\n\
    \    return max_depth\n\n", "    # TODO: Complete this function\n    return [0]\n\
    \n", "    paren_list = paren_string.split()\n    max_nesting = []\n    for paren\
    \ in paren_list:\n        max_nesting.append(find_max_nesting(paren))\n    return\
    \ max_nesting\n\n", "    paren_list = paren_string.split()\n    max_nesting =\
    \ []\n    for paren in paren_list:\n        max_nesting.append(get_max_nesting(paren))\n\
    \    return max_nesting\n\n", "    paren_list = paren_string.split()\n    max_nesting\
    \ = []\n    for paren in paren_list:\n        max_nesting.append(get_max_nesting(paren))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for paren_group in paren_groups:\n        max_nesting.append(find_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split(' ')\n  \
    \  return [max_nested_parens(group) for group in paren_groups]\n\n", "    paren_groups\
    \ = paren_string.split(' ')\n    return [parse_parens(group) for group in paren_groups]\n\
    \n", "    paren_groups = paren_string.split(' ')\n    max_nesting = []\n    for\
    \ paren_group in paren_groups:\n        max_nesting.append(get_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    return\
    \ [max_nested_parens(group) for group in paren_groups]\n\n", "    paren_groups\
    \ = paren_string.split()\n    max_depth = []\n    for group in paren_groups:\n\
    \        depth = 0\n        max_depth_group = 0\n        for char in group:\n\
    \            if char == '(':\n                depth += 1\n                max_depth_group\
    \ = max(max_depth_group, depth)\n            elif char == ')':\n             \
    \   depth -= 1\n        max_depth.append(max_depth_group)\n    return max_depth\n\
    \n", "    paren_string = paren_string.replace(' ', '')\n    paren_list = []\n\
    \    paren_count = 0\n    for paren in paren_string:\n        if paren == '(':\n\
    \            paren_count += 1\n        elif paren == ')':\n            paren_list.append(paren_count)\n\
    \            paren_count -= 1\n    return paren_list\n\n", "    paren_groups =\
    \ paren_string.split(' ')\n    max_nesting = []\n    for group in paren_groups:\n\
    \        max_nesting.append(get_max_nesting(group))\n    return max_nesting\n\n",
  "    paren_groups = paren_string.split()\n    max_nesting = []\n    for group in\
    \ paren_groups:\n        max_nesting.append(max_nesting_parens(group))\n    return\
    \ max_nesting\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for paren_group in paren_groups:\n        max_nesting.append(get_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for paren_group in paren_groups:\n        max_nesting.append(max_nesting_parens(paren_group))\n\
    \    return max_nesting\n\n", "    # TODO: implement this function\n    return\
    \ []\n\n", "    paren_groups = paren_string.split()\n    return [max_nesting_parens(group)\
    \ for group in paren_groups]\n\n", "    paren_groups = paren_string.split(' ')\n\
    \    max_nesting = []\n    for paren_group in paren_groups:\n        max_nesting.append(max_nesting_parens(paren_group))\n\
    \    return max_nesting\n\n", "    result = []\n    for paren_group in paren_string.split('\
    \ '):\n        result.append(paren_group.count('(') - paren_group.count(')'))\n\
    \    return result\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for group in paren_groups:\n        max_nesting.append(max_nesting_parens(group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split(' ')\n  \
    \  max_nesting = []\n    for group in paren_groups:\n        max_nesting.append(find_max_nesting(group))\n\
    \    return max_nesting\n\n", "    paren_list = paren_string.split(' ')\n    max_nesting\
    \ = []\n    for paren in paren_list:\n        max_nesting.append(parse_parens(paren))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for paren_group in paren_groups:\n        max_nesting.append(find_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split(' ')\n  \
    \  max_nesting = []\n    for group in paren_groups:\n        max_nesting.append(max_nesting_level(group))\n\
    \    return max_nesting\n\n", "    return [max_nested_parens(paren_string) for\
    \ paren_string in paren_string.split()]\n\n", "    paren_list = paren_string.split('\
    \ ')\n    max_nesting = []\n    for paren in paren_list:\n        max_nesting.append(parse_parens(paren))\n\
    \    return max_nesting\n\n", "    paren_list = paren_string.split(' ')\n    return\
    \ [max_nested_parens(paren) for paren in paren_list]\n\n", "    paren_groups =\
    \ paren_string.split(' ')\n    max_nesting = []\n    for paren_group in paren_groups:\n\
    \        max_nesting.append(parse_parens(paren_group))\n    return max_nesting\n\
    \n", "    paren_groups = paren_string.split(' ')\n    max_nesting = []\n    for\
    \ paren_group in paren_groups:\n        max_nesting.append(get_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    paren_list = paren_string.split()\n    max_depth\
    \ = []\n    for paren in paren_list:\n        depth = 0\n        max_depth_so_far\
    \ = 0\n        for char in paren:\n            if char == '(':\n             \
    \   depth += 1\n                max_depth_so_far = max(max_depth_so_far, depth)\n\
    \            elif char == ')':\n                depth -= 1\n        max_depth.append(max_depth_so_far)\n\
    \    return max_depth\n\n", "    return [max_nested_parens(paren_string) for paren_string\
    \ in paren_string.split()]\n\n", "    paren_list = paren_string.split(' ')\n \
    \   max_depth = []\n    for paren in paren_list:\n        depth = 0\n        max_depth_so_far\
    \ = 0\n        for char in paren:\n            if char == '(':\n             \
    \   depth += 1\n                max_depth_so_far = max(max_depth_so_far, depth)\n\
    \            elif char == ')':\n                depth -= 1\n        max_depth.append(max_depth_so_far)\n\
    \    return max_depth\n\n", "    paren_list = paren_string.split(' ')\n    max_nesting\
    \ = []\n    for paren in paren_list:\n        max_nesting.append(max_nesting_parens(paren))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split(' ')\n  \
    \  max_nesting = []\n    for paren_group in paren_groups:\n        max_nesting.append(parse_nested_parens_helper(paren_group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    return\
    \ [max_nested_parens(group) for group in paren_groups]\n\n", "    paren_list =\
    \ paren_string.split()\n    return [nested_parens(paren) for paren in paren_list]\n\
    \n", "    paren_groups = paren_string.split()\n    max_nesting = []\n    for paren_group\
    \ in paren_groups:\n        max_nesting.append(get_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    paren_list = paren_string.split()\n    return\
    \ [max_nested_parens(paren) for paren in paren_list]\n\n", "    paren_list = paren_string.split()\n\
    \    max_depth = []\n    for paren in paren_list:\n        max_depth.append(max_depth_parens(paren))\n\
    \    return max_depth\n\n", "    paren_groups = paren_string.split()\n    max_depth\
    \ = []\n    for group in paren_groups:\n        depth = 0\n        max_depth_so_far\
    \ = 0\n        for c in group:\n            if c == '(':\n                depth\
    \ += 1\n                max_depth_so_far = max(max_depth_so_far, depth)\n    \
    \        elif c == ')':\n                depth -= 1\n        max_depth.append(max_depth_so_far)\n\
    \    return max_depth\n\n", "    max_nesting = []\n    for group in paren_string.split():\n\
    \        max_nesting.append(max_nesting_parens(group))\n    return max_nesting\n\
    \n", "    paren_list = paren_string.split(' ')\n    max_depth = []\n    for paren\
    \ in paren_list:\n        depth = 0\n        max_depth_so_far = 0\n        for\
    \ char in paren:\n            if char == '(':\n                depth += 1\n  \
    \              max_depth_so_far = max(max_depth_so_far, depth)\n            elif\
    \ char == ')':\n                depth -= 1\n        max_depth.append(max_depth_so_far)\n\
    \    return max_depth\n\n", "    paren_groups = paren_string.split(' ')\n    return\
    \ [max_nesting_level(group) for group in paren_groups]\n\n", "    paren_groups\
    \ = paren_string.split(' ')\n    max_nesting = []\n    for paren_group in paren_groups:\n\
    \        max_nesting.append(find_max_nesting(paren_group))\n    return max_nesting\n\
    \n", "    paren_groups = paren_string.split(' ')\n    max_nesting = []\n    for\
    \ paren_group in paren_groups:\n        max_nesting.append(parse_parens(paren_group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for group in paren_groups:\n        max_nesting.append(get_max_nesting(group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    return\
    \ [max_nesting_level(paren_group) for paren_group in paren_groups]\n\n", "   \
    \ # TODO: Implement this function\n    pass\n\n", "    return [paren_string.count('(')\
    \ - paren_string.count(')') for paren_string in paren_string.split()]\n\n", " \
    \   # TODO: Implement this function\n    pass\n\n", "    paren_list = paren_string.split()\n\
    \    max_nesting = []\n    for paren in paren_list:\n        max_nesting.append(find_max_nesting(paren))\n\
    \    return max_nesting\n\n", "    paren_list = paren_string.split()\n    max_nesting\
    \ = []\n    for paren in paren_list:\n        max_nesting.append(parse_parens(paren))\n\
    \    return max_nesting\n\n", "    return [max_nested_parens(paren_string) for\
    \ paren_string in paren_string.split()]\n\n", "    paren_groups = paren_string.split('\
    \ ')\n    max_nesting = []\n    for group in paren_groups:\n        max_nesting.append(find_max_nesting(group))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split()\n    max_nesting\
    \ = []\n    for paren_group in paren_groups:\n        max_nesting.append(find_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    # TODO: Complete this function\n    pass\n\n",
  "    paren_list = paren_string.split()\n    max_nesting = []\n    for paren in paren_list:\n\
    \        max_nesting.append(get_max_nesting(paren))\n    return max_nesting\n\n",
  "    paren_groups = paren_string.split()\n    max_nesting = []\n    for paren_group\
    \ in paren_groups:\n        max_nesting.append(get_max_nesting(paren_group))\n\
    \    return max_nesting\n\n", "    paren_list = paren_string.split()\n    max_nesting\
    \ = []\n    for paren in paren_list:\n        max_nesting.append(max_nesting_parens(paren))\n\
    \    return max_nesting\n\n", "    paren_groups = paren_string.split(' ')\n  \
    \  return [max_nested_parens(group) for group in paren_groups]\n\n", "    if paren_string\
    \ is None:\n        return None\n\n    paren_string = paren_string.strip()\n \
    \   if len(paren_string) == 0:\n        return []\n\n    paren_groups = paren_string.split('\
    \ ')\n    max_nesting_levels = []\n    for paren_group in paren_groups:\n    \
    \    max_nesting_levels.append(get_max_nesting_level(paren_group))\n\n    return\
    \ max_nesting_levels\n\n", "    max_depth = 0\n    current_depth = 0\n    depths\
    \ = []\n    for char in paren_string:\n        if char == '(':\n            current_depth\
    \ += 1\n            max_depth = max(max_depth, current_depth)\n        elif char\
    \ == ')':\n            current_depth -= 1\n        elif char == ' ':\n       \
    \     depths.append(max_depth)\n            max_depth = 0\n            current_depth\
    \ = 0\n    depths.append(max_depth)\n    return depths\n\n", "    # TODO: Write\
    \ your code here\n    pass\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
