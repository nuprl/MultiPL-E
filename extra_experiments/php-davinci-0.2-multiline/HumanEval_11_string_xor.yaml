name: HumanEval_11_string_xor
language: php
prompt: "<?php\n/* Input are two strings a and b consisting only of 1s and 0s.\nPerform\
  \ binary XOR on these inputs and return result also as a string.\n>>> string_xor(\"\
  010\", \"110\")\n\"100\"*/\nfunction string_xor($a, $b) {\n"
tests: "function candidate(...$args) {\n    return string_xor(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(\"111000\", \"101010\") !== \"010010\") { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(\"1\", \"1\") !== \"0\"\
  ) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"0101\", \"0000\"\
  ) !== \"0101\") { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nGiven a string of digits,\
    \ you should replace any digit below 5 with '0' and any digit 5 and above with\
    \ '1'. Return the resulting string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'\n\
    */", "  $a_arr = str_split($a);\n  $b_arr = str_split($b);\n  $result = [];\n\
    \  for ($i = 0; $i < count($a_arr); $i++) {\n    if ($a_arr[$i] == $b_arr[$i])\
    \ {\n      $result[] = 0;\n    } else {\n      $result[] = 1;\n    }\n  }\n  return\
    \ implode($result);\n}\n\n/*\nGiven a string of digits, you should replace any\
    \ digit below 5 with '0' and any digit 5 and above with '1'. Return the resulting\
    \ string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'\n*/", "  $result\
    \ = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\nInput is a string of 1s and 0s.\nReturn the\
    \ number of 1s in the string.\n>>> count_ones(\"1000101\")\n4\n*/", "    $result\
    \ = '';\n    for ($i = 0; $i < strlen($a); $i++) {\n        $result .= $a[$i]\
    \ ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\nInput is a string of 1s and\
    \ 0s.\nReturn the number of 0s in the string.\n>>> count_zeros(\"1000101011\"\
    )\n4\n*/", "    $result = '';\n    for ($i = 0; $i < strlen($a); $i++) {\n   \
    \     $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\nInput\
    \ is a string of 1s and 0s.\nReturn the number of 1s in the string.\n>>> count_ones(\"\
    1000101\")\n4\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n \
    \   $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string\
    \ consisting of 1s and 0s.\nReturn the number of substrings of this string that\
    \ are palindromes.\n>>> count_binary_substrings(\"10011\")\n3\n>>> count_binary_substrings(\"\
    101\")\n2\n>>> count_binary_substrings(\"1111\")\n6\n*/", "    $result = \"\"\
    ;\n    for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $result;\n}\n\n/* Input are two strings a and b consisting\
    \ only of 1s and 0s.\nPerform binary AND on these inputs and return result also\
    \ as a string.\n>>> string_and(\"010\", \"110\")\n\"010\"*/", "  $a = str_split($a);\n\
    \  $b = str_split($b);\n  $result = [];\n  for ($i = 0; $i < count($a); $i++)\
    \ {\n    if ($a[$i] == $b[$i]) {\n      $result[] = 0;\n    } else {\n      $result[]\
    \ = 1;\n    }\n  }\n  return implode($result);\n}\n\n/*\nGiven a string, return\
    \ a new string where the first and last chars have been exchanged.\n>>> front_back('code')\n\
    'eodc'\n>>> front_back('a')\n'a'\n>>> front_back('ab')\n'ba'\n*/", "  $result\
    \ = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\nInput is a string of 1s and 0s.\nReturn the\
    \ number of 0s in the string.\n>>> count_zeros(\"1000101011\")\n5\n*/", "  $result\
    \ = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\nGiven a string of digits, you should replace\
    \ any digit below 5 with '0' and any digit 5 and above with '1'. Return the resulting\
    \ string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'\n*/", "    $result\
    \ = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $result;\n}\n\n/*\nGiven a string of digits, you should replace\
    \ any digit below 5 with '0' and any digit 5 and above with '1'. Return the resulting\
    \ string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'\n*/", "  $result\
    \ = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\nInput is a string of 1s and 0s.\nReturn the\
    \ number of 1s in the string.\n>>> count_ones(\"1000101\")\n4\n*/", "  $result\
    \ = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\nGiven a string of digits, you should replace\
    \ any digit below 5 with '0' and any digit 5 and above with '1'. Return the resulting\
    \ string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'\n*/", "    $result\
    \ = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $result;\n}\n\n/*\n>>> string_xor(\"10101\", \"00101\")\n\"\
    10000\"\n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"\
    1010\", \"1010\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"1010\", \"0101\")\n\"\
    1111\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"0101\")\n\"1000\"\n*/\n\n/*\n>>>\
    \ string_xor(\"1101\", \"0001\")\n\"1100\"\n*/\n\n/*\n>>> string_xor(\"1101\"\
    , \"0110\")\n\"1001\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1010\")\n\"0111\"\n\
    */\n\n/*\n>>> string_xor(\"1101\", \"0101\")\n\"1000\"\n*/\n\n/*\n>>> string_xor(\"\
    1101\", \"1010\")\n\"0111\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1101\")\n\"\
    0000\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1110\")\n\"0111\"\n*/\n\n/*\n>>>\
    \ string_xor(\"1101\", \"1111\")\n\"0100\"\n*/\n\n/*\n>>> string_xor(\"1101\"\
    , \"0000\")\n\"1101\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"0001\")\n\"1100\"\n\
    */\n\n/*\n>>> string_xor(\"1101\", \"0010\")\n\"1110\"\n*/\n\n/*\n>>> string_xor(\"\
    1101\", \"0011\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"0100\")\n\"\
    1001\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"0101\")\n\"1000\"\n*/\n\n/*\n>>>\
    \ string_xor(\"1101\", \"0110\")\n\"1010", "    $result = '';\n    for ($i = 0;\
    \ $i < strlen($a); $i++) {\n        $result .= $a[$i] == $b[$i] ? '0' : '1';\n\
    \    }\n    return $result;\n}\n\n/*\nInput is a string consisting of 1s and 0s.\n\
    Return the number of consecutive 1s in the string.\n>>> count_ones(\"10001\")\n\
    2\n>>> count_ones(\"101\")\n1\n>>> count_ones(\"1111\")\n4\n*/", "    $result\
    \ = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $result;\n}\n\n/*\n>>> string_xor(\"010\", \"110\")\n\"100\"\
    \n*/\n\necho string_xor(\"010\", \"110\");\n", "  $result = \"\";\n  for($i=0;\
    \ $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n\
    }\n\n/*\nInput is a string consisting of 1s and 0s.\nReturn the number of 0s in\
    \ the string.\n>>> count_zeros(\"1000101011\")\n5\n*/", "  $result = \"\";\n \
    \ for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return\
    \ $result;\n}\n\n/*\nInput is a string consisting of 1s and 0s.\nReturn the number\
    \ of 0s in the string.\n>>> count_zeros(\"1000101011\")\n5\n*/", "    $result\
    \ = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $result;\n}\n\n/*\n>>> string_xor(\"010\", \"110\")\n\"100\"\
    \n*/\n\necho string_xor(\"010\", \"110\");\n", "    $result = \"\";\n    for($i=0;\
    \ $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return\
    \ $result;\n}\necho string_xor(\"010\", \"110\");", "    $result = \"\";\n   \
    \ for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n\
    \    return $result;\n}\n\n/*\nInput is a string consisting of 1s and 0s.\nReturn\
    \ the number of 0s in the string.\n>>> count_zeros(\"100101\")\n3\n*/", "    $result\
    \ = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $result;\n}", "  $result = \"\";\n  for($i=0; $i<strlen($a);\
    \ $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}", "  $result\
    \ = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/* Input is a string consisting of 1s and 0s.\n\
    Return the number of 0s in the string.\n>>> count_zeros(\"100101\")\n3*/", " \
    \ $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^\
    \ $b[$i];\n  }\n  return $result;\n}", "  $result = \"\";\n  for($i=0; $i<strlen($a);\
    \ $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\n\
    >>> string_xor(\"1101\", \"1010\")\n\"0111\"\n*/\n\n/*\n>>> string_xor(\"0011\"\
    , \"1100\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n\
    */\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"\
    010\", \"101\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"0011\")\n\"0110\"\
    \n*/\n\n/*\n>>> string_xor(\"0011\", \"0101\")\n\"0110\"\n*/\n\n/*\n>>> string_xor(\"\
    1101\", \"1010\")\n\"0111\"\n*/\n\n/*\n>>> string_xor(\"1010\", \"1101\")\n\"\
    0111\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1010\")\n\"0111\"\n*/\n\n/*\n>>>\
    \ string_xor(\"1010\", \"1101\")\n\"0111\"\n*/\n\n/*\n>>> string_xor(\"1101\"\
    , \"1010\")\n\"0111\"\n*/\n\n/*\n>>> string_xor(\"1010\", \"1101\")\n\"0111\"\n\
    */\n\n/*\n>>> string_xor(\"1101\", \"1010\")\n\"0111\"\n*/\n\n/*\n>>> string_xor(\"\
    1010\", \"1101\")\n\"0111\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1010\")\n\"\
    0111\"\n*/\n\n/*\n>>> string_xor(\"1010\", \"1101\")\n\"0111\"\n*/\n\n/*\n>>>\
    \ string_xor(\"1101\", \"1010\")\n\"0111\"\n*/\n\n/*\n>>> string_xor(\"1010\"\
    , \"1101\")\n\"0111\"\n*/\n\n/*\n>>> string_x", "  $result = \"\";\n  for($i=0;\
    \ $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n\
    }\n\n/* >>> string_xor(\"1101\", \"1010\")\n\"0111\"*/\necho string_xor(\"1101\"\
    , \"1010\");", "    $result = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n  \
    \      $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\n>>> string_xor(\"\
    010\", \"110\")\n\"100\"\n>>> string_xor(\"1\", \"0\")\n\"1\"\n>>> string_xor(\"\
    0\", \"1\")\n\"1\"\n>>> string_xor(\"1\", \"1\")\n\"0\"\n>>> string_xor(\"0\"\
    , \"0\")\n\"0\"\n*/", "  $a = str_split($a);\n  $b = str_split($b);\n  $res =\
    \ [];\n  for ($i = 0; $i < count($a); $i++) {\n    if ($a[$i] == $b[$i]) {\n \
    \     $res[] = 0;\n    } else {\n      $res[] = 1;\n    }\n  }\n  return implode($res);\n\
    }\n\n/*\n>>> string_xor(\"010\", \"110\")\n\"100\"\n>>> string_xor(\"110\", \"\
    010\")\n\"100\"\n>>> string_xor(\"001\", \"101\")\n\"100\"\n>>> string_xor(\"\
    000\", \"111\")\n\"111\"\n>>> string_xor(\"010\", \"101\")\n\"111\"\n>>> string_xor(\"\
    101\", \"010\")\n\"111\"\n>>> string_xor(\"100\", \"000\")\n\"100\"\n>>> string_xor(\"\
    001\", \"011\")\n\"010\"\n>>> string_xor(\"110\", \"111\")\n\"001\"\n>>> string_xor(\"\
    100\", \"110\")\n\"010\"\n>>> string_xor(\"001\", \"100\")\n\"101\"\n>>> string_xor(\"\
    000\", \"001\")\n\"001\"\n>>> string_xor(\"111\", \"110\")\n\"001\"\n>>> string_xor(\"\
    011\", \"100\")\n\"111\"\n>>> string_xor(\"100\", \"101\")\n\"001\"\n>>> string_xor(\"\
    000\", \"011\")\n\"011\"\n>>> string_xor(\"101\", \"000\")\n\"101\"\n>>> string_xor(\"\
    111\", \"101\")\n\"010\"\n>>> string_xor(\"101\", \"011\")\n\"110\"\n>>> string_xor(\"\
    110\", \"001\")\n\"111\"\n>>> string_xor(\"010\", \"000\")\n\"010\"\n>>> string_xor(\"\
    111\", \"011\")\n\"100\"\n>>> string_xor(\"101\", \"110\")\n\"011\"\n>>> string_xor(\"\
    000\", \"111\")\n\"111\"\n>>> string_xor(\"001\", \"101\")\n\"100\"\n>>> string_xor(\"\
    011", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i]\
    \ ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\n>>> string_xor(\"10101\", \"00101\"\
    )\n\"10000\"\n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n\
    >>> string_xor(\"1010\", \"1010\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"1010\"\
    , \"0101\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1010\")\n\"0111\"\n\
    */\n\n/*\n>>> string_xor(\"1101\", \"0101\")\n\"1000\"\n*/\n\n/*\n>>> string_xor(\"\
    1101\", \"1101\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"0000\")\n\"\
    1101\"\n*/\n\n/*\n>>> string_xor(\"0000\", \"1101\")\n\"1101\"\n*/\n\n/*\n>>>\
    \ string_xor(\"1010\", \"0101\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"1010\"\
    , \"1010\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"1010\", \"0000\")\n\"1010\"\n\
    */\n\n/*\n>>> string_xor(\"0000\", \"1010\")\n\"1010\"\n*/\n\n/*\n>>> string_xor(\"\
    1010\", \"1111\")\n\"0101\"\n*/\n\n/*\n>>> string_xor(\"1010\", \"1101\")\n\"\
    0111\"\n*/\n\n/*\n>>> string_xor(\"1010\", \"0111\")\n\"1101\"\n*/\n\n/*\n>>>\
    \ string_xor(\"1010\", \"1000\")\n\"0010\"\n*/\n\n/*\n>>> string_xor(\"1100\"\
    , \"1010\")\n\"0110\"\n*/\n\n/*\n>>> string_xor(\"0100\", \"1010\")\n\"1110\"\n\
    */\n\n/*\n>>> string_xor(\"0010\", \"1010\")\n\"", "  $result = \"\";\n  for($i=0;\
    \ $i<strlen($a); $i++) {\n    $result .= ($a[$i] == $b[$i]) ? \"0\" : \"1\";\n\
    \  }\n  return $result;\n}\n\n/* Input is a string consisting of 1s and 0s.\n\
    Return the number of 0s in the string.\n>>> count_zeros(\"1000101011\")\n5*/",
  "    $result = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i]\
    \ ^ $b[$i];\n    }\n    return $result;\n}\n\n/* Input is a string of 1s and 0s.\n\
    Return the number of 1s in the string.\n>>> count_ones(\"100101\")\n3*/", "  $result\
    \ = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\nInput is a string of 1s and 0s.\nReturn the\
    \ number of 1s in the string.\n>>> count_ones(\"1000101\")\n4\n*/", "  $result\
    \ = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\n>>> string_xor(\"10101\", \"00101\")\n\"10000\"\
    \n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"\
    1010\", \"1010\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"11101\", \"10101\")\n\"\
    01000\"\n*/\n\n/*\n>>> string_xor(\"1111\", \"1111\")\n\"0000\"\n*/\n\n/*\n>>>\
    \ string_xor(\"10001\", \"01110\")\n\"11111\"\n*/\n\n/*\n>>> string_xor(\"00110\"\
    , \"10111\")\n\"11001\"\n*/\n\n/*\n>>> string_xor(\"01100\", \"00111\")\n\"01011\"\
    \n*/\n\n/*\n>>> string_xor(\"11100\", \"00011\")\n\"11111\"\n*/\n\n/*\n>>> string_xor(\"\
    11001\", \"01110\")\n\"10111\"\n*/\n\n/*\n>>> string_xor(\"01110\", \"11001\"\
    )\n\"10111\"\n*/\n\n/*\n>>> string_xor(\"11010\", \"01001\")\n\"10111\"\n*/\n\n\
    /*\n>>> string_xor(\"11111\", \"11111\")\n\"00000\"\n*/\n\n/*\n>>> string_xor(\"\
    11001\", \"11001\")\n\"00000\"\n*/\n\n/*\n>>> string_xor(\"11100\", \"11100\"\
    )\n\"00000\"\n*/\n\n/*\n>>> string_xor(\"11010\", \"11010\")\n\"00000\"\n*/\n\n\
    /*\n>>> string_xor(\"11111\", \"00000\")\n\"11111\"\n*/\n\n/*\n>>> string_xor(\"\
    11001\", \"00000\")\n\"11001\"\n*/\n\n/*\n>>> string_xor(\"11100\", \"00000\"\
    )\n\"11100\"\n*/\n\n/*\n>>> string_xor(\"11010\", \"", "    $result = \"\";\n\
    \    for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n \
    \   }\n    return $result;\n}\n\n/*\nInput is a string consisting of 1s and 0s.\n\
    Return the number of substrings that start and end with 1.\n>>> count_substrings(\"\
    0110111\")\n3\n>>> count_substrings(\"101\")\n2\n>>> count_substrings(\"111111\"\
    )\n6\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string of 1s\
    \ and 0s.\nReturn the number of 1s in the string.\n>>> count_ones(\"1000101\"\
    )\n4\n*/", "    $result = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n      \
    \  $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\n>>> string_xor(\"\
    0101\", \"0011\")\n\"0110\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"\
    1111\"\n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"\
    010\", \"101\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\
    \n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"\
    0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"\
    1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>>\
    \ string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\"\
    , \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n\
    */\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"\
    0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"\
    1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>>\
    \ string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\"\
    , \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n\
    */\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"", "    $result = \"\";\n\
    \    for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n \
    \   }\n    return $result;\n}\n\n/*\nInput is a string of 1s and 0s.\nReturn the\
    \ number of 0s in the string.\n>>> count_zeros(\"1000101011\")\n5\n*/", "    $result\
    \ = '';\n    for ($i = 0; $i < strlen($a); $i++) {\n        $result .= $a[$i]\
    \ ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\nInput is a string consisting\
    \ of 1s and 0s.\nReturn the number of 0s in the string.\n>>> count_zeros(\"1000101011\"\
    )\n5\n*/", "    $result = '';\n    for ($i = 0; $i < strlen($a); $i++) {\n   \
    \     $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\n>>> string_xor(\"\
    10101\", \"00101\")\n\"10000\"\n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"\
    111\"\n*/\n\n/*\n>>> string_xor(\"1010\", \"1010\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"\
    1010\", \"0101\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"11101\", \"10101\")\n\"\
    01000\"\n*/\n\n/*\n>>> string_xor(\"11101\", \"10101\")\n\"01000\"\n*/\n\n/*\n\
    >>> string_xor(\"10101\", \"11101\")\n\"01000\"\n*/\n\n/*\n>>> string_xor(\"11101\"\
    , \"11101\")\n\"00000\"\n*/\n\n/*\n>>> string_xor(\"11101\", \"01010\")\n\"10111\"\
    \n*/\n\n/*\n>>> string_xor(\"11101\", \"01010\")\n\"10111\"\n*/\n\n/*\n>>> string_xor(\"\
    11101\", \"01010\")\n\"10111\"\n*/\n\n/*\n>>> string_xor(\"11101\", \"01010\"\
    )\n\"10111\"\n*/\n\n/*\n>>> string_xor(\"11101\", \"01010\")\n\"10111\"\n*/\n\n\
    /*\n>>> string_xor(\"11101\", \"01010\")\n\"10111\"\n*/\n\n/*\n>>> string_xor(\"\
    11101\", \"01010\")\n\"10111\"\n*/\n\n/*\n>>> string_xor(\"11101\", \"01010\"\
    )\n\"10111\"\n*/\n\n/*\n>>> string_xor(\"11101\", \"01010\")\n\"10111\"\n*/\n\n\
    /*\n>>> string_xor(\"11101\", \"01010\")\n\"10111\"\n*/\n\n/*\n>>> string_xor(\"\
    11101\", \"01010\")\n\"10111\"\n*/\n\n/*\n>>> string", "  $result = \"\";\n  for($i=0;\
    \ $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n\
    }\n\n/*\nGiven a list of integers, return the largest product that can be made\
    \ by multiplying any three integers.\nFor example, if the list is [-10, -10, 5,\
    \ 2], we should return 500, since that's -10 * -10 * 5.\nYou can assume the list\
    \ has at least three integers.\n>>> largest_product([-10, -10, 5, 2])\n500\n>>>\
    \ largest_product([-10, -10, -5, 2])\n100\n>>> largest_product([-10, -10, 5, -2])\n\
    100\n>>> largest_product([-10, -10, -5, -2])\n-50\n>>> largest_product([-10, -10,\
    \ 5, -2, -2])\n100\n>>> largest_product([-10, -10, 5, -2, -2, -2])\n-50\n>>> largest_product([-10,\
    \ -10, 5, -2, -2, -2, -2])\n-50\n>>> largest_product([-10, -10, 5, -2, -2, -2,\
    \ -2, -2])\n-50\n>>> largest_product([-10, -10, 5, -2, -2, -2, -2, -2, -2])\n\
    -50\n>>> largest_product([-10, -10, 5, -2, -2, -2, -2, -2, -2, -2])\n-50\n>>>\
    \ largest_product([-10, -10, 5, -2, -2, -2, -2, -2, -2, -2, -2])\n-50\n>>> largest_product([-10,\
    \ -10, 5, -2, -2, -2, -2, -2, -2, -2, -2, -2])\n-50\n>>> largest_product([-10,\
    \ -10, 5, -2, -2, -2, -2, -2, -2, -2, -2, -2,", "    $res = '';\n    for ($i =\
    \ 0; $i < strlen($a); $i++) {\n        $res .= $a[$i] ^ $b[$i];\n    }\n    return\
    \ $res;\n}\n\n/*\nInput is a string of 1s and 0s.\nReturn the number of 0s in\
    \ the string.\n>>> count_zeros(\"1000101011\")\n5\n*/", "  $result = '';\n  for($i=0;\
    \ $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n\
    }\n\n/*\nGiven a string of digits, you should replace any digit below 5 with '0'\
    \ and any digit 5 and above with '1'. Return the resulting string.\n>>> fake_bin('45385593107843568')\n\
    '01011110001100111'\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++)\
    \ {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\n>>> string_xor(\"\
    10101\", \"00101\")\n\"10000\"\n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"\
    111\"\n*/\n\n/*\n>>> string_xor(\"1010\", \"1010\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"\
    1010\", \"1011\")\n\"0001\"\n*/\n\n/*\n>>> string_xor(\"1010\", \"1001\")\n\"\
    0011\"\n*/\n\n/*\n>>> string_xor(\"110011\", \"10101\")\n\"011110\"\n*/\n\n/*\n\
    >>> string_xor(\"1100110\", \"10101\")\n\"0111001\"\n*/\n\n/*\n>>> string_xor(\"\
    1100110\", \"1001101\")\n\"0111011\"\n*/\n\n/*\n>>> string_xor(\"1100110\", \"\
    10011001\")\n\"01110001\"\n*/\n\n/*\n>>> string_xor(\"1100110\", \"100110001\"\
    )\n\"011100001\"\n*/\n\n/*\n>>> string_xor(\"1100110\", \"1001100001\")\n\"0111000001\"\
    \n*/\n\n/*\n>>> string_xor(\"1100110\", \"10011000001\")\n\"01110000001\"\n*/\n\
    \n/*\n>>> string_xor(\"1100110\", \"1001100000001\")\n\"0111000000001\"\n*/\n\n\
    /*\n>>> string_xor(\"1100110\", \"10011000000001\")\n\"01110000000001\"\n*/\n\n\
    /*\n>>> string_xor(\"1100110\", \"100110000000001\")\n\"011100000000001\"\n*/\n\
    \n/*\n>>> string_xor(\"1100110\", \"1001100000000001\")\n\"0111000000000001\"\n\
    */\n\n/*\n>>> string_xor(\"1100110\", \"10011000000000001\")\n\"01110000000000001\"\
    \n*/\n\n/*\n>>>", "  $result = '';\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\n>>> string_xor(\"010\"\
    , \"110\")\n\"100\"\n*/\necho string_xor(\"010\", \"110\");\n", "  $a = str_split($a);\n\
    \  $b = str_split($b);\n  $result = [];\n  for ($i = 0; $i < count($a); $i++)\
    \ {\n    if ($a[$i] == $b[$i]) {\n      $result[] = 0;\n    } else {\n      $result[]\
    \ = 1;\n    }\n  }\n  return implode($result);\n}\n\n/*\nInput are two strings\
    \ a and b consisting only of 1s and 0s.\nPerform binary AND on these inputs and\
    \ return result also as a string.\n>>> string_and(\"010\", \"110\")\n\"010\"\n\
    */", "  $a = str_split($a);\n  $b = str_split($b);\n  $result = [];\n  for ($i\
    \ = 0; $i < count($a); $i++) {\n    if ($a[$i] == $b[$i]) {\n      $result[] =\
    \ 0;\n    } else {\n      $result[] = 1;\n    }\n  }\n  return implode('', $result);\n\
    }\n\n/*\nGiven a string of digits, you should replace any digit below 5 with '0'\
    \ and any digit 5 and above with '1'. Return the resulting string.\n>>> fake_bin('45385593107843568')\n\
    '01011110001100111'\n*/", "    $result = \"\";\n    for($i=0; $i<strlen($a); $i++)\
    \ {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\n\
    >>> string_xor(\"0101\", \"0011\")\n\"0110\"\n>>> string_xor(\"000\", \"111\"\
    )\n\"111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"0011\")\n\"0110\"\n>>> string_xor(\"\
    000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"0011\")\n\"0110\"\
    \n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"0101\"\
    , \"0011\")\n\"0110\"\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n>>>\
    \ string_xor(\"0101\", \"0011\")\n\"0110\"\n>>> string_xor(\"000\", \"111\")\n\
    \"111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"0011\")\n\"0110\"\n>>> string_xor(\"\
    000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"0011\")\n\"0110\"\
    \n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"0101\"\
    , \"0011\")\n\"0110\"\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n>>>\
    \ string_xor(\"0101\", \"0011\")\n\"0110\"\n>>> string_xor(\"000\", \"111\")\n\
    \"111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"0011\")\n\"0110\"\n>>> string_xor(\"\
    000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"0011\")\n\"0110\"\
    \n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"0101\"\
    , \"00", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .=\
    \ $a[$i] ^ $b[$i];\n  }\n  return $result;\n}", "  $result = \"\";\n  for($i=0;\
    \ $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n\
    }\n\n/*\nInput is a string of 1s and 0s.\nReturn the number of 0s in the string.\n\
    >>> count_zeros(\"1000101011\")\n5\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a);\
    \ $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\n\
    Given a string of digits, you should replace any digit below 5 with '0' and any\
    \ digit 5 and above with '1'. Return the resulting string.\n>>> fake_bin('45385593107843568')\n\
    '01011110001100111'\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++)\
    \ {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/* Input is\
    \ an array of integers.\nReturn the sum of the integers in the array.\n>>> sum_array([1,\
    \ 2, 3, 4])\n10*/", "    $a = str_split($a);\n    $b = str_split($b);\n    $result\
    \ = [];\n    for ($i = 0; $i < count($a); $i++) {\n        $result[] = $a[$i]\
    \ ^ $b[$i];\n    }\n    return implode($result);\n}\n\n/*\nGiven a string, return\
    \ the sum of the numbers appearing in the string, ignoring all other characters.\n\
    A number is a series of 1 or more digit chars in a row.\n(Note: Character.isDigit(char)\
    \ tests if a char is one of the chars '0', '1', .. '9'.\nInteger.parseInt(string)\
    \ converts a string to an int.)\n>>> sumNumbers(\"abc123xyz\")\n123\n>>> sumNumbers(\"\
    aa11b33\")\n44\n>>> sumNumbers(\"7 11\")\n18\n*/", "    $a = str_split($a);\n\
    \    $b = str_split($b);\n    $result = [];\n    foreach ($a as $key => $value)\
    \ {\n        $result[] = $a[$key] ^ $b[$key];\n    }\n    return implode($result);\n\
    }\n\n/*\nGiven a string, return the sum of the numbers appearing in the string,\
    \ ignoring all other characters. A number is a series of 1 or more digit chars\
    \ in a row. (Note: Character.isDigit(char) tests if a char is one of the chars\
    \ '0', '1', .. '9'. Integer.parseInt(string) converts a string to an int.)\n\n\
    sumNumbers(\"abc123xyz\") \u2192 123\nsumNumbers(\"aa11b33\") \u2192 44\nsumNumbers(\"\
    7 11\") \u2192 18\n*/", "  $a = str_split($a);\n  $b = str_split($b);\n  $result\
    \ = [];\n  for ($i = 0; $i < count($a); $i++) {\n    if ($a[$i] == $b[$i]) {\n\
    \      $result[] = 0;\n    } else {\n      $result[] = 1;\n    }\n  }\n  return\
    \ implode($result);\n}\n\necho string_xor(\"010\", \"110\");", "    $result =\
    \ \"\";\n    for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $result;\n}\n\n/*\nGiven a string of digits, you should replace\
    \ any digit below 5 with '0' and any digit 5 and above with '1'. Return the resulting\
    \ string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'\n*/", "  $res\
    \ = '';\n  for ($i = 0; $i < strlen($a); $i++) {\n    $res .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $res;\n}\n\n/*\nInput is a string consisting of 1s and 0s.\nReturn\
    \ the number of 0s in the string.\n>>> count_zeros(\"1000101011\")\n5\n*/", " \
    \ $a = str_split($a);\n  $b = str_split($b);\n  $result = [];\n  for ($i = 0;\
    \ $i < count($a); $i++) {\n    if ($a[$i] == $b[$i]) {\n      $result[] = 0;\n\
    \    } else {\n      $result[] = 1;\n    }\n  }\n  return implode($result);\n\
    }\n\n/*\n>>> string_xor(\"010\", \"110\")\n\"100\"\n*/\n\necho string_xor(\"010\"\
    , \"110\");", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\n>>> string_xor(\"010\"\
    , \"110\")\n\"100\"\n*/\necho string_xor(\"010\", \"110\");", "  $result = \"\"\
    ;\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n\
    \  return $result;\n}\n\n/*\nInput is a string containing only 1s and 0s.\nReturn\
    \ the number of substrings that start and end with 1.\n>>> count_ones(\"0110011\"\
    )\n3\n>>> count_ones(\"111\")\n3\n>>> count_ones(\"000\")\n0\n*/", "  $result\
    \ = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}", "    $result = \"\";\n    for($i=0; $i<strlen($a);\
    \ $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\
    \n/* Input is a string consisting of 1s and 0s.\nReturn the number of 0s in the\
    \ string.\n>>> count_zeros(\"1000101011\")\n5 */", "    $result = \"\";\n    for($i=0;\
    \ $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return\
    \ $result;\n}\n\n/* Input is a string of 1s and 0s.\nReturn the number of 1s in\
    \ the string.\n>>> count_ones(\"100101\")\n3*/", "  $a = str_split($a);\n  $b\
    \ = str_split($b);\n  $result = [];\n  for ($i = 0; $i < count($a); $i++) {\n\
    \    if ($a[$i] == $b[$i]) {\n      $result[] = 0;\n    } else {\n      $result[]\
    \ = 1;\n    }\n  }\n  return implode($result);\n}\n\n/*\n>>> string_xor(\"010\"\
    , \"110\")\n\"100\"\n>>> string_xor(\"111\", \"110\")\n\"001\"\n>>> string_xor(\"\
    000\", \"001\")\n\"001\"\n>>> string_xor(\"10101\", \"00101\")\n\"10000\"\n*/",
  "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^\
    \ $b[$i];\n  }\n  return $result;\n}\n\n/*\n>>> string_xor(\"0101\", \"1100\"\
    )\n\"1001\"\n>>> string_xor(\"0011\", \"0101\")\n\"0110\"\n>>> string_xor(\"0001\"\
    , \"1110\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1100\")\n\"1001\"\n\
    >>> string_xor(\"0011\", \"0101\")\n\"0110\"\n>>> string_xor(\"0001\", \"1110\"\
    )\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1100\")\n\"1001\"\n>>> string_xor(\"\
    0011\", \"0101\")\n\"0110\"\n>>> string_xor(\"0001\", \"1110\")\n\"1111\"\n*/\n\
    \n/*\n>>> string_xor(\"0101\", \"1100\")\n\"1001\"\n>>> string_xor(\"0011\", \"\
    0101\")\n\"0110\"\n>>> string_xor(\"0001\", \"1110\")\n\"1111\"\n*/\n\n/*\n>>>\
    \ string_xor(\"0101\", \"1100\")\n\"1001\"\n>>> string_xor(\"0011\", \"0101\"\
    )\n\"0110\"\n>>> string_xor(\"0001\", \"1110\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"\
    0101\", \"1100\")\n\"1001\"\n>>> string_xor(\"0011\", \"0101\")\n\"0110\"\n>>>\
    \ string_xor(\"0001\", \"1110\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\"\
    , \"1100\")\n\"1001\"\n>>> string_xor(\"0011\", \"0101\")\n\"0110\"\n>>> string_xor(\"\
    0001\", \"1110\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1100\")\n\"\
    1001\"\n>>> string_xor(\"0011\", \"0101\")\n\"0110\"\n>>> string_xor(\"0001\"\
    , \"", "  $a = str_split($a);\n  $b = str_split($b);\n  $result = [];\n  for ($i\
    \ = 0; $i < count($a); $i++) {\n    if ($a[$i] == $b[$i]) {\n      $result[] =\
    \ 0;\n    } else {\n      $result[] = 1;\n    }\n  }\n  return implode($result);\n\
    }\n\n/* Given a string of digits, you should replace any digit below 5 with '0'\n\
    and any digit 5 and above with '1'. Return the resulting string.\n>>> fake_bin('45385593107843568')\n\
    '01011110001100111'*/", "  $result = '';\n  for($i=0; $i<strlen($a); $i++) {\n\
    \    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a\
    \ string of 1s and 0s.\nReturn the string in reverse.\n>>> reverse_binary(\"1101\"\
    )\n\"1011\"\n*/", "  $res = \"\";\n  for ($i = 0; $i < strlen($a); $i++) {\n \
    \   $res .= $a[$i] ^ $b[$i];\n  }\n  return $res;\n}\n\n/*\n>>> string_xor(\"\
    10101\", \"00101\")\n\"10000\"\n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"\
    111\"\n*/\n\n/*\n>>> string_xor(\"1010\", \"1010\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"\
    1010\", \"0101\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0\", \"0\")\n\"0\"\n*/\n\
    \n/*\n>>> string_xor(\"1\", \"1\")\n\"0\"\n*/\n\n/*\n>>> string_xor(\"1\", \"\
    0\")\n\"1\"\n*/\n\n/*\n>>> string_xor(\"0\", \"1\")\n\"1\"\n*/\n\n/*\n>>> string_xor(\"\
    \", \"\")\n\"\"\n*/\n\n/*\n>>> string_xor(\"\", \"1\")\n\"\"\n*/\n\n/*\n>>> string_xor(\"\
    \", \"0\")\n\"\"\n*/\n\n/*\n>>> string_xor(\"1\", \"\")\n\"\"\n*/\n\n/*\n>>> string_xor(\"\
    0\", \"\")\n\"\"\n*/\n\n/*\n>>> string_xor(\"11\", \"\")\n\"\"\n*/\n\n/*\n>>>\
    \ string_xor(\"\", \"11\")\n\"\"\n*/\n\n/*\n>>> string_xor(\"01\", \"\")\n\"\"\
    \n*/\n\n/*\n>>> string_xor(\"\", \"01\")\n\"\"\n*/\n\n/*\n>>> string_xor(\"01\"\
    , \"01\")\n\"00\"\n*/\n\n/*\n>>> string_xor(\"01\", \"10\")\n\"11\"\n*/\n\n/*\n\
    >>> string_xor(\"10\", \"01\")\n\"11\"\n*/\n\n/*\n>>> string_xor(\"10\", \"10\"\
    )\n\"00\"\n*/\n\n/*\n>>> string_xor(\"11\", \"01\")\n\"10\"\n*/\n\n/*\n>>> string_xor(\"\
    11\", \"10\")", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\n>>> string_xor(\"10101\"\
    , \"00101\")\n\"10000\"\n*/\necho string_xor(\"10101\", \"00101\").\"\\n\";\n\n\
    /*\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\necho string_xor(\"000\", \"\
    111\").\"\\n\";\n\n/*\n>>> string_xor(\"010\", \"110\")\n\"100\"\n*/\necho string_xor(\"\
    010\", \"110\").\"\\n\";\n\n/*\n>>> string_xor(\"01010101\", \"10101010\")\n\"\
    11111111\"\n*/\necho string_xor(\"01010101\", \"10101010\").\"\\n\";\n\n/*\n>>>\
    \ string_xor(\"1100101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101",
  "    $a = str_split($a);\n    $b = str_split($b);\n    $result = [];\n    for ($i\
    \ = 0; $i < count($a); $i++) {\n        if ($a[$i] == $b[$i]) {\n            $result[]\
    \ = 0;\n        } else {\n            $result[] = 1;\n        }\n    }\n    return\
    \ implode('', $result);\n}\n\n/*\n>>> string_xor(\"010\", \"110\")\n\"100\"\n\
    */\n\n/*\n>>> string_xor(\"101\", \"010\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"\
    101\", \"111\")\n\"010\"\n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"111\"\n\
    */\n\n/*\n>>> string_xor(\"010\", \"101\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"\
    101\", \"000\")\n\"101\"\n*/\n\n/*\n>>> string_xor(\"000\", \"000\")\n\"000\"\n\
    */\n\n/*\n>>> string_xor(\"111\", \"111\")\n\"000\"\n*/\n\n/*\n>>> string_xor(\"\
    010\", \"000\")\n\"010\"\n*/\n\n/*\n>>> string_xor(\"101\", \"010\")\n\"111\"\n\
    */\n\n/*\n>>> string_xor(\"000\", \"101\")\n\"101\"\n*/\n\n/*\n>>> string_xor(\"\
    111\", \"000\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"111\", \"010\")\n\"101\"\n\
    */\n\n/*\n>>> string_xor(\"010\", \"111\")\n\"101\"\n*/\n\n/*\n>>> string_xor(\"\
    000\", \"010\")\n\"010\"\n*/\n\n/*\n>>> string_xor(\"110\", \"101\")\n\"011\"\n\
    */\n\n/*\n>>> string_xor(\"101\", \"110\")\n\"011\"\n*/\n\n/*\n>>> string_xor(\"\
    011\", \"100\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"100\", \"011\")\n\"111\"\n\
    */\n\n/*\n>>> string_xor(\"", "  $result = '';\n  for($i=0; $i<strlen($a); $i++)\
    \ {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nGiven a\
    \ string of digits, you should replace any digit below 5 with '0' and any digit\
    \ 5 and above with '1'. Return the resulting string.\n>>> fake_bin('45385593107843568')\n\
    '01011110001100111'\n*/", "    $result = '';\n    for ($i = 0; $i < strlen($a);\
    \ $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\
    \n/*\nYou are given a string of length N and a parameter k. The string can be\
    \ manipulated by taking one of the first k letters and moving it to the end.\n\
    \nWrite a program to determine the lexicographically smallest string that can\
    \ be created after an unlimited number of moves.\n\nFor example, suppose we are\
    \ given the string daily and k = 1. The best we can create in this case is ailyd.\n\
    \n>>> lex_smallest(\"daily\", 1)\n\"ailyd\"\n*/", "  $result = \"\";\n  for($i=0;\
    \ $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n\
    }", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i]\
    \ ^ $b[$i];\n  }\n  return $result;\n}\n\n/* Input is a string of 1s and 0s.\n\
    Return the number of 1s in the string.\n>>> count_ones(\"1000101\")\n4*/", " \
    \ $a = str_split($a);\n  $b = str_split($b);\n  $result = [];\n  for ($i = 0;\
    \ $i < count($a); $i++) {\n    if ($a[$i] == $b[$i]) {\n      $result[] = 0;\n\
    \    } else {\n      $result[] = 1;\n    }\n  }\n  return implode($result);\n\
    }\necho string_xor(\"010\", \"110\");", "    $a = str_split($a);\n    $b = str_split($b);\n\
    \    $result = [];\n    for ($i = 0; $i < count($a); $i++) {\n        if ($a[$i]\
    \ == $b[$i]) {\n            $result[] = 0;\n        } else {\n            $result[]\
    \ = 1;\n        }\n    }\n    return implode($result);\n}\n\n/*\nInput is a string\
    \ of 1s and 0s.\nReturn the number of 0s in the string.\n>>> count_zeros(\"1000101011\"\
    )\n4\n*/", "    $result = '';\n    for ($i = 0; $i < strlen($a); $i++) {\n   \
    \     $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\n * You\
    \ are given a string $S consisting of lowercase English letters.\n * You need\
    \ to find the number of occurrences of the letter 'a' in the given string.\n *\
    \ >>> count_a('abracadabra')\n * 5\n */", "    $result = \"\";\n    for($i=0;\
    \ $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return\
    \ $result;\n}\n\n/*\n>>> string_xor(\"10101\", \"00101\")\n\"10000\"\n*/\necho\
    \ string_xor(\"10101\", \"00101\");", "  $result = \"\";\n  for($i=0; $i<strlen($a);\
    \ $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}", "    $result\
    \ = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n        $result .= ($a[$i] ^\
    \ $b[$i]);\n    }\n    return $result;\n}\n\n/*\nInput is a string of 1s and 0s.\n\
    Return the number of 1s in the string.\n>>> count_ones(\"100101\")\n3\n*/", " \
    \ $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^\
    \ $b[$i];\n  }\n  return $result;\n}\n\n/* Given a string of digits, you should\
    \ replace any digit below 5 with '0'\nand any digit 5 and above with '1'. Return\
    \ the resulting string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'*/",
  "  $a = str_split($a);\n  $b = str_split($b);\n  $result = [];\n  for ($i = 0; $i\
    \ < count($a); $i++) {\n    if ($a[$i] == $b[$i]) {\n      $result[] = 0;\n  \
    \  } else {\n      $result[] = 1;\n    }\n  }\n  return implode($result);\n}\n\
    \n/*\n>>> string_xor(\"010\", \"110\")\n\"100\"\n*/\n\necho string_xor(\"010\"\
    , \"110\");", "  $result = '';\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\n>>> string_xor(\"10101\"\
    , \"00101\")\n\"10000\"\n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"111\"\n\
    */\n\n/*\n>>> string_xor(\"1010\", \"1010\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"\
    1010\", \"0101\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"11001\", \"01111\")\n\"\
    10110\"\n*/\n\n/*\n>>> string_xor(\"01110\", \"10101\")\n\"11011\"\n*/\n\n/*\n\
    >>> string_xor(\"11100\", \"00111\")\n\"11011\"\n*/\n\n/*\n>>> string_xor(\"11100\"\
    , \"00111\")\n\"11011\"\n*/\n\n/*\n>>> string_xor(\"11100\", \"00111\")\n\"11011\"\
    \n*/\n\n/*\n>>> string_xor(\"11100\", \"00111\")\n\"11011\"\n*/\n\n/*\n>>> string_xor(\"\
    11100\", \"00111\")\n\"11011\"\n*/\n\n/*\n>>> string_xor(\"11100\", \"00111\"\
    )\n\"11011\"\n*/\n\n/*\n>>> string_xor(\"11100\", \"00111\")\n\"11011\"\n*/\n\n\
    /*\n>>> string_xor(\"11100\", \"00111\")\n\"11011\"\n*/\n\n/*\n>>> string_xor(\"\
    11100\", \"00111\")\n\"11011\"\n*/\n\n/*\n>>> string_xor(\"11100\", \"00111\"\
    )\n\"11011\"\n*/\n\n/*\n>>> string_xor(\"11100\", \"00111\")\n\"11011\"\n*/\n\n\
    /*\n>>> string_xor(\"11100\", \"00111\")\n\"11011\"\n*/\n\n/*\n>>> string_xor(\"\
    11100\", \"00111\")\n\"11011\"\n*/\n\n/*\n>>>", "    $result = \"\";\n    for($i=0;\
    \ $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return\
    \ $result;\n}\n\n/*\n>>> string_xor(\"010\", \"110\")\n\"100\"\n>>> string_xor(\"\
    101\", \"111\")\n\"010\"\n>>> string_xor(\"111\", \"111\")\n\"000\"\n>>> string_xor(\"\
    000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"010\", \"110\")\n\"100\"\n\
    >>> string_xor(\"101\", \"111\")\n\"010\"\n>>> string_xor(\"111\", \"111\")\n\"\
    000\"\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/", "  $result = \"\";\n  for($i=0;\
    \ $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n\
    }\n\n/*\nInput is a string of 1s and 0s.\nReturn the number of 1s in the string.\n\
    >>> count_ones(\"1000101\")\n4\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a);\
    \ $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\n\
    Input is a string consisting of 1s and 0s.\nReturn the number of substrings that\
    \ start and end with 1.\n>>> count_substrings(\"0110111\")\n3\n>>> count_substrings(\"\
    101\")\n2\n>>> count_substrings(\"111111\")\n6\n*/", "  $result = '';\n  for($i=0;\
    \ $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n\
    }\n\n/*\n>>> string_xor(\"10\", \"10\")\n\"00\"\n>>> string_xor(\"10\", \"01\"\
    )\n\"11\"\n>>> string_xor(\"10\", \"00\")\n\"10\"\n*/\n\n/*\n>>> string_xor(\"\
    10101\", \"00101\")\n\"10000\"\n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"\
    111\"\n*/\n\n/*\n>>> string_xor(\"01110\", \"10101\")\n\"11001\"\n*/\n\n/*\n>>>\
    \ string_xor(\"01010101010101\", \"10101010101010\")\n\"11111111111111\"\n*/\n\
    \n/*\n>>> string_xor(\"100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100100",
  "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= ($a[$i] ==\
    \ $b[$i]) ? \"0\" : \"1\";\n  }\n  return $result;\n}\n\n/*\n>>> string_xor(\"\
    010\", \"110\")\n\"100\"\n>>> string_xor(\"000\", \"111\")\n\"111\"\n>>> string_xor(\"\
    10101\", \"00101\")\n\"10000\"\n*/\n", "  $result = \"\";\n  for($i=0; $i<strlen($a);\
    \ $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\necho string_xor(\"\
    010\", \"110\");", "    $result = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n\
    \        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\n>>>\
    \ string_xor(\"101\", \"010\")\n\"111\"\n>>> string_xor(\"101\", \"101\")\n\"\
    000\"\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"\
    101\", \"010\")\n\"111\"\n>>> string_xor(\"101\", \"101\")\n\"000\"\n>>> string_xor(\"\
    000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"101\", \"010\")\n\"111\"\n\
    >>> string_xor(\"101\", \"101\")\n\"000\"\n>>> string_xor(\"000\", \"111\")\n\"\
    111\"\n*/\n\n/*\n>>> string_xor(\"101\", \"010\")\n\"111\"\n>>> string_xor(\"\
    101\", \"101\")\n\"000\"\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n\
    >>> string_xor(\"101\", \"010\")\n\"111\"\n>>> string_xor(\"101\", \"101\")\n\"\
    000\"\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"\
    101\", \"010\")\n\"111\"\n>>> string_xor(\"101\", \"101\")\n\"000\"\n>>> string_xor(\"\
    000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"101\", \"010\")\n\"111\"\n\
    >>> string_xor(\"101\", \"101\")\n\"000\"\n>>> string_xor(\"000\", \"111\")\n\"\
    111\"\n*/\n\n/*\n>>> string_xor(\"101\", \"010\")\n\"111\"\n>>> string_xor(\"\
    101\", \"101\")\n\"000\"\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n\
    >>> string_xor(\"101\", \"010\")\n\"111\"\n>>> string_xor(\"101\", \"101\")",
  "  $a = str_split($a);\n  $b = str_split($b);\n  $result = [];\n  for ($i = 0; $i\
    \ < count($a); $i++) {\n    if ($a[$i] == $b[$i]) {\n      $result[] = 0;\n  \
    \  } else {\n      $result[] = 1;\n    }\n  }\n  return implode($result);\n}\n\
    \n/*\nGiven a string of digits, you should replace any digit below 5 with '0'\
    \ and any digit 5 and above with '1'. Return the resulting string.\n>>> fake_bin('45385593107843568')\n\
    '01011110001100111'\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++)\
    \ {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\necho string_xor(\"\
    010\", \"110\");", "    $result = '';\n    for ($i = 0; $i < strlen($a); $i++)\
    \ {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\n\
    >>> string_xor(\"010\", \"110\")\n\"100\"\n*/\n\n/*\n>>> string_xor(\"101\", \"\
    101\")\n\"000\"\n*/\n\n/*\n>>> string_xor(\"100\", \"000\")\n\"100\"\n*/\n\n/*\n\
    >>> string_xor(\"001\", \"101\")\n\"100\"\n*/\n\n/*\n>>> string_xor(\"000\", \"\
    111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"010\", \"101\")\n\"111\"\n*/\n\n/*\n\
    >>> string_xor(\"101\", \"010\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"101\", \"\
    000\")\n\"101\"\n*/\n\n/*\n>>> string_xor(\"100\", \"111\")\n\"011\"\n*/\n\n/*\n\
    >>> string_xor(\"001\", \"100\")\n\"101\"\n*/\n\n/*\n>>> string_xor(\"111\", \"\
    100\")\n\"011\"\n*/\n\n/*\n>>> string_xor(\"000\", \"011\")\n\"011\"\n*/\n\n/*\n\
    >>> string_xor(\"011\", \"101\")\n\"110\"\n*/\n\n/*\n>>> string_xor(\"110\", \"\
    101\")\n\"011\"\n*/\n\n/*\n>>> string_xor(\"111\", \"001\")\n\"110\"\n*/\n\n/*\n\
    >>> string_xor(\"110\", \"011\")\n\"101\"\n*/\n\n/*\n>>> string_xor(\"000\", \"\
    110\")\n\"110\"\n*/\n\n/*\n>>> string_xor(\"101\", \"011\")\n\"110\"\n*/\n\n/*\n\
    >>> string_xor(\"011\", \"000\")\n\"011\"\n*/\n\n/*\n>>> string_xor(\"110\", \"\
    111\")\n\"001\"\n*/\n\n/*\n>>> string_xor(\"100\", \"001\")\n\"101\"\n*/\n\n/*\n\
    >>> string_xor(\"001\", \"011", "    $result = \"\";\n    for($i=0; $i<strlen($a);\
    \ $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\
    \n/*\nInput is a string consisting of 1s and 0s.\nReturn the number of 0s in the\
    \ string.\n>>> count_zeros(\"100101\")\n3\n>>> count_zeros(\"001\")\n2\n*/", " \
    \ $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^\
    \ $b[$i];\n  }\n  return $result;\n}\n\n/*\n>>> string_xor(\"10101\", \"00101\"\
    )\n\"10000\"\n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n\
    >>> string_xor(\"1010\", \"1010\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"1010\"\
    , \"0101\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"0101\")\n\"1000\"\n\
    */\n\n/*\n>>> string_xor(\"1101\", \"0001\")\n\"1100\"\n*/\n\n/*\n>>> string_xor(\"\
    1101\", \"0110\")\n\"1001\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1010\")\n\"\
    0111\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"0111\")\n\"1010\"\n*/\n\n/*\n>>>\
    \ string_xor(\"1101\", \"1111\")\n\"0010\"\n*/\n\n/*\n>>> string_xor(\"1101\"\
    , \"1011\")\n\"0100\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1110\")\n\"0001\"\n\
    */\n\n/*\n>>> string_xor(\"1101\", \"1101\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"\
    1101\", \"1100\")\n\"0001\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1000\")\n\"\
    0101\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"0100\")\n\"1001\"\n*/\n\n/*\n>>>\
    \ string_xor(\"1101\", \"0010\")\n\"1101\"\n*/\n\n/*\n>>> string_xor(\"1101\"\
    , \"0001\")\n\"1100\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"0000\")\n\"1101\"\n\
    */\n\n/*\n>>> string_xor(\"1100\", \"0111\")\n\"1011\"\n*/", "    $a = str_split($a);\n\
    \    $b = str_split($b);\n    $result = '';\n    foreach ($a as $key => $value)\
    \ {\n        if ($value == $b[$key]) {\n            $result .= '0';\n        }\
    \ else {\n            $result .= '1';\n        }\n    }\n    return $result;\n\
    }\n\n/*\n * Create a function that takes a string and returns a string in which\
    \ each character is repeated once.\n * double_char(\"String\") \u279E \"SSttrriinngg\"\
    \n * double_char(\"Hello World!\") \u279E \"HHeelllloo  WWoorrlldd!!\"\n * double_char(\"\
    1234!_ \") \u279E \"11223344!!__  \"\n */", "  $a = str_split($a);\n  $b = str_split($b);\n\
    \  $result = [];\n  for ($i = 0; $i < count($a); $i++) {\n    if ($a[$i] == $b[$i])\
    \ {\n      $result[] = 0;\n    } else {\n      $result[] = 1;\n    }\n  }\n  return\
    \ implode($result);\n}\n\n/*\nGiven a string, return a new string that has transformed\
    \ based on the input:\n\nChange case of every character, ie. lower case to upper\
    \ case, upper case to lower case.\nReverse the order of words from the input.\n\
    For example:\n\nstring_transformer(\"Example Input\")/string_transformer(\"Example\
    \ Input\") == \"iNPUT eXAMPLE\"\nYou may assume the input only contain English\
    \ alphabet and spaces.\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++)\
    \ {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nGiven a\
    \ string of digits, output all the contiguous substrings of length n in that string.\n\
    For example, the string \"49142\" has the following 3-digit series:\n\"491\"\n\
    \"914\"\n\"142\"\nAnd the following 4-digit series:\n\"4914\"\n\"9142\"\nAnd if\
    \ you ask for a 6-digit series from a 5-digit string, you deserve whatever you\
    \ get.\n>>> series_sum(3)\n\"491\"\n\"914\"\n\"142\"\n>>> series_sum(4)\n\"4914\"\
    \n\"9142\"\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nGiven an array of integers,\
    \ find the pair of adjacent elements that has the largest product and return that\
    \ product.\n>>> adjacent_element_product([3, 6, -2, -5, 7, 3])\n21\n*/", "  $result\
    \ = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\nGiven a string of digits, you should replace\
    \ any digit below 5 with '0' and any digit 5 and above with '1'. Return the resulting\
    \ string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'\n*/", "  $result\
    \ = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\nInput is a string consisting of 1s and 0s.\n\
    Return the number of 0s in the string.\n>>> count_zeros(\"1000101011\")\n4\n*/",
  "    $result = '';\n    for ($i = 0; $i < strlen($a); $i++) {\n        $result .=\
    \ $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\n * Given a string, return\
    \ the number of words it contains.\n * >>> count_words(\"Hello world\")\n * 2\n\
    \ */", "  $a = str_split($a);\n  $b = str_split($b);\n  $result = '';\n  for ($i\
    \ = 0; $i < count($a); $i++) {\n    if ($a[$i] == $b[$i]) {\n      $result .=\
    \ '0';\n    } else {\n      $result .= '1';\n    }\n  }\n  return $result;\n}\n\
    \n/*\nInput is a string of 1s and 0s.\nReturn the number of 1s in the string.\n\
    >>> count_ones(\"1000101\")\n4\n*/", "  $a = str_split($a);\n  $b = str_split($b);\n\
    \  $result = [];\n  for ($i = 0; $i < count($a); $i++) {\n    if ($a[$i] == $b[$i])\
    \ {\n      $result[] = 0;\n    } else {\n      $result[] = 1;\n    }\n  }\n  return\
    \ implode($result);\n}\n\n/*\n>>> string_xor(\"010\", \"110\")\n\"100\"\n*/\n\n\
    /*\n>>> string_xor(\"101\", \"010\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"101\"\
    , \"101\")\n\"000\"\n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\
    \n/*\n>>> string_xor(\"111\", \"000\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"100\"\
    , \"000\")\n\"100\"\n*/\n\n/*\n>>> string_xor(\"001\", \"101\")\n\"100\"\n*/\n\
    \n/*\n>>> string_xor(\"101\", \"010\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"101\"\
    , \"101\")\n\"000\"\n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\
    \n/*\n>>> string_xor(\"111\", \"000\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"100\"\
    , \"000\")\n\"100\"\n*/\n\n/*\n>>> string_xor(\"001\", \"101\")\n\"100\"\n*/\n\
    \n/*\n>>> string_xor(\"100\", \"111\")\n\"011\"\n*/\n\n/*\n>>> string_xor(\"000\"\
    , \"000\")\n\"000\"\n*/\n\n/*\n>>> string_xor(\"001\", \"011\")\n\"010\"\n*/\n\
    \n/*\n>>> string_xor(\"110\", \"101\")\n\"011\"\n*/\n\n/*\n>>> string_xor(\"111\"\
    , \"100\")\n\"011\"\n*/\n\n/*\n>>> string_xor(\"000\", \"001\")\n\"001\"\n*/\n\
    \n/*\n>>> string_xor(\"101\",", "  $result = \"\";\n  for($i=0; $i<strlen($a);\
    \ $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\n\
    Input is a string consisting of 1s and 0s.\nReturn the number of 1s in the string.\n\
    >>> count_ones(\"1000101\")\n4\n*/", "    $a = str_split($a);\n    $b = str_split($b);\n\
    \    $c = [];\n    for ($i = 0; $i < count($a); $i++) {\n        if ($a[$i] ==\
    \ $b[$i]) {\n            $c[] = 0;\n        } else {\n            $c[] = 1;\n\
    \        }\n    }\n    return implode($c);\n}\n\n/*\nInput is a string of 1s and\
    \ 0s.\nReturn the number of 0s in the string.\n>>> count_zeros(\"1000101011\"\
    )\n5\n*/", "    $result = '';\n    for ($i = 0; $i < strlen($a); $i++) {\n   \
    \     $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/* Given a\
    \ string of digits, you should replace any digit below 5 with '0' and any digit\
    \ 5 and above with '1'.\nReturn the resulting string.\n>>> fake_bin('45385593107843568')\n\
    '01011110001100111'*/", "  $a = str_split($a);\n  $b = str_split($b);\n  $result\
    \ = [];\n  for ($i = 0; $i < count($a); $i++) {\n    if ($a[$i] == $b[$i]) {\n\
    \      $result[] = 0;\n    } else {\n      $result[] = 1;\n    }\n  }\n  return\
    \ implode($result);\n}\n\n/*\nGiven a string of digits, you should replace any\
    \ digit below 5 with '0' and any digit 5 and above with '1'. Return the resulting\
    \ string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'\n*/", "  $result\
    \ = '';\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\nGiven a string of digits, you should replace\
    \ any digit below 5 with '0' and any digit 5 and above with '1'. Return the resulting\
    \ string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'\n*/", "    $result\
    \ = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $result;\n}\n\n/*\nGiven a string of digits, output all the\
    \ contiguous substrings of length n in that string.\n>>> substrings(\"123456789\"\
    , 3)\n[\"123\", \"234\", \"345\", \"456\", \"567\", \"678\", \"789\"]\n*/", " \
    \ $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^\
    \ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string of 1s and 0s.\n\
    Return the number of 1s in the string.\n>>> count_ones(\"10001\")\n2\n*/", " \
    \   $a = str_split($a);\n    $b = str_split($b);\n    $result = [];\n    foreach\
    \ ($a as $key => $value) {\n        if ($value == $b[$key]) {\n            $result[]\
    \ = 0;\n        } else {\n            $result[] = 1;\n        }\n    }\n    return\
    \ implode($result);\n}\n\n/*\nGiven a string, return a new string that has transformed\
    \ based on the input:\n\nChange case of every character, ie. lower case to upper\
    \ case, upper case to lower case.\nReverse the order of words from the input.\n\
    For example:\n\nstring_transformer(\"Example Input\")/string_transformer(\"Example\
    \ Input\") == \"iNPUT eXAMPLE\"\nYou may assume the input only contain English\
    \ alphabet and spaces.\n*/", "    $result = \"\";\n    for($i=0; $i<strlen($a);\
    \ $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\
    \n/*\nInput is a string of 1s and 0s.\nReturn the number of 1s in the string.\n\
    >>> count_ones(\"1000101\")\n4\n*/", "  $result = '';\n  for($i=0; $i<strlen($a);\
    \ $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\n\
    Input is a string of 1s and 0s.\nReturn the number of 0s in the string.\n>>> count_zeros(\"\
    1000101011\")\n5\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n\
    \    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\necho string_xor(\"\
    010\", \"110\");", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n  \
    \  $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string\
    \ consisting of 1s and 0s.\nReturn the number of substrings that start and end\
    \ with 1.\n>>> count_ones(\"0110011\")\n3\n>>> count_ones(\"101\")\n2\n>>> count_ones(\"\
    111111\")\n21\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n \
    \   $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string\
    \ consisting of 1s and 0s.\nReturn the number of 0s in the string.\n>>> count_zeros(\"\
    1000101011\")\n5\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n\
    \    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a\
    \ string of 1s and 0s.\nReturn the number of 1s in the string.\n>>> count_ones(\"\
    10011\")\n3\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n   \
    \ $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string\
    \ consisting of 1s and 0s.\nReturn the number of 0s in the string.\n>>> count_zeros(\"\
    1000101011\")\n5\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n\
    \    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a\
    \ string consisting of 1s and 0s.\nReturn the number of 0s in the string.\n>>>\
    \ count_zeros(\"1000101011\")\n5\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a);\
    \ $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\n\
    Input is a string of 1s and 0s.\nReturn the number of 1s in the string.\n>>> count_ones(\"\
    110\")\n2\n*/", "    $result = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n \
    \       $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\nInput\
    \ is a string of 1s and 0s.\nReturn the number of 1s in the string.\n>>> count_ones(\"\
    1000101\")\n4\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n \
    \   $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/* Input is a string\
    \ of 1s and 0s.\nReturn the number of 1s in the string.\n>>> count_ones(\"10011\"\
    )\n3*/", "  $a = str_split($a);\n  $b = str_split($b);\n  $result = [];\n  foreach\
    \ ($a as $key => $value) {\n    if ($value == $b[$key]) {\n      $result[] = 0;\n\
    \    } else {\n      $result[] = 1;\n    }\n  }\n  return implode($result);\n\
    }\n\n/*\nGiven a list of integers, return the largest product that can be made\
    \ by multiplying any three integers.\nFor example, if the list is [-10, -10, 5,\
    \ 2], we should return 500, since that's -10 * -10 * 5.\nYou can assume the list\
    \ has at least three integers.\n>>> largest_product([-10, -10, 5, 2])\n500\n>>>\
    \ largest_product([-10, -10, 5, 2, -1])\n500\n>>> largest_product([-10, -10, 5,\
    \ 2, -1, -1])\n500\n>>> largest_product([-10, -10, 5, 2, -1, -1, -1])\n500\n>>>\
    \ largest_product([-10, -10, 5, 2, -1, -1, -1, -1])\n500\n>>> largest_product([-10,\
    \ -10, 5, 2, -1, -1, -1, -1, -1])\n500\n>>> largest_product([-10, -10, 5, 2, -1,\
    \ -1, -1, -1, -1, -1])\n500\n>>> largest_product([-10, -10, 5, 2, -1, -1, -1,\
    \ -1, -1, -1, -1])\n500\n>>> largest_product([-10, -10, 5, 2, -1, -1, -1, -1,\
    \ -1, -1, -1, -1])\n500\n>>> largest_product([-10, -10, 5, 2, -1, -1, -1, -1,\
    \ -1, -1, -1, -1, -1])\n500\n>>> largest_product([-10, -10, 5, 2, -1, -1, -1,\
    \ -1, -1, -1, -", "    $result = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n\
    \        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\nYou\
    \ are given an array of integers. On each move you are allowed to increase exactly\
    \ one of its element by one. Find the minimal number of moves required to obtain\
    \ a strictly increasing sequence from the input.\n>>> arrayChange([1, 1, 1])\n\
    3\n>>> arrayChange([-1000, 0, -2, 0])\n5\n*/", "    $a = str_split($a);\n    $b\
    \ = str_split($b);\n    $result = [];\n    for ($i = 0; $i < count($a); $i++)\
    \ {\n        if ($a[$i] == $b[$i]) {\n            $result[] = 0;\n        } else\
    \ {\n            $result[] = 1;\n        }\n    }\n    return implode($result);\n\
    }\n\n/*\nGiven a string of digits, you should replace any digit below 5 with '0'\
    \ and any digit 5 and above with '1'. Return the resulting string.\n\n>>> fake_bin('45385593107843568')\n\
    '01011110001100111'\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++)\
    \ {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/* Input is\
    \ a string of 1s and 0s.\nReturn the number of 1s in the string.\n>>> count_ones(\"\
    1000101\")\n4*/", "  $result = '';\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string consisting\
    \ of 1s and 0s.\nReturn the number of 1s in the string.\n>>> count_ones(\"1000101\"\
    )\n4\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string consisting\
    \ of 1s and 0s.\nReturn the number of 0s in the string.\n>>> count_zeros(\"1000101011\"\
    )\n5\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nGiven a string of digits,\
    \ you should replace any digit below 5 with '0' and any digit 5 and above with\
    \ '1'. Return the resulting string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'\n\
    */", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i]\
    \ ^ $b[$i];\n  }\n  return $result;\n}\n\n/* Input are two strings a and b consisting\
    \ only of 1s and 0s.\nPerform binary AND on these inputs and return result also\
    \ as a string.\n>>> string_and(\"010\", \"110\")\n\"010\"*/", "    $result = \"\
    \";\n    for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $result;\n}\n\n/*\nGiven a string of digits, you should replace\
    \ any digit below 5 with '0' and any digit 5 and above with '1'. Return the resulting\
    \ string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'\n*/", "  $result\
    \ = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\nInput is a string of 1s and 0s.\nReturn the\
    \ number of 1s in the string.\n>>> count_ones(\"1000101\")\n4\n*/", "  $a = str_split($a);\n\
    \  $b = str_split($b);\n  $result = [];\n  for ($i = 0; $i < count($a); $i++)\
    \ {\n    if ($a[$i] == $b[$i]) {\n      $result[] = 0;\n    } else {\n      $result[]\
    \ = 1;\n    }\n  }\n  return implode($result);\n}\n\n/*\nInput is a string of\
    \ 1s and 0s.\nOutput is a string of 1s and 0s.\nThe output string should be the\
    \ same length as the input string.\nThe output string should be the result of\
    \ performing a binary XOR on all the characters in the input string.\n>>> xor_encrypt(\"\
    10101\", \"00101\")\n\"10000\"\n>>> xor_encrypt(\"10101\", \"11110\")\n\"01111\"\
    \n*/", "  $res = '';\n  for ($i = 0; $i < strlen($a); $i++) {\n    $res .= $a[$i]\
    \ ^ $b[$i];\n  }\n  return $res;\n}\n\n/*\nInput is a string of 1s and 0s.\nReturn\
    \ the number of 1s in the string.\n>>> count_ones(\"10001\")\n2\n*/", "    $a\
    \ = str_split($a);\n    $b = str_split($b);\n    $result = [];\n    for ($i =\
    \ 0; $i < count($a); $i++) {\n        $result[] = $a[$i] ^ $b[$i];\n    }\n  \
    \  return implode('', $result);\n}\n\n/*\n>>> string_xor(\"0101\", \"0011\")\n\
    \"0110\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>>\
    \ string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"010\", \"\
    110\")\n\"100\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n\
    /*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"\
    0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"\
    1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>>\
    \ string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\"\
    , \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n\
    */\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"\
    0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"\
    1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>>\
    \ string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\"\
    , \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111",
  "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^\
    \ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string of 1s and 0s.\n\
    Return the number of 0s in the string.\n>>> count_zeros(\"1000101011\")\n5\n*/",
  "    $a = str_split($a);\n    $b = str_split($b);\n    $result = [];\n    for ($i\
    \ = 0; $i < count($a); $i++) {\n        $result[] = $a[$i] ^ $b[$i];\n    }\n\
    \    return implode($result);\n}\n\n/*\nInput is a string of 1s and 0s.\nReturn\
    \ the number of 1s in the string.\n>>> count_ones(\"1000101\")\n4\n*/", "  $result\
    \ = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\n>>> string_xor(\"10101\", \"00101\")\n\"10000\"\
    \n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"\
    1010\", \"1010\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"1010\", \"0101\")\n\"\
    1111\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"0101\")\n\"1000\"\n*/\n\n/*\n>>>\
    \ string_xor(\"1101\", \"1101\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"1101\"\
    , \"0100\")\n\"1001\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"0010\")\n\"1111\"\n\
    */\n\n/*\n>>> string_xor(\"1101\", \"0001\")\n\"1100\"\n*/\n\n/*\n>>> string_xor(\"\
    1101\", \"0000\")\n\"1101\"\n*/\n\n/*\n>>> string_xor(\"1100\", \"0000\")\n\"\
    1100\"\n*/\n\n/*\n>>> string_xor(\"1010\", \"0000\")\n\"1010\"\n*/\n\n/*\n>>>\
    \ string_xor(\"0101\", \"0000\")\n\"0101\"\n*/\n\n/*\n>>> string_xor(\"0000\"\
    , \"0000\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"1111\", \"0000\")\n\"1111\"\n\
    */\n\n/*\n>>> string_xor(\"1110\", \"0000\")\n\"1110\"\n*/\n\n/*\n>>> string_xor(\"\
    1100\", \"0000\")\n\"1100\"\n*/\n\n/*\n>>> string_xor(\"1000\", \"0000\")\n\"\
    1000\"\n*/\n\n/*\n>>> string_xor(\"0000\", \"1111\")\n\"1111\"\n*/\n\n/*\n>>>\
    \ string_xor(\"0000\", \"1110\")\n\"1110\"\n*/\n\n/*\n>>> string_xor(\"0000\",",
  "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^\
    \ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string of 1s and 0s.\n\
    Return the number of 0s in the string.\n>>> count_zeros(\"1000101011\")\n5\n*/",
  "  $result = '';\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/* Given a string of digits, you should replace\
    \ any digit below 5 with '0' and any digit 5 and above with '1'. Return the resulting\
    \ string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'*/", "  $result\
    \ = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\nGiven a string of digits, you should replace\
    \ any digit below 5 with '0' and any digit 5 and above with '1'. Return the resulting\
    \ string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'\n*/", "  $result\
    \ = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\nInput is a string of 1s and 0s.\nReturn the\
    \ number of 1s in the string.\n>>> count_ones(\"100101\")\n3\n*/", "  $result\
    \ = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\n>>> string_xor(\"10101\", \"00101\")\n\"10000\"\
    \n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"\
    1010\", \"1010\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"1010\", \"0101\")\n\"\
    1111\"\n*/\n\n/*\n>>> string_xor(\"0\", \"0\")\n\"0\"\n*/\n\n/*\n>>> string_xor(\"\
    1\", \"0\")\n\"1\"\n*/\n\n/*\n>>> string_xor(\"0\", \"1\")\n\"1\"\n*/\n\n/*\n\
    >>> string_xor(\"1\", \"1\")\n\"0\"\n*/\n\n/*\n>>> string_xor(\"\", \"\")\n\"\"\
    \n*/\n\n/*\n>>> string_xor(\"\", \"0\")\n\"0\"\n*/\n\n/*\n>>> string_xor(\"\"\
    , \"1\")\n\"1\"\n*/\n\n/*\n>>> string_xor(\"0\", \"\")\n\"0\"\n*/\n\n/*\n>>> string_xor(\"\
    1\", \"\")\n\"1\"\n*/\n\n/*\n>>> string_xor(\"0\", \"0\")\n\"0\"\n*/\n\n/*\n>>>\
    \ string_xor(\"0\", \"0\")\n\"0\"\n*/\n\n/*\n>>> string_xor(\"0\", \"0\")\n\"\
    0\"\n*/\n\n/*\n>>> string_xor(\"0\", \"0\")\n\"0\"\n*/\n\n/*\n>>> string_xor(\"\
    0\", \"0\")\n\"0\"\n*/\n\n/*\n>>> string_xor(\"0\", \"0\")\n\"0\"\n*/\n\n/*\n\
    >>> string_xor(\"0\", \"0\")\n\"0\"\n*/\n\n/*\n>>> string_xor(\"0\", \"0\")\n\"\
    0\"\n*/\n\n/*\n>>> string_xor(\"0\", \"0\")\n", "  $result = '';\n  for($i=0;\
    \ $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n\
    }\n\n/* Input is a string consisting of 1s and 0s.\nReturn the number of 0s in\
    \ the string.\n>>> count_zeros(\"1000101011\")\n5*/", "  $result = \"\";\n  for($i=0;\
    \ $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n\
    }\n\n/* Input is a string of 1s and 0s.\nReturn the number of 1s in the string.\n\
    >>> count_ones(\"100101\")\n3*/", "    $result = \"\";\n    for($i=0; $i<strlen($a);\
    \ $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}",
  "    $result = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i]\
    \ ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\n>>> string_xor(\"010\", \"110\"\
    )\n\"100\"\n>>> string_xor(\"101\", \"111\")\n\"010\"\n>>> string_xor(\"100\"\
    , \"000\")\n\"100\"\n>>> string_xor(\"111\", \"111\")\n\"000\"\n>>> string_xor(\"\
    \", \"111\")\n\"\"\n>>> string_xor(\"010\", \"\")\n\"\"\n>>> string_xor(\"\",\
    \ \"\")\n\"\"\n*/", "  $a = str_split($a);\n  $b = str_split($b);\n  $result =\
    \ [];\n  foreach ($a as $key => $value) {\n    if ($value == $b[$key]) {\n   \
    \   $result[] = 0;\n    } else {\n      $result[] = 1;\n    }\n  }\n  return implode($result);\n\
    }\n\n/*\nGiven a string of digits, you should replace any digit below 5 with '0'\
    \ and any digit 5 and above with '1'. Return the resulting string.\n>>> fake_bin('45385593107843568')\n\
    '01011110001100111'\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++)\
    \ {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/* Input are\
    \ two strings a and b consisting only of 1s and 0s.\nPerform binary AND on these\
    \ inputs and return result also as a string.\n>>> string_and(\"010\", \"110\"\
    )\n\"010\"*/", "    $result = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n  \
    \      $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\nGiven\
    \ a string, return a new string where the first and last chars have been exchanged.\n\
    >>> front_back('code')\n'eodc'\n>>> front_back('a')\n'a'\n>>> front_back('ab')\n\
    'ba'\n*/", "  $result = '';\n  for($i=0; $i<strlen($a); $i++) {\n    $result .=\
    \ $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\n>>> string_xor(\"10101\"\
    , \"00101\")\n\"10000\"\n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"111\"\n\
    */\n\n/*\n>>> string_xor(\"1010\", \"1010\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"\
    1010\", \"0101\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"11101\", \"10101\")\n\"\
    01000\"\n*/\n\n/*\n>>> string_xor(\"11101\", \"10101\")\n\"01000\"\n*/\n\n/*\n\
    >>> string_xor(\"11101\", \"10101\")\n\"01000\"\n*/\n\n/*\n>>> string_xor(\"11101\"\
    , \"10101\")\n\"01000\"\n*/\n\n/*\n>>> string_xor(\"11101\", \"10101\")\n\"01000\"\
    \n*/\n\n/*\n>>> string_xor(\"11101\", \"10101\")\n\"01000\"\n*/\n\n/*\n>>> string_xor(\"\
    11101\", \"10101\")\n\"01000\"\n*/\n\n/*\n>>> string_xor(\"11101\", \"10101\"\
    )\n\"01000\"\n*/\n\n/*\n>>> string_xor(\"11101\", \"10101\")\n\"01000\"\n*/\n\n\
    /*\n>>> string_xor(\"11101\", \"10101\")\n\"01000\"\n*/\n\n/*\n>>> string_xor(\"\
    11101\", \"10101\")\n\"01000\"\n*/\n\n/*\n>>> string_xor(\"11101\", \"10101\"\
    )\n\"01000\"\n*/\n\n/*\n>>> string_xor(\"11101\", \"10101\")\n\"01000\"\n*/\n\n\
    /*\n>>> string_xor(\"11101\", \"10101\")\n\"01000\"\n*/\n\n/*\n>>> string_xor(\"\
    11101\", \"10101\")\n\"01000\"\n*/\n\n/*\n>>>", "    $result = \"\";\n    for($i=0;\
    \ $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return\
    \ $result;\n}\necho string_xor(\"010\", \"110\");", "  $a = str_split($a);\n \
    \ $b = str_split($b);\n  $result = [];\n  for ($i = 0; $i < count($a); $i++) {\n\
    \    if ($a[$i] == $b[$i]) {\n      $result[] = 0;\n    } else {\n      $result[]\
    \ = 1;\n    }\n  }\n  return implode($result);\n}\n\n/*\nGiven a string of digits,\
    \ you should replace any digit below 5 with '0' and any digit 5 and above with\
    \ '1'. Return the resulting string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'\n\
    */", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i]\
    \ ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string of 1s and 0s.\n\
    Return the number of 1s in the string.\n>>> count_ones(\"1000101\")\n4\n*/", " \
    \   $result = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n        $result .=\
    \ $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\nInput is a string of\
    \ 1s and 0s.\nReturn the number of 1s in the string.\n>>> count_ones(\"1000101\"\
    )\n4\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}", "  $a = str_split($a);\n  $b\
    \ = str_split($b);\n  $res = [];\n  for ($i = 0; $i < count($a); $i++) {\n   \
    \ if ($a[$i] == $b[$i]) {\n      $res[] = 0;\n    } else {\n      $res[] = 1;\n\
    \    }\n  }\n  return implode($res);\n}\n\n/*\nInput are two strings a and b consisting\
    \ only of 1s and 0s.\nPerform binary AND on these inputs and return result also\
    \ as a string.\n>>> string_and(\"010\", \"110\")\n\"010\"\n*/", "    $a = str_split($a);\n\
    \    $b = str_split($b);\n    $res = [];\n    for ($i = 0; $i < count($a); $i++)\
    \ {\n        if ($a[$i] == $b[$i]) {\n            $res[] = 0;\n        } else\
    \ {\n            $res[] = 1;\n        }\n    }\n    return implode($res);\n}\n\
    \n/*\nYou are given a string of n lines, each substring being n characters long:\
    \ For example:\n\ns = \"abcd\\nefgh\\nijkl\\nmnop\"\n\nWe will study some transformations\
    \ of this square of strings.\n\nClock rotation 180 degrees: rot\nrot(s) => \"\
    ponm\\nlkji\\nhgfe\\ndcba\"\nselfie_and_rot(s) (or selfieAndRot or selfie-and-rot)\
    \ It is initial string + string obtained by clock rotation 180 degrees with dots\
    \ interspersed in order (hopefully) to better show the rotation when printed.\n\
    s = \"abcd\\nefgh\\nijkl\\nmnop\" -->\n\"abcd....\\nefgh....\\nijkl....\\nmnop....\\\
    n....ponm\\n....lkji\\n....hgfe\\n....dcba\"\nor printed:\n|rotation        |selfie_and_rot\n\
    |abcd --> ponm   |abcd --> abcd....\n|efgh     lkji   |efgh     efgh....\n|ijkl\
    \     hgfe   |ijkl     ijkl....\n|mnop     dcba   |mnop     mnop....\n       \
    \                    ....ponm\n                           ....lkji\n         \
    \                  ....hgfe\n                           ....dcba", "    $result\
    \ = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $result;\n}\n\n/*\n>>> string_xor(\"10101\", \"00101\")\n\"\
    10000\"\n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"\
    1010\", \"1010\")\n\"0000\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1010\")\n\"\
    0111\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1010\")\n\"0111\"\n*/\n\n/*\n>>>\
    \ string_xor(\"1101\", \"1010\")\n\"0111\"\n*/\n\n/*\n>>> string_xor(\"1101\"\
    , \"1010\")\n\"0111\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1010\")\n\"0111\"\n\
    */\n\n/*\n>>> string_xor(\"1101\", \"1010\")\n\"0111\"\n*/\n\n/*\n>>> string_xor(\"\
    1101\", \"1010\")\n\"0111\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1010\")\n\"\
    0111\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1010\")\n\"0111\"\n*/\n\n/*\n>>>\
    \ string_xor(\"1101\", \"1010\")\n\"0111\"\n*/\n\n/*\n>>> string_xor(\"1101\"\
    , \"1010\")\n\"0111\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1010\")\n\"0111\"\n\
    */\n\n/*\n>>> string_xor(\"1101\", \"1010\")\n\"0111\"\n*/\n\n/*\n>>> string_xor(\"\
    1101\", \"1010\")\n\"0111\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1010\")\n\"\
    0111\"\n*/\n\n/*\n>>> string_xor(\"1101\", \"1010\")\n\"0111\"\n*/\n\n/*\n", " \
    \ $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^\
    \ $b[$i];\n  }\n  return $result;\n}\necho string_xor(\"010\", \"110\");", " \
    \ $a = str_split($a);\n  $b = str_split($b);\n  $result = [];\n  for ($i = 0;\
    \ $i < count($a); $i++) {\n    if ($a[$i] == $b[$i]) {\n      $result[] = 0;\n\
    \    } else {\n      $result[] = 1;\n    }\n  }\n  return implode($result);\n\
    }\necho string_xor(\"010\", \"110\");", "  $result = \"\";\n  for($i=0; $i<strlen($a);\
    \ $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\n\
    Input is a string of 1s and 0s.\nReturn the number of 1s in the string.\n>>> count_ones(\"\
    1000101\")\n4\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n \
    \   $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string\
    \ of 1s and 0s.\nReturn the number of 1s in the string.\n>>> count_ones(\"1000101\"\
    )\n4\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string of 1s\
    \ and 0s.\nReturn the number of 1s in the string.\n>>> count_ones(\"1000101\"\
    )\n4\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/* Given a string of digits,\
    \ you should replace any digit below 5 with '0'\nand any digit 5 and above with\
    \ '1'. Return the resulting string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'*/",
  "  $result = '';\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\nInput is a string of 1s and 0s.\nReturn the\
    \ number of 1s in the string.\n>>> count_ones(\"1000101\")\n4\n*/", "    $result\
    \ = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $result;\n}\n\n/*\n>>> string_xor(\"010\", \"110\")\n\"100\"\
    \n>>> string_xor(\"101\", \"010\")\n\"111\"\n>>> string_xor(\"101\", \"101\")\n\
    \"000\"\n*/", "    $result = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n   \
    \     $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\necho string_xor(\"\
    010\", \"110\");", "  $result = '';\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}", "  $result = \"\";\n  for($i=0;\
    \ $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n\
    }\n\n/*\n>>> string_xor(\"0101\", \"0011\")\n\"0110\"\n*/\n\n/*\n>>> string_xor(\"\
    0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"111\"\
    \n*/\n\n/*\n>>> string_xor(\"010\", \"101\")\n\"111\"\n*/\n\n/*\n>>> string_xor(\"\
    0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"\
    1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>>\
    \ string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\"\
    , \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n\
    */\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"\
    0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"\
    1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>>\
    \ string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\"\
    , \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n\
    */\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"\
    0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"\
    1111\"", "    $result = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n        $result\
    \ .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\n>>> string_xor(\"\
    10101\", \"00101\")\n\"10000\"\n*/\n\n/*\n>>> string_xor(\"000\", \"111\")\n\"\
    111\"\n*/\n\n/*\n>>> string_xor(\"10101\", \"10101\")\n\"00000\"\n*/\n\n/*\n>>>\
    \ string_xor(\"111010\", \"101\")\n\"100111\"\n*/\n\n/*\n>>> string_xor(\"\",\
    \ \"\")\n\"\"\n*/\n\n/*\n>>> string_xor(\"1\", \"0\")\n\"1\"\n*/\n\n/*\n>>> string_xor(\"\
    0\", \"1\")\n\"1\"\n*/\n\n/*\n>>> string_xor(\"0\", \"0\")\n\"0\"\n*/\n\n/*\n\
    >>> string_xor(\"1\", \"1\")\n\"0\"\n*/\n\n/*\n>>> string_xor(\"10\", \"10\")\n\
    \"00\"\n*/\n\n/*\n>>> string_xor(\"10\", \"0\")\n\"10\"\n*/\n\n/*\n>>> string_xor(\"\
    0\", \"10\")\n\"10\"\n*/\n\n/*\n>>> string_xor(\"10\", \"1\")\n\"11\"\n*/\n\n\
    /*\n>>> string_xor(\"1\", \"10\")\n\"11\"\n*/\n\n/*\n>>> string_xor(\"11\", \"\
    10\")\n\"01\"\n*/\n\n/*\n>>> string_xor(\"10\", \"11\")\n\"01\"\n*/\n\n/*\n>>>\
    \ string_xor(\"111\", \"111\")\n\"000\"\n*/\n\n/*\n>>> string_xor(\"110\", \"\
    101\")\n\"011\"\n*/\n\n/*\n>>> string_xor(\"101\", \"110\")\n\"011\"\n*/\n\n/*\n\
    >>> string_xor(\"100\", \"111\")\n\"011\"\n*/\n\n/*\n>>> string_xor(\"111\", \"\
    100\")\n\"011\"\n*/\n\n/*\n>>> string_xor(\"11", "  $a = str_split($a);\n  $b\
    \ = str_split($b);\n  $result = [];\n  for ($i = 0; $i < count($a); $i++) {\n\
    \    if ($a[$i] == $b[$i]) {\n      $result[] = 0;\n    } else {\n      $result[]\
    \ = 1;\n    }\n  }\n  return implode($result);\n}\n\n/*\nGiven a string, return\
    \ the sum of the numbers appearing in the string, ignoring all other characters.\n\
    A number is a series of 1 or more digit chars in a row.\n(Note: Character.isDigit(char)\
    \ tests if a char is one of the chars '0', '1', .. '9'.\nInteger.parseInt(string)\
    \ converts a string to an int.)\n\nsumNumbers(\"abc123xyz\") \u2192 123\nsumNumbers(\"\
    aa11b33\") \u2192 44\nsumNumbers(\"7 11\") \u2192 18\n*/", "  $result = \"\";\n\
    \  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return\
    \ $result;\n}\n\n/*\nInput is a string of 1s and 0s.\nReturn the number of 1s\
    \ in the string.\n>>> count_ones(\"1000101\")\n4\n*/", "  $c = '';\n  for ($i\
    \ = 0; $i < strlen($a); $i++) {\n    $c .= ($a[$i] == $b[$i]) ? '0' : '1';\n \
    \ }\n  return $c;\n}\n\n/*\nGiven a string of digits, you should replace any digit\
    \ below 5 with '0' and any digit 5 and above with '1'. Return the resulting string.\n\
    >>> fake_bin('45385593107843568')\n'01011110001100111'\n*/", "  $result = \"\"\
    ;\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n\
    \  return $result;\n}\n\n/*\nInput is a string consisting of only 1s and 0s.\n\
    Return the number of substrings that start and end with 1.\n>>> count_substrings(\"\
    0110111\")\n3\n>>> count_substrings(\"101\")\n2\n>>> count_substrings(\"111111\"\
    )\n6\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string consisting\
    \ of 1s and 0s.\nReturn the number of 0s in the string.\n>>> count_zeros(\"1000101011\"\
    )\n5\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string of 1s\
    \ and 0s.\nReturn the number of 1s in the string.\n>>> count_ones(\"1000101\"\
    )\n4\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string consisting\
    \ of 1s and 0s.\nReturn the number of 0s in the string.\n>>> count_zeros(\"1000101011\"\
    )\n5\n*/", "    $result = '';\n    for ($i = 0; $i < strlen($a); $i++) {\n   \
    \     $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\nInput\
    \ is a string of 1s and 0s.\nReturn the number of 1s in the string.\n>>> count_ones(\"\
    10001\")\n2\n*/", "    $result = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n\
    \        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\necho string_xor(\"\
    010\", \"110\");", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n  \
    \  $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string\
    \ of 1s and 0s.\nReturn the number of 1s in the string.\n>>> count_bits(\"100101\"\
    )\n3\n*/", "    $result = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n      \
    \  $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\n>>> string_xor(\"\
    010\", \"110\")\n\"100\"\n>>> string_xor(\"101\", \"111\")\n\"010\"\n>>> string_xor(\"\
    101\", \"010\")\n\"111\"\n>>> string_xor(\"000\", \"111\")\n\"111\"\n>>> string_xor(\"\
    010\", \"101\")\n\"111\"\n>>> string_xor(\"101\", \"000\")\n\"101\"\n*/", "  \
    \  $result = '';\n    for ($i = 0; $i < strlen($a); $i++) {\n        $result .=\
    \ $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/* Given a string of digits,\
    \ you should replace any digit below 5 with '0' and any digit 5 and above with\
    \ '1'.\nReturn the resulting string.\n>>> fake_bin('45385593107843568')\n'01011110001100111'*/",
  "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^\
    \ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string consisting of 1s\
    \ and 0s.\nReturn the number of consecutive 0s in the string.\n>>> count_zeros(\"\
    1001000100001\")\n4\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++)\
    \ {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/* Given a\
    \ string of digits, you should replace any digit below 5 with '0' and any digit\
    \ 5 and above with '1'.\nReturn the resulting string.\n>>> fake_bin('45385593107843568')\n\
    '01011110001100111'*/", "    $result = \"\";\n    for($i=0; $i<strlen($a); $i++)\
    \ {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\n\
    Input are two strings a and b consisting only of 1s and 0s.\nPerform binary AND\
    \ on these inputs and return result also as a string.\n>>> string_and(\"010\"\
    , \"110\")\n\"010\"\n*/", "  $result = \"\";\n  for($i=0; $i<strlen($a); $i++)\
    \ {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is\
    \ a string of 1s and 0s.\nReturn a string that is the input string with the first\
    \ character removed.\n>>> remove_first_bit(\"100101\")\n\"00101\"\n*/", "    $result\
    \ = '';\n    for ($i = 0; $i < strlen($a); $i++) {\n        $result .= $a[$i]\
    \ ^ $b[$i];\n    }\n    return $result;\n}\n\n/*\nYou are given an array of integers.\n\
    On each move you are allowed to increase exactly one of its element by one.\n\
    Find the minimal number of moves required to obtain a strictly increasing sequence\
    \ from the input.\n>>> arrayChange([1, 1, 1])\n3\n>>> arrayChange([-1000, 0, -2,\
    \ 0])\n5\n*/", "  $result = '';\n  for($i=0; $i<strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nInput is a string of 1s\
    \ and 0s.\nReturn the number of 1s in the string.\n>>> count_ones(\"1000101\"\
    )\n4\n*/", "  $result = '';\n  for($i=0; $i<strlen($a); $i++) {\n    $result .=\
    \ $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n\n/*\nGiven a string, return a\
    \ new string that has transformed based on the input:\n\nChange case of every\
    \ character, ie. lower case to upper case, upper case to lower case.\nReverse\
    \ the order of words from the input.\nFor example:\n\nstring_transformer(\"Example\
    \ Input\")/string_transformer(\"Example Input\")/string_transformer(\"Example\
    \ Input\")/string_transformer(\"Example Input\")/string_transformer(\"Example\
    \ Input\") should return 'iNPUT eXAMPLE'\n\nYou may assume the input only contain\
    \ English alphabet and spaces.\n*/", "    $result = \"\";\n    for($i=0; $i<strlen($a);\
    \ $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\
    \n/*\nGiven a string of digits, you should replace any digit below 5 with '0'\
    \ and any digit 5 and above with '1'. Return the resulting string.\n>>> fake_bin('45385593107843568')\n\
    '01011110001100111'\n*/", "  $a = str_split($a);\n  $b = str_split($b);\n  $res\
    \ = [];\n  for ($i = 0; $i < count($a); $i++) {\n    if ($a[$i] == $b[$i]) {\n\
    \      $res[] = 0;\n    } else {\n      $res[] = 1;\n    }\n  }\n  return implode($res);\n\
    }\n\n/*\nInput is a string consisting of 1s and 0s.\nReturn the number of 0s in\
    \ the string.\n>>> count_zeros(\"1000101011\")\n4\n*/", "  $result = \"\";\n \
    \ for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return\
    \ $result;\n}\n\n/*\nInput is a string consisting of 1s and 0s.\nReturn the number\
    \ of 0s in the string.\n>>> count_zeros(\"1000101011\")\n5\n*/", "  $c = '';\n\
    \  for ($i = 0; $i < strlen($a); $i++) {\n    $c .= ($a[$i] == $b[$i]) ? '0' :\
    \ '1';\n  }\n  return $c;\n}\n\n/*\nInput is a string of 1s and 0s.\nReturn the\
    \ number of 1s in the string.\n>>> count_ones(\"10001\")\n2\n*/", "  $result =\
    \ \"\";\n  for($i=0; $i<strlen($a); $i++) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n\n/*\nInput is a string of 1s and 0s.\nReturn the\
    \ number of 1s in the string.\n>>> count_ones(\"1000101\")\n4\n*/", "    $result\
    \ = \"\";\n    for($i=0; $i<strlen($a); $i++) {\n        $result .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $result;\n}\n\n/*\n>>> string_xor(\"0101\", \"0011\")\n\"0110\"\
    \n*/\n\n/*\n>>> string_xor(\"0101\", \"1010\")\n\"1111\"\n*/\n\n/*\n>>> string_xor(\"\
    000\", \"111\")\n\"111\"\n*/", "    $result = '';\n    for ($i = 0; $i < strlen($a);\
    \ $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\
    \n/*\n>>> string_xor(\"101\", \"010\")\n\"111\"\n>>> string_xor(\"101\", \"011\"\
    )\n\"110\"\n>>> string_xor(\"101\", \"110\")\n\"011\"\n>>> string_xor(\"101\"\
    , \"111\")\n\"010\"\n>>> string_xor(\"000\", \"001\")\n\"001\"\n>>> string_xor(\"\
    010\", \"101\")\n\"111\"\n>>> string_xor(\"101\", \"101\")\n\"000\"\n>>> string_xor(\"\
    111\", \"000\")\n\"111\"\n>>> string_xor(\"100\", \"011\")\n\"111\"\n>>> string_xor(\"\
    001\", \"110\")\n\"111\"\n>>> string_xor(\"000\", \"000\")\n\"000\"\n>>> string_xor(\"\
    001\", \"111\")\n\"110\"\n>>> string_xor(\"111\", \"010\")\n\"101\"\n>>> string_xor(\"\
    110\", \"101\")\n\"011\"\n>>> string_xor(\"010\", \"000\")\n\"010\"\n>>> string_xor(\"\
    101\", \"011\")\n\"110\"\n>>> string_xor(\"110\", \"001\")\n\"111\"\n>>> string_xor(\"\
    100\", \"101\")\n\"001\"\n>>> string_xor(\"111\", \"101\")\n\"010\"\n>>> string_xor(\"\
    001\", \"101\")\n\"100\"\n>>> string_xor(\"011\", \"101\")\n\"110\"\n>>> string_xor(\"\
    101\", \"100\")\n\"001\"\n>>> string_xor(\"110\", \"011\")\n\"101\"\n>>> string_xor(\"\
    011\", \"001\")\n\"010\"\n>>> string_xor(\"100\", \"011\")\n\"111\"\n>>> string_xor(\"\
    101\", \"110\")\n\"011\"\n>>> string_xor(\"001\", \"011\")\n\"010\"\n>>> string_xor(\"\
    011\", \"111\")\n\"100\"\n>>> string_", "  $a = str_split($a);\n  $b = str_split($b);\n\
    \  $result = [];\n  for ($i = 0; $i < count($a); $i++) {\n    if ($a[$i] == $b[$i])\
    \ {\n      $result[] = 0;\n    } else {\n      $result[] = 1;\n    }\n  }\n  return\
    \ implode($result);\n}\n\n/* Input is a string consisting of 1s and 0s.\nReturn\
    \ a string with the same number of 1s and 0s,\nbut with the leftmost 1 moved to\
    \ the rightmost position.\n>>> leftmost_one(\"010101\")\n\"001010\"\n>>> leftmost_one(\"\
    00101010\")\n\"00001010\"*/", "    $result = '';\n    for ($i = 0; $i < strlen($a);\
    \ $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n\
    \n/*\nInput is a string of 1s and 0s.\nReturn the number of 1s in the string.\n\
    >>> count_ones(\"1000101\")\n4\n*/"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
