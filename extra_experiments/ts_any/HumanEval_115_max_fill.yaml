name: HumanEval_115_max_fill
language: ts
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n// 6\n// Example\
  \ 2:\n// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
  \ 2)\n// 5\n// Example 3:\n// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n// 0\n//\
  \ Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid: any, capacity: any): any {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0,\
  \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0,\
  \ 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n\
  }\n\ntest();"
completions: ["    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n \
    \       for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                grid[i][j] = 0;\n                count++;\n      \
    \          let k = i;\n                while (k < grid.length && grid[k][j] ===\
    \ 1) {\n                    grid[k][j] = 0;\n                    k++;\n      \
    \          }\n            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let row_count = 0;\n        for\
    \ (let j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n      \
    \          row_count++;\n            }\n        }\n        count += Math.ceil(row_count\
    \ / capacity);\n    }\n    return count;\n}\n", "    let total = 0;\n    let row\
    \ = grid.length;\n    let col = grid[0].length;\n    let buckets = new Array(col).fill(0);\n\
    \    let buckets_count = 0;\n    for (let i = 0; i < row; i++) {\n        for\
    \ (let j = 0; j < col; j++) {\n            if (grid[i][j] === 1) {\n         \
    \       buckets[j] += 1;\n                total += 1;\n            }\n       \
    \ }\n    }\n    buckets_count = Math.ceil(Math.max(...buckets) / capacity);\n\
    \    return buckets_count * col + total;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                grid[i][j] = 0;\n            }\n        }\n    }\n    return\
    \ count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "    let count\
    \ = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n    let max\
    \ = 0;\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col;\
    \ j++) {\n            if (grid[i][j] == 1) {\n                count++;\n     \
    \       }\n        }\n        max = Math.max(max, count);\n        count = 0;\n\
    \    }\n    return max * capacity;\n}\n", "    let count = 0;\n    for (let i\
    \ = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++)\
    \ {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \                grid[i][j] = 0;\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    let max = 0;\n    let row = 0;\n    let\
    \ col = 0;\n    let maxRow = 0;\n    let maxCol = 0;\n    let maxRowCount = 0;\n\
    \    let maxColCount = 0;\n    let maxRowCount2 = 0;\n    let maxColCount2 = 0;\n\
    \    let maxRowCount3 = 0;\n    let maxColCount3 = 0;\n    let maxRowCount4 =\
    \ 0;\n    let maxColCount4 = 0;\n    let maxRowCount5 = 0;\n    let maxColCount5\
    \ = 0;\n    let maxRowCount6 = 0;\n    let maxColCount6 = 0;\n    let maxRowCount7\
    \ = 0;\n    let maxColCount7 = 0;\n    let maxRowCount8 = 0;\n    let maxColCount8\
    \ = 0;\n    let maxRowCount9 = 0;\n    let maxColCount9 = 0;\n    let maxRowCount10\
    \ = 0;\n    let maxColCount10 = 0;\n    let maxRowCount11 = 0;\n    let maxColCount11\
    \ = 0;\n    let maxRowCount12 = 0;\n    let maxColCount12 = 0;\n    let maxRowCount13\
    \ = 0;\n    let maxColCount13 = 0;\n    let maxRowCount14 = 0;\n    let maxColCount14\
    \ = 0;\n    let maxRowCount15 = 0;\n    let maxColCount15 = 0;\n    let maxRowCount16\
    \ = 0;\n    let maxColCount16 = 0;\n    let maxRowCount17 = 0;\n    let maxColCount17\
    \ = 0;\n    let maxRowCount18 = 0;\n    let maxColCount18 = 0;\n    let maxRowCount19\
    \ = 0;\n    let maxColCount19 = 0;\n    let maxRowCount20 = 0;\n    let maxColCount20\
    \ = 0;\n    let maxRowCount21 = 0;\n    let maxColCount21 = 0;\n    let maxRowCount22\
    \ = 0;\n    let maxColCount22 = 0;\n    let maxRowCount23 = 0;\n    let maxColCount23\
    \ = 0;\n    let maxRowCount24 = 0;", "    let count = 0;\n    let row = grid.length;\n\
    \    let col = grid[0].length;\n    let max = 0;\n    for (let i = 0; i < row;\
    \ i++) {\n        for (let j = 0; j < col; j++) {\n            if (grid[i][j]\
    \ == 1) {\n                count++;\n            }\n        }\n        if (count\
    \ > max) {\n            max = count;\n        }\n        count = 0;\n    }\n \
    \   return max * capacity;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1,\
    \ 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]],\
    \ 5));", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n  \
    \      for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                grid[i][j] = 0;\n                count++;\n      \
    \          let k = i;\n                while (k < grid.length && grid[k][j] ===\
    \ 1) {\n                    grid[k][j] = 0;\n                    k++;\n      \
    \          }\n            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let max = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count++;\n    \
    \        }\n        }\n        if (count > max) {\n            max = count;\n\
    \        }\n        count = 0;\n    }\n    return max * capacity;\n}\n", "   \
    \ let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             count += capacity;\n                grid[i][j] = 0;\n          \
    \  }\n        }\n    }\n    return count;\n}\n", "    let result = 0;\n    let\
    \ max = 0;\n    let min = 0;\n    for (let i = 0; i < grid.length; i++) {\n  \
    \      for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                max = max + 1;\n            }\n        }\n       \
    \ if (max > min) {\n            min = max;\n        }\n        max = 0;\n    }\n\
    \    result = min * capacity;\n    return result;\n}\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let row_max = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let\
    \ row_sum = row.reduce((a, b) => a + b, 0);\n        if (row_sum > row_max) {\n\
    \            row_max = row_sum;\n        }\n    }\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b)\
    \ => a + b, 0);\n        if (row_sum < row_max) {\n            let diff = row_max\
    \ - row_sum;\n            count += diff;\n        }\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let max = 0;\n    let max_index\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (grid[i][j] == 1) {\n             \
    \   count++;\n            }\n        }\n        if (count > max) {\n         \
    \   max = count;\n            max_index = i;\n        }\n        count = 0;\n\
    \    }\n    let max_count = 0;\n    for (let i = 0; i < grid[max_index].length;\
    \ i++) {\n        if (grid[max_index][i] == 1) {\n            max_count++;\n \
    \       }\n    }\n    return max_count * capacity;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let wells = grid.length;\n\
    \    let well_length = grid[0].length;\n    let well_depth = 0;\n    let bucket_depth\
    \ = 0;\n    let bucket_capacity = capacity;\n    let bucket_full = false;\n  \
    \  let bucket_empty = false;\n    let bucket_depth_increment = 0;\n    let bucket_depth_decrement\
    \ = 0;\n    let bucket_depth_increment_count = 0;\n    let bucket_depth_decrement_count\
    \ = 0;\n    let bucket_depth_increment_count_total = 0;\n    let bucket_depth_decrement_count_total\
    \ = 0;\n    let bucket_depth_increment_count_total_max = 0;\n    let bucket_depth_decrement_count_total_max\
    \ = 0;\n    let bucket_depth_increment_count_total_max_index = 0;\n    let bucket_depth_decrement_count_total_max_index\
    \ = 0;\n    let bucket_depth_increment_count_total_max_index_row = 0;\n    let\
    \ bucket_depth_decrement_count_total_max_index_row = 0;\n    let bucket_depth_increment_count_total_max_index_col\
    \ = 0;\n    let bucket_depth_decrement_count_total_max_index_col = 0;\n    let\
    \ bucket_depth_increment_count_total_max_index_row_col = 0;\n    let bucket_depth_decrement_count_total_max_index_row_col\
    \ = 0;\n    let bucket_depth_increment_count_total_max_index_row_col_row = 0;\n\
    \    let bucket_depth_decrement_count_total_max_index_row_col_row = 0;\n    let\
    \ bucket_depth_increment_count_total_max_index_row_col_col = 0;\n    let bucket_depth_decrement_count_total_max_index_row_col_col\
    \ = 0;\n    let bucket_depth_increment_count_total_max_index_row_col_row_col =\
    \ 0;", "    let count = 0;\n    let max = 0;\n    let max_index = 0;\n    let\
    \ max_index_array = [];\n    let max_array = [];\n    let max_array_index = 0;\n\
    \    let max_array_index_array = [];\n    let max_array_index_array_index = 0;\n\
    \    let max_array_index_array_index_array = [];\n    let max_array_index_array_index_array_index\
    \ = 0;\n    let max_array_index_array_index_array_index_array = [];\n    let max_array_index_array_index_array_index_array_index\
    \ = 0;\n    let max_array_index_array_index_array_index_array_index_array = [];\n\
    \    let max_array_index_array_index_array_index_array_index_array_index = 0;\n\
    \    let max_array_index_array_index_array_index_array_index_array_index_array\
    \ = [];\n    let max_array_index_array_index_array_index_array_index_array_index_array_index\
    \ = 0;\n    let max_array_index_array_index_array_index_array_index_array_index_array_index_array\
    \ = [];\n    let max_array_index_array_index_array_index_array_index_array_index_array_index_array_index\
    \ = 0;\n    let max_array_index_array_index_array_index_array_index_array_index_array_index_array_index_array\
    \ = [];\n    let max_array_index_array_index_array_index_array_index_array_index_array_index_array_index_array_index\
    \ = 0;\n    let max_array_index_array_index_array_index_array_index_array_index_array_index_array_index_array_index_array\
    \ = [];\n    let max_array_index_array_index_array_index_array_index_array_index_array_index_array_index_array_index_array_index\
    \ = 0;\n    let max_array_index_array_index_array_index_array_index", "    let\
    \ count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j\
    \ = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
    \           count += capacity;\n                grid[i][j] = 0;\n            }\n\
    \        }\n    }\n    return count;\n}\n", "    let times = 0;\n    let max =\
    \ 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j <\
    \ grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n              \
    \  max = Math.max(max, j);\n            }\n        }\n    }\n    for (let i =\
    \ 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++)\
    \ {\n            if (grid[i][j] === 1) {\n                times += 1;\n      \
    \          grid[i][j] = 0;\n                if (j + capacity > max) {\n      \
    \              capacity = j + capacity - max;\n                } else {\n    \
    \                capacity = 0;\n                }\n            }\n        }\n\
    \    }\n    return times;\n}\n", "    let count = 0;\n    for (let i = 0; i <\
    \ grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n  \
    \          if (grid[i][j] === 1) {\n                count += capacity;\n     \
    \           grid[i][j] = 0;\n            }\n        }\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let rowSum = row.reduce((a, b) =>\
    \ a + b, 0);\n        if (rowSum > capacity) {\n            return -1;\n     \
    \   }\n        if (rowSum === capacity) {\n            count += row.length;\n\
    \        } else {\n            for (let j = 0; j < row.length; j++) {\n      \
    \          if (row[j] === 1) {\n                    count++;\n               \
    \ }\n            }\n        }\n    }\n    return count;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
