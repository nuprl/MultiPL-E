name: HumanEval_129_minPath
language: ts
prompt: "//Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n// each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have\
  \ to find the minimum path of length k in the grid. You can start\n// from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n// in other words,\
  \ you can go to cells which share an edge with you current\n// cell.\n// Please\
  \ note that a path of length k means visiting exactly k cells (not\n// necessarily\
  \ distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered\
  \ less than a path B (of length k) if\n// after making the ordered arrays of the\
  \ values on the cells that A and B go\n// through (let's call them lst_A and lst_B),\
  \ lst_A is lexicographically less\n// than lst_B, in other words, there exist an\
  \ integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j\
  \ (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer\
  \ is unique.\n// Return an ordered array of the values on the cells that the minimum\
  \ path go through.\n// Examples:    \n// >>> minPath([[1, 2, 3], [4, 5, 6], [7,\
  \ 8, 9]], 3)\n// [1, 2, 1]\n// >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n\
  // [1]\nfunction minPath(grid: any, k: any): any {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = minPath;\n  assert.deepEqual(candidate([[1, 2, 3],\
  \ [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1]);\n  assert.deepEqual(candidate([[5, 9, 3],\
  \ [4, 1, 6], [7, 8, 2]], 1),[1]);\n  assert.deepEqual(candidate([[1, 2, 3, 4], [5,\
  \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2]);\n  assert.deepEqual(candidate([[6,\
  \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10,\
  \ 1, 10, 1]);\n  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5,\
  \ 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1]);\n  assert.deepEqual(candidate([[11,\
  \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1,\
  \ 6, 1, 6, 1]);\n  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5,\
  \ 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n  assert.deepEqual(candidate([[2,\
  \ 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);\n  assert.deepEqual(candidate([[6,\
  \ 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);\n  assert.deepEqual(candidate([[1,\
  \ 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n  assert.deepEqual(candidate([[1,\
  \ 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n\ntest();"
completions: ["    let n = grid.length;\n    let m = grid[0].length;\n    let minPath\
    \ = [];\n    let minPathSum = Infinity;\n    let visited = [];\n    for (let i\
    \ = 0; i < n; i++) {\n        visited[i] = [];\n        for (let j = 0; j < m;\
    \ j++) {\n            visited[i][j] = false;\n        }\n    }\n    for (let i\
    \ = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            let path\
    \ = [];\n            let pathSum = 0;\n            let pathSumMin = Infinity;\n\
    \            let pathSumMinIndex = 0;\n            let pathSumMinIndexes = [];\n\
    \            let pathSumMinIndexesIndex = 0;\n            let pathSumMinIndexesIndexes\
    \ = [];\n            let pathSumMinIndexesIndexesIndex = 0;\n            let pathSumMinIndexesIndexesIndexes\
    \ = [];\n            let pathSumMinIndexesIndexesIndexesIndex = 0;\n         \
    \   let pathSumMinIndexesIndexesIndexesIndexes = [];\n            let pathSumMinIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n            let pathSumMinIndexesIndexesIndexesIndexesIndexes = [];\n\
    \            let pathSumMinIndexesIndexesIndexesIndexesIndexesIndex = 0;\n   \
    \         let pathSumMinIndexesIndexesIndexesIndexesIndexesIndexes = [];\n   \
    \         let pathSumMinIndexesIndexesIndexesIndexesIndexesIndexesIndex = 0;\n\
    \            let pathSumMinIndexesIndexesIndexesIndexesIndexesIndexesIndexes =\
    \ [];\n            let pathSumMinIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n            let pathSumMinIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexes\
    \ = [];\n            let pathSumMinIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n            let pathSumMinIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexes\
    \ = [];\n            let pathSumMinIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n            let pathSumMin", "    const n = grid.length;\n    const m\
    \ = grid[0].length;\n    const dp = new Array(n);\n    for (let i = 0; i < n;\
    \ i++) {\n        dp[i] = new Array(m);\n        for (let j = 0; j < m; j++) {\n\
    \            dp[i][j] = new Array(k + 1);\n            for (let l = 0; l <= k;\
    \ l++) {\n                dp[i][j][l] = new Array(2);\n                dp[i][j][l][0]\
    \ = [];\n                dp[i][j][l][1] = Infinity;\n            }\n        }\n\
    \    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            dp[i][j][1][0] = [grid[i][j]];\n            dp[i][j][1][1] =\
    \ grid[i][j];\n        }\n    }\n    for (let l = 2; l <= k; l++) {\n        for\
    \ (let i = 0; i < n; i++) {\n            for (let j = 0; j < m; j++) {\n     \
    \           for (let di = -1; di <= 1; di++) {\n                    for (let dj\
    \ = -1; dj <= 1; dj++) {\n                        if (Math.abs(di) + Math.abs(dj)\
    \ !== 1) continue;\n                        const ni = i + di;\n             \
    \           const nj = j + dj;\n                        if (ni < 0 || ni >= n\
    \ || nj < 0 || nj >= m) continue;\n                        const cur = dp[i][j][l\
    \ - 1][1] + grid[i][j];\n                        if (cur < dp[ni][nj][l][1]) {\n\
    \                            dp[ni][nj][l][1] = cur;\n                       \
    \     dp[ni][nj][l][0] = dp[i][j][l - 1][0].concat(grid[i][j]);\n            \
    \            }\n                    }\n                }\n            }\n    \
    \    }\n    }", "    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m;\
    \ j++) {\n            let path = [];\n            let sum = 0;\n            dfs(i,\
    \ j, k, path, sum);\n        }\n    }\n    return minPath;\n\n    function dfs(i:\
    \ number, j: number, k: number, path: any, sum: number) {\n        if (k === 0)\
    \ {\n            if (sum < minSum) {\n                minSum = sum;\n        \
    \        minPath = path.slice();\n            }\n            return;\n       \
    \ }\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n    \
    \        return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i + 1, j, k - 1, path, sum);\n      \
    \  dfs(i - 1, j, k - 1, path, sum);\n        dfs(i, j + 1, k - 1, path, sum);\n\
    \        dfs(i, j - 1, k - 1, path, sum);\n        path.pop();\n        visited[i][j]\
    \ = false;\n    }\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let min = Infinity;\n    let res = [];\n    let dp = [];\n    for (let i\
    \ = 0; i < n; i++) {\n        dp[i] = [];\n        for (let j = 0; j < m; j++)\
    \ {\n            dp[i][j] = [];\n        }\n    }\n    for (let i = 0; i < n;\
    \ i++) {\n        for (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n\
    \        }\n    }\n    return res;\n\n    function dfs(i: any, j: any, path: any,\
    \ cnt: any) {\n        if (cnt > k) {\n            return;\n        }\n      \
    \  if (cnt == k) {\n            if (path.length < min) {\n                min\
    \ = path.length;\n                res = path;\n            } else if (path.length\
    \ == min) {\n                for (let i = 0; i < path.length; i++) {\n       \
    \             if (path[i] < res[i]) {\n                        res = path;\n \
    \                       break;\n                    } else if (path[i] > res[i])\
    \ {\n                        break;\n                    }\n                }\n\
    \            }\n            return;\n        }\n        if (dp[i][j][cnt] != undefined)\
    \ {\n            return;\n        }\n        dp[i][j][cnt] = true;\n        path.push(grid[i][j]);\n\
    \        if (i > 0) {\n            dfs(i - 1, j, path.slice(), cnt + 1);\n   \
    \     }\n        if (i < n - 1) {\n            dfs(i + 1, j, path.slice(), cnt\
    \ + 1);\n        }\n        if (j > 0) {\n            dfs(i, j - 1, path.slice(),\
    \ cnt + 1);\n        }\n        if (j < m - 1) {\n            dfs(i, j + 1, path.slice(),\
    \ cnt + 1);\n        }\n    }\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = new Array(k);\n    let\
    \ minSum = Infinity;\n    let minPathSum = Infinity;\n    let minPathIndex = 0;\n\
    \    let minPathIndexSum = 0;\n    let dfs = (i: any, j: any, path: any, pathIndex:\
    \ any, pathSum: any) => {\n        if (pathIndex === k) {\n            if (pathSum\
    \ < minPathSum) {\n                minPathSum = pathSum;\n                minPathIndexSum\
    \ = pathIndex;\n                for (let i = 0; i < k; i++) {\n              \
    \      minPath[i] = path[i];\n                }\n            } else if (pathSum\
    \ === minPathSum) {\n                for (let i = 0; i < k; i++) {\n         \
    \           if (path[i] < minPath[i]) {\n                        minPathIndexSum\
    \ = pathIndex;\n                        for (let i = 0; i < k; i++) {\n      \
    \                      minPath[i] = path[i];\n                        }\n    \
    \                    break;\n                    } else if (path[i] > minPath[i])\
    \ {\n                        break;\n                    }\n                }\n\
    \            }\n            return;\n        }\n        if (i < 0 || i >= n ||\
    \ j < 0 || j >= m || visited[i][j]) {\n            return;\n        }\n      \
    \  visited[i][j] = true;\n        path[pathIndex] = grid[i][j];\n        pathSum\
    \ += grid[i][j];\n        dfs(i - 1, j, path, pathIndex + 1, pathSum);\n     \
    \   dfs(i + 1, j, path, pathIndex + 1, pathSum);\n        dfs(i, j - 1, path,\
    \ pathIndex + 1, pathSum);\n        dfs(i, j + 1, path, pathIndex + 1, pathSum);\n\
    \        visited[i][j] = false;\n    };\n", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let min = Infinity;\n    let minPath = [];\n    let\
    \ visited = [];\n    for (let i = 0; i < n; i++) {\n        visited[i] = [];\n\
    \        for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n \
    \       }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j\
    \ < m; j++) {\n            let path = [];\n            dfs(i, j, k, path, visited);\n\
    \            if (path.length < min) {\n                min = path.length;\n  \
    \              minPath = path;\n            }\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath:\
    \ any = [];\n    let minPathSum: any = Infinity;\n    let visited: any = [];\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = [];\n        for (let\
    \ j = 0; j < m; j++) {\n            visited[i][j] = false;\n        }\n    }\n\
    \    let dfs = (i: any, j: any, path: any, pathSum: any) => {\n        if (i <\
    \ 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n            return;\n  \
    \      }\n        path.push(grid[i][j]);\n        pathSum += grid[i][j];\n   \
    \     if (path.length === k) {\n            if (pathSum < minPathSum) {\n    \
    \            minPathSum = pathSum;\n                minPath = path.slice();\n\
    \            }\n            path.pop();\n            return;\n        }\n    \
    \    visited[i][j] = true;\n        dfs(i - 1, j, path, pathSum);\n        dfs(i\
    \ + 1, j, path, pathSum);\n        dfs(i, j - 1, path, pathSum);\n        dfs(i,\
    \ j + 1, path, pathSum);\n        visited[i][j] = false;\n        path.pop();\n\
    \    };\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n}\n",
  "    let N = grid.length;\n    let M = grid[0].length;\n    let minPath = [];\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2\
    \ = [];\n    let minPathSum3 = Infinity;\n    let minPath3 = [];\n    let minPathSum4\
    \ = Infinity;\n    let minPath4 = [];\n    let minPathSum5 = Infinity;\n    let\
    \ minPath5 = [];\n    let minPathSum6 = Infinity;\n    let minPath6 = [];\n  \
    \  let minPathSum7 = Infinity;\n    let minPath7 = [];\n    let minPathSum8 =\
    \ Infinity;\n    let minPath8 = [];\n    let minPathSum9 = Infinity;\n    let\
    \ minPath9 = [];\n    let minPathSum10 = Infinity;\n    let minPath10 = [];\n\
    \    let minPathSum11 = Infinity;\n    let minPath11 = [];\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minPathSum13 = Infinity;\n   \
    \ let minPath13 = [];\n    let minPathSum14 = Infinity;\n    let minPath14 = [];\n\
    \    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let minPathSum16\
    \ = Infinity;\n    let minPath16 = [];\n    let minPathSum17 = Infinity;\n   \
    \ let minPath17 = [];\n    let minPathSum18 = Infinity;\n    let minPath18 = [];\n\
    \    let minPathSum19 = Infinity;\n    let minPath19 = [];\n    let minPathSum20\
    \ = Infinity;\n    let minPath20 = [];\n    let minPathSum21 = Infinity;\n   \
    \ let minPath21 = [];\n    let minPathSum22 = Infinity;\n    let minPath22 = [];\n\
    \    let minPathSum23 = Infinity;\n    let minPath23 = [];\n    let minPathSum24\
    \ = Infinity;\n    let minPath24 = [];\n    let minPathSum25 = Infinity;\n   \
    \ let minPath25 = [];\n    let minPathSum26 = Infinity;\n    let minPath26 = [];\n\
    \    let minPathSum27 = Infinity;\n    let minPath27 = [];\n    let minPathSum28\
    \ =", "    let n = grid.length;\n    let m = grid[0].length;\n    let dp = new\
    \ Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = new Array(m);\n\
    \        for (let j = 0; j < m; j++) {\n            dp[i][j] = new Array(k + 1);\n\
    \            for (let l = 0; l <= k; l++) {\n                dp[i][j][l] = new\
    \ Array(2);\n                dp[i][j][l][0] = new Array(2);\n                dp[i][j][l][1]\
    \ = new Array(2);\n            }\n        }\n    }\n    for (let i = 0; i < n;\
    \ i++) {\n        for (let j = 0; j < m; j++) {\n            for (let l = 0; l\
    \ <= k; l++) {\n                for (let p = 0; p < 2; p++) {\n              \
    \      for (let q = 0; q < 2; q++) {\n                        dp[i][j][l][p][q]\
    \ = new Array(2);\n                    }\n                }\n            }\n \
    \       }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j\
    \ < m; j++) {\n            for (let l = 0; l <= k; l++) {\n                for\
    \ (let p = 0; p < 2; p++) {\n                    for (let q = 0; q < 2; q++) {\n\
    \                        for (let r = 0; r < 2; r++) {\n                     \
    \       dp[i][j][l][p][q][r] = new Array(2);\n                        }\n    \
    \                }\n                }\n            }\n        }\n    }\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n         \
    \   for (let l = 0; l <= k; l++) {\n                for (let p = 0; p < 2; p++)\
    \ {\n                    for (let q = 0; q < 2; q++) {\n                     \
    \   for (let", "    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ minPath = [];\n    let minSum = Infinity;\n    let visited = [];\n    for (let\
    \ i = 0; i < n; i++) {\n        visited[i] = [];\n        for (let j = 0; j <\
    \ m; j++) {\n            visited[i][j] = false;\n        }\n    }\n    function\
    \ dfs(i: any, j: any, sum: any, path: any) {\n        if (sum > minSum) {\n  \
    \          return;\n        }\n        if (path.length === k) {\n            if\
    \ (sum < minSum) {\n                minSum = sum;\n                minPath = path;\n\
    \            }\n            return;\n        }\n        if (i < 0 || i >= n ||\
    \ j < 0 || j >= m || visited[i][j]) {\n            return;\n        }\n      \
    \  visited[i][j] = true;\n        dfs(i - 1, j, sum + grid[i][j], path.concat(grid[i][j]));\n\
    \        dfs(i + 1, j, sum + grid[i][j], path.concat(grid[i][j]));\n        dfs(i,\
    \ j - 1, sum + grid[i][j], path.concat(grid[i][j]));\n        dfs(i, j + 1, sum\
    \ + grid[i][j], path.concat(grid[i][j]));\n        visited[i][j] = false;\n  \
    \  }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n\
    \            dfs(i, j, 0, []);\n        }\n    }\n    return minPath;\n}\n", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = new Array(k);\n    let minPathSum = Infinity;\n    let\
    \ minPathSumIndex = -1;\n    let minPathSumIndex2 = -1;\n    let minPathSumIndex3\
    \ = -1;\n    let minPathSumIndex4 = -1;\n    let minPathSumIndex5 = -1;\n    let\
    \ minPathSumIndex6 = -1;\n    let minPathSumIndex7 = -1;\n    let minPathSumIndex8\
    \ = -1;\n    let minPathSumIndex9 = -1;\n    let minPathSumIndex10 = -1;\n   \
    \ let minPathSumIndex11 = -1;\n    let minPathSumIndex12 = -1;\n    let minPathSumIndex13\
    \ = -1;\n    let minPathSumIndex14 = -1;\n    let minPathSumIndex15 = -1;\n  \
    \  let minPathSumIndex16 = -1;\n    let minPathSumIndex17 = -1;\n    let minPathSumIndex18\
    \ = -1;\n    let minPathSumIndex19 = -1;\n    let minPathSumIndex20 = -1;\n  \
    \  let minPathSumIndex21 = -1;\n    let minPathSumIndex22 = -1;\n    let minPathSumIndex23\
    \ = -1;\n    let minPathSumIndex24 = -1;\n    let minPathSumIndex25 = -1;\n  \
    \  let minPathSumIndex26 = -1;\n    let minPathSumIndex27 = -1;\n    let minPathSumIndex28\
    \ = -1;\n    let minPathSumIndex29 = -1;\n    let minPathSumIndex30 = -1;\n  \
    \  let minPathSumIndex31 = -1;\n    let minPathSumIndex32 = -1;\n    let minPathSumIndex33\
    \ = -1;\n    let minPathSumIndex34 = -1;\n    let minPathSumIndex35 = -1;\n  \
    \  let minPathSumIndex36", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp = new Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i]\
    \ = new Array(m);\n        for (let j = 0; j < m; j++) {\n            dp[i][j]\
    \ = new Array(k + 1);\n            for (let l = 0; l <= k; l++) {\n          \
    \      dp[i][j][l] = new Array(2);\n                dp[i][j][l][0] = -1;\n   \
    \             dp[i][j][l][1] = -1;\n            }\n        }\n    }\n    let ans\
    \ = new Array(k);\n    let min = Number.MAX_SAFE_INTEGER;\n    for (let i = 0;\
    \ i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            let cur =\
    \ dfs(i, j, k, grid, dp);\n            if (cur < min) {\n                min =\
    \ cur;\n                for (let l = 0; l < k; l++) {\n                    ans[l]\
    \ = dp[i][j][k][1];\n                }\n            }\n        }\n    }\n    return\
    \ ans;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = [];\n        for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n\
    \        }\n    }\n    let dfs = (i: any, j: any, path: any, sum: any) => {\n\
    \        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || sum > minSum)\
    \ {\n            return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        if (path.length === k) {\n            if\
    \ (sum < minPathSum) {\n                minPathSum = sum;\n                minPath\
    \ = path.slice();\n            }\n        } else {\n            dfs(i - 1, j,\
    \ path, sum);\n            dfs(i + 1, j, path, sum);\n            dfs(i, j - 1,\
    \ path, sum);\n            dfs(i, j + 1, path, sum);\n        }\n        path.pop();\n\
    \        visited[i][j] = false;\n    };\n    for (let i = 0; i < n; i++) {\n \
    \       for (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n       \
    \     minSum = minPathSum;\n        }\n    }\n    return minPath;\n}\n", "   \
    \ let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(0));\n    let min = new Array(k).fill(Infinity);\n    let\
    \ minPath = new Array(k).fill(0);\n    let minPaths = [];\n    let minPathsCount\
    \ = 0;\n    let minPathsCountMax = 0;\n    let minPathsCountMaxIndex = 0;\n  \
    \  let minPathsCountMaxIndexes = [];\n    let minPathsCountMaxIndexesCount = 0;\n\
    \    let minPathsCountMaxIndexesCountMax = 0;\n    let minPathsCountMaxIndexesCountMaxIndex\
    \ = 0;\n    let minPathsCountMaxIndexesCountMaxIndexes = [];\n    let minPathsCountMaxIndexesCountMaxIndexesCount\
    \ = 0;\n    let minPathsCountMaxIndexesCountMaxIndexesCountMax = 0;\n    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndex\
    \ = 0;\n    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexes = [];\n\
    \    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCount = 0;\n   \
    \ let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMax = 0;\n   \
    \ let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndex = 0;\n\
    \    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndexes\
    \ = [];\n    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndexesCount\
    \ = 0;\n    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMax\
    \ = 0;\n    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndex\
    \ = 0;\n    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndexes\
    \ = [];\n    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndexesCount\
    \ = 0;\n    let minPathsCountMaxIndexesCountMax", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for (let i\
    \ = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n    }\n\
    \    let res = [];\n    let min = Number.MAX_VALUE;\n    for (let i = 0; i < n;\
    \ i++) {\n        for (let j = 0; j < m; j++) {\n            let path = [];\n\
    \            dfs(i, j, k, grid, visited, path, res, min);\n        }\n    }\n\
    \    return res;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp = new Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i]\
    \ = new Array(m);\n        for (let j = 0; j < m; j++) {\n            dp[i][j]\
    \ = new Array(k + 1);\n            for (let l = 0; l <= k; l++) {\n          \
    \      dp[i][j][l] = new Array(2);\n                dp[i][j][l][0] = Infinity;\n\
    \                dp[i][j][l][1] = [];\n            }\n        }\n    }\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n         \
    \   dp[i][j][1][0] = grid[i][j];\n            dp[i][j][1][1] = [grid[i][j]];\n\
    \        }\n    }\n    for (let l = 2; l <= k; l++) {\n        for (let i = 0;\
    \ i < n; i++) {\n            for (let j = 0; j < m; j++) {\n                if\
    \ (i > 0) {\n                    if (dp[i - 1][j][l - 1][0] < dp[i][j][l][0])\
    \ {\n                        dp[i][j][l][0] = dp[i - 1][j][l - 1][0];\n      \
    \                  dp[i][j][l][1] = dp[i - 1][j][l - 1][1].slice();\n        \
    \            } else if (dp[i - 1][j][l - 1][0] == dp[i][j][l][0]) {\n        \
    \                let tmp = dp[i - 1][j][l - 1][1].slice();\n                 \
    \       tmp.push(grid[i][j]);\n                        if (tmp < dp[i][j][l][1])\
    \ {\n                            dp[i][j][l][1] = tmp;\n                     \
    \   }\n                    }\n                }\n                if (i < n", " \
    \   let N = grid.length;\n    let minPath: any = [];\n    let minSum: any = Infinity;\n\
    \    let minPaths: any = [];\n    let minSums: any = [];\n    let visited: any\
    \ = [];\n    for (let i = 0; i < N; i++) {\n        visited.push([]);\n      \
    \  for (let j = 0; j < N; j++) {\n            visited[i].push(false);\n      \
    \  }\n    }\n    function dfs(i: any, j: any, path: any, sum: any) {\n       \
    \ if (i < 0 || i >= N || j < 0 || j >= N || visited[i][j]) {\n            return;\n\
    \        }\n        if (path.length === k) {\n            if (sum < minSum) {\n\
    \                minSum = sum;\n                minPath = path;\n            }\
    \ else if (sum === minSum) {\n                minPaths.push(path);\n         \
    \       minSums.push(sum);\n            }\n            return;\n        }\n  \
    \      visited[i][j] = true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n\
    \        dfs(i - 1, j, path.slice(), sum);\n        dfs(i + 1, j, path.slice(),\
    \ sum);\n        dfs(i, j - 1, path.slice(), sum);\n        dfs(i, j + 1, path.slice(),\
    \ sum);\n        visited[i][j] = false;\n    }\n    for (let i = 0; i < N; i++)\
    \ {\n        for (let j = 0; j < N; j++) {\n            dfs(i, j, [], 0);\n  \
    \      }\n    }\n    for (let i = 0; i < minPaths.length; i++) {\n        if (minSums[i]\
    \ === minSum) {\n            if (minPaths[i] < minPath) {\n                minPath\
    \ = minPaths[i];\n            }\n        }\n    }\n    return minPath;\n}\n",
  "    // Your code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited.push([]);\n\
    \        for (let j = 0; j < m; j++) {\n            visited[i].push(false);\n\
    \        }\n    }\n    let minPath = [];\n    for (let i = 0; i < k; i++) {\n\
    \        minPath.push(Infinity);\n    }\n    let minPathSum = Infinity;\n    let\
    \ curPath = [];\n    let curPathSum = 0;\n    let dfs = (i: any, j: any) => {\n\
    \        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n        \
    \    return;\n        }\n        visited[i][j] = true;\n        curPath.push(grid[i][j]);\n\
    \        curPathSum += grid[i][j];\n        if (curPath.length === k) {\n    \
    \        if (curPathSum < minPathSum) {\n                minPathSum = curPathSum;\n\
    \                minPath = curPath.slice();\n            } else if (curPathSum\
    \ === minPathSum) {\n                for (let i = 0; i < k; i++) {\n         \
    \           if (curPath[i] < minPath[i]) {\n                        minPath =\
    \ curPath.slice();\n                        break;\n                    } else\
    \ if (curPath[i] > minPath[i]) {\n                        break;\n           \
    \         }\n                }\n            }\n        } else {\n            dfs(i\
    \ - 1, j);\n            dfs(i + 1, j);\n            dfs(i, j - 1);\n         \
    \   dfs(i, j + 1);\n        }\n        curPath.pop();\n        curPathSum -= grid[i][j];\n\
    \        visited[i][j] = false;\n    };\n    for (let i = 0; i < n; i++) {\n \
    \       for (let j = 0; j < m; j++) {\n            dfs(i, j);\n        }\n   \
    \ }\n    return minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp = [];\n    for (let i = 0; i < n; i++) {\n        dp[i] = [];\n  \
    \      for (let j = 0; j < m; j++) {\n            dp[i][j] = [];\n        }\n\
    \    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            if (i == 0 && j == 0) {\n                dp[i][j][0] = grid[i][j];\n\
    \            } else if (i == 0) {\n                dp[i][j][0] = dp[i][j - 1][0]\
    \ + grid[i][j];\n            } else if (j == 0) {\n                dp[i][j][0]\
    \ = dp[i - 1][j][0] + grid[i][j];\n            } else {\n                dp[i][j][0]\
    \ = Math.min(dp[i - 1][j][0], dp[i][j - 1][0]) + grid[i][j];\n            }\n\
    \        }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            for (let l = 1; l < k; l++) {\n                if\
    \ (i == 0 && j == 0) {\n                    dp[i][j][l] = grid[i][j];\n      \
    \          } else if (i == 0) {\n                    dp[i][j][l] = dp[i][j - 1][l]\
    \ + grid[i][j];\n                } else if (j == 0) {\n                    dp[i][j][l]\
    \ = dp[i - 1][j][l] + grid[i][j];\n                } else {\n                \
    \    dp[i][j][l] = Math.min(dp[i - 1][j][l], dp[i][j - 1][l]) + grid[i][j];\n\
    \                }\n            }\n        }\n    }\n   ", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = [];\n    let min_path = [];\n    let\
    \ min_path_len = k;\n    let min_path_sum = Infinity;\n    let visited = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = new Array(m);\n     \
    \   for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n      \
    \  }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m;\
    \ j++) {\n            let path = [];\n            let path_sum = 0;\n        \
    \    let path_len = 0;\n            let dfs = (i: any, j: any) => {\n        \
    \        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n        \
    \            return;\n                }\n                path.push(grid[i][j]);\n\
    \                path_sum += grid[i][j];\n                path_len++;\n      \
    \          visited[i][j] = true;\n                if (path_len === k) {\n    \
    \                if (path_sum < min_path_sum) {\n                        min_path_sum\
    \ = path_sum;\n                        min_path = path;\n                    }\
    \ else if (path_sum === min_path_sum) {\n                        for (let i =\
    \ 0; i < k; i++) {\n                            if (path[i] < min_path[i]) {\n\
    \                                min_path = path;\n                          \
    \      break;\n                            } else if (path[i] > min_path[i]) {\n\
    \                                break;\n                            }\n     \
    \                   }\n                    }\n                } else {\n     \
    \               dfs(i + 1, j);\n                    dfs(i - 1, j);\n         \
    \           dfs(i, j + 1);\n                    dfs(i, j - 1);\n             \
    \   }\n                path.pop();\n                path_sum -= grid[i][j];\n\
    \                path_len--;\n                visited[i][j] = false;\n       \
    \     }\n           ", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minPathSum = Infinity;\n    let visited = [];\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = [];\n        for (let\
    \ j = 0; j < m; j++) {\n            visited[i][j] = false;\n        }\n    }\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          let path = [];\n            let pathSum = 0;\n            dfs(i, j,\
    \ 0, path, pathSum);\n        }\n    }\n    return minPath;\n\n    function dfs(i:\
    \ number, j: number, steps: number, path: number[], pathSum: number) {\n     \
    \   if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || steps >= k) {\n\
    \            return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        pathSum += grid[i][j];\n        if (steps === k - 1) {\n            if\
    \ (pathSum < minPathSum) {\n                minPathSum = pathSum;\n          \
    \      minPath = path.slice();\n            } else if (pathSum === minPathSum)\
    \ {\n                if (path.join('') < minPath.join('')) {\n               \
    \     minPath = path.slice();\n                }\n            }\n        } else\
    \ {\n            dfs(i + 1, j, steps + 1, path, pathSum);\n            dfs(i -\
    \ 1, j, steps + 1, path, pathSum);\n            dfs(i, j + 1, steps + 1, path,\
    \ pathSum);\n            dfs(i, j - 1, steps + 1, path, pathSum);\n        }\n\
    \        visited[i][j] = false;\n        path.pop();\n    }\n}\n", "    let n\
    \ = grid.length;\n    let m = grid[0].length;\n    let dp = new Array(n);\n  \
    \  for (let i = 0; i < n; i++) {\n        dp[i] = new Array(m);\n        for (let\
    \ j = 0; j < m; j++) {\n            dp[i][j] = new Array(k + 1);\n           \
    \ for (let l = 0; l <= k; l++) {\n                dp[i][j][l] = new Array(2);\n\
    \                dp[i][j][l][0] = new Array(2);\n                dp[i][j][l][1]\
    \ = new Array(2);\n            }\n        }\n    }\n    for (let i = 0; i < n;\
    \ i++) {\n        for (let j = 0; j < m; j++) {\n            dp[i][j][1][0][0]\
    \ = grid[i][j];\n            dp[i][j][1][0][1] = i;\n            dp[i][j][1][1][0]\
    \ = grid[i][j];\n            dp[i][j][1][1][1] = j;\n        }\n    }\n    for\
    \ (let l = 2; l <= k; l++) {\n        for (let i = 0; i < n; i++) {\n        \
    \    for (let j = 0; j < m; j++) {\n                dp[i][j][l][0][0] = Infinity;\n\
    \                dp[i][j][l][0][1] = -1;\n                dp[i][j][l][1][0] =\
    \ Infinity;\n                dp[i][j][l][1][1] = -1;\n                if (i >\
    \ 0) {\n                    if (dp[i - 1][j][l - 1][0][0] < dp[i][j][l][0][0])\
    \ {\n                        dp[i][j][l][0][0] = dp[i - 1][j][l - 1][0][0];\n\
    \                        dp[i][j][l][0][1] = dp[i - 1", "    // your code here\n\
    }\n", "    // Your code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited.push([]);\n\
    \        for (let j = 0; j < m; j++) {\n            visited[i].push(false);\n\
    \        }\n    }\n    let minPath = [];\n    for (let i = 0; i < n; i++) {\n\
    \        for (let j = 0; j < m; j++) {\n            let path = [];\n         \
    \   dfs(grid, i, j, k, visited, path);\n            if (path.length < minPath.length\
    \ || minPath.length == 0) {\n                minPath = path;\n            }\n\
    \        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let visited = new Array(n);\n    for (let i = 0; i\
    \ < n; i++) {\n        visited[i] = new Array(m).fill(false);\n    }\n    let\
    \ minPath = new Array(k);\n    let minPathSum = Number.MAX_SAFE_INTEGER;\n   \
    \ for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n     \
    \       let path = new Array(k);\n            let pathSum = 0;\n            let\
    \ pathIndex = 0;\n            dfs(i, j, path, pathSum, pathIndex);\n        }\n\
    \    }\n    return minPath;\n\n    function dfs(i: number, j: number, path: number[],\
    \ pathSum: number, pathIndex: number) {\n        if (pathIndex === k) {\n    \
    \        if (pathSum < minPathSum) {\n                minPathSum = pathSum;\n\
    \                minPath = path.slice();\n            }\n            return;\n\
    \        }\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n\
    \            return;\n        }\n        visited[i][j] = true;\n        path[pathIndex]\
    \ = grid[i][j];\n        pathSum += grid[i][j];\n        dfs(i - 1, j, path, pathSum,\
    \ pathIndex + 1);\n        dfs(i + 1, j, path, pathSum, pathIndex + 1);\n    \
    \    dfs(i, j - 1, path, pathSum, pathIndex + 1);\n        dfs(i, j + 1, path,\
    \ pathSum, pathIndex + 1);\n        visited[i][j] = false;\n    }\n}\n", "   \
    \ let n = grid.length;\n    let m = grid[0].length;\n    let min = Infinity;\n\
    \    let minPath = [];\n    let visited = [];\n    for (let i = 0; i < n; i++)\
    \ {\n        visited[i] = [];\n        for (let j = 0; j < m; j++) {\n       \
    \     visited[i][j] = false;\n        }\n    }\n    for (let i = 0; i < n; i++)\
    \ {\n        for (let j = 0; j < m; j++) {\n            let path = [];\n     \
    \       let curr = grid[i][j];\n            path.push(curr);\n            visited[i][j]\
    \ = true;\n            dfs(i, j, path, k, visited, grid, n, m);\n            visited[i][j]\
    \ = false;\n        }\n    }\n    return minPath;\n}\n", "    let N = grid.length;\n\
    \    let M = grid[0].length;\n    let visited = new Array(N);\n    for (let i\
    \ = 0; i < N; i++) {\n        visited[i] = new Array(M).fill(false);\n    }\n\
    \    let minPath = new Array(k);\n    let minPathSum = Number.MAX_SAFE_INTEGER;\n\
    \    let minPathSumIndex = 0;\n    let minPathSumIndex2 = 0;\n    let minPathSumIndex3\
    \ = 0;\n    let minPathSumIndex4 = 0;\n    let minPathSumIndex5 = 0;\n    let\
    \ minPathSumIndex6 = 0;\n    let minPathSumIndex7 = 0;\n    let minPathSumIndex8\
    \ = 0;\n    let minPathSumIndex9 = 0;\n    let minPathSumIndex10 = 0;\n    let\
    \ minPathSumIndex11 = 0;\n    let minPathSumIndex12 = 0;\n    let minPathSumIndex13\
    \ = 0;\n    let minPathSumIndex14 = 0;\n    let minPathSumIndex15 = 0;\n    let\
    \ minPathSumIndex16 = 0;\n    let minPathSumIndex17 = 0;\n    let minPathSumIndex18\
    \ = 0;\n    let minPathSumIndex19 = 0;\n    let minPathSumIndex20 = 0;\n    let\
    \ minPathSumIndex21 = 0;\n    let minPathSumIndex22 = 0;\n    let minPathSumIndex23\
    \ = 0;\n    let minPathSumIndex24 = 0;\n    let minPathSumIndex25 = 0;\n    let\
    \ minPathSumIndex26 = 0;\n    let minPathSumIndex27 = 0;\n    let minPathSumIndex28\
    \ = 0;\n    let minPathSumIndex29 = 0;\n    let minPathSumIndex30 = 0;\n    let\
    \ minPathSumIndex31 = 0;\n    let minPathSumIndex32 = 0;\n    let minPathSumIndex33\
    \ = 0;\n    let minPathSumIndex34 = 0;\n    let minPathSumIndex35 = 0;\n    let\
    \ minPathSumIndex36 = 0;\n    let minPathSumIndex37 = 0;\n    let minPathSumIndex38\
    \ = 0;\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i] = new\
    \ Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          let path = [];\n            let sum = 0;\n            dfs(i, j, k,\
    \ path, sum);\n        }\n    }\n    return minPath;\n\n    function dfs(i: number,\
    \ j: number, k: number, path: number[], sum: number) {\n        if (i < 0 || i\
    \ >= n || j < 0 || j >= m || visited[i][j] || path.length >= k) {\n          \
    \  return;\n        }\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n\
    \        visited[i][j] = true;\n        if (path.length === k) {\n           \
    \ if (sum < minSum) {\n                minSum = sum;\n                minPath\
    \ = path.slice();\n            } else if (sum === minSum) {\n                for\
    \ (let i = 0; i < k; i++) {\n                    if (path[i] < minPath[i]) {\n\
    \                        minPath = path.slice();\n                        break;\n\
    \                    } else if (path[i] > minPath[i]) {\n                    \
    \    break;\n                    }\n                }\n            }\n       \
    \ } else {\n            dfs(i - 1, j, k, path, sum);\n            dfs(i + 1, j,\
    \ k, path, sum);\n            dfs(i, j - 1, k, path, sum);\n            dfs(i,\
    \ j + 1, k, path, sum);\n        }\n        path.pop();\n        sum -= grid[i][j];\n\
    \        visited[i][j] = false;\n    }\n}\n", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let dp = new Array(n);\n    for (let i = 0; i < n;\
    \ i++) {\n        dp[i] = new Array(m);\n        for (let j = 0; j < m; j++) {\n\
    \            dp[i][j] = new Array(k + 1);\n            for (let l = 0; l <= k;\
    \ l++) {\n                dp[i][j][l] = new Array(2);\n                dp[i][j][l][0]\
    \ = -1;\n                dp[i][j][l][1] = -1;\n            }\n        }\n    }\n\
    \    let ans = new Array(k);\n    for (let i = 0; i < k; i++) {\n        ans[i]\
    \ = -1;\n    }\n    let min = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i\
    \ < n; i++) {\n        for (let j = 0; j < m; j++) {\n            let val = solve(i,\
    \ j, k, grid, dp);\n            if (val < min) {\n                min = val;\n\
    \                for (let l = 0; l < k; l++) {\n                    ans[l] = dp[i][j][k][l];\n\
    \                }\n            }\n        }\n    }\n    return ans;\n}\n", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n\
    \    let minPathValue = Infinity;\n    let visited = [];\n    for (let i = 0;\
    \ i < n; i++) {\n        visited[i] = [];\n        for (let j = 0; j < m; j++)\
    \ {\n            visited[i][j] = false;\n        }\n    }\n    for (let i = 0;\
    \ i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            let path =\
    \ [];\n            let pathValue = 0;\n            let pathLength = 0;\n     \
    \       let queue = [];\n            queue.push([i, j]);\n            while (queue.length\
    \ > 0) {\n                let current = queue.shift();\n                let x\
    \ = current[0];\n                let y = current[1];\n                if (x <\
    \ 0 || x >= n || y < 0 || y >= m || visited[x][y]) {\n                    continue;\n\
    \                }\n                visited[x][y] = true;\n                path.push(grid[x][y]);\n\
    \                pathValue += grid[x][y];\n                pathLength++;\n   \
    \             if (pathLength === k) {\n                    if (pathValue < minPathValue)\
    \ {\n                        minPathValue = pathValue;\n                     \
    \   minPath = path;\n                    } else if (pathValue === minPathValue)\
    \ {\n                        if (path < minPath) {\n                         \
    \   minPath = path;\n                        }\n                    }\n      \
    \              break;\n                }\n                queue.push([x - 1, y]);\n\
    \                queue.push([x + 1, y]);\n                queue.push([x, y - 1]);\n\
    \                queue.push([x, y + 1]);\n            }\n            for (let\
    \ i = 0; i < n; i++) {\n                for (let j = 0; j < m; j++) {\n      \
    \              visited[i][j] = false;\n                }\n            }\n    \
    \    }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let m\
    \ = grid[0].length;\n    let dp = new Array(n);\n    for (let i = 0; i < n; i++)\
    \ {\n        dp[i] = new Array(m);\n        for (let j = 0; j < m; j++) {\n  \
    \          dp[i][j] = new Array(k + 1);\n            for (let l = 0; l <= k; l++)\
    \ {\n                dp[i][j][l] = new Array(2);\n                dp[i][j][l][0]\
    \ = -1;\n                dp[i][j][l][1] = -1;\n            }\n        }\n    }\n\
    \    let ans = new Array(k);\n    let min = Infinity;\n    for (let i = 0; i <\
    \ n; i++) {\n        for (let j = 0; j < m; j++) {\n            let cur = dfs(i,\
    \ j, k, grid, dp);\n            if (cur < min) {\n                min = cur;\n\
    \                for (let l = 0; l < k; l++) {\n                    ans[l] = dp[i][j][k][l];\n\
    \                }\n            }\n        }\n    }\n    return ans;\n}\n", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n\
    \    let minPathSum = Infinity;\n    let visited = [];\n    for (let i = 0; i\
    \ < n; i++) {\n        visited[i] = [];\n        for (let j = 0; j < m; j++) {\n\
    \            visited[i][j] = false;\n        }\n    }\n    for (let i = 0; i <\
    \ n; i++) {\n        for (let j = 0; j < m; j++) {\n            let path = [];\n\
    \            let pathSum = 0;\n            dfs(i, j, k, path, pathSum);\n    \
    \    }\n    }\n    return minPath;\n\n    function dfs(i: number, j: number, k:\
    \ number, path: any, pathSum: number) {\n        if (i < 0 || i >= n || j < 0\
    \ || j >= m || visited[i][j] || path.length === k) {\n            return;\n  \
    \      }\n        path.push(grid[i][j]);\n        pathSum += grid[i][j];\n   \
    \     visited[i][j] = true;\n        if (path.length === k) {\n            if\
    \ (pathSum < minPathSum) {\n                minPathSum = pathSum;\n          \
    \      minPath = path.slice();\n            } else if (pathSum === minPathSum)\
    \ {\n                if (path < minPath) {\n                    minPath = path.slice();\n\
    \                }\n            }\n        } else {\n            dfs(i - 1, j,\
    \ k, path, pathSum);\n            dfs(i + 1, j, k, path, pathSum);\n         \
    \   dfs(i, j - 1, k, path, pathSum);\n            dfs(i, j + 1, k, path, pathSum);\n\
    \        }\n        path.pop();\n        pathSum -= grid[i][j];\n        visited[i][j]\
    \ = false;\n    }\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited.push([]);\n\
    \        for (let j = 0; j < m; j++) {\n            visited[i].push(false);\n\
    \        }\n    }\n    let minPath = [];\n    for (let i = 0; i < n; i++) {\n\
    \        for (let j = 0; j < m; j++) {\n            let path = [];\n         \
    \   dfs(grid, visited, i, j, k, path);\n            if (path.length > 0) {\n \
    \               if (minPath.length === 0) {\n                    minPath = path;\n\
    \                } else {\n                    for (let i = 0; i < path.length;\
    \ i++) {\n                        if (path[i] < minPath[i]) {\n              \
    \              minPath = path;\n                            break;\n         \
    \               } else if (path[i] > minPath[i]) {\n                         \
    \   break;\n                        }\n                    }\n               \
    \ }\n            }\n        }\n    }\n    return minPath;\n}\n", "    let n =\
    \ grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = new Array(k);\n    let minPathSum = Number.MAX_SAFE_INTEGER;\n\
    \    let minPathSumIndex = -1;\n    let dfs = (i: any, j: any, k: any, path: any,\
    \ pathSum: any) => {\n        if (k === 0) {\n            if (pathSum < minPathSum)\
    \ {\n                minPathSum = pathSum;\n                minPathSumIndex =\
    \ path.length - 1;\n                minPath = path.slice();\n            } else\
    \ if (pathSum === minPathSum) {\n                let pathIndex = path.length -\
    \ 1;\n                for (let i = 0; i <= minPathSumIndex; i++) {\n         \
    \           if (path[pathIndex] < minPath[i]) {\n                        minPathSumIndex\
    \ = i;\n                        minPath = path.slice();\n                    \
    \    break;\n                    } else if (path[pathIndex] > minPath[i]) {\n\
    \                        break;\n                    }\n                    pathIndex--;\n\
    \                }\n            }\n            return;\n        }\n        if\
    \ (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n            return;\n\
    \        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n  \
    \      pathSum += grid[i][j];\n        dfs(i - 1, j, k - 1, path, pathSum);\n\
    \        dfs(i + 1, j, k - 1, path, pathSum);\n        dfs(i, j - 1, k - 1, path,\
    \ pathSum);\n        dfs(i, j + 1, k - 1, path, pathSum);\n        path.pop();\n\
    \        pathSum -= grid[i][j];\n        visited[i][j] = false;\n    };\n    for\
    \ (let i = 0; i < n; i++) {\n        for", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let dp = new Array(n);\n    for (let i = 0; i < n;\
    \ i++) {\n        dp[i] = new Array(m);\n        for (let j = 0; j < m; j++) {\n\
    \            dp[i][j] = new Array(k + 1);\n            for (let l = 0; l <= k;\
    \ l++) {\n                dp[i][j][l] = new Array(2);\n                dp[i][j][l][0]\
    \ = -1;\n                dp[i][j][l][1] = -1;\n            }\n        }\n    }\n\
    \    let ans = new Array(k);\n    let min = [Infinity, Infinity];\n    for (let\
    \ i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            let\
    \ temp = dfs(i, j, k, grid, dp);\n            if (temp[0] < min[0]) {\n      \
    \          min = temp;\n                ans = dp[i][j][k][1];\n            }\n\
    \        }\n    }\n    return ans;\n}\n", "    let n = grid.length;\n    let m\
    \ = grid[0].length;\n    let dp = new Array(n).fill(0).map(() => new Array(m).fill(0).map(()\
    \ => new Array(k + 1).fill(Infinity)));\n    let path = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(0).map(() => new Array(k + 1).fill(0)));\n    let min =\
    \ Infinity;\n    let minPath = [];\n    for (let i = 0; i < n; i++) {\n      \
    \  for (let j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n    \
    \        path[i][j][1] = grid[i][j];\n            if (dp[i][j][1] < min) {\n \
    \               min = dp[i][j][1];\n                minPath = path[i][j][1];\n\
    \            }\n        }\n    }\n    for (let l = 2; l <= k; l++) {\n       \
    \ for (let i = 0; i < n; i++) {\n            for (let j = 0; j < m; j++) {\n \
    \               let curr = grid[i][j];\n                if (i > 0) {\n       \
    \             let newVal = dp[i - 1][j][l - 1] + curr;\n                    if\
    \ (newVal < dp[i][j][l]) {\n                        dp[i][j][l] = newVal;\n  \
    \                      path[i][j][l] = path[i - 1][j][l - 1].concat(curr);\n \
    \                   }\n                }\n                if (i < n - 1) {\n \
    \                   let newVal = dp[i + 1][j][l - 1] + curr;\n               \
    \     if (newVal < dp[i][j][l]) {\n                        dp[i][j][l] = newVal;\n\
    \                        path[i][j][l] = path[i + 1][j][l - 1].concat(curr);\n\
    \                    }\n                }\n                if (j > 0) {\n    \
    \                let", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minSumPath = [];\n\
    \    let sum = 0;\n    let visited = [];\n    for (let i = 0; i < n; i++) {\n\
    \        visited[i] = [];\n        for (let j = 0; j < m; j++) {\n           \
    \ visited[i][j] = false;\n        }\n    }\n    function dfs(i: any, j: any, path:\
    \ any, sum: any) {\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j])\
    \ {\n            return;\n        }\n        path.push(grid[i][j]);\n        sum\
    \ += grid[i][j];\n        visited[i][j] = true;\n        if (path.length === k)\
    \ {\n            if (sum < minSum) {\n                minSum = sum;\n        \
    \        minSumPath = path.slice();\n            } else if (sum === minSum) {\n\
    \                if (path.toString() < minSumPath.toString()) {\n            \
    \        minSumPath = path.slice();\n                }\n            }\n      \
    \  } else {\n            dfs(i - 1, j, path, sum);\n            dfs(i + 1, j,\
    \ path, sum);\n            dfs(i, j - 1, path, sum);\n            dfs(i, j + 1,\
    \ path, sum);\n        }\n        visited[i][j] = false;\n        path.pop();\n\
    \        sum -= grid[i][j];\n    }\n    for (let i = 0; i < n; i++) {\n      \
    \  for (let j = 0; j < m; j++) {\n            dfs(i, j, minPath, sum);\n     \
    \   }\n    }\n    return minSumPath;\n}\n", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let minPathSum3\
    \ = Infinity;\n    let minPath3 = [];\n    let minPathSum4 = Infinity;\n    let\
    \ minPath4 = [];\n    let minPathSum5 = Infinity;\n    let minPath5 = [];\n  \
    \  let minPathSum6 = Infinity;\n    let minPath6 = [];\n    let minPathSum7 =\
    \ Infinity;\n    let minPath7 = [];\n    let minPathSum8 = Infinity;\n    let\
    \ minPath8 = [];\n    let minPathSum9 = Infinity;\n    let minPath9 = [];\n  \
    \  let minPathSum10 = Infinity;\n    let minPath10 = [];\n    let minPathSum11\
    \ = Infinity;\n    let minPath11 = [];\n    let minPathSum12 = Infinity;\n   \
    \ let minPath12 = [];\n    let minPathSum13 = Infinity;\n    let minPath13 = [];\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minPathSum15\
    \ = Infinity;\n    let minPath15 = [];\n    let minPathSum16 = Infinity;\n   \
    \ let minPath16 = [];\n    let minPathSum17 = Infinity;\n    let minPath17 = [];\n\
    \    let minPathSum18 = Infinity;\n    let minPath18 = [];\n    let minPathSum19\
    \ = Infinity;\n    let minPath19 = [];\n    let minPathSum20 = Infinity;\n   \
    \ let minPath20 = [];\n    let minPathSum21 = Infinity;\n    let minPath21 = [];\n\
    \    let minPathSum22 = Infinity;\n    let minPath22 = [];\n    let minPathSum23\
    \ = Infinity;\n    let minPath23 = [];\n    let minPathSum24 = Infinity;\n   \
    \ let minPath24 = [];\n    let minPathSum25 = Infinity;\n    let minPath25 = [];\n\
    \    let minPathSum26 = Infinity;\n    let minPath26 = [];\n    let minPathSum27\
    \ = Infinity;\n    let minPath27 = [];\n    let minPathSum28 =", "    let n =\
    \ grid.length;\n    let m = grid[0].length;\n    let visited = [];\n    for (let\
    \ i = 0; i < n; i++) {\n        visited.push([]);\n        for (let j = 0; j <\
    \ m; j++) {\n            visited[i].push(false);\n        }\n    }\n    let minPath\
    \ = [];\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            let path = [];\n            dfs(grid, i, j, k, visited, path);\n\
    \            if (path.length == k) {\n                if (minPath.length == 0)\
    \ {\n                    minPath = path;\n                } else {\n         \
    \           for (let i = 0; i < k; i++) {\n                        if (path[i]\
    \ < minPath[i]) {\n                            minPath = path;\n             \
    \               break;\n                        } else if (path[i] > minPath[i])\
    \ {\n                            break;\n                        }\n         \
    \           }\n                }\n            }\n        }\n    }\n    return\
    \ minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n   \
    \ let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited.push([]);\n\
    \        for (let j = 0; j < m; j++) {\n            visited[i].push(false);\n\
    \        }\n    }\n    let minPath = [];\n    for (let i = 0; i < k; i++) {\n\
    \        minPath.push(Infinity);\n    }\n    let minPathSum = Infinity;\n    let\
    \ minPathSum2 = Infinity;\n    let minPathSum3 = Infinity;\n    let minPathSum4\
    \ = Infinity;\n    let minPathSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPathSum7 = Infinity;\n    let minPathSum8 = Infinity;\n    let minPathSum9\
    \ = Infinity;\n    let minPathSum10 = Infinity;\n    let minPathSum11 = Infinity;\n\
    \    let minPathSum12 = Infinity;\n    let minPathSum13 = Infinity;\n    let minPathSum14\
    \ = Infinity;\n    let minPathSum15 = Infinity;\n    let minPathSum16 = Infinity;\n\
    \    let minPathSum17 = Infinity;\n    let minPathSum18 = Infinity;\n    let minPathSum19\
    \ = Infinity;\n    let minPathSum20 = Infinity;\n    let minPathSum21 = Infinity;\n\
    \    let minPathSum22 = Infinity;\n    let minPathSum23 = Infinity;\n    let minPathSum24\
    \ = Infinity;\n    let minPathSum25 = Infinity;\n    let minPathSum26 = Infinity;\n\
    \    let minPathSum27 = Infinity;\n    let minPathSum28 = Infinity;\n    let minPathSum29\
    \ = Infinity;\n    let minPathSum30 = Infinity;\n    let minPathSum31 = Infinity;\n\
    \    let minPathSum32 = Infinity;\n    let minPathSum33 = Infinity;\n    let minPathSum34\
    \ = Infinity;\n    let minPathSum35 = Infinity;\n    let minPathSum36 = Infinity;\n\
    \    let minPathSum37 = Infinity;\n    let minPathSum38 = Infinity;\n    let minPathSum39\
    \ = Infinity;\n    let minPath", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPaths = [];\n \
    \   let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited[i] =\
    \ [];\n        for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n\
    \        }\n    }\n    let dfs = (i: any, j: any, path: any, sum: any) => {\n\
    \        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n        \
    \    return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        if (path.length === k) {\n            if\
    \ (sum < minSum) {\n                minSum = sum;\n                minPaths =\
    \ [path.slice()];\n            } else if (sum === minSum) {\n                minPaths.push(path.slice());\n\
    \            }\n        } else {\n            dfs(i - 1, j, path, sum);\n    \
    \        dfs(i + 1, j, path, sum);\n            dfs(i, j - 1, path, sum);\n  \
    \          dfs(i, j + 1, path, sum);\n        }\n        path.pop();\n       \
    \ visited[i][j] = false;\n    };\n    for (let i = 0; i < n; i++) {\n        for\
    \ (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n        }\n    }\n\
    \    minPaths.sort((a: any, b: any) => {\n        for (let i = 0; i < k; i++)\
    \ {\n            if (a[i] < b[i]) {\n                return -1;\n            }\
    \ else if (a[i] > b[i]) {\n                return 1;\n            }\n        }\n\
    \        return 0;\n    });\n    return minPaths[0];\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = Number.MAX_SAFE_INTEGER;\n    let\
    \ minPath = [];\n    let visited = new Array(n);\n    for (let i = 0; i < n; i++)\
    \ {\n        visited[i] = new Array(m).fill(false);\n    }\n    for (let i = 0;\
    \ i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            let path =\
    \ [];\n            let curr = grid[i][j];\n            path.push(curr);\n    \
    \        visited[i][j] = true;\n            dfs(i, j, k - 1, path, visited, grid,\
    \ n, m);\n            visited[i][j] = false;\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let min = Infinity;\n\
    \    let minPath = [];\n    let visited = [];\n    for (let i = 0; i < n; i++)\
    \ {\n        visited[i] = [];\n        for (let j = 0; j < m; j++) {\n       \
    \     visited[i][j] = false;\n        }\n    }\n    for (let i = 0; i < n; i++)\
    \ {\n        for (let j = 0; j < m; j++) {\n            let path = [];\n     \
    \       let pathSum = 0;\n            dfs(i, j, k, path, pathSum, grid, visited);\n\
    \            if (pathSum < min) {\n                min = pathSum;\n          \
    \      minPath = path;\n            }\n        }\n    }\n    return minPath;\n\
    }\n", "    // your code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let min = Infinity;\n    let minPath = [];\n    let path = [];\n    let visited\
    \ = [];\n    for (let i = 0; i < n; i++) {\n        visited[i] = [];\n       \
    \ for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n        }\n\
    \    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            dfs(i, j, k, grid, visited, path, min, minPath);\n        }\n\
    \    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp = new Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i]\
    \ = new Array(m);\n        for (let j = 0; j < m; j++) {\n            dp[i][j]\
    \ = new Array(k + 1);\n            for (let l = 0; l <= k; l++) {\n          \
    \      dp[i][j][l] = new Array(2);\n                dp[i][j][l][0] = -1;\n   \
    \             dp[i][j][l][1] = -1;\n            }\n        }\n    }\n    let ans\
    \ = new Array(k);\n    let min = Infinity;\n    for (let i = 0; i < n; i++) {\n\
    \        for (let j = 0; j < m; j++) {\n            let cur = dfs(i, j, k, grid,\
    \ dp);\n            if (cur < min) {\n                min = cur;\n           \
    \     for (let l = 0; l < k; l++) {\n                    ans[l] = dp[i][j][k][1][l];\n\
    \                }\n            }\n        }\n    }\n    return ans;\n}\n", " \
    \   // Your code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPathSum3 = Infinity;\n    let minPathSum4\
    \ = Infinity;\n    let minPathSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPathSum7 = Infinity;\n    let minPathSum8 = Infinity;\n    let minPathSum9\
    \ = Infinity;\n    let minPathSum10 = Infinity;\n    let minPathSum11 = Infinity;\n\
    \    let minPathSum12 = Infinity;\n    let minPathSum13 = Infinity;\n    let minPathSum14\
    \ = Infinity;\n    let minPathSum15 = Infinity;\n    let minPathSum16 = Infinity;\n\
    \    let minPathSum17 = Infinity;\n    let minPathSum18 = Infinity;\n    let minPathSum19\
    \ = Infinity;\n    let minPathSum20 = Infinity;\n    let minPathSum21 = Infinity;\n\
    \    let minPathSum22 = Infinity;\n    let minPathSum23 = Infinity;\n    let minPathSum24\
    \ = Infinity;\n    let minPathSum25 = Infinity;\n    let minPathSum26 = Infinity;\n\
    \    let minPathSum27 = Infinity;\n    let minPathSum28 = Infinity;\n    let minPathSum29\
    \ = Infinity;\n    let minPathSum30 = Infinity;\n    let minPathSum31 = Infinity;\n\
    \    let minPathSum32 = Infinity;\n    let minPathSum33 = Infinity;\n    let minPathSum34\
    \ = Infinity;\n    let minPathSum35 = Infinity;\n    let minPathSum36 = Infinity;\n\
    \    let minPathSum37 = Infinity;\n    let minPathSum38 = Infinity;\n    let minPathSum39\
    \ = Infinity;\n    let minPathSum40 = Infinity;\n    let minPathSum41 = Infinity;\n\
    \    let minPathSum42 = Infinity;\n    let minPathSum43 = Infinity;\n    let minPathSum44\
    \ = Infinity;\n    let minPathSum45 = Infinity;\n    let minPathSum46 = Infinity;\n\
    \    let minPathSum47 = Infinity;\n    let minPathSum48 =", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(() =>\
    \ new Array(m).fill(0));\n    let minPath = new Array(k);\n    let minSum = Infinity;\n\
    \    let dfs = (i: any, j: any, sum: any, path: any) => {\n        if (i < 0 ||\
    \ i >= n || j < 0 || j >= m || visited[i][j]) {\n            return;\n       \
    \ }\n        visited[i][j] = 1;\n        path.push(grid[i][j]);\n        sum +=\
    \ grid[i][j];\n        if (path.length === k) {\n            if (sum < minSum)\
    \ {\n                minSum = sum;\n                minPath = path.slice();\n\
    \            } else if (sum === minSum) {\n                for (let i = 0; i <\
    \ k; i++) {\n                    if (path[i] < minPath[i]) {\n               \
    \         minPath = path.slice();\n                        break;\n          \
    \          } else if (path[i] > minPath[i]) {\n                        break;\n\
    \                    }\n                }\n            }\n        } else {\n \
    \           dfs(i + 1, j, sum, path);\n            dfs(i - 1, j, sum, path);\n\
    \            dfs(i, j + 1, sum, path);\n            dfs(i, j - 1, sum, path);\n\
    \        }\n        path.pop();\n        visited[i][j] = 0;\n    };\n    for (let\
    \ i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dfs(i,\
    \ j, 0, []);\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for (let i\
    \ = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n    }\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPathSum3 = Infinity;\n    let minPathSum4\
    \ = Infinity;\n    let minPathSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPathSum7 = Infinity;\n    let minPathSum8 = Infinity;\n    let minPathSum9\
    \ = Infinity;\n    let minPathSum10 = Infinity;\n    let minPathSum11 = Infinity;\n\
    \    let minPathSum12 = Infinity;\n    let minPathSum13 = Infinity;\n    let minPathSum14\
    \ = Infinity;\n    let minPathSum15 = Infinity;\n    let minPathSum16 = Infinity;\n\
    \    let minPathSum17 = Infinity;\n    let minPathSum18 = Infinity;\n    let minPathSum19\
    \ = Infinity;\n    let minPathSum20 = Infinity;\n    let minPathSum21 = Infinity;\n\
    \    let minPathSum22 = Infinity;\n    let minPathSum23 = Infinity;\n    let minPathSum24\
    \ = Infinity;\n    let minPathSum25 = Infinity;\n    let minPathSum26 = Infinity;\n\
    \    let minPathSum27 = Infinity;\n    let minPathSum28 = Infinity;\n    let minPathSum29\
    \ = Infinity;\n    let minPathSum30 = Infinity;\n    let minPathSum31 = Infinity;\n\
    \    let minPathSum32 = Infinity;\n    let minPathSum33 = Infinity;\n    let minPathSum34\
    \ = Infinity;\n    let minPathSum35 = Infinity;\n    let minPathSum36 = Infinity;\n\
    \    let minPathSum37 = Infinity;\n    let minPathSum38 = Infinity;\n    let minPathSum39\
    \ = Infinity;\n    let minPathSum40 = Infinity;\n    let minPathSum41 = Infinity;\n\
    \    let minPathSum42 = Infinity;\n    let minPathSum43 = Infinity;\n    let",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let min = [];\n    let\
    \ min_sum = Infinity;\n    let min_path = [];\n    let min_path_sum = Infinity;\n\
    \    let min_path_len = Infinity;\n    let min_path_idx = Infinity;\n    let min_path_idx_sum\
    \ = Infinity;\n    let min_path_idx_len = Infinity;\n    let min_path_idx_sum_len\
    \ = Infinity;\n    let min_path_idx_sum_len_idx = Infinity;\n    let min_path_idx_sum_len_idx_sum\
    \ = Infinity;\n    let min_path_idx_sum_len_idx_sum_len = Infinity;\n    let min_path_idx_sum_len_idx_sum_len_idx\
    \ = Infinity;\n    let min_path_idx_sum_len_idx_sum_len_idx_sum = Infinity;\n\
    \    let min_path_idx_sum_len_idx_sum_len_idx_sum_len = Infinity;\n    let min_path_idx_sum_len_idx_sum_len_idx_sum_len_idx\
    \ = Infinity;\n    let min_path_idx_sum_len_idx_sum_len_idx_sum_len_idx_sum =\
    \ Infinity;\n    let min_path_idx_sum_len_idx_sum_len_idx_sum_len_idx_sum_len\
    \ = Infinity;\n    let min_path_idx_sum_len_idx_sum_len_idx_sum_len_idx_sum_len_idx\
    \ = Infinity;\n    let min_path_idx_sum_len_idx_sum_len_idx_sum_len_idx_sum_len_idx_sum\
    \ = Infinity;\n    let min_path_idx_sum_len_idx_sum_len_idx_sum_len_idx_sum_len_idx_sum_len\
    \ = Infinity;\n    let min_path_idx_sum_len", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = [];\n        for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n\
    \        }\n    }\n    function dfs(i: any, j: any, path: any, sum: any) {\n \
    \       if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n         \
    \   return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        if (path.length === k) {\n            if\
    \ (sum < minPathSum) {\n                minPathSum = sum;\n                minPath\
    \ = path.slice();\n            }\n        } else {\n            dfs(i - 1, j,\
    \ path, sum);\n            dfs(i + 1, j, path, sum);\n            dfs(i, j - 1,\
    \ path, sum);\n            dfs(i, j + 1, path, sum);\n        }\n        path.pop();\n\
    \        visited[i][j] = false;\n    }\n    for (let i = 0; i < n; i++) {\n  \
    \      for (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n        }\n\
    \    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let min = Infinity;\n    let minPath = [];\n    let visited = [];\n    for\
    \ (let i = 0; i < n; i++) {\n        visited[i] = [];\n        for (let j = 0;\
    \ j < m; j++) {\n            visited[i][j] = false;\n        }\n    }\n    let\
    \ dfs = (i: any, j: any, path: any, length: any) => {\n        if (i < 0 || i\
    \ >= n || j < 0 || j >= m || visited[i][j]) return;\n        path.push(grid[i][j]);\n\
    \        visited[i][j] = true;\n        if (length === k) {\n            if (path\
    \ < min) {\n                min = path;\n                minPath = path.slice();\n\
    \            }\n        } else {\n            dfs(i + 1, j, path, length + 1);\n\
    \            dfs(i - 1, j, path, length + 1);\n            dfs(i, j + 1, path,\
    \ length + 1);\n            dfs(i, j - 1, path, length + 1);\n        }\n    \
    \    path.pop();\n        visited[i][j] = false;\n    }\n    for (let i = 0; i\
    \ < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dfs(i, j, [],\
    \ 0);\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = [];\n    for (let i = 0; i < n;\
    \ i++) {\n        visited.push([]);\n        for (let j = 0; j < m; j++) {\n \
    \           visited[i].push(false);\n        }\n    }\n    let minPath = [];\n\
    \    let minSum = Infinity;\n    for (let i = 0; i < n; i++) {\n        for (let\
    \ j = 0; j < m; j++) {\n            let path = [];\n            let sum = 0;\n\
    \            dfs(i, j, k, path, sum);\n        }\n    }\n    return minPath;\n\
    \n    function dfs(i: number, j: number, k: number, path: number[], sum: number)\
    \ {\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n    \
    \        return;\n        }\n        if (k === 0) {\n            if (sum < minSum)\
    \ {\n                minSum = sum;\n                minPath = path.slice();\n\
    \            }\n            return;\n        }\n        visited[i][j] = true;\n\
    \        path.push(grid[i][j]);\n        sum += grid[i][j];\n        dfs(i - 1,\
    \ j, k - 1, path, sum);\n        dfs(i + 1, j, k - 1, path, sum);\n        dfs(i,\
    \ j - 1, k - 1, path, sum);\n        dfs(i, j + 1, k - 1, path, sum);\n      \
    \  visited[i][j] = false;\n        path.pop();\n    }\n}\n", "    // Your code\
    \ here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ minPath = [];\n    let minSum = Infinity;\n    let minPaths = [];\n    let minPathsSum\
    \ = [];\n    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = [];\n        for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n\
    \        }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            let path = [];\n            let sum = 0;\n      \
    \      let paths = [];\n            let pathsSum = [];\n            let pathSum\
    \ = 0;\n            let pathSumIndex = 0;\n            let pathIndex = 0;\n  \
    \          let pathIndexes = [];\n            let pathIndexesSum = [];\n     \
    \       let pathIndexSum = 0;\n            let pathIndexSumIndex = 0;\n      \
    \      let pathIndexIndex = 0;\n            let pathIndexIndexes = [];\n     \
    \       let pathIndexIndexesSum = [];\n            let pathIndexIndexSum = 0;\n\
    \            let pathIndexIndexSumIndex = 0;\n            let pathIndexIndexIndex\
    \ = 0;\n            let pathIndexIndexIndexes = [];\n            let pathIndexIndexIndexesSum\
    \ = [];\n            let pathIndexIndexIndexSum = 0;\n            let pathIndexIndexIndexSumIndex\
    \ = 0;\n            let pathIndexIndexIndexIndex = 0;\n            let pathIndexIndexIndexIndexes\
    \ = [];\n            let pathIndexIndexIndexIndexesSum = [];\n            let\
    \ pathIndexIndexIndexIndexSum = 0;\n            let pathIndexIndexIndexIndexSumIndex\
    \ = 0;\n            let pathIndexIndexIndexIndexIndex = 0;\n            let pathIndexIndexIndexIndexIndexes\
    \ = [];\n            let pathIndexIndexIndexIndexIndexesSum = [];\n          \
    \  let pathIndexIndexIndexIndexIndexSum = 0;\n            let pathIndexIndexIndexIndexIndexSumIndex\
    \ = 0;\n            let pathIndexIndexIndexIndexIndexIndex = 0;\n            let\
    \ pathIndexIndexIndexIndexIndexIndexes = [];\n            let pathIndexIndexIndexIndexIndexIndexesSum\
    \ = [];\n            let pathIndexIndexIndexIndexIndexIndexSum =", "    let n\
    \ = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(0));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    function dfs(i: any, j: any, path: any, sum:\
    \ any) {\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || path.length\
    \ > k) {\n            return;\n        }\n        path.push(grid[i][j]);\n   \
    \     sum += grid[i][j];\n        visited[i][j] = 1;\n        if (path.length\
    \ === k) {\n            if (sum < minPathSum) {\n                minPathSum =\
    \ sum;\n                minPath = path.slice();\n            } else if (sum ===\
    \ minPathSum) {\n                if (path < minPath) {\n                    minPath\
    \ = path.slice();\n                }\n            }\n        } else {\n      \
    \      dfs(i - 1, j, path, sum);\n            dfs(i + 1, j, path, sum);\n    \
    \        dfs(i, j - 1, path, sum);\n            dfs(i, j + 1, path, sum);\n  \
    \      }\n        path.pop();\n        visited[i][j] = 0;\n    }\n    for (let\
    \ i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dfs(i,\
    \ j, [], 0);\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = [];\n    let min_sum = Infinity;\n\
    \    let min_path = [];\n    for (let i = 0; i < n; i++) {\n        for (let j\
    \ = 0; j < m; j++) {\n            let path = [];\n            let sum = 0;\n \
    \           let visited = [];\n            for (let i = 0; i < n; i++) {\n   \
    \             visited.push([]);\n                for (let j = 0; j < m; j++) {\n\
    \                    visited[i].push(false);\n                }\n            }\n\
    \            dfs(grid, i, j, k, path, sum, visited);\n            if (sum < min_sum)\
    \ {\n                min_sum = sum;\n                min_path = path;\n      \
    \      }\n        }\n    }\n    return min_path;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPaths = [];\n    let visited = [];\n    for (let i = 0; i < n; i++)\
    \ {\n        visited[i] = [];\n        for (let j = 0; j < m; j++) {\n       \
    \     visited[i][j] = false;\n        }\n    }\n    for (let i = 0; i < n; i++)\
    \ {\n        for (let j = 0; j < m; j++) {\n            let path = [];\n     \
    \       let sum = 0;\n            let paths = [];\n            dfs(i, j, k, n,\
    \ m, grid, visited, path, sum, paths);\n            if (sum < minSum) {\n    \
    \            minSum = sum;\n                minPath = path;\n                minPaths\
    \ = paths;\n            } else if (sum === minSum) {\n                if (path\
    \ < minPath) {\n                    minPath = path;\n                    minPaths\
    \ = paths;\n                }\n            }\n        }\n    }\n    return minPaths;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n    let minPathSum2\
    \ = Infinity;\n    let minPath2 = [];\n    let minSum2 = Infinity;\n    let minPathSum3\
    \ = Infinity;\n    let minPath3 = [];\n    let minSum3 = Infinity;\n    let minPathSum4\
    \ = Infinity;\n    let minPath4 = [];\n    let minSum4 = Infinity;\n    let minPathSum5\
    \ = Infinity;\n    let minPath5 = [];\n    let minSum5 = Infinity;\n    let minPathSum6\
    \ = Infinity;\n    let minPath6 = [];\n    let minSum6 = Infinity;\n    let minPathSum7\
    \ = Infinity;\n    let minPath7 = [];\n    let minSum7 = Infinity;\n    let minPathSum8\
    \ = Infinity;\n    let minPath8 = [];\n    let minSum8 = Infinity;\n    let minPathSum9\
    \ = Infinity;\n    let minPath9 = [];\n    let minSum9 = Infinity;\n    let minPathSum10\
    \ = Infinity;\n    let minPath10 = [];\n    let minSum10 = Infinity;\n    let\
    \ minPathSum11 = Infinity;\n    let minPath11 = [];\n    let minSum11 = Infinity;\n\
    \    let minPathSum12 = Infinity;\n    let minPath12 = [];\n    let minSum12 =\
    \ Infinity;\n    let minPathSum13 = Infinity;\n    let minPath13 = [];\n    let\
    \ minSum13 = Infinity;\n    let minPathSum14 = Infinity;\n    let minPath14 =\
    \ [];\n    let minSum14 = Infinity;\n    let minPathSum15 = Infinity;\n    let\
    \ minPath15 = [];\n    let minSum15 = Infinity;\n    let minPathSum16 = Infinity;\n\
    \    let minPath16 = [];\n    let minSum16 = Infinity;\n    let minPathSum17 =\
    \ Infinity;\n    let minPath17 = [];\n    let minSum17 = Infinity;\n    let minPathSum18\
    \ = Infinity;\n    let minPath18 = [];\n    let minSum18 = Infinity;\n    let\
    \ minPathSum19 = Infinity", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Number.MAX_SAFE_INTEGER;\n    let minSumPath = [];\n    let dfs = (i: any, j:\
    \ any, path: any, sum: any) => {\n        if (i < 0 || i >= n || j < 0 || j >=\
    \ m || visited[i][j]) {\n            return;\n        }\n        if (path.length\
    \ === k) {\n            if (sum < minSum) {\n                minSum = sum;\n \
    \               minSumPath = path.slice();\n            }\n            return;\n\
    \        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n  \
    \      sum += grid[i][j];\n        dfs(i - 1, j, path, sum);\n        dfs(i +\
    \ 1, j, path, sum);\n        dfs(i, j - 1, path, sum);\n        dfs(i, j + 1,\
    \ path, sum);\n        path.pop();\n        sum -= grid[i][j];\n        visited[i][j]\
    \ = false;\n    };\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            dfs(i, j, [], 0);\n        }\n    }\n    return minSumPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let dp = [];\n\
    \    for (let i = 0; i < n; i++) {\n        dp[i] = [];\n        for (let j =\
    \ 0; j < m; j++) {\n            dp[i][j] = [];\n        }\n    }\n    for (let\
    \ i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dp[i][j][0]\
    \ = grid[i][j];\n        }\n    }\n    for (let i = 0; i < n; i++) {\n       \
    \ for (let j = 0; j < m; j++) {\n            for (let l = 1; l < k; l++) {\n \
    \               let min = Number.MAX_SAFE_INTEGER;\n                if (i > 0)\
    \ {\n                    min = Math.min(min, dp[i - 1][j][l - 1]);\n         \
    \       }\n                if (i < n - 1) {\n                    min = Math.min(min,\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 min = Math.min(min, dp[i][j - 1][l - 1]);\n                }\n\
    \                if (j < m - 1) {\n                    min = Math.min(min, dp[i][j\
    \ + 1][l - 1]);\n                }\n                dp[i][j][l] = min;\n     \
    \       }\n        }\n    }\n    let min = Number.MAX_SAFE_INTEGER;\n    let minI\
    \ = -1;\n    let minJ = -1;\n    for (let i = 0; i < n; i++) {\n        for (let\
    \ j = 0; j < m; j++) {\n            if (dp[i][j][k - 1] < min) {\n           \
    \     min = dp[i][j][k - 1];\n                minI = i;\n                minJ\
    \ = j;\n            }\n        }\n    }\n    let res = [];\n    for (let i = 0;\
    \ i < k", "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath\
    \ = [];\n    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n   \
    \ let minPath2 = [];\n    let minPathSum3 = Infinity;\n    let minPath3 = [];\n\
    \    let minPathSum4 = Infinity;\n    let minPath4 = [];\n    let minPathSum5\
    \ = Infinity;\n    let minPath5 = [];\n    let minPathSum6 = Infinity;\n    let\
    \ minPath6 = [];\n    let minPathSum7 = Infinity;\n    let minPath7 = [];\n  \
    \  let minPathSum8 = Infinity;\n    let minPath8 = [];\n    let minPathSum9 =\
    \ Infinity;\n    let minPath9 = [];\n    let minPathSum10 = Infinity;\n    let\
    \ minPath10 = [];\n    let minPathSum11 = Infinity;\n    let minPath11 = [];\n\
    \    let minPathSum12 = Infinity;\n    let minPath12 = [];\n    let minPathSum13\
    \ = Infinity;\n    let minPath13 = [];\n    let minPathSum14 = Infinity;\n   \
    \ let minPath14 = [];\n    let minPathSum15 = Infinity;\n    let minPath15 = [];\n\
    \    let minPathSum16 = Infinity;\n    let minPath16 = [];\n    let minPathSum17\
    \ = Infinity;\n    let minPath17 = [];\n    let minPathSum18 = Infinity;\n   \
    \ let minPath18 = [];\n    let minPathSum19 = Infinity;\n    let minPath19 = [];\n\
    \    let minPathSum20 = Infinity;\n    let minPath20 = [];\n    let minPathSum21\
    \ = Infinity;\n    let minPath21 = [];\n    let minPathSum22 = Infinity;\n   \
    \ let minPath22 = [];\n    let minPathSum23 = Infinity;\n    let minPath23 = [];\n\
    \    let minPathSum24 = Infinity;\n    let minPath24 = [];\n    let minPathSum25\
    \ = Infinity;\n    let minPath25 = [];\n    let minPathSum26 = Infinity;\n   \
    \ let minPath26 = [];\n    let minPathSum27 = Infinity;\n    let minPath27 = [];\n\
    \    let minPathSum28 =", "    // your code here\n    let n = grid.length;\n \
    \   let m = grid[0].length;\n    let min = Infinity;\n    let minPath = [];\n\
    \    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited.push([]);\n\
    \        for (let j = 0; j < m; j++) {\n            visited[i].push(false);\n\
    \        }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            let path = [];\n            let pathSum = 0;\n  \
    \          dfs(i, j, k, path, pathSum, visited);\n            if (pathSum < min)\
    \ {\n                min = pathSum;\n                minPath = path;\n       \
    \     }\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = [];\n    for (let i = 0; i < n;\
    \ i++) {\n        visited.push([]);\n        for (let j = 0; j < m; j++) {\n \
    \           visited[i].push(false);\n        }\n    }\n    let minPath = [];\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          let path = [];\n            dfs(i, j, k, path, visited);\n        \
    \    if (path.length == k) {\n                if (minPath.length == 0) {\n   \
    \                 minPath = path;\n                } else {\n                \
    \    for (let i = 0; i < k; i++) {\n                        if (path[i] < minPath[i])\
    \ {\n                            minPath = path;\n                           \
    \ break;\n                        } else if (path[i] > minPath[i]) {\n       \
    \                     break;\n                        }\n                    }\n\
    \                }\n            }\n        }\n    }\n    return minPath;\n}\n",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2\
    \ = [];\n    let minPathSum3 = Infinity;\n    let minPath3 = [];\n    let minPathSum4\
    \ = Infinity;\n    let minPath4 = [];\n    let minPathSum5 = Infinity;\n    let\
    \ minPath5 = [];\n    let minPathSum6 = Infinity;\n    let minPath6 = [];\n  \
    \  let minPathSum7 = Infinity;\n    let minPath7 = [];\n    let minPathSum8 =\
    \ Infinity;\n    let minPath8 = [];\n    let minPathSum9 = Infinity;\n    let\
    \ minPath9 = [];\n    let minPathSum10 = Infinity;\n    let minPath10 = [];\n\
    \    let minPathSum11 = Infinity;\n    let minPath11 = [];\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minPathSum13 = Infinity;\n   \
    \ let minPath13 = [];\n    let minPathSum14 = Infinity;\n    let minPath14 = [];\n\
    \    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let minPathSum16\
    \ = Infinity;\n    let minPath16 = [];\n    let minPathSum17 = Infinity;\n   \
    \ let minPath17 = [];\n    let minPathSum18 = Infinity;\n    let minPath18 = [];\n\
    \    let minPathSum19 = Infinity;\n    let minPath19 = [];\n    let minPathSum20\
    \ = Infinity;\n    let minPath20 = [];\n    let minPathSum21 = Infinity;\n   \
    \ let minPath21 = [];\n    let minPathSum22 = Infinity;\n    let minPath22 = [];\n\
    \    let minPathSum23 = Infinity;\n    let minPath23 = [];\n    let minPathSum24\
    \ = Infinity;\n    let minPath24 = [];\n    let minPathSum25 = Infinity;\n   \
    \ let minPath25 = [];\n    let minPathSum26 = Infinity;\n    let minPath26 = [];\n\
    \    let minPathSum27 = Infinity;\n    let minPath27 = [];\n    let minPathSum28\
    \ =", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n).fill(0).map(() => new Array(m).fill(0));\n    let minPath = [];\n\
    \    let minSum = Infinity;\n    let dfs = (i: any, j: any, path: any, sum: any)\
    \ => {\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || sum\
    \ > minSum) {\n            return;\n        }\n        visited[i][j] = 1;\n  \
    \      path.push(grid[i][j]);\n        sum += grid[i][j];\n        if (path.length\
    \ === k) {\n            if (sum < minSum) {\n                minSum = sum;\n \
    \               minPath = path.slice();\n            }\n        } else {\n   \
    \         dfs(i + 1, j, path, sum);\n            dfs(i - 1, j, path, sum);\n \
    \           dfs(i, j + 1, path, sum);\n            dfs(i, j - 1, path, sum);\n\
    \        }\n        path.pop();\n        visited[i][j] = 0;\n    };\n    for (let\
    \ i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dfs(i,\
    \ j, [], 0);\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let visited = [];\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = [];\n        for (let\
    \ j = 0; j < m; j++) {\n            visited[i][j] = false;\n        }\n    }\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          let path = [];\n            let pathSum = 0;\n            let pathSum2\
    \ = 0;\n            let path2 = [];\n            dfs(i, j, 0, path, pathSum, path2,\
    \ pathSum2);\n            if (pathSum < minPathSum) {\n                minPathSum\
    \ = pathSum;\n                minPath = path;\n            }\n            if (pathSum2\
    \ < minPathSum2) {\n                minPathSum2 = pathSum2;\n                minPath2\
    \ = path2;\n            }\n        }\n    }\n    return minPathSum < minPathSum2\
    \ ? minPath : minPath2;\n    function dfs(i: any, j: any, k: any, path: any, pathSum:\
    \ any, path2: any, pathSum2: any) {\n        if (k === 0) {\n            path.push(grid[i][j]);\n\
    \            pathSum += grid[i][j];\n            path2.push(grid[i][j]);\n   \
    \         pathSum2 += grid[i][j];\n            return;\n        }\n        if\
    \ (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n            return;\n\
    \        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n  \
    \      pathSum += grid[i][j];\n        path2.push(grid[i][j]);\n        pathSum2\
    \ += grid[i][j];\n        dfs(i + 1, j, k - 1, path, pathSum, path", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n    let\
    \ minSum = Infinity;\n    let minSumPath = [];\n    let visited = [];\n    for\
    \ (let i = 0; i < n; i++) {\n        visited[i] = [];\n        for (let j = 0;\
    \ j < m; j++) {\n            visited[i][j] = false;\n        }\n    }\n    function\
    \ dfs(i: any, j: any, path: any, sum: any) {\n        if (i < 0 || i >= n || j\
    \ < 0 || j >= m || visited[i][j]) {\n            return;\n        }\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        visited[i][j] = true;\n        if (path.length\
    \ === k) {\n            if (sum < minSum) {\n                minSum = sum;\n \
    \               minSumPath = path.slice();\n            } else if (sum === minSum)\
    \ {\n                if (path.join('') < minSumPath.join('')) {\n            \
    \        minSumPath = path.slice();\n                }\n            }\n      \
    \  } else {\n            dfs(i - 1, j, path, sum);\n            dfs(i + 1, j,\
    \ path, sum);\n            dfs(i, j - 1, path, sum);\n            dfs(i, j + 1,\
    \ path, sum);\n        }\n        path.pop();\n        visited[i][j] = false;\n\
    \    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            dfs(i, j, [], 0);\n        }\n    }\n    return minSumPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath\
    \ = [];\n    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n   \
    \ let minPath2 = [];\n    let minPath3 = [];\n    let minPathSum3 = Infinity;\n\
    \    let minPathSum4 = Infinity;\n    let minPath4 = [];\n    let minPath5 = [];\n\
    \    let minPathSum5 = Infinity;\n    let minPathSum6 = Infinity;\n    let minPath6\
    \ = [];\n    let minPath7 = [];\n    let minPathSum7 = Infinity;\n    let minPathSum8\
    \ = Infinity;\n    let minPath8 = [];\n    let minPath9 = [];\n    let minPathSum9\
    \ = Infinity;\n    let minPathSum10 = Infinity;\n    let minPath10 = [];\n   \
    \ let minPath11 = [];\n    let minPathSum11 = Infinity;\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minPath13 = [];\n    let minPathSum13\
    \ = Infinity;\n    let minPathSum14 = Infinity;\n    let minPath14 = [];\n   \
    \ let minPath15 = [];\n    let minPathSum15 = Infinity;\n    let minPathSum16\
    \ = Infinity;\n    let minPath16 = [];\n    let minPath17 = [];\n    let minPathSum17\
    \ = Infinity;\n    let minPathSum18 = Infinity;\n    let minPath18 = [];\n   \
    \ let minPath19 = [];\n    let minPathSum19 = Infinity;\n    let minPathSum20\
    \ = Infinity;\n    let minPath20 = [];\n    let minPath21 = [];\n    let minPathSum21\
    \ = Infinity;\n    let minPathSum22 = Infinity;\n    let minPath22 = [];\n   \
    \ let minPath23 = [];\n    let minPathSum23 = Infinity;\n    let minPathSum24\
    \ = Infinity;\n    let minPath24 = [];\n    let minPath25 = [];\n    let minPathSum25\
    \ = Infinity;\n    let minPathSum26 = Infinity;\n    let minPath26 = [];\n   \
    \ let minPath27 = [];\n    let minPathSum27 = Infinity;\n    let minPathSum28\
    \ =", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i] = new\
    \ Array(m).fill(false);\n    }\n    let minPath = new Array(k);\n    let minSum\
    \ = Infinity;\n    let minPathSum = Infinity;\n    let minPathIndex = 0;\n   \
    \ let minPathSumIndex = 0;\n    let dfs = (i: any, j: any, path: any, pathSum:\
    \ any, pathIndex: any) => {\n        if (pathIndex === k) {\n            if (pathSum\
    \ < minPathSum) {\n                minPathSum = pathSum;\n                minPathSumIndex\
    \ = 0;\n                minPath[minPathSumIndex++] = path.slice();\n         \
    \   } else if (pathSum === minPathSum) {\n                minPath[minPathSumIndex++]\
    \ = path.slice();\n            }\n            return;\n        }\n        if (i\
    \ < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n            return;\n\
    \        }\n        visited[i][j] = true;\n        path[pathIndex] = grid[i][j];\n\
    \        pathSum += grid[i][j];\n        if (pathSum > minSum) {\n           \
    \ visited[i][j] = false;\n            return;\n        }\n        dfs(i - 1, j,\
    \ path, pathSum, pathIndex + 1);\n        dfs(i + 1, j, path, pathSum, pathIndex\
    \ + 1);\n        dfs(i, j - 1, path, pathSum, pathIndex + 1);\n        dfs(i,\
    \ j + 1, path, pathSum, pathIndex + 1);\n        visited[i][j] = false;\n    };\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          dfs(i, j, [], 0, 0);\n            minSum = Math.min(minSum, minPathSum);\n\
    \        }\n    }\n    let minPaths =", "    let n = grid.length;\n    let m =\
    \ grid[0].length;\n    let dp = new Array(n);\n    for (let i = 0; i < n; i++)\
    \ {\n        dp[i] = new Array(m);\n        for (let j = 0; j < m; j++) {\n  \
    \          dp[i][j] = new Array(k + 1);\n            for (let l = 0; l <= k; l++)\
    \ {\n                dp[i][j][l] = new Array(2);\n                dp[i][j][l][0]\
    \ = new Array(2);\n                dp[i][j][l][1] = new Array(2);\n          \
    \  }\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j\
    \ = 0; j < m; j++) {\n            dp[i][j][1][0][0] = grid[i][j];\n          \
    \  dp[i][j][1][0][1] = i;\n            dp[i][j][1][1][0] = grid[i][j];\n     \
    \       dp[i][j][1][1][1] = j;\n        }\n    }\n    for (let l = 2; l <= k;\
    \ l++) {\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j\
    \ < m; j++) {\n                if (i > 0) {\n                    if (dp[i - 1][j][l\
    \ - 1][0][0] < dp[i][j][l][0][0]) {\n                        dp[i][j][l][0][0]\
    \ = dp[i - 1][j][l - 1][0][0];\n                        dp[i][j][l][0][1] = i\
    \ - 1;\n                    }\n                    if (dp[i - 1][j][l - 1][1][0]\
    \ > dp[i][j][l][1][0]) {\n                        dp[i][j][l][1][0] = dp[i - 1][j][l\
    \ - 1][1][0];\n                        dp[", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let minPath = [];\n    let minSum = Infinity;\n   \
    \ let minPathSum = Infinity;\n    let minPaths = [];\n    let minPathsSum = [];\n\
    \    let minPathsSumIndex = [];\n    let minPathsSumIndexIndex = [];\n    let\
    \ minPathsSumIndexIndexIndex = [];\n    let minPathsSumIndexIndexIndexIndex =\
    \ [];\n    let minPathsSumIndexIndexIndexIndexIndex = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndex = [];\n    let\
    \ minPathsSumIndexIndexIndexIndexIndexIndexIndexIndex = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];", "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let visited = [];\n    for (let i = 0;\
    \ i < n; i++) {\n        visited[i] = [];\n        for (let j = 0; j < m; j++)\
    \ {\n            visited[i][j] = false;\n        }\n    }\n    let dfs = (i: any,\
    \ j: any, path: any, sum: any) => {\n        if (i < 0 || i >= n || j < 0 || j\
    \ >= m || visited[i][j]) {\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n      \
    \  if (path.length === k) {\n            if (sum < minSum) {\n               \
    \ minSum = sum;\n                minPath = path.slice();\n            }\n    \
    \    } else {\n            dfs(i - 1, j, path, sum);\n            dfs(i + 1, j,\
    \ path, sum);\n            dfs(i, j - 1, path, sum);\n            dfs(i, j + 1,\
    \ path, sum);\n        }\n        path.pop();\n        visited[i][j] = false;\n\
    \    };\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n}\n",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let min = [];\n    let\
    \ min_sum = Infinity;\n    let min_path = [];\n    let visited = [];\n    for\
    \ (let i = 0; i < n; i++) {\n        visited.push([]);\n        for (let j = 0;\
    \ j < m; j++) {\n            visited[i].push(false);\n        }\n    }\n    function\
    \ dfs(i: any, j: any, path: any, sum: any) {\n        if (i < 0 || i >= n || j\
    \ < 0 || j >= m || visited[i][j]) {\n            return;\n        }\n        if\
    \ (path.length === k) {\n            if (sum < min_sum) {\n                min_sum\
    \ = sum;\n                min_path = path;\n            } else if (sum === min_sum)\
    \ {\n                for (let i = 0; i < k; i++) {\n                    if (path[i]\
    \ < min_path[i]) {\n                        min_path = path;\n               \
    \         break;\n                    } else if (path[i] > min_path[i]) {\n  \
    \                      break;\n                    }\n                }\n    \
    \        }\n            return;\n        }\n        visited[i][j] = true;\n  \
    \      path.push(grid[i][j]);\n        dfs(i + 1, j, path.slice(), sum + grid[i][j]);\n\
    \        dfs(i - 1, j, path.slice(), sum + grid[i][j]);\n        dfs(i, j + 1,\
    \ path.slice(), sum + grid[i][j]);\n        dfs(i, j - 1, path.slice(), sum +\
    \ grid[i][j]);\n        visited[i][j] = false;\n    }\n    for (let i = 0; i <\
    \ n; i++) {\n        for (let j = 0; j < m; j++) {\n            dfs(i, j, [],\
    \ 0);\n        }\n    }\n    return min_path;\n}\n", "    let N = grid.length;\n\
    \    let M = grid[0].length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let visited = new Array(N);\n    for (let i = 0; i < N; i++) {\n        visited[i]\
    \ = new Array(M);\n        for (let j = 0; j < M; j++) {\n            visited[i][j]\
    \ = false;\n        }\n    }\n    for (let i = 0; i < N; i++) {\n        for (let\
    \ j = 0; j < M; j++) {\n            let path = [];\n            let pathSum =\
    \ 0;\n            dfs(i, j, k, path, pathSum);\n        }\n    }\n    return minPath;\n\
    \n    function dfs(i: number, j: number, k: number, path: any, pathSum: number)\
    \ {\n        if (k === 0) {\n            if (pathSum < minPathSum) {\n       \
    \         minPathSum = pathSum;\n                minPath = path.slice();\n   \
    \         }\n            return;\n        }\n        if (i < 0 || i >= N || j\
    \ < 0 || j >= M || visited[i][j]) {\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        path.push(grid[i][j]);\n        pathSum += grid[i][j];\n  \
    \      dfs(i + 1, j, k - 1, path, pathSum);\n        dfs(i - 1, j, k - 1, path,\
    \ pathSum);\n        dfs(i, j + 1, k - 1, path, pathSum);\n        dfs(i, j -\
    \ 1, k - 1, path, pathSum);\n        path.pop();\n        pathSum -= grid[i][j];\n\
    \        visited[i][j] = false;\n    }\n}\n", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let dp = new Array(n);\n    for (let i = 0; i < n;\
    \ i++) {\n        dp[i] = new Array(m);\n        for (let j = 0; j < m; j++) {\n\
    \            dp[i][j] = new Array(k + 1);\n            for (let l = 0; l <= k;\
    \ l++) {\n                dp[i][j][l] = new Array(2);\n                dp[i][j][l][0]\
    \ = new Array(2);\n                dp[i][j][l][1] = new Array(2);\n          \
    \  }\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j\
    \ = 0; j < m; j++) {\n            for (let l = 0; l <= k; l++) {\n           \
    \     dp[i][j][l][0][0] = dp[i][j][l][0][1] = dp[i][j][l][1][0] = dp[i][j][l][1][1]\
    \ = -1;\n            }\n        }\n    }\n    let ans = new Array(k);\n    let\
    \ res = f(grid, dp, 0, 0, k, 0, 0);\n    for (let i = 0; i < k; i++) {\n     \
    \   ans[i] = res[i];\n    }\n    return ans;\n}", "    // your code here\n}\n",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let dp = Array(n).fill(0).map(()\
    \ => Array(m).fill(0).map(() => Array(k + 1).fill(Infinity)));\n    let q = [];\n\
    \    let ans = [];\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n            q.push([i,\
    \ j, 1]);\n        }\n    }\n    while (q.length) {\n        let [i, j, l] = q.shift();\n\
    \        if (l == k) {\n            ans = [i, j, l];\n            break;\n   \
    \     }\n        for (let [x, y] of [[i - 1, j], [i + 1, j], [i, j - 1], [i, j\
    \ + 1]]) {\n            if (x < 0 || x >= n || y < 0 || y >= m) continue;\n  \
    \          if (dp[x][y][l + 1] > dp[i][j][l] + grid[x][y]) {\n               \
    \ dp[x][y][l + 1] = dp[i][j][l] + grid[x][y];\n                q.push([x, y, l\
    \ + 1]);\n            }\n        }\n    }\n    let [i, j, l] = ans;\n    let res\
    \ = [];\n    while (l) {\n        res.push(grid[i][j]);\n        for (let [x,\
    \ y] of [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]) {\n            if (x\
    \ < 0 || x >= n || y < 0 || y >= m) continue;\n            if (dp[x][y][l - 1]\
    \ + grid[i][j] == dp[i][j][l]) {\n                i = x;\n                j =\
    \ y;\n                l--;\n                break;\n            }\n        }\n\
    \    }\n    return res;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minPathSum = Infinity;\n    let visited = new\
    \ Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            let path = [];\n            let pathSum = 0;\n            dfs(i,\
    \ j, path, pathSum, visited);\n            if (pathSum < minPathSum) {\n     \
    \           minPathSum = pathSum;\n                minPath = path;\n         \
    \   }\n        }\n    }\n    return minPath;\n\n    function dfs(i: number, j:\
    \ number, path: any, pathSum: number, visited: any) {\n        if (path.length\
    \ === k) {\n            return;\n        }\n        if (i < 0 || i >= n || j <\
    \ 0 || j >= m || visited[i][j]) {\n            return;\n        }\n        path.push(grid[i][j]);\n\
    \        pathSum += grid[i][j];\n        visited[i][j] = true;\n        dfs(i\
    \ + 1, j, path, pathSum, visited);\n        dfs(i - 1, j, path, pathSum, visited);\n\
    \        dfs(i, j + 1, path, pathSum, visited);\n        dfs(i, j - 1, path, pathSum,\
    \ visited);\n        visited[i][j] = false;\n        path.pop();\n    }\n}\n",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let min = Infinity;\n\
    \    let minPath = [];\n    let visited = [];\n    for (let i = 0; i < n; i++)\
    \ {\n        visited[i] = [];\n        for (let j = 0; j < m; j++) {\n       \
    \     visited[i][j] = false;\n        }\n    }\n    for (let i = 0; i < n; i++)\
    \ {\n        for (let j = 0; j < m; j++) {\n            let path = [];\n     \
    \       dfs(grid, i, j, k, path, visited);\n            if (path.length > 0 &&\
    \ path.length < min) {\n                min = path.length;\n                minPath\
    \ = path;\n            }\n        }\n    }\n    return minPath;\n}\n", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = new Array(k);\n    let minSum = Infinity;\n    for (let\
    \ i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            let\
    \ path = [];\n            let sum = 0;\n            dfs(i, j, 0, path, sum);\n\
    \        }\n    }\n    return minPath;\n\n    function dfs(i: number, j: number,\
    \ depth: number, path: number[], sum: number) {\n        if (depth == k) {\n \
    \           if (sum < minSum) {\n                minSum = sum;\n             \
    \   minPath = path.slice();\n            }\n            return;\n        }\n \
    \       if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n         \
    \   return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i - 1, j, depth + 1, path, sum);\n  \
    \      dfs(i + 1, j, depth + 1, path, sum);\n        dfs(i, j - 1, depth + 1,\
    \ path, sum);\n        dfs(i, j + 1, depth + 1, path, sum);\n        path.pop();\n\
    \        sum -= grid[i][j];\n        visited[i][j] = false;\n    }\n}\n", "  \
    \  let n = grid.length;\n    let m = grid[0].length;\n    let min_path = [];\n\
    \    let min_sum = Infinity;\n    let min_sum_path = [];\n    let visited = [];\n\
    \    for (let i = 0; i < n; i++) {\n        visited.push([]);\n        for (let\
    \ j = 0; j < m; j++) {\n            visited[i].push(false);\n        }\n    }\n\
    \    let dfs = function (i: any, j: any, path: any, sum: any) {\n        if (sum\
    \ > min_sum) {\n            return;\n        }\n        if (path.length === k)\
    \ {\n            if (sum < min_sum) {\n                min_sum = sum;\n      \
    \          min_sum_path = path;\n            }\n            return;\n        }\n\
    \        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n        \
    \    return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i - 1, j, path, sum);\n        dfs(i\
    \ + 1, j, path, sum);\n        dfs(i, j - 1, path, sum);\n        dfs(i, j + 1,\
    \ path, sum);\n        path.pop();\n        sum -= grid[i][j];\n        visited[i][j]\
    \ = false;\n    };\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            dfs(i, j, [], 0);\n        }\n    }\n    return min_sum_path;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n    let minPathSum2\
    \ = Infinity;\n    let minPathSum3 = Infinity;\n    let minPathSum4 = Infinity;\n\
    \    let minPathSum5 = Infinity;\n    let minPathSum6 = Infinity;\n    let minPathSum7\
    \ = Infinity;\n    let minPathSum8 = Infinity;\n    let minPathSum9 = Infinity;\n\
    \    let minPathSum10 = Infinity;\n    let minPathSum11 = Infinity;\n    let minPathSum12\
    \ = Infinity;\n    let minPathSum13 = Infinity;\n    let minPathSum14 = Infinity;\n\
    \    let minPathSum15 = Infinity;\n    let minPathSum16 = Infinity;\n    let minPathSum17\
    \ = Infinity;\n    let minPathSum18 = Infinity;\n    let minPathSum19 = Infinity;\n\
    \    let minPathSum20 = Infinity;\n    let minPathSum21 = Infinity;\n    let minPathSum22\
    \ = Infinity;\n    let minPathSum23 = Infinity;\n    let minPathSum24 = Infinity;\n\
    \    let minPathSum25 = Infinity;\n    let minPathSum26 = Infinity;\n    let minPathSum27\
    \ = Infinity;\n    let minPathSum28 = Infinity;\n    let minPathSum29 = Infinity;\n\
    \    let minPathSum30 = Infinity;\n    let minPathSum31 = Infinity;\n    let minPathSum32\
    \ = Infinity;\n    let minPathSum33 = Infinity;\n    let minPathSum34 = Infinity;\n\
    \    let minPathSum35 = Infinity;\n    let minPathSum36 = Infinity;\n    let minPathSum37\
    \ = Infinity;\n    let minPathSum38 = Infinity;\n    let minPathSum39 = Infinity;\n\
    \    let minPathSum40 = Infinity;\n    let minPathSum41 = Infinity;\n    let minPathSum42\
    \ = Infinity;\n    let minPathSum43 = Infinity;\n    let minPathSum44 = Infinity;\n\
    \    let minPathSum45 = Infinity;\n    let minPathSum46 = Infinity;\n    let minPathSum47\
    \ = Infinity;\n    let minPathSum48 =", "    let n = grid.length;\n    let m =\
    \ grid[0].length;\n    let minPath: any = [];\n    let minSum: any = Infinity;\n\
    \    let minPaths: any = [];\n    let minSums: any = [];\n    let visited: any\
    \ = [];\n    for (let i = 0; i < n; i++) {\n        visited.push([]);\n      \
    \  for (let j = 0; j < m; j++) {\n            visited[i].push(false);\n      \
    \  }\n    }\n    function dfs(i: any, j: any, path: any, sum: any) {\n       \
    \ if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n            return;\n\
    \        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n  \
    \      sum += grid[i][j];\n        if (path.length === k) {\n            if (sum\
    \ < minSum) {\n                minSum = sum;\n                minPath = path.slice();\n\
    \            } else if (sum === minSum) {\n                minPaths.push(path.slice());\n\
    \                minSums.push(sum);\n            }\n        } else {\n       \
    \     dfs(i - 1, j, path, sum);\n            dfs(i + 1, j, path, sum);\n     \
    \       dfs(i, j - 1, path, sum);\n            dfs(i, j + 1, path, sum);\n   \
    \     }\n        path.pop();\n        visited[i][j] = false;\n    }\n    for (let\
    \ i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dfs(i,\
    \ j, [], 0);\n        }\n    }\n    if (minPaths.length) {\n        let minPaths2:\
    \ any = [];\n        let minSums2: any = [];\n        for (let i = 0; i < minPaths.length;\
    \ i++) {\n            if (minSums[i] === minSum) {\n                minPaths2.push(minPaths[i]);\n\
    \                min", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPaths = [];\n \
    \   let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited[i] =\
    \ [];\n        for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n\
    \        }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            let path = [];\n            let sum = 0;\n      \
    \      dfs(i, j, k, path, sum);\n        }\n    }\n    return minPaths;\n\n  \
    \  function dfs(i: any, j: any, k: any, path: any, sum: any) {\n        if (k\
    \ === 0) {\n            if (sum < minSum) {\n                minSum = sum;\n \
    \               minPaths = [path];\n            } else if (sum === minSum) {\n\
    \                minPaths.push(path);\n            }\n            return;\n  \
    \      }\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n\
    \            return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i + 1, j, k - 1, path.slice(), sum);\n\
    \        dfs(i - 1, j, k - 1, path.slice(), sum);\n        dfs(i, j + 1, k - 1,\
    \ path.slice(), sum);\n        dfs(i, j - 1, k - 1, path.slice(), sum);\n    \
    \    visited[i][j] = false;\n    }\n}\n", "    let n = grid.length;\n    let m\
    \ = grid[0].length;\n    let visited = new Array(n);\n    for (let i = 0; i <\
    \ n; i++) {\n        visited[i] = new Array(m).fill(false);\n    }\n    let minPath\
    \ = [];\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            let path = [];\n            let res = dfs(grid, i, j, k, path,\
    \ visited);\n            if (res && (!minPath.length || minPath.length > res.length))\
    \ {\n                minPath = res;\n            }\n        }\n    }\n    return\
    \ minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n   \
    \ let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPaths = [];\n    let minPathsSum = [];\n    let minPathsSum2 = [];\n\
    \    let minPathsSum3 = [];\n    let minPathsSum4 = [];\n    let minPathsSum5\
    \ = [];\n    let minPathsSum6 = [];\n    let minPathsSum7 = [];\n    let minPathsSum8\
    \ = [];\n    let minPathsSum9 = [];\n    let minPathsSum10 = [];\n    let minPathsSum11\
    \ = [];\n    let minPathsSum12 = [];\n    let minPathsSum13 = [];\n    let minPathsSum14\
    \ = [];\n    let minPathsSum15 = [];\n    let minPathsSum16 = [];\n    let minPathsSum17\
    \ = [];\n    let minPathsSum18 = [];\n    let minPathsSum19 = [];\n    let minPathsSum20\
    \ = [];\n    let minPathsSum21 = [];\n    let minPathsSum22 = [];\n    let minPathsSum23\
    \ = [];\n    let minPathsSum24 = [];\n    let minPathsSum25 = [];\n    let minPathsSum26\
    \ = [];\n    let minPathsSum27 = [];\n    let minPathsSum28 = [];\n    let minPathsSum29\
    \ = [];\n    let minPathsSum30 = [];\n    let minPathsSum31 = [];\n    let minPathsSum32\
    \ = [];\n    let minPathsSum33 = [];\n    let minPathsSum34 = [];\n    let minPathsSum35\
    \ = [];\n    let minPathsSum36 = [];\n    let minPathsSum37 = [];\n    let minPathsSum38\
    \ = [];\n    let minPathsSum39 = [];\n    let minPathsSum40 = [];\n    let minPathsSum41\
    \ = [];\n    let minPathsSum42 = [];\n    let minPathsSum43 = [];\n    let minPathsSum44\
    \ = [];\n    let minPathsSum45 = [];\n    let minPathsSum46 = [];\n", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    let minSumPath\
    \ = [];\n    let dfs = (i: any, j: any, path: any, sum: any) => {\n        if\
    \ (i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || path.length > k) {\n\
    \            return;\n        }\n        path.push(grid[i][j]);\n        sum +=\
    \ grid[i][j];\n        visited[i][j] = true;\n        if (path.length === k) {\n\
    \            if (sum < minSum) {\n                minSum = sum;\n            \
    \    minSumPath = path.slice();\n            } else if (sum === minSum) {\n  \
    \              if (path.join('') < minSumPath.join('')) {\n                  \
    \  minSumPath = path.slice();\n                }\n            }\n        } else\
    \ {\n            dfs(i - 1, j, path, sum);\n            dfs(i + 1, j, path, sum);\n\
    \            dfs(i, j - 1, path, sum);\n            dfs(i, j + 1, path, sum);\n\
    \        }\n        path.pop();\n        visited[i][j] = false;\n    }\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n         \
    \   dfs(i, j, [], 0);\n        }\n    }\n    return minSumPath;\n}\n", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n    let\
    \ minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2 =\
    \ [];\n    let minPathSum3 = Infinity;\n    let minPath3 = [];\n    let minPathSum4\
    \ = Infinity;\n    let minPath4 = [];\n    let minPathSum5 = Infinity;\n    let\
    \ minPath5 = [];\n    let minPathSum6 = Infinity;\n    let minPath6 = [];\n  \
    \  let minPathSum7 = Infinity;\n    let minPath7 = [];\n    let minPathSum8 =\
    \ Infinity;\n    let minPath8 = [];\n    let minPathSum9 = Infinity;\n    let\
    \ minPath9 = [];\n    let minPathSum10 = Infinity;\n    let minPath10 = [];\n\
    \    let minPathSum11 = Infinity;\n    let minPath11 = [];\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minPathSum13 = Infinity;\n   \
    \ let minPath13 = [];\n    let minPathSum14 = Infinity;\n    let minPath14 = [];\n\
    \    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let minPathSum16\
    \ = Infinity;\n    let minPath16 = [];\n    let minPathSum17 = Infinity;\n   \
    \ let minPath17 = [];\n    let minPathSum18 = Infinity;\n    let minPath18 = [];\n\
    \    let minPathSum19 = Infinity;\n    let minPath19 = [];\n    let minPathSum20\
    \ = Infinity;\n    let minPath20 = [];\n    let minPathSum21 = Infinity;\n   \
    \ let minPath21 = [];\n    let minPathSum22 = Infinity;\n    let minPath22 = [];\n\
    \    let minPathSum23 = Infinity;\n    let minPath23 = [];\n    let minPathSum24\
    \ = Infinity;\n    let minPath24 = [];\n    let minPathSum25 = Infinity;\n   \
    \ let minPath25 = [];\n    let minPathSum26 = Infinity;\n    let minPath26 = [];\n\
    \    let minPathSum27 = Infinity;\n    let minPath27 = [];\n    let minPathSum28\
    \ =", "    // Your code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = new Array(k);\n    let\
    \ minPathSum = Number.MAX_SAFE_INTEGER;\n    let minPathSum2 = Number.MAX_SAFE_INTEGER;\n\
    \    let minPathSum3 = Number.MAX_SAFE_INTEGER;\n    let minPathSum4 = Number.MAX_SAFE_INTEGER;\n\
    \    let minPathSum5 = Number.MAX_SAFE_INTEGER;\n    let minPathSum6 = Number.MAX_SAFE_INTEGER;\n\
    \    let minPathSum7 = Number.MAX_SAFE_INTEGER;\n    let minPathSum8 = Number.MAX_SAFE_INTEGER;\n\
    \    let minPathSum9 = Number.MAX_SAFE_INTEGER;\n    let minPathSum10 = Number.MAX_SAFE_INTEGER;\n\
    \    let minPathSum11 = Number.MAX_SAFE_INTEGER;\n    let minPathSum12 = Number.MAX_SAFE_INTEGER;\n\
    \    let minPathSum13 = Number.MAX_SAFE_INTEGER;\n    let minPathSum14 = Number.MAX_SAFE_INTEGER;\n\
    \    let minPathSum15 = Number.MAX_SAFE_INTEGER;\n    let minPathSum16 = Number.MAX_SAFE_INTEGER;\n\
    \    let minPathSum17 = Number.MAX_SAFE_INTEGER;\n    let minPathSum18 = Number.MAX_SAFE_INTEGER;\n\
    \    let minPathSum19 = Number.MAX_SAFE_INTEGER;\n    let minPathSum20 = Number.MAX_SAFE_INTEGER;\n\
    \    let minPathSum21 = Number.MAX_SAFE_INTEGER;\n    let minPathSum22 = Number.MAX_SAFE_INTEGER;\n\
    \    let minPathSum23 = Number.MAX_SAFE_INTEGER;", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let dp = new Array(n);\n    for (let i = 0;\
    \ i < n; i++) {\n        dp[i] = new Array(m);\n        for (let j = 0; j < m;\
    \ j++) {\n            dp[i][j] = new Array(k + 1);\n            for (let l = 0;\
    \ l <= k; l++) {\n                dp[i][j][l] = new Array(2);\n              \
    \  dp[i][j][l][0] = [];\n                dp[i][j][l][1] = Infinity;\n        \
    \    }\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let\
    \ j = 0; j < m; j++) {\n            dp[i][j][1][0] = [grid[i][j]];\n         \
    \   dp[i][j][1][1] = grid[i][j];\n        }\n    }\n    for (let l = 2; l <= k;\
    \ l++) {\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j\
    \ < m; j++) {\n                let min = Infinity;\n                let minPath\
    \ = [];\n                if (i > 0) {\n                    if (dp[i - 1][j][l\
    \ - 1][1] < min) {\n                        min = dp[i - 1][j][l - 1][1];\n  \
    \                      minPath = dp[i - 1][j][l - 1][0].slice();\n           \
    \         }\n                }\n                if (i < n - 1) {\n           \
    \         if (dp[i + 1][j][l - 1][1] < min) {\n                        min = dp[i\
    \ + 1][j][l - 1][1];\n                        minPath = dp[i + 1][j][l - 1][0].slice();\n\
    \                    }\n                }\n                if (j > 0) {\n    \
    \                if (dp[i][j - 1][l - 1][1] < min) {\n                       \
    \ min = dp[i][j - 1][l -", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let visited = [];\n  \
    \  for (let i = 0; i < n; i++) {\n        visited[i] = [];\n        for (let j\
    \ = 0; j < m; j++) {\n            visited[i][j] = false;\n        }\n    }\n \
    \   for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n   \
    \         let path = [];\n            let sum = 0;\n            let dfs = (i:\
    \ any, j: any, path: any, sum: any) => {\n                if (i < 0 || i >= n\
    \ || j < 0 || j >= m || visited[i][j] || path.length >= k) {\n               \
    \     return;\n                }\n                path.push(grid[i][j]);\n   \
    \             sum += grid[i][j];\n                visited[i][j] = true;\n    \
    \            if (path.length === k) {\n                    if (sum < minSum) {\n\
    \                        minSum = sum;\n                        minPath = path;\n\
    \                    }\n                }\n                dfs(i - 1, j, path,\
    \ sum);\n                dfs(i + 1, j, path, sum);\n                dfs(i, j -\
    \ 1, path, sum);\n                dfs(i, j + 1, path, sum);\n                visited[i][j]\
    \ = false;\n                path.pop();\n            }\n            dfs(i, j,\
    \ path, sum);\n        }\n    }\n    return minPath;\n}\nconsole.log(minPath([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3));\nconsole.log(minPath([[5, 9, 3], [4, 1, 6],\
    \ [7, 8, 2]], 1));", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minSumPath = [];\n\
    \    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = [];\n        for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n\
    \        }\n    }\n    function dfs(i: any, j: any, path: any, sum: any) {\n \
    \       if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n         \
    \   return;\n        }\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n\
    \        visited[i][j] = true;\n        if (path.length === k) {\n           \
    \ if (sum < minSum) {\n                minSum = sum;\n                minSumPath\
    \ = path.slice();\n            } else if (sum === minSum) {\n                if\
    \ (path.join('') < minSumPath.join('')) {\n                    minSumPath = path.slice();\n\
    \                }\n            }\n        } else {\n            dfs(i - 1, j,\
    \ path, sum);\n            dfs(i + 1, j, path, sum);\n            dfs(i, j - 1,\
    \ path, sum);\n            dfs(i, j + 1, path, sum);\n        }\n        path.pop();\n\
    \        visited[i][j] = false;\n    }\n    for (let i = 0; i < n; i++) {\n  \
    \      for (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n        }\n\
    \    }\n    return minSumPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m;\
    \ j++) {\n            let path = [];\n            let sum = 0;\n            dfs(i,\
    \ j, k, grid, visited, path, sum);\n            if (sum < minSum) {\n        \
    \        minSum = sum;\n                minPath = path;\n            }\n     \
    \   }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let m\
    \ = grid[0].length;\n    let min = Infinity;\n    let minPath = [];\n    let visited\
    \ = new Set();\n    let dfs = (i: any, j: any, path: any, sum: any) => {\n   \
    \     if (sum > min) return;\n        if (path.length === k) {\n            if\
    \ (sum < min) {\n                min = sum;\n                minPath = path;\n\
    \            }\n            return;\n        }\n        if (i < 0 || i >= n ||\
    \ j < 0 || j >= m) return;\n        if (visited.has(i * m + j)) return;\n    \
    \    visited.add(i * m + j);\n        dfs(i - 1, j, path.concat(grid[i][j]), sum\
    \ + grid[i][j]);\n        dfs(i + 1, j, path.concat(grid[i][j]), sum + grid[i][j]);\n\
    \        dfs(i, j - 1, path.concat(grid[i][j]), sum + grid[i][j]);\n        dfs(i,\
    \ j + 1, path.concat(grid[i][j]), sum + grid[i][j]);\n        visited.delete(i\
    \ * m + j);\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let dp = new\
    \ Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = new Array(m);\n\
    \        for (let j = 0; j < m; j++) {\n            dp[i][j] = new Array(k + 1);\n\
    \            for (let l = 0; l <= k; l++) {\n                dp[i][j][l] = new\
    \ Array(2);\n                dp[i][j][l][0] = new Array(2);\n                dp[i][j][l][1]\
    \ = new Array(2);\n            }\n        }\n    }\n    for (let i = 0; i < n;\
    \ i++) {\n        for (let j = 0; j < m; j++) {\n            for (let l = 0; l\
    \ <= k; l++) {\n                for (let p = 0; p < 2; p++) {\n              \
    \      for (let q = 0; q < 2; q++) {\n                        dp[i][j][l][p][q]\
    \ = new Array(2);\n                    }\n                }\n            }\n \
    \       }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j\
    \ < m; j++) {\n            for (let l = 0; l <= k; l++) {\n                for\
    \ (let p = 0; p < 2; p++) {\n                    for (let q = 0; q < 2; q++) {\n\
    \                        for (let r = 0; r < 2; r++) {\n                     \
    \       dp[i][j][l][p][q][r] = new Array(2);\n                        }\n    \
    \                }\n                }\n            }\n        }\n    }\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n         \
    \   for (let l = 0; l <= k; l++) {\n                for (let p = 0; p < 2; p++)\
    \ {\n                    for (let q = 0; q < 2; q++) {\n                     \
    \   for (let", "    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ minPath = [];\n    let minValue = Infinity;\n    let minPaths = [];\n    let\
    \ visited = [];\n    for (let i = 0; i < n; i++) {\n        visited[i] = [];\n\
    \        for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n \
    \       }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j\
    \ < m; j++) {\n            let path = [];\n            let value = 0;\n      \
    \      dfs(i, j, k, path, value);\n        }\n    }\n    return minPaths;\n\n\
    \    function dfs(i: any, j: any, k: any, path: any, value: any) {\n        if\
    \ (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n            return;\n\
    \        }\n        path.push(grid[i][j]);\n        value += grid[i][j];\n   \
    \     visited[i][j] = true;\n        if (path.length === k) {\n            if\
    \ (value < minValue) {\n                minValue = value;\n                minPaths\
    \ = [path];\n            } else if (value === minValue) {\n                minPaths.push(path);\n\
    \            }\n        } else {\n            dfs(i - 1, j, k, path.slice(), value);\n\
    \            dfs(i + 1, j, k, path.slice(), value);\n            dfs(i, j - 1,\
    \ k, path.slice(), value);\n            dfs(i, j + 1, k, path.slice(), value);\n\
    \        }\n        visited[i][j] = false;\n    }\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = [];\n    let min_sum = Infinity;\n\
    \    let min_path = [];\n    let path = [];\n    let sum = 0;\n    let visited\
    \ = [];\n    for (let i = 0; i < n; i++) {\n        visited.push([]);\n      \
    \  for (let j = 0; j < m; j++) {\n            visited[i].push(false);\n      \
    \  }\n    }\n    function dfs(i: any, j: any, k: any) {\n        if (k == 0) {\n\
    \            if (sum < min_sum) {\n                min_sum = sum;\n          \
    \      min_path = path.slice();\n            }\n            return;\n        }\n\
    \        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n        \
    \    return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i - 1, j, k - 1);\n        dfs(i + 1,\
    \ j, k - 1);\n        dfs(i, j - 1, k - 1);\n        dfs(i, j + 1, k - 1);\n \
    \       visited[i][j] = false;\n        path.pop();\n        sum -= grid[i][j];\n\
    \    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            dfs(i, j, k);\n        }\n    }\n    return min_path;\n}\n",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let min = Number.MAX_SAFE_INTEGER;\n\
    \    let minPath = [];\n    let visited = [];\n    for (let i = 0; i < n; i++)\
    \ {\n        visited[i] = [];\n        for (let j = 0; j < m; j++) {\n       \
    \     visited[i][j] = false;\n        }\n    }\n    for (let i = 0; i < n; i++)\
    \ {\n        for (let j = 0; j < m; j++) {\n            let path = [];\n     \
    \       let pathSum = 0;\n            dfs(i, j, path, pathSum, visited);\n   \
    \         if (pathSum < min) {\n                min = pathSum;\n             \
    \   minPath = path;\n            }\n        }\n    }\n    return minPath;\n\n\
    \    function dfs(i: any, j: any, path: any, pathSum: any, visited: any) {\n \
    \       if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n         \
    \   return;\n        }\n        path.push(grid[i][j]);\n        pathSum += grid[i][j];\n\
    \        visited[i][j] = true;\n        if (path.length === k) {\n           \
    \ return;\n        }\n        dfs(i + 1, j, path, pathSum, visited);\n       \
    \ dfs(i - 1, j, path, pathSum, visited);\n        dfs(i, j + 1, path, pathSum,\
    \ visited);\n        dfs(i, j - 1, path, pathSum, visited);\n        visited[i][j]\
    \ = false;\n        path.pop();\n    }\n}\n", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let minPath = [];\n    let minSum = Infinity;\n   \
    \ let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited[i] = [];\n\
    \        for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n \
    \       }\n    }\n    function dfs(i: any, j: any, path: any, sum: any) {\n  \
    \      if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n          \
    \  return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        if (path.length === k) {\n            if\
    \ (sum < minSum) {\n                minSum = sum;\n                minPath = path.slice();\n\
    \            }\n        } else {\n            dfs(i - 1, j, path, sum);\n    \
    \        dfs(i + 1, j, path, sum);\n            dfs(i, j - 1, path, sum);\n  \
    \          dfs(i, j + 1, path, sum);\n        }\n        path.pop();\n       \
    \ visited[i][j] = false;\n    }\n    for (let i = 0; i < n; i++) {\n        for\
    \ (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n        }\n    }\n\
    \    return minPath;\n}\n", "    // your code here\n}", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let dp = new Array(n);\n    for (let i = 0;\
    \ i < n; i++) {\n        dp[i] = new Array(m);\n        for (let j = 0; j < m;\
    \ j++) {\n            dp[i][j] = new Array(k + 1);\n            for (let l = 0;\
    \ l <= k; l++) {\n                dp[i][j][l] = new Array(2);\n              \
    \  dp[i][j][l][0] = Infinity;\n                dp[i][j][l][1] = [];\n        \
    \    }\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let\
    \ j = 0; j < m; j++) {\n            dp[i][j][1][0] = grid[i][j];\n           \
    \ dp[i][j][1][1] = [grid[i][j]];\n        }\n    }\n    for (let l = 2; l <= k;\
    \ l++) {\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j\
    \ < m; j++) {\n                if (i > 0) {\n                    let temp = dp[i\
    \ - 1][j][l - 1][0] + grid[i][j];\n                    if (temp < dp[i][j][l][0])\
    \ {\n                        dp[i][j][l][0] = temp;\n                        dp[i][j][l][1]\
    \ = dp[i - 1][j][l - 1][1].concat(grid[i][j]);\n                    }\n      \
    \          }\n                if (i < n - 1) {\n                    let temp =\
    \ dp[i + 1][j][l - 1][0] + grid[i][j];\n                    if (temp < dp[i][j][l][0])\
    \ {\n                        dp[i][j][l][0] = temp;\n                        dp[i][j][l][1]\
    \ = dp[i + 1][j][l - 1][1].concat(", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp = new Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i]\
    \ = new Array(m);\n        for (let j = 0; j < m; j++) {\n            dp[i][j]\
    \ = new Array(k + 1);\n            for (let l = 0; l <= k; l++) {\n          \
    \      dp[i][j][l] = new Array(2);\n                dp[i][j][l][0] = -1;\n   \
    \             dp[i][j][l][1] = -1;\n            }\n        }\n    }\n    let ans\
    \ = new Array(k);\n    let min = Infinity;\n    for (let i = 0; i < n; i++) {\n\
    \        for (let j = 0; j < m; j++) {\n            let cur = dfs(i, j, k, grid,\
    \ dp);\n            if (cur < min) {\n                min = cur;\n           \
    \     for (let l = 0; l < k; l++) {\n                    ans[l] = dp[i][j][k][1][l];\n\
    \                }\n            }\n        }\n    }\n    return ans;\n}\n", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2\
    \ = [];\n    let minPath3 = [];\n    let minPathSum3 = Infinity;\n    let minPath4\
    \ = [];\n    let minPathSum4 = Infinity;\n    let minPath5 = [];\n    let minPathSum5\
    \ = Infinity;\n    let minPath6 = [];\n    let minPathSum6 = Infinity;\n    let\
    \ minPath7 = [];\n    let minPathSum7 = Infinity;\n    let minPath8 = [];\n  \
    \  let minPathSum8 = Infinity;\n    let minPath9 = [];\n    let minPathSum9 =\
    \ Infinity;\n    let minPath10 = [];\n    let minPathSum10 = Infinity;\n    let\
    \ minPath11 = [];\n    let minPathSum11 = Infinity;\n    let minPath12 = [];\n\
    \    let minPathSum12 = Infinity;\n    let minPath13 = [];\n    let minPathSum13\
    \ = Infinity;\n    let minPath14 = [];\n    let minPathSum14 = Infinity;\n   \
    \ let minPath15 = [];\n    let minPathSum15 = Infinity;\n    let minPath16 = [];\n\
    \    let minPathSum16 = Infinity;\n    let minPath17 = [];\n    let minPathSum17\
    \ = Infinity;\n    let minPath18 = [];\n    let minPathSum18 = Infinity;\n   \
    \ let minPath19 = [];\n    let minPathSum19 = Infinity;\n    let minPath20 = [];\n\
    \    let minPathSum20 = Infinity;\n    let minPath21 = [];\n    let minPathSum21\
    \ = Infinity;\n    let minPath22 = [];\n    let minPathSum22 = Infinity;\n   \
    \ let minPath23 = [];\n    let minPathSum23 = Infinity;\n    let minPath24 = [];\n\
    \    let minPathSum24 = Infinity;\n    let minPath25 = [];\n    let minPathSum25\
    \ = Infinity;\n    let minPath26 = [];\n    let minPathSum26 = Infinity;\n   \
    \ let minPath27 = [];\n    let minPathSum27 = Infinity;\n    let minPath28 = [];",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n\
    \    let minSum = Infinity;\n    let minPathSum = Infinity;\n    let visited =\
    \ [];\n    for (let i = 0; i < n; i++) {\n        visited[i] = [];\n        for\
    \ (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n        }\n \
    \   }\n    let dfs = (i: any, j: any, path: any, sum: any) => {\n        if (i\
    \ < 0 || i >= n || j < 0 || j >= m || visited[i][j] || sum > minSum) {\n     \
    \       return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        if (path.length === k) {\n            if\
    \ (sum < minPathSum) {\n                minPathSum = sum;\n                minPath\
    \ = path.slice();\n            }\n        } else {\n            dfs(i + 1, j,\
    \ path, sum);\n            dfs(i - 1, j, path, sum);\n            dfs(i, j + 1,\
    \ path, sum);\n            dfs(i, j - 1, path, sum);\n        }\n        path.pop();\n\
    \        visited[i][j] = false;\n    };\n    for (let i = 0; i < n; i++) {\n \
    \       for (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n       \
    \     minSum = minPathSum;\n        }\n    }\n    return minPath;\n}\n", "   \
    \ let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = new Array(k);\n    let minPathSum = Number.MAX_SAFE_INTEGER;\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          let path = new Array(k);\n            let pathSum = 0;\n          \
    \  dfs(i, j, 0, path, pathSum);\n        }\n    }\n    return minPath;\n\n   \
    \ function dfs(i: number, j: number, step: number, path: any, pathSum: any) {\n\
    \        if (step == k) {\n            if (pathSum < minPathSum) {\n         \
    \       minPathSum = pathSum;\n                minPath = path.slice();\n     \
    \       }\n            return;\n        }\n        if (i < 0 || i >= n || j <\
    \ 0 || j >= m || visited[i][j]) {\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        path[step] = grid[i][j];\n        pathSum += grid[i][j];\n\
    \        dfs(i - 1, j, step + 1, path, pathSum);\n        dfs(i + 1, j, step +\
    \ 1, path, pathSum);\n        dfs(i, j - 1, step + 1, path, pathSum);\n      \
    \  dfs(i, j + 1, step + 1, path, pathSum);\n        visited[i][j] = false;\n \
    \   }\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let dp\
    \ = [];\n    for (let i = 0; i < n; i++) {\n        dp[i] = [];\n        for (let\
    \ j = 0; j < m; j++) {\n            dp[i][j] = [];\n        }\n    }\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n         \
    \   dp[i][j][0] = [grid[i][j]];\n        }\n    }\n    for (let i = 0; i < n;\
    \ i++) {\n        for (let j = 0; j < m; j++) {\n            for (let l = 1; l\
    \ < k; l++) {\n                let min = [];\n                if (i > 0) {\n \
    \                   min = dp[i - 1][j][l - 1];\n                }\n          \
    \      if (j > 0 && (min.length == 0 || dp[i][j - 1][l - 1] < min)) {\n      \
    \              min = dp[i][j - 1][l - 1];\n                }\n               \
    \ if (i < n - 1 && (min.length == 0 || dp[i + 1][j][l - 1] < min)) {\n       \
    \             min = dp[i + 1][j][l - 1];\n                }\n                if\
    \ (j < m - 1 && (min.length == 0 || dp[i][j + 1][l - 1] < min)) {\n          \
    \          min = dp[i][j + 1][l - 1];\n                }\n                dp[i][j][l]\
    \ = min.concat(grid[i][j]);\n            }\n        }\n    }\n    let min = [];\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          if (min.length == 0 || dp[i][j][k - 1] < min) {\n                min\
    \ = dp[i][j][k - 1];\n            }\n        }\n    }\n    return min;\n}", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = new Array(k);\n    let minSum = Number.MAX_SAFE_INTEGER;\n\
    \    let minPathSum = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i < n; i++)\
    \ {\n        for (let j = 0; j < m; j++) {\n            minPath = new Array(k);\n\
    \            minSum = Number.MAX_SAFE_INTEGER;\n            minPathSum = Number.MAX_SAFE_INTEGER;\n\
    \            findPath(grid, visited, i, j, 0, k, 0, minPath, minSum, minPathSum);\n\
    \        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let minPathSum3\
    \ = Infinity;\n    let minPath3 = [];\n    let minPathSum4 = Infinity;\n    let\
    \ minPath4 = [];\n    let minPathSum5 = Infinity;\n    let minPath5 = [];\n  \
    \  let minPathSum6 = Infinity;\n    let minPath6 = [];\n    let minPathSum7 =\
    \ Infinity;\n    let minPath7 = [];\n    let minPathSum8 = Infinity;\n    let\
    \ minPath8 = [];\n    let minPathSum9 = Infinity;\n    let minPath9 = [];\n  \
    \  let minPathSum10 = Infinity;\n    let minPath10 = [];\n    let minPathSum11\
    \ = Infinity;\n    let minPath11 = [];\n    let minPathSum12 = Infinity;\n   \
    \ let minPath12 = [];\n    let minPathSum13 = Infinity;\n    let minPath13 = [];\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minPathSum15\
    \ = Infinity;\n    let minPath15 = [];\n    let minPathSum16 = Infinity;\n   \
    \ let minPath16 = [];\n    let minPathSum17 = Infinity;\n    let minPath17 = [];\n\
    \    let minPathSum18 = Infinity;\n    let minPath18 = [];\n    let minPathSum19\
    \ = Infinity;\n    let minPath19 = [];\n    let minPathSum20 = Infinity;\n   \
    \ let minPath20 = [];\n    let minPathSum21 = Infinity;\n    let minPath21 = [];\n\
    \    let minPathSum22 = Infinity;\n    let minPath22 = [];\n    let minPathSum23\
    \ = Infinity;\n    let minPath23 = [];\n    let minPathSum24 = Infinity;\n   \
    \ let minPath24 = [];\n    let minPathSum25 = Infinity;\n    let minPath25 = [];\n\
    \    let minPathSum26 = Infinity;\n    let minPath26 = [];\n    let minPathSum27\
    \ = Infinity;\n    let minPath27 = [];\n    let minPathSum28 =", "    let n =\
    \ grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minPathSum = Number.MAX_SAFE_INTEGER;\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          let path = [];\n            let pathSum = 0;\n            dfs(i, j,\
    \ k, path, pathSum);\n        }\n    }\n    return minPath;\n\n    function dfs(i:\
    \ number, j: number, k: number, path: number[], pathSum: number) {\n        if\
    \ (i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || path.length > k) {\n\
    \            return;\n        }\n        path.push(grid[i][j]);\n        pathSum\
    \ += grid[i][j];\n        visited[i][j] = true;\n        if (path.length === k)\
    \ {\n            if (pathSum < minPathSum) {\n                minPathSum = pathSum;\n\
    \                minPath = path.slice();\n            } else if (pathSum === minPathSum)\
    \ {\n                if (path.toString() < minPath.toString()) {\n           \
    \         minPath = path.slice();\n                }\n            }\n        }\
    \ else {\n            dfs(i - 1, j, k, path, pathSum);\n            dfs(i + 1,\
    \ j, k, path, pathSum);\n            dfs(i, j - 1, k, path, pathSum);\n      \
    \      dfs(i, j + 1, k, path, pathSum);\n        }\n        path.pop();\n    \
    \    pathSum -= grid[i][j];\n        visited[i][j] = false;\n    }\n}\n", "  \
    \  let n = grid.length;\n    let m = grid[0].length;\n    let dp = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        dp[i] = new Array(m);\n        for\
    \ (let j = 0; j < m; j++) {\n            dp[i][j] = new Array(k + 1);\n      \
    \      for (let l = 0; l <= k; l++) {\n                dp[i][j][l] = [];\n   \
    \         }\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        for\
    \ (let j = 0; j < m; j++) {\n            dp[i][j][1] = [grid[i][j]];\n       \
    \ }\n    }\n    for (let l = 2; l <= k; l++) {\n        for (let i = 0; i < n;\
    \ i++) {\n            for (let j = 0; j < m; j++) {\n                let min =\
    \ [];\n                if (i > 0) {\n                    min = dp[i - 1][j][l\
    \ - 1];\n                }\n                if (j > 0 && (min.length == 0 || min\
    \ > dp[i][j - 1][l - 1])) {\n                    min = dp[i][j - 1][l - 1];\n\
    \                }\n                if (i < n - 1 && (min.length == 0 || min >\
    \ dp[i + 1][j][l - 1])) {\n                    min = dp[i + 1][j][l - 1];\n  \
    \              }\n                if (j < m - 1 && (min.length == 0 || min > dp[i][j\
    \ + 1][l - 1])) {\n                    min = dp[i][j + 1][l - 1];\n          \
    \      }\n                dp[i][j][l] = min.concat(grid[i][j]);\n            }\n\
    \        }\n    }\n    let min = [];\n    for (let i = 0; i < n; i++) {\n    \
    \    for (let j = 0; j < m; j++) {\n            if (min.length == 0 ||", "   \
    \ let n = grid.length;\n    let m = grid[0].length;\n    let dp = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        dp[i] = new Array(m);\n        for\
    \ (let j = 0; j < m; j++) {\n            dp[i][j] = new Array(k + 1);\n      \
    \      for (let l = 0; l <= k; l++) {\n                dp[i][j][l] = new Array(2);\n\
    \                dp[i][j][l][0] = -1;\n                dp[i][j][l][1] = -1;\n\
    \            }\n        }\n    }\n    let ans = new Array(k);\n    let min = 100000000;\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          let cur = solve(i, j, k, grid, dp);\n            if (cur < min) {\n\
    \                min = cur;\n                for (let l = 0; l < k; l++) {\n \
    \                   ans[l] = dp[i][j][k][l];\n                }\n            }\n\
    \        }\n    }\n    return ans;\n}\n", "    // your code here\n}\n", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let dp = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        dp[i] = new Array(m);\n        for\
    \ (let j = 0; j < m; j++) {\n            dp[i][j] = new Array(k + 1);\n      \
    \      for (let l = 0; l <= k; l++) {\n                dp[i][j][l] = new Array(2);\n\
    \                dp[i][j][l][0] = -1;\n                dp[i][j][l][1] = -1;\n\
    \            }\n        }\n    }\n    let ans = new Array(k);\n    for (let i\
    \ = 0; i < k; i++) {\n        ans[i] = -1;\n    }\n    let min = Infinity;\n \
    \   for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n   \
    \         let cur = solve(i, j, k, grid, dp);\n            if (cur < min) {\n\
    \                min = cur;\n                for (let l = 0; l < k; l++) {\n \
    \                   ans[l] = dp[i][j][k][l];\n                }\n            }\n\
    \        }\n    }\n    return ans;\n}\n", "    let N = grid.length;\n    let minPath\
    \ = [];\n    let minPathSum = Infinity;\n    let minPathSumIndex = -1;\n    let\
    \ minPathSumIndexes = [];\n    let minPathSumIndexesSum = 0;\n    let minPathSumIndexesSumIndex\
    \ = -1;\n    let minPathSumIndexesSumIndexes = [];\n    let minPathSumIndexesSumIndexesSum\
    \ = 0;\n    let minPathSumIndexesSumIndexesSumIndex = -1;\n    let minPathSumIndexesSumIndexesSumIndexes\
    \ = [];\n    let minPathSumIndexesSumIndexesSumIndexesSum = 0;\n    let minPathSumIndexesSumIndexesSumIndexesSumIndex\
    \ = -1;\n    let minPathSumIndexesSumIndexesSumIndexesSumIndexes = [];\n    let\
    \ minPathSumIndexesSumIndexesSumIndexesSumIndexesSum = 0;\n    let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndex\
    \ = -1;\n    let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexes = [];\n\
    \    let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSum = 0;\n \
    \   let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndex = -1;\n\
    \    let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexes =\
    \ [];\n    let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSum\
    \ = 0;\n    let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndex\
    \ = -1;\n    let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexes\
    \ = [];\n    let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSum\
    \ = 0;\n    let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndex\
    \ = -1;\n    let minPathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexesSumIndexes\
    \ = [];\n    let min", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp = new Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i]\
    \ = new Array(m);\n        for (let j = 0; j < m; j++) {\n            dp[i][j]\
    \ = new Array(k + 1);\n            for (let l = 0; l <= k; l++) {\n          \
    \      dp[i][j][l] = new Array(2);\n                dp[i][j][l][0] = -1;\n   \
    \             dp[i][j][l][1] = -1;\n            }\n        }\n    }\n    let ans\
    \ = new Array(k);\n    let min = solve(0, 0, k, grid, dp);\n    for (let i = 0;\
    \ i < k; i++) {\n        ans[i] = grid[min[0]][min[1]];\n        min = dp[min[0]][min[1]][min[2]];\n\
    \    }\n    return ans;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minSumPath = [];\n\
    \    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = [];\n        for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n\
    \        }\n    }\n    function dfs(i: any, j: any, path: any, sum: any) {\n \
    \       if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n         \
    \   return;\n        }\n        if (path.length === k) {\n            if (sum\
    \ < minSum) {\n                minSum = sum;\n                minSumPath = path;\n\
    \            }\n            return;\n        }\n        visited[i][j] = true;\n\
    \        path.push(grid[i][j]);\n        sum += grid[i][j];\n        dfs(i + 1,\
    \ j, path, sum);\n        dfs(i - 1, j, path, sum);\n        dfs(i, j + 1, path,\
    \ sum);\n        dfs(i, j - 1, path, sum);\n        path.pop();\n        sum -=\
    \ grid[i][j];\n        visited[i][j] = false;\n    }\n    for (let i = 0; i <\
    \ n; i++) {\n        for (let j = 0; j < m; j++) {\n            dfs(i, j, [],\
    \ 0);\n        }\n    }\n    return minSumPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for (let i\
    \ = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n    }\n\
    \    let minPath = [];\n    for (let i = 0; i < k; i++) {\n        minPath.push(Infinity);\n\
    \    }\n    let minPathSum = Infinity;\n    for (let i = 0; i < n; i++) {\n  \
    \      for (let j = 0; j < m; j++) {\n            let path = [];\n           \
    \ let pathSum = 0;\n            let dfs = (i: any, j: any, k: any) => {\n    \
    \            if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || k < 0)\
    \ {\n                    return;\n                }\n                visited[i][j]\
    \ = true;\n                path.push(grid[i][j]);\n                pathSum +=\
    \ grid[i][j];\n                if (k === 0) {\n                    if (pathSum\
    \ < minPathSum) {\n                        minPathSum = pathSum;\n           \
    \             minPath = path.slice();\n                    } else if (pathSum\
    \ === minPathSum) {\n                        for (let i = 0; i < k; i++) {\n \
    \                           if (path[i] < minPath[i]) {\n                    \
    \            minPath = path.slice();\n                                break;\n\
    \                            } else if (path[i] > minPath[i]) {\n            \
    \                    break;\n                            }\n                 \
    \       }\n                    }\n                } else {\n                 \
    \   dfs(i - 1, j, k - 1);\n                    dfs(i + 1, j, k - 1);\n       \
    \             dfs(i, j - 1, k - 1);\n                    dfs(i, j + 1, k - 1);\n\
    \                }\n                visited[i][j] = false;\n                path.pop();\n\
    \                pathSum -= grid[i][j];\n            }\n            dfs(i, j,\
    \ k - 1);\n        }\n    }\n    return minPath;\n}\n", "    // your code here\n\
    }\n", "    let N = grid.length;\n    let M = grid[0].length;\n    let path = [];\n\
    \    let minPath = [];\n    let min = Number.MAX_SAFE_INTEGER;\n    let visited\
    \ = [];\n    for (let i = 0; i < N; i++) {\n        visited[i] = [];\n       \
    \ for (let j = 0; j < M; j++) {\n            visited[i][j] = false;\n        }\n\
    \    }\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < M; j++)\
    \ {\n            dfs(grid, i, j, k, path, visited);\n            if (path.length\
    \ < min) {\n                min = path.length;\n                minPath = path.slice();\n\
    \            }\n            path = [];\n            for (let i = 0; i < N; i++)\
    \ {\n                for (let j = 0; j < M; j++) {\n                    visited[i][j]\
    \ = false;\n                }\n            }\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath\
    \ = [];\n    let minPathSum = Infinity;\n    let visited = new Set();\n    let\
    \ queue = [];\n    let start = [0, 0];\n    queue.push(start);\n    while (queue.length\
    \ > 0) {\n        let curr = queue.shift();\n        let i = curr[0];\n      \
    \  let j = curr[1];\n        if (visited.has(i + \",\" + j)) {\n            continue;\n\
    \        }\n        visited.add(i + \",\" + j);\n        if (i < 0 || i >= n ||\
    \ j < 0 || j >= m) {\n            continue;\n        }\n        if (i === n -\
    \ 1 && j === m - 1) {\n            if (curr[2].length < minPathSum) {\n      \
    \          minPathSum = curr[2].length;\n                minPath = curr[2];\n\
    \            }\n            continue;\n        }\n        let neighbors = [\n\
    \            [i - 1, j],\n            [i + 1, j],\n            [i, j - 1],\n \
    \           [i, j + 1]\n        ];\n        for (let neighbor of neighbors) {\n\
    \            let newPath = curr[2].slice();\n            newPath.push(grid[neighbor[0]][neighbor[1]]);\n\
    \            queue.push([neighbor[0], neighbor[1], newPath]);\n        }\n   \
    \ }\n    return minPath;\n}\n", "    // your code here\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let dp = new Array(n);\n    for (let i = 0;\
    \ i < n; i++) {\n        dp[i] = new Array(m);\n        for (let j = 0; j < m;\
    \ j++) {\n            dp[i][j] = new Array(k + 1);\n            for (let l = 0;\
    \ l <= k; l++) {\n                dp[i][j][l] = new Array(2);\n              \
    \  dp[i][j][l][0] = new Array(2);\n                dp[i][j][l][1] = new Array(2);\n\
    \            }\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        for\
    \ (let j = 0; j < m; j++) {\n            for (let l = 0; l <= k; l++) {\n    \
    \            dp[i][j][l][0][0] = Infinity;\n                dp[i][j][l][0][1]\
    \ = Infinity;\n                dp[i][j][l][1][0] = Infinity;\n               \
    \ dp[i][j][l][1][1] = Infinity;\n            }\n        }\n    }\n    for (let\
    \ i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dp[i][j][1][0][0]\
    \ = grid[i][j];\n            dp[i][j][1][0][1] = grid[i][j];\n            dp[i][j][1][1][0]\
    \ = grid[i][j];\n            dp[i][j][1][1][1] = grid[i][j];\n        }\n    }\n\
    \    for (let l = 2; l <= k; l++) {\n        for (let i = 0; i < n; i++) {\n \
    \           for (let j = 0; j < m; j++) {\n                if (i > 0) {\n    \
    \                if (dp[i - 1][j][l - 1][0][0] < dp[i][j", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPathSum3\
    \ = Infinity;\n    let minPathSum4 = Infinity;\n    let minPathSum5 = Infinity;\n\
    \    let minPathSum6 = Infinity;\n    let minPathSum7 = Infinity;\n    let minPathSum8\
    \ = Infinity;\n    let minPathSum9 = Infinity;\n    let minPathSum10 = Infinity;\n\
    \    let minPathSum11 = Infinity;\n    let minPathSum12 = Infinity;\n    let minPathSum13\
    \ = Infinity;\n    let minPathSum14 = Infinity;\n    let minPathSum15 = Infinity;\n\
    \    let minPathSum16 = Infinity;\n    let minPathSum17 = Infinity;\n    let minPathSum18\
    \ = Infinity;\n    let minPathSum19 = Infinity;\n    let minPathSum20 = Infinity;\n\
    \    let minPathSum21 = Infinity;\n    let minPathSum22 = Infinity;\n    let minPathSum23\
    \ = Infinity;\n    let minPathSum24 = Infinity;\n    let minPathSum25 = Infinity;\n\
    \    let minPathSum26 = Infinity;\n    let minPathSum27 = Infinity;\n    let minPathSum28\
    \ = Infinity;\n    let minPathSum29 = Infinity;\n    let minPathSum30 = Infinity;\n\
    \    let minPathSum31 = Infinity;\n    let minPathSum32 = Infinity;\n    let minPathSum33\
    \ = Infinity;\n    let minPathSum34 = Infinity;\n    let minPathSum35 = Infinity;\n\
    \    let minPathSum36 = Infinity;\n    let minPathSum37 = Infinity;\n    let minPathSum38\
    \ = Infinity;\n    let minPathSum39 = Infinity;\n    let minPathSum40 = Infinity;\n\
    \    let minPathSum41 = Infinity;\n    let minPathSum42 = Infinity;\n    let minPathSum43\
    \ = Infinity;\n    let minPathSum44 = Infinity;\n    let minPathSum45 = Infinity;\n\
    \    let minPathSum46 = Infinity;\n    let minPathSum47 = Infinity;\n    let minPathSum48\
    \ =", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i] = new\
    \ Array(m).fill(false);\n    }\n    let minPath = new Array(k);\n    let minSum\
    \ = Infinity;\n    let minPathSum = Infinity;\n    let dfs = (i: any, j: any,\
    \ path: any, pathSum: any, pathLen: any) => {\n        if (pathLen === k) {\n\
    \            if (pathSum < minPathSum) {\n                minPathSum = pathSum;\n\
    \                minPath = path.slice();\n            }\n            return;\n\
    \        }\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n\
    \            return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        pathSum += grid[i][j];\n        dfs(i + 1, j, path, pathSum, pathLen\
    \ + 1);\n        dfs(i - 1, j, path, pathSum, pathLen + 1);\n        dfs(i, j\
    \ + 1, path, pathSum, pathLen + 1);\n        dfs(i, j - 1, path, pathSum, pathLen\
    \ + 1);\n        path.pop();\n        pathSum -= grid[i][j];\n        visited[i][j]\
    \ = false;\n    };\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            dfs(i, j, [], 0, 0);\n        }\n    }\n    return\
    \ minPath;\n}\nconsole.log(minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3));\nconsole.log(minPath([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1));", "    let n = grid.length;\n    let m =\
    \ grid[0].length;\n    let visited = new Array(n);\n    for (let i = 0; i < n;\
    \ i++) {\n        visited[i] = new Array(m).fill(false);\n    }\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let minSumPath = [];\n    let dfs = (i:\
    \ any, j: any, path: any, sum: any) => {\n        if (i < 0 || i >= n || j < 0\
    \ || j >= m || visited[i][j] || path.length > k) {\n            return;\n    \
    \    }\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n        visited[i][j]\
    \ = true;\n        if (path.length === k) {\n            if (sum < minSum) {\n\
    \                minSum = sum;\n                minSumPath = path.slice();\n \
    \           } else if (sum === minSum) {\n                if (path.join('') <\
    \ minSumPath.join('')) {\n                    minSumPath = path.slice();\n   \
    \             }\n            }\n        } else {\n            dfs(i - 1, j, path,\
    \ sum);\n            dfs(i + 1, j, path, sum);\n            dfs(i, j - 1, path,\
    \ sum);\n            dfs(i, j + 1, path, sum);\n        }\n        path.pop();\n\
    \        visited[i][j] = false;\n    };\n    for (let i = 0; i < n; i++) {\n \
    \       for (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n       \
    \ }\n    }\n    return minSumPath;\n}\n", "    let n = grid.length;\n    let m\
    \ = grid[0].length;\n    let dp = new Array(n);\n    for (let i = 0; i < n; i++)\
    \ {\n        dp[i] = new Array(m);\n        for (let j = 0; j < m; j++) {\n  \
    \          dp[i][j] = new Array(k + 1);\n            for (let l = 0; l <= k; l++)\
    \ {\n                dp[i][j][l] = new Array(2);\n                dp[i][j][l][0]\
    \ = -1;\n                dp[i][j][l][1] = -1;\n            }\n        }\n    }\n\
    \    let ans = new Array(k);\n    for (let i = 0; i < k; i++) {\n        ans[i]\
    \ = -1;\n    }\n    let min = [1000000000, -1];\n    for (let i = 0; i < n; i++)\
    \ {\n        for (let j = 0; j < m; j++) {\n            let cur = dfs(grid, dp,\
    \ i, j, k, n, m);\n            if (cur[0] < min[0]) {\n                min = cur;\n\
    \            }\n        }\n    }\n    let cur = min[1];\n    for (let i = k -\
    \ 1; i >= 0; i--) {\n        ans[i] = cur % n;\n        cur = cur / n;\n    }\n\
    \    return ans;\n}\n", "    // Your code here\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = Infinity;\n    let minPath = [];\n\
    \    let path = [];\n    let visited = [];\n    for (let i = 0; i < n; i++) {\n\
    \        visited[i] = [];\n        for (let j = 0; j < m; j++) {\n           \
    \ visited[i][j] = false;\n        }\n    }\n    for (let i = 0; i < n; i++) {\n\
    \        for (let j = 0; j < m; j++) {\n            dfs(i, j, k, 0, path, visited);\n\
    \        }\n    }\n    return minPath;\n\n    function dfs(i: any, j: any, k:\
    \ any, sum: any, path: any, visited: any) {\n        if (i < 0 || i >= n || j\
    \ < 0 || j >= m || visited[i][j]) {\n            return;\n        }\n        if\
    \ (sum + grid[i][j] > min) {\n            return;\n        }\n        if (k ===\
    \ 0) {\n            if (sum < min) {\n                min = sum;\n           \
    \     minPath = path.slice();\n            }\n            return;\n        }\n\
    \        path.push(grid[i][j]);\n        visited[i][j] = true;\n        dfs(i\
    \ - 1, j, k - 1, sum + grid[i][j], path, visited);\n        dfs(i + 1, j, k -\
    \ 1, sum + grid[i][j], path, visited);\n        dfs(i, j - 1, k - 1, sum + grid[i][j],\
    \ path, visited);\n        dfs(i, j + 1, k - 1, sum + grid[i][j], path, visited);\n\
    \        visited[i][j] = false;\n        path.pop();\n    }\n}\n", "    let n\
    \ = grid.length;\n    let m = grid[0].length;\n    let min = Number.MAX_SAFE_INTEGER;\n\
    \    let minPath = [];\n    for (let i = 0; i < n; i++) {\n        for (let j\
    \ = 0; j < m; j++) {\n            let path = [];\n            let pathSum = 0;\n\
    \            let visited = [];\n            for (let i = 0; i < n; i++) {\n  \
    \              visited[i] = [];\n                for (let j = 0; j < m; j++) {\n\
    \                    visited[i][j] = false;\n                }\n            }\n\
    \            dfs(i, j, grid, path, pathSum, visited, k);\n            if (pathSum\
    \ < min) {\n                min = pathSum;\n                minPath = path;\n\
    \            }\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let minPath = [];\n    let minPathValue = Infinity;\n\
    \    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = [];\n        for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n\
    \        }\n    }\n    let dfs = (i: any, j: any, path: any, pathValue: any) =>\
    \ {\n        if (path.length === k) {\n            if (pathValue < minPathValue)\
    \ {\n                minPathValue = pathValue;\n                minPath = path;\n\
    \            }\n            return;\n        }\n        if (i < 0 || i >= n ||\
    \ j < 0 || j >= m || visited[i][j]) {\n            return;\n        }\n      \
    \  visited[i][j] = true;\n        path.push(grid[i][j]);\n        pathValue +=\
    \ grid[i][j];\n        dfs(i + 1, j, path, pathValue);\n        dfs(i - 1, j,\
    \ path, pathValue);\n        dfs(i, j + 1, path, pathValue);\n        dfs(i, j\
    \ - 1, path, pathValue);\n        path.pop();\n        pathValue -= grid[i][j];\n\
    \        visited[i][j] = false;\n    }\n    for (let i = 0; i < n; i++) {\n  \
    \      for (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n        }\n\
    \    }\n    return minPath;\n}\n", "    // your code here\n}\n", "    let n =\
    \ grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = new Array(k);\n    let minPathSum = Infinity;\n    let\
    \ minPathSumIndex = -1;\n    let minPathSumIndex2 = -1;\n    let minPathSumIndex3\
    \ = -1;\n    let minPathSumIndex4 = -1;\n    let minPathSumIndex5 = -1;\n    let\
    \ minPathSumIndex6 = -1;\n    let minPathSumIndex7 = -1;\n    let minPathSumIndex8\
    \ = -1;\n    let minPathSumIndex9 = -1;\n    let minPathSumIndex10 = -1;\n   \
    \ let minPathSumIndex11 = -1;\n    let minPathSumIndex12 = -1;\n    let minPathSumIndex13\
    \ = -1;\n    let minPathSumIndex14 = -1;\n    let minPathSumIndex15 = -1;\n  \
    \  let minPathSumIndex16 = -1;\n    let minPathSumIndex17 = -1;\n    let minPathSumIndex18\
    \ = -1;\n    let minPathSumIndex19 = -1;\n    let minPathSumIndex20 = -1;\n  \
    \  let minPathSumIndex21 = -1;\n    let minPathSumIndex22 = -1;\n    let minPathSumIndex23\
    \ = -1;\n    let minPathSumIndex24 = -1;\n    let minPathSumIndex25 = -1;\n  \
    \  let minPathSumIndex26 = -1;\n    let minPathSumIndex27 = -1;\n    let minPathSumIndex28\
    \ = -1;\n    let minPathSumIndex29 = -1;\n    let minPathSumIndex30 = -1;\n  \
    \  let minPathSumIndex31 = -1;\n    let minPathSumIndex32 = -1;\n    let minPathSumIndex33\
    \ = -1;\n    let minPathSumIndex34 = -1;\n    let minPathSumIndex35 = -1;\n  \
    \  let minPathSumIndex36", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minPathSum\
    \ = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let\
    \ minPathSum3 = Infinity;\n    let minPath3 = [];\n    let minPathSum4 = Infinity;\n\
    \    let minPath4 = [];\n    let minPathSum5 = Infinity;\n    let minPath5 = [];\n\
    \    let minPathSum6 = Infinity;\n    let minPath6 = [];\n    let minPathSum7\
    \ = Infinity;\n    let minPath7 = [];\n    let minPathSum8 = Infinity;\n    let\
    \ minPath8 = [];\n    let minPathSum9 = Infinity;\n    let minPath9 = [];\n  \
    \  let minPathSum10 = Infinity;\n    let minPath10 = [];\n    let minPathSum11\
    \ = Infinity;\n    let minPath11 = [];\n    let minPathSum12 = Infinity;\n   \
    \ let minPath12 = [];\n    let minPathSum13 = Infinity;\n    let minPath13 = [];\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minPathSum15\
    \ = Infinity;\n    let minPath15 = [];\n    let minPathSum16 = Infinity;\n   \
    \ let minPath16 = [];\n    let minPathSum17 = Infinity;\n    let minPath17 = [];\n\
    \    let minPathSum18 = Infinity;\n    let minPath18 = [];\n    let minPathSum19\
    \ = Infinity;\n    let minPath19 = [];\n    let minPathSum20 = Infinity;\n   \
    \ let minPath20 = [];\n    let minPathSum21 = Infinity;\n    let minPath21 = [];\n\
    \    let minPathSum22 = Infinity;\n    let minPath22 = [];\n    let minPathSum23\
    \ = Infinity;\n    let minPath23 = [];\n    let minPathSum24 = Infinity;\n   \
    \ let minPath24 = [];\n    let minPathSum25 = Infinity;\n    let minPath25 =",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2\
    \ = [];\n    let minPath3 = [];\n    let minPathSum3 = Infinity;\n    let minPathSum4\
    \ = Infinity;\n    let minPath4 = [];\n    let minPath5 = [];\n    let minPathSum5\
    \ = Infinity;\n    let minPathSum6 = Infinity;\n    let minPath6 = [];\n    let\
    \ minPath7 = [];\n    let minPathSum7 = Infinity;\n    let minPathSum8 = Infinity;\n\
    \    let minPath8 = [];\n    let minPath9 = [];\n    let minPathSum9 = Infinity;\n\
    \    let minPathSum10 = Infinity;\n    let minPath10 = [];\n    let minPath11\
    \ = [];\n    let minPathSum11 = Infinity;\n    let minPathSum12 = Infinity;\n\
    \    let minPath12 = [];\n    let minPath13 = [];\n    let minPathSum13 = Infinity;\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minPath15\
    \ = [];\n    let minPathSum15 = Infinity;\n    let minPathSum16 = Infinity;\n\
    \    let minPath16 = [];\n    let minPath17 = [];\n    let minPathSum17 = Infinity;\n\
    \    let minPathSum18 = Infinity;\n    let minPath18 = [];\n    let minPath19\
    \ = [];\n    let minPathSum19 = Infinity;\n    let minPathSum20 = Infinity;\n\
    \    let minPath20 = [];\n    let minPath21 = [];\n    let minPathSum21 = Infinity;\n\
    \    let minPathSum22 = Infinity;\n    let minPath22 = [];\n    let minPath23\
    \ = [];\n    let minPathSum23 = Infinity;\n    let minPathSum24 = Infinity;\n\
    \    let minPath24 = [];\n    let minPath25 = [];\n    let minPathSum25 = Infinity;\n\
    \    let minPathSum26 = Infinity;\n    let minPath26 = [];\n    let minPath27\
    \ = [];\n    let minPathSum27 = Infinity;\n    let minPathSum28 =", "    // your\
    \ code goes here\n    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPaths = [];\n    let minPathsSum = [];\n    let minPathsSumIndex =\
    \ [];\n    let minPathsSumIndex2 = [];\n    let minPathsSumIndex3 = [];\n    let\
    \ minPathsSumIndex4 = [];\n    let minPathsSumIndex5 = [];\n    let minPathsSumIndex6\
    \ = [];\n    let minPathsSumIndex7 = [];\n    let minPathsSumIndex8 = [];\n  \
    \  let minPathsSumIndex9 = [];\n    let minPathsSumIndex10 = [];\n    let minPathsSumIndex11\
    \ = [];\n    let minPathsSumIndex12 = [];\n    let minPathsSumIndex13 = [];\n\
    \    let minPathsSumIndex14 = [];\n    let minPathsSumIndex15 = [];\n    let minPathsSumIndex16\
    \ = [];\n    let minPathsSumIndex17 = [];\n    let minPathsSumIndex18 = [];\n\
    \    let minPathsSumIndex19 = [];\n    let minPathsSumIndex20 = [];\n    let minPathsSumIndex21\
    \ = [];\n    let minPathsSumIndex22 = [];\n    let minPathsSumIndex23 = [];\n\
    \    let minPathsSumIndex24 = [];\n    let minPathsSumIndex25 = [];\n    let minPathsSumIndex26\
    \ = [];\n    let minPathsSumIndex27 = [];\n    let minPathsSumIndex28 = [];\n\
    \    let minPathsSumIndex29 = [];\n    let minPathsSumIndex30 = [];\n    let minPathsSumIndex31\
    \ = [];\n    let minPathsSumIndex32 = [];\n    let minPathsSumIndex33 = [];\n\
    \    let minPathsSumIndex34 = [];\n    let minPathsSumIndex35 = [];\n    let minPathsSumIndex36\
    \ = [];\n    let minPathsSumIndex37 = [];\n    let minPathsSumIndex38 = [];\n\
    \    let minPathsSumIndex39 = [];\n    let minPathsSumIndex40 = [];\n    let minPath",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let min = [];\n    let\
    \ min_sum = Infinity;\n    let min_path = [];\n    let path = [];\n    let sum\
    \ = 0;\n    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited.push([]);\n\
    \        for (let j = 0; j < m; j++) {\n            visited[i].push(false);\n\
    \        }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            path = [];\n            sum = 0;\n            for\
    \ (let i = 0; i < n; i++) {\n                for (let j = 0; j < m; j++) {\n \
    \                   visited[i][j] = false;\n                }\n            }\n\
    \            dfs(grid, i, j, k, path, sum, visited);\n            if (sum < min_sum)\
    \ {\n                min_sum = sum;\n                min_path = path;\n      \
    \      }\n        }\n    }\n    return min_path;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let dp = new Array(n);\n    for (let i = 0;\
    \ i < n; i++) {\n        dp[i] = new Array(m);\n        for (let j = 0; j < m;\
    \ j++) {\n            dp[i][j] = new Array(k + 1);\n            for (let l = 0;\
    \ l <= k; l++) {\n                dp[i][j][l] = new Array(2);\n              \
    \  dp[i][j][l][0] = Number.MAX_SAFE_INTEGER;\n                dp[i][j][l][1] =\
    \ [];\n            }\n        }\n    }\n    let ans = [];\n    for (let i = 0;\
    \ i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dp[i][j][1][0]\
    \ = grid[i][j];\n            dp[i][j][1][1] = [grid[i][j]];\n            if (i\
    \ > 0) {\n                if (dp[i - 1][j][1][0] < dp[i][j][1][0]) {\n       \
    \             dp[i][j][1][0] = dp[i - 1][j][1][0];\n                    dp[i][j][1][1]\
    \ = dp[i - 1][j][1][1];\n                } else if (dp[i - 1][j][1][0] == dp[i][j][1][0])\
    \ {\n                    if (dp[i - 1][j][1][1] < dp[i][j][1][1]) {\n        \
    \                dp[i][j][1][1] = dp[i - 1][j][1][1];\n                    }\n\
    \                }\n            }\n            if (j > 0) {\n                if\
    \ (dp[i][j - 1][1][0] < dp[i][j][1][0]) {\n                    dp[i][j][1][0]\
    \ = dp[i][j - 1][1][0];\n                    dp", "    let N = grid.length;\n\
    \    let minPath = [];\n    let minPathSum = Infinity;\n    let visited = [];\n\
    \    for (let i = 0; i < N; i++) {\n        visited.push([]);\n        for (let\
    \ j = 0; j < N; j++) {\n            visited[i].push(false);\n        }\n    }\n\
    \    let dfs = (i: any, j: any, path: any, pathSum: any) => {\n        if (i <\
    \ 0 || i >= N || j < 0 || j >= N || visited[i][j]) {\n            return;\n  \
    \      }\n        path.push(grid[i][j]);\n        pathSum += grid[i][j];\n   \
    \     visited[i][j] = true;\n        if (path.length === k) {\n            if\
    \ (pathSum < minPathSum) {\n                minPathSum = pathSum;\n          \
    \      minPath = path.slice();\n            }\n            else if (pathSum ===\
    \ minPathSum) {\n                for (let i = 0; i < k; i++) {\n             \
    \       if (path[i] < minPath[i]) {\n                        minPath = path.slice();\n\
    \                        break;\n                    }\n                    else\
    \ if (path[i] > minPath[i]) {\n                        break;\n              \
    \      }\n                }\n            }\n        }\n        else {\n      \
    \      dfs(i - 1, j, path, pathSum);\n            dfs(i + 1, j, path, pathSum);\n\
    \            dfs(i, j - 1, path, pathSum);\n            dfs(i, j + 1, path, pathSum);\n\
    \        }\n        path.pop();\n        pathSum -= grid[i][j];\n        visited[i][j]\
    \ = false;\n    };\n    for (let i = 0; i < N; i++) {\n        for (let j = 0;\
    \ j < N; j++) {\n            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i] = new\
    \ Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let dfs = (i: any, j: any, path: any, sum:\
    \ any) => {\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j] ||\
    \ path.length > k) {\n            return;\n        }\n        visited[i][j] =\
    \ true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n        if\
    \ (path.length === k) {\n            if (sum < minPathSum) {\n               \
    \ minPathSum = sum;\n                minPath = path.slice();\n            } else\
    \ if (sum === minPathSum) {\n                if (path.join('') < minPath.join(''))\
    \ {\n                    minPath = path.slice();\n                }\n        \
    \    }\n        } else {\n            dfs(i + 1, j, path, sum);\n            dfs(i\
    \ - 1, j, path, sum);\n            dfs(i, j + 1, path, sum);\n            dfs(i,\
    \ j - 1, path, sum);\n        }\n        path.pop();\n        visited[i][j] =\
    \ false;\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j\
    \ < m; j++) {\n            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let dp = new\
    \ Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = new Array(m);\n\
    \        for (let j = 0; j < m; j++) {\n            dp[i][j] = new Array(k + 1);\n\
    \            for (let l = 0; l <= k; l++) {\n                dp[i][j][l] = new\
    \ Array(2);\n                dp[i][j][l][0] = [];\n                dp[i][j][l][1]\
    \ = Infinity;\n            }\n        }\n    }\n    for (let i = 0; i < n; i++)\
    \ {\n        for (let j = 0; j < m; j++) {\n            dp[i][j][1][0] = [grid[i][j]];\n\
    \            dp[i][j][1][1] = grid[i][j];\n        }\n    }\n    for (let l =\
    \ 2; l <= k; l++) {\n        for (let i = 0; i < n; i++) {\n            for (let\
    \ j = 0; j < m; j++) {\n                if (i > 0) {\n                    let\
    \ newPath = dp[i - 1][j][l - 1][0].slice();\n                    newPath.push(grid[i][j]);\n\
    \                    let newSum = dp[i - 1][j][l - 1][1] + grid[i][j];\n     \
    \               if (newSum < dp[i][j][l][1] ||\n                        (newSum\
    \ == dp[i][j][l][1] && newPath < dp[i][j][l][0])) {\n                        dp[i][j][l][0]\
    \ = newPath;\n                        dp[i][j][l][1] = newSum;\n             \
    \       }\n                }\n                if (j > 0) {\n                 \
    \   let newPath = dp[i][j - 1][l - 1][0].slice();\n                    newPath.push(grid[i][j]);\n\
    \                    let newSum = d", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited.push([]);\n\
    \        for (let j = 0; j < m; j++) {\n            visited[i].push(false);\n\
    \        }\n    }\n    let minPath = [];\n    let minPathSum = Infinity;\n   \
    \ for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n     \
    \       let currPath = [];\n            let currPathSum = 0;\n            dfs(i,\
    \ j, k, currPath, currPathSum);\n        }\n    }\n    return minPath;\n\n   \
    \ function dfs(i: number, j: number, k: number, currPath: any, currPathSum: number)\
    \ {\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n    \
    \        return;\n        }\n        if (k === 0) {\n            if (currPathSum\
    \ < minPathSum) {\n                minPathSum = currPathSum;\n               \
    \ minPath = currPath.slice();\n            } else if (currPathSum === minPathSum)\
    \ {\n                if (currPath.length > 0 && minPath.length > 0 && currPath[0]\
    \ < minPath[0]) {\n                    minPath = currPath.slice();\n         \
    \       }\n            }\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        currPath.push(grid[i][j]);\n        currPathSum += grid[i][j];\n\
    \        dfs(i - 1, j, k - 1, currPath, currPathSum);\n        dfs(i + 1, j, k\
    \ - 1, currPath, currPathSum);\n        dfs(i, j - 1, k - 1, currPath, currPathSum);\n\
    \        dfs(i, j + 1, k - 1, currPath, currPathSum);\n        currPath.pop();\n\
    \        currPathSum -=", "    // your code here\n}\n", "    // Your code here\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i] = new\
    \ Array(m).fill(false);\n    }\n    let minPath = new Array(k);\n    let minPathSum\
    \ = Infinity;\n    let minPathSumIndex = -1;\n    let minPathSumIndex2 = -1;\n\
    \    let minPathSumIndex3 = -1;\n    let minPathSumIndex4 = -1;\n    let minPathSumIndex5\
    \ = -1;\n    let minPathSumIndex6 = -1;\n    let minPathSumIndex7 = -1;\n    let\
    \ minPathSumIndex8 = -1;\n    let minPathSumIndex9 = -1;\n    let minPathSumIndex10\
    \ = -1;\n    let minPathSumIndex11 = -1;\n    let minPathSumIndex12 = -1;\n  \
    \  let minPathSumIndex13 = -1;\n    let minPathSumIndex14 = -1;\n    let minPathSumIndex15\
    \ = -1;\n    let minPathSumIndex16 = -1;\n    let minPathSumIndex17 = -1;\n  \
    \  let minPathSumIndex18 = -1;\n    let minPathSumIndex19 = -1;\n    let minPathSumIndex20\
    \ = -1;\n    let minPathSumIndex21 = -1;\n    let minPathSumIndex22 = -1;\n  \
    \  let minPathSumIndex23 = -1;\n    let minPathSumIndex24 = -1;\n    let minPathSumIndex25\
    \ = -1;\n    let minPathSumIndex26 = -1;\n    let minPathSumIndex27 = -1;\n  \
    \  let minPathSumIndex28 = -1;\n    let minPathSumIndex29 = -1;\n    let minPathSumIndex30\
    \ = -1;\n    let minPathSumIndex31 = -1;\n    let minPathSumIndex32 = -1;\n  \
    \  let minPathSumIndex33 = -1;\n    let minPathSumIndex34 = -1;\n    let minPathSumIndex35\
    \ = -1;\n    let minPathSumIndex36", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minPathSum\
    \ = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i < n; i++) {\n        for (let\
    \ j = 0; j < m; j++) {\n            let path = [];\n            let pathSum =\
    \ 0;\n            dfs(i, j, k, path, pathSum);\n        }\n    }\n    return minPath;\n\
    \n    function dfs(i: number, j: number, k: number, path: number[], pathSum: number)\
    \ {\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || path.length\
    \ > k) {\n            return;\n        }\n        path.push(grid[i][j]);\n   \
    \     pathSum += grid[i][j];\n        visited[i][j] = true;\n        if (path.length\
    \ === k) {\n            if (pathSum < minPathSum) {\n                minPathSum\
    \ = pathSum;\n                minPath = path.slice();\n            } else if (pathSum\
    \ === minPathSum) {\n                if (path < minPath) {\n                 \
    \   minPath = path.slice();\n                }\n            }\n        } else\
    \ {\n            dfs(i + 1, j, k, path, pathSum);\n            dfs(i - 1, j, k,\
    \ path, pathSum);\n            dfs(i, j + 1, k, path, pathSum);\n            dfs(i,\
    \ j - 1, k, path, pathSum);\n        }\n        visited[i][j] = false;\n     \
    \   path.pop();\n    }\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = new Array(k);\n    let\
    \ minPathSum = Infinity;\n    let minPathSumIndex = -1;\n    let minPathSumIndex2\
    \ = -1;\n    let minPathSumIndex3 = -1;\n    let minPathSumIndex4 = -1;\n    let\
    \ minPathSumIndex5 = -1;\n    let minPathSumIndex6 = -1;\n    let minPathSumIndex7\
    \ = -1;\n    let minPathSumIndex8 = -1;\n    let minPathSumIndex9 = -1;\n    let\
    \ minPathSumIndex10 = -1;\n    let minPathSumIndex11 = -1;\n    let minPathSumIndex12\
    \ = -1;\n    let minPathSumIndex13 = -1;\n    let minPathSumIndex14 = -1;\n  \
    \  let minPathSumIndex15 = -1;\n    let minPathSumIndex16 = -1;\n    let minPathSumIndex17\
    \ = -1;\n    let minPathSumIndex18 = -1;\n    let minPathSumIndex19 = -1;\n  \
    \  let minPathSumIndex20 = -1;\n    let minPathSumIndex21 = -1;\n    let minPathSumIndex22\
    \ = -1;\n    let minPathSumIndex23 = -1;\n    let minPathSumIndex24 = -1;\n  \
    \  let minPathSumIndex25 = -1;\n    let minPathSumIndex26 = -1;\n    let minPathSumIndex27\
    \ = -1;\n    let minPathSumIndex28 = -1;\n    let minPathSumIndex29 = -1;\n  \
    \  let minPathSumIndex30 = -1;\n    let minPathSumIndex31 = -1;\n    let minPathSumIndex32\
    \ = -1;\n    let minPathSumIndex33 = -1;\n    let minPathSumIndex34 = -1;\n  \
    \  let minPathSumIndex35 = -1;\n    let minPathSumIndex36", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for (let i\
    \ = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n    }\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    for (let i = 0; i < n;\
    \ i++) {\n        for (let j = 0; j < m; j++) {\n            let path = [];\n\
    \            let sum = 0;\n            dfs(i, j, k, path, sum);\n        }\n \
    \   }\n    return minPath;\n\n    function dfs(i: number, j: number, k: number,\
    \ path: any, sum: number) {\n        if (k === 0) {\n            if (sum < minSum)\
    \ {\n                minSum = sum;\n                minPath = path.slice();\n\
    \            }\n            return;\n        }\n        if (i < 0 || i >= n ||\
    \ j < 0 || j >= m || visited[i][j]) {\n            return;\n        }\n      \
    \  visited[i][j] = true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n\
    \        dfs(i + 1, j, k - 1, path, sum);\n        dfs(i - 1, j, k - 1, path,\
    \ sum);\n        dfs(i, j + 1, k - 1, path, sum);\n        dfs(i, j - 1, k - 1,\
    \ path, sum);\n        path.pop();\n        visited[i][j] = false;\n    }\n}\n",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n\
    \    let minSum = Infinity;\n    let minPaths = [];\n    let visited = [];\n \
    \   for (let i = 0; i < n; i++) {\n        visited[i] = [];\n        for (let\
    \ j = 0; j < m; j++) {\n            visited[i][j] = false;\n        }\n    }\n\
    \    let dfs = (i: any, j: any, path: any, sum: any) => {\n        if (i < 0 ||\
    \ i >= n || j < 0 || j >= m || visited[i][j]) {\n            return;\n       \
    \ }\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n        visited[i][j]\
    \ = true;\n        if (path.length === k) {\n            if (sum < minSum) {\n\
    \                minSum = sum;\n                minPaths = [];\n             \
    \   minPaths.push(path.slice());\n            } else if (sum === minSum) {\n \
    \               minPaths.push(path.slice());\n            }\n        } else {\n\
    \            dfs(i + 1, j, path, sum);\n            dfs(i - 1, j, path, sum);\n\
    \            dfs(i, j + 1, path, sum);\n            dfs(i, j - 1, path, sum);\n\
    \        }\n        path.pop();\n        sum -= grid[i][j];\n        visited[i][j]\
    \ = false;\n    };\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            dfs(i, j, [], 0);\n        }\n    }\n    for (let\
    \ i = 0; i < minPaths.length; i++) {\n        if (minPaths[i].length < minPath.length)\
    \ {\n            minPath = minPaths[i];\n        } else if (minPaths[i].length\
    \ === minPath.length) {\n            for (let j = 0; j < minPaths[i].length; j++)\
    \ {", "    const n = grid.length;\n    const m = grid[0].length;\n    const visited\
    \ = new Array(n).fill(0).map(() => new Array(m).fill(false));\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    function dfs(i: number, j: number, path:\
    \ any[], sum: number) {\n        if (sum > minSum) return;\n        if (path.length\
    \ === k) {\n            if (sum < minSum) {\n                minSum = sum;\n \
    \               minPath = path;\n            }\n            return;\n        }\n\
    \        visited[i][j] = true;\n        if (i > 0 && !visited[i - 1][j]) {\n \
    \           dfs(i - 1, j, path.concat(grid[i - 1][j]), sum + grid[i - 1][j]);\n\
    \        }\n        if (i < n - 1 && !visited[i + 1][j]) {\n            dfs(i\
    \ + 1, j, path.concat(grid[i + 1][j]), sum + grid[i + 1][j]);\n        }\n   \
    \     if (j > 0 && !visited[i][j - 1]) {\n            dfs(i, j - 1, path.concat(grid[i][j\
    \ - 1]), sum + grid[i][j - 1]);\n        }\n        if (j < m - 1 && !visited[i][j\
    \ + 1]) {\n            dfs(i, j + 1, path.concat(grid[i][j + 1]), sum + grid[i][j\
    \ + 1]);\n        }\n        visited[i][j] = false;\n    }\n    for (let i = 0;\
    \ i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dfs(i, j,\
    \ [grid[i][j]], grid[i][j]);\n        }\n    }\n    return minPath;\n}\n", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let dp = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        dp[i] = new Array(m);\n        for\
    \ (let j = 0; j < m; j++) {\n            dp[i][j] = new Array(k + 1);\n      \
    \      for (let l = 0; l <= k; l++) {\n                dp[i][j][l] = new Array(2);\n\
    \                dp[i][j][l][0] = -1;\n                dp[i][j][l][1] = -1;\n\
    \            }\n        }\n    }\n    let ans = new Array(k);\n    let res = rec(0,\
    \ 0, k, grid, dp);\n    for (let i = 0; i < k; i++) {\n        ans[i] = res[0][i];\n\
    \    }\n    return ans;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited.push([]);\n\
    \        for (let j = 0; j < m; j++) {\n            visited[i].push(false);\n\
    \        }\n    }\n    let minPath = [];\n    for (let i = 0; i < n; i++) {\n\
    \        for (let j = 0; j < m; j++) {\n            let path = [];\n         \
    \   let min = [];\n            dfs(grid, i, j, k, path, min, visited);\n     \
    \       if (minPath.length === 0 || minPath.length > min.length) {\n         \
    \       minPath = min;\n            }\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let dp = new\
    \ Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = new Array(m);\n\
    \        for (let j = 0; j < m; j++) {\n            dp[i][j] = new Array(k + 1);\n\
    \            for (let l = 0; l <= k; l++) {\n                dp[i][j][l] = new\
    \ Array(2);\n                dp[i][j][l][0] = -1;\n                dp[i][j][l][1]\
    \ = -1;\n            }\n        }\n    }\n    let ans = new Array(k);\n    let\
    \ min = Number.MAX_SAFE_INTEGER;\n    let min_i = -1;\n    let min_j = -1;\n \
    \   for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n   \
    \         let tmp = solve(i, j, k, n, m, grid, dp);\n            if (tmp < min)\
    \ {\n                min = tmp;\n                min_i = i;\n                min_j\
    \ = j;\n            }\n        }\n    }\n    for (let i = 0; i < k; i++) {\n \
    \       ans[i] = grid[min_i][min_j];\n        let tmp = dp[min_i][min_j][k - i][0];\n\
    \        min_j = dp[min_i][min_j][k - i][1];\n        min_i = tmp;\n    }\n  \
    \  return ans;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let min = Infinity;\n    let minPath = [];\n    let visited = [];\n    for\
    \ (let i = 0; i < n; i++) {\n        visited[i] = [];\n        for (let j = 0;\
    \ j < m; j++) {\n            visited[i][j] = false;\n        }\n    }\n    let\
    \ dfs = (i: any, j: any, path: any, sum: any) => {\n        if (i < 0 || i >=\
    \ n || j < 0 || j >= m || visited[i][j]) {\n            return;\n        }\n \
    \       path.push(grid[i][j]);\n        sum += grid[i][j];\n        if (path.length\
    \ === k) {\n            if (sum < min) {\n                min = sum;\n       \
    \         minPath = path.slice();\n            }\n            path.pop();\n  \
    \          return;\n        }\n        visited[i][j] = true;\n        dfs(i +\
    \ 1, j, path, sum);\n        dfs(i - 1, j, path, sum);\n        dfs(i, j + 1,\
    \ path, sum);\n        dfs(i, j - 1, path, sum);\n        visited[i][j] = false;\n\
    \        path.pop();\n    }\n    for (let i = 0; i < n; i++) {\n        for (let\
    \ j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n        }\n    }\n    return\
    \ minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n   \
    \ let visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    let minSumPath = [];\n    let dfs = (i: any, j: any, path: any,\
    \ sum: any) => {\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]\
    \ || path.length > k) {\n            return;\n        }\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        visited[i][j] = true;\n        if (path.length\
    \ === k) {\n            if (sum < minSum) {\n                minSum = sum;\n \
    \               minSumPath = path.slice();\n            } else if (sum === minSum)\
    \ {\n                if (path < minPath) {\n                    minPath = path.slice();\n\
    \                }\n            }\n        } else {\n            dfs(i - 1, j,\
    \ path, sum);\n            dfs(i + 1, j, path, sum);\n            dfs(i, j - 1,\
    \ path, sum);\n            dfs(i, j + 1, path, sum);\n        }\n        path.pop();\n\
    \        visited[i][j] = false;\n    }\n    for (let i = 0; i < n; i++) {\n  \
    \      for (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n        }\n\
    \    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    let minSumPath = [];\n    let dfs = (i: any, j: any, path: any,\
    \ sum: any) => {\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]\
    \ || path.length > k) {\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n      \
    \  if (path.length === k) {\n            if (sum < minSum) {\n               \
    \ minSum = sum;\n                minSumPath = path.slice();\n            } else\
    \ if (sum === minSum) {\n                if (path.join('') < minSumPath.join(''))\
    \ {\n                    minSumPath = path.slice();\n                }\n     \
    \       }\n        } else {\n            dfs(i - 1, j, path, sum);\n         \
    \   dfs(i + 1, j, path, sum);\n            dfs(i, j - 1, path, sum);\n       \
    \     dfs(i, j + 1, path, sum);\n        }\n        path.pop();\n        visited[i][j]\
    \ = false;\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            dfs(i, j, [], 0);\n        }\n    }\n    return minSumPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath:\
    \ any = [];\n    let minPathValue: any = [];\n    let minPathIndex: any = [];\n\
    \    let minPathValueIndex: any = [];\n    let minPathValueIndexIndex: any = [];\n\
    \    let minPathValueIndexIndexIndex: any = [];\n    let minPathValueIndexIndexIndexIndex:\
    \ any = [];\n    let minPathValueIndexIndexIndexIndexIndex: any = [];\n    let\
    \ minPathValueIndexIndexIndexIndexIndexIndex: any = [];\n    let minPathValueIndexIndexIndexIndexIndexIndexIndex:\
    \ any = [];\n    let minPathValueIndexIndexIndexIndexIndexIndexIndexIndex: any\
    \ = [];\n    let minPathValueIndexIndexIndexIndexIndexIndexIndexIndexIndex: any\
    \ = [];\n    let minPathValueIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ any = [];\n    let minPathValueIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ any = [];\n    let minPathValueIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ any = [];\n    let minPathValueIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ any = [];\n    let minPathValueIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ any = [];\n    let minPathValueIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ any = [];\n    let minPathValueIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ any = [];\n    let minPathValueIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ any = [];\n    let minPathValueIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ any = [];\n    let minPathValueIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ any = [];\n    let minPathValueIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ any = [];\n    let minPathValueIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ any = [];\n    let minPathValueIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minPathSum = Number.MAX_SAFE_INTEGER;\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          let path = [];\n            let pathSum = 0;\n            visited[i][j]\
    \ = true;\n            path.push(grid[i][j]);\n            pathSum += grid[i][j];\n\
    \            dfs(grid, i, j, k - 1, visited, path, pathSum);\n            visited[i][j]\
    \ = false;\n        }\n    }\n    return minPath;\n\n    function dfs(grid: any,\
    \ i: any, j: any, k: any, visited: any, path: any, pathSum: any) {\n        if\
    \ (k === 0) {\n            if (pathSum < minPathSum) {\n                minPathSum\
    \ = pathSum;\n                minPath = path.slice();\n            } else if (pathSum\
    \ === minPathSum) {\n                if (path < minPath) {\n                 \
    \   minPath = path.slice();\n                }\n            }\n            return;\n\
    \        }\n        if (i > 0 && !visited[i - 1][j]) {\n            visited[i\
    \ - 1][j] = true;\n            path.push(grid[i - 1][j]);\n            pathSum\
    \ += grid[i - 1][j];\n            dfs(grid, i - 1, j, k - 1, visited, path, pathSum);\n\
    \            path.pop();\n            pathSum -= grid[i - 1][j];\n           \
    \ visited[i - 1][j] = false;\n        }\n        if (i < n - 1 && !visited[i +\
    \ 1][j]) {\n            visited[i + 1][j] = true;\n            path.push(grid[i\
    \ + 1][j]);\n            pathSum += grid[i + 1", "    let n = grid.length;\n \
    \   let m = grid[0].length;\n    let dp = new Array(n);\n    for (let i = 0; i\
    \ < n; i++) {\n        dp[i] = new Array(m);\n        for (let j = 0; j < m; j++)\
    \ {\n            dp[i][j] = new Array(k + 1);\n            for (let l = 0; l <=\
    \ k; l++) {\n                dp[i][j][l] = new Array(2);\n                dp[i][j][l][0]\
    \ = -1;\n                dp[i][j][l][1] = -1;\n            }\n        }\n    }\n\
    \    let res = new Array(k);\n    for (let i = 0; i < k; i++) {\n        res[i]\
    \ = -1;\n    }\n    let ans = -1;\n    for (let i = 0; i < n; i++) {\n       \
    \ for (let j = 0; j < m; j++) {\n            let tmp = solve(i, j, k, grid, dp);\n\
    \            if (ans == -1 || tmp < ans) {\n                ans = tmp;\n     \
    \           for (let l = 0; l < k; l++) {\n                    res[l] = dp[i][j][k][1][l];\n\
    \                }\n            }\n        }\n    }\n    return res;\n}\n", " \
    \   // Your code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let path = [];\n    let sum = 0;\n    let pathSum = 0;\n    let visited =\
    \ [];\n    for (let i = 0; i < n; i++) {\n        visited[i] = [];\n        for\
    \ (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n        }\n \
    \   }\n    function dfs(i: any, j: any, k: any) {\n        if (k === 0) {\n  \
    \          if (pathSum < minPathSum) {\n                minPathSum = pathSum;\n\
    \                minPath = path.slice();\n            } else if (pathSum === minPathSum)\
    \ {\n                for (let i = 0; i < path.length; i++) {\n               \
    \     if (path[i] < minPath[i]) {\n                        minPath = path.slice();\n\
    \                        break;\n                    } else if (path[i] > minPath[i])\
    \ {\n                        break;\n                    }\n                }\n\
    \            }\n            return;\n        }\n        if (i < 0 || i >= n ||\
    \ j < 0 || j >= m || visited[i][j]) {\n            return;\n        }\n      \
    \  visited[i][j] = true;\n        path.push(grid[i][j]);\n        pathSum += grid[i][j];\n\
    \        dfs(i - 1, j, k - 1);\n        dfs(i + 1, j, k - 1);\n        dfs(i,\
    \ j - 1, k - 1);\n        dfs(i, j + 1, k - 1);\n        path.pop();\n       \
    \ pathSum -= grid[i][j];\n        visited[i][j] = false;\n    }\n    for (let\
    \ i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dfs(i,\
    \ j, k);\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min_path = [];\n    let min_sum = Infinity;\n\
    \    let min_sum_path = [];\n    let min_sum_path_set = new Set();\n    let min_sum_path_set_size\
    \ = 0;\n    let min_sum_path_set_size_prev = 0;\n    let min_sum_path_set_size_prev_prev\
    \ = 0;\n    let min_sum_path_set_size_prev_prev_prev = 0;\n    let min_sum_path_set_size_prev_prev_prev_prev\
    \ = 0;\n    let min_sum_path_set_size_prev_prev_prev_prev_prev = 0;\n    let min_sum_path_set_size_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    let min_sum_path_set_size_prev_prev_prev_prev_prev_prev_prev = 0;\n\
    \    let min_sum_path_set_size_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n\
    \    let min_sum_path_set_size_prev_prev_prev_prev_prev_prev_prev_prev_prev =\
    \ 0;\n    let min_sum_path_set_size_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    let min_sum_path_set_size_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    let min_sum_path_set_size_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    let min_sum_path_set_size_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    let min_sum_path_set_size_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    let min_sum_path_set_size_prev_prev", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = [];\n    let min_sum = Infinity;\n\
    \    let min_path = [];\n    let dfs = (x: any, y: any, sum: any, path: any) =>\
    \ {\n        if (sum > min_sum) return;\n        if (path.length === k) {\n  \
    \          if (sum < min_sum) {\n                min_sum = sum;\n            \
    \    min_path = path;\n            }\n            return;\n        }\n       \
    \ if (x > 0) dfs(x - 1, y, sum + grid[x - 1][y], path.concat(grid[x - 1][y]));\n\
    \        if (x < n - 1) dfs(x + 1, y, sum + grid[x + 1][y], path.concat(grid[x\
    \ + 1][y]));\n        if (y > 0) dfs(x, y - 1, sum + grid[x][y - 1], path.concat(grid[x][y\
    \ - 1]));\n        if (y < m - 1) dfs(x, y + 1, sum + grid[x][y + 1], path.concat(grid[x][y\
    \ + 1]));\n    };\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            dfs(i, j, grid[i][j], [grid[i][j]]);\n        }\n\
    \    }\n    return min_path;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPaths = [];\n    let minPathsSum = [];\n    let minPathsSum2 = [];\n\
    \    let minPaths2 = [];\n    let minPathsSum3 = [];\n    let minPaths3 = [];\n\
    \    let minPathsSum4 = [];\n    let minPaths4 = [];\n    let minPathsSum5 = [];\n\
    \    let minPaths5 = [];\n    let minPathsSum6 = [];\n    let minPaths6 = [];\n\
    \    let minPathsSum7 = [];\n    let minPaths7 = [];\n    let minPathsSum8 = [];\n\
    \    let minPaths8 = [];\n    let minPathsSum9 = [];\n    let minPaths9 = [];\n\
    \    let minPathsSum10 = [];\n    let minPaths10 = [];\n    let minPathsSum11\
    \ = [];\n    let minPaths11 = [];\n    let minPathsSum12 = [];\n    let minPaths12\
    \ = [];\n    let minPathsSum13 = [];\n    let minPaths13 = [];\n    let minPathsSum14\
    \ = [];\n    let minPaths14 = [];\n    let minPathsSum15 = [];\n    let minPaths15\
    \ = [];\n    let minPathsSum16 = [];\n    let minPaths16 = [];\n    let minPathsSum17\
    \ = [];\n    let minPaths17 = [];\n    let minPathsSum18 = [];\n    let minPaths18\
    \ = [];\n    let minPathsSum19 = [];\n    let minPaths19 = [];\n    let minPathsSum20\
    \ = [];\n    let minPaths20 = [];\n    let minPathsSum21 = [];\n    let minPaths21\
    \ = [];\n    let minPathsSum22 = [];\n    let minPaths22 = [];\n    let minPathsSum23\
    \ = [];\n    let minPaths23 = [];\n    let minPathsSum24 = [];\n    let minPaths24\
    \ = [];\n    let minPathsSum25 = [];\n    let min", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let start = grid[0][0];\n    let end = grid[n\
    \ - 1][m - 1];\n    let res = [];\n    let visited = new Set();\n    let queue\
    \ = [];\n    queue.push([0, 0, [start]]);\n    while (queue.length > 0) {\n  \
    \      let [x, y, path] = queue.shift();\n        if (x === n - 1 && y === m -\
    \ 1) {\n            if (path.length === k) {\n                res.push(path);\n\
    \            }\n            continue;\n        }\n        if (path.length ===\
    \ k) {\n            continue;\n        }\n        let key = `${x}-${y}`;\n   \
    \     if (visited.has(key)) {\n            continue;\n        }\n        visited.add(key);\n\
    \        if (x > 0) {\n            let next = grid[x - 1][y];\n            queue.push([x\
    \ - 1, y, [...path, next]]);\n        }\n        if (x < n - 1) {\n          \
    \  let next = grid[x + 1][y];\n            queue.push([x + 1, y, [...path, next]]);\n\
    \        }\n        if (y > 0) {\n            let next = grid[x][y - 1];\n   \
    \         queue.push([x, y - 1, [...path, next]]);\n        }\n        if (y <\
    \ m - 1) {\n            let next = grid[x][y + 1];\n            queue.push([x,\
    \ y + 1, [...path, next]]);\n        }\n    }\n    res.sort((a, b) => {\n    \
    \    for (let i = 0; i < a.length; i++) {\n            if (a[i] !== b[i]) {\n\
    \                return a[i] - b[i];\n            }\n        }\n        return\
    \ 0;\n    });\n    return res[0];\n}\n", "    let n = grid.length;\n    let m\
    \ = grid[0].length;\n    let min = Infinity;\n    let minPath = [];\n    let visited\
    \ = [];\n    for (let i = 0; i < n; i++) {\n        visited[i] = [];\n       \
    \ for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n        }\n\
    \    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            let path = [];\n            let pathSum = 0;\n            visited[i][j]\
    \ = true;\n            dfs(i, j, path, pathSum, k);\n            visited[i][j]\
    \ = false;\n        }\n    }\n    return minPath;\n\n    function dfs(i: any,\
    \ j: any, path: any, pathSum: any, k: any) {\n        path.push(grid[i][j]);\n\
    \        pathSum += grid[i][j];\n        if (path.length === k) {\n          \
    \  if (pathSum < min) {\n                min = pathSum;\n                minPath\
    \ = path.slice();\n            }\n            return;\n        }\n        if (i\
    \ > 0 && !visited[i - 1][j]) {\n            visited[i - 1][j] = true;\n      \
    \      dfs(i - 1, j, path, pathSum, k);\n            visited[i - 1][j] = false;\n\
    \        }\n        if (i < n - 1 && !visited[i + 1][j]) {\n            visited[i\
    \ + 1][j] = true;\n            dfs(i + 1, j, path, pathSum, k);\n            visited[i\
    \ + 1][j] = false;\n        }\n        if (j > 0 && !visited[i][j - 1]) {\n  \
    \          visited[i][j - 1] = true;\n            dfs(i, j - 1, path, pathSum,\
    \ k);\n            visited[i][j - 1] = false;\n        }\n        if (j < m -\
    \ 1 && !visited[i][j + 1]) {", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPaths = [];\n \
    \   let path = [];\n    let sum = 0;\n    let paths = [];\n    let visited = [];\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = [];\n        for (let\
    \ j = 0; j < m; j++) {\n            visited[i][j] = false;\n        }\n    }\n\
    \    function dfs(i: any, j: any, k: any) {\n        if (k === 0) {\n        \
    \    paths.push(path.slice());\n            if (sum < minSum) {\n            \
    \    minSum = sum;\n                minPaths = [path.slice()];\n            }\
    \ else if (sum === minSum) {\n                minPaths.push(path.slice());\n \
    \           }\n            return;\n        }\n        if (i < 0 || i >= n ||\
    \ j < 0 || j >= m || visited[i][j]) {\n            return;\n        }\n      \
    \  visited[i][j] = true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n\
    \        dfs(i + 1, j, k - 1);\n        dfs(i - 1, j, k - 1);\n        dfs(i,\
    \ j + 1, k - 1);\n        dfs(i, j - 1, k - 1);\n        visited[i][j] = false;\n\
    \        path.pop();\n        sum -= grid[i][j];\n    }\n    for (let i = 0; i\
    \ < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dfs(i, j, k);\n\
    \        }\n    }\n    for (let i = 0; i < minPaths.length; i++) {\n        if\
    \ (minPaths[i].length < minPath.length) {\n            minPath = minPaths[i];\n\
    \        } else if (minPaths[i].length === minPath.length) {\n            for\
    \ (let j = 0; j <", "    let n = grid.length;\n    let m = grid[0].length;\n \
    \   let minPath = [];\n    let minPathSum = Infinity;\n    for (let i = 0; i <\
    \ n; i++) {\n        for (let j = 0; j < m; j++) {\n            let path = [];\n\
    \            let pathSum = 0;\n            let visited = [];\n            for\
    \ (let i = 0; i < n; i++) {\n                visited.push([]);\n             \
    \   for (let j = 0; j < m; j++) {\n                    visited[i].push(false);\n\
    \                }\n            }\n            dfs(i, j, k, path, pathSum, visited);\n\
    \            if (pathSum < minPathSum) {\n                minPathSum = pathSum;\n\
    \                minPath = path;\n            }\n        }\n    }\n    return\
    \ minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n   \
    \ let minPath = [];\n    let minSum = Infinity;\n    let minPaths = [];\n    let\
    \ minPathsSum = [];\n    function findPath(path: any, sum: any, i: any, j: any)\
    \ {\n        if (path.length == k) {\n            if (sum < minSum) {\n      \
    \          minSum = sum;\n                minPath = path;\n            }\n   \
    \         return;\n        }\n        if (i > 0) {\n            findPath(path.concat(grid[i\
    \ - 1][j]), sum + grid[i - 1][j], i - 1, j);\n        }\n        if (i < n - 1)\
    \ {\n            findPath(path.concat(grid[i + 1][j]), sum + grid[i + 1][j], i\
    \ + 1, j);\n        }\n        if (j > 0) {\n            findPath(path.concat(grid[i][j\
    \ - 1]), sum + grid[i][j - 1], i, j - 1);\n        }\n        if (j < m - 1) {\n\
    \            findPath(path.concat(grid[i][j + 1]), sum + grid[i][j + 1], i, j\
    \ + 1);\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let\
    \ j = 0; j < m; j++) {\n            findPath([grid[i][j]], grid[i][j], i, j);\n\
    \        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let visited = new Set();\n    let queue = [];\n    queue.push([0, 0, grid[0][0],\
    \ [grid[0][0]]]);\n    while (queue.length > 0) {\n        let [i, j, sum, path]\
    \ = queue.shift();\n        if (sum > minPathSum) {\n            continue;\n \
    \       }\n        if (path.length === k) {\n            if (sum < minPathSum)\
    \ {\n                minPathSum = sum;\n                minPath = path;\n    \
    \        } else if (path < minPath) {\n                minPath = path;\n     \
    \       }\n            continue;\n        }\n        if (i > 0 && !visited.has(`${i\
    \ - 1},${j}`)) {\n            queue.push([i - 1, j, sum + grid[i - 1][j], [...path,\
    \ grid[i - 1][j]]]);\n        }\n        if (i < n - 1 && !visited.has(`${i +\
    \ 1},${j}`)) {\n            queue.push([i + 1, j, sum + grid[i + 1][j], [...path,\
    \ grid[i + 1][j]]]);\n        }\n        if (j > 0 && !visited.has(`${i},${j -\
    \ 1}`)) {\n            queue.push([i, j - 1, sum + grid[i][j - 1], [...path, grid[i][j\
    \ - 1]]]);\n        }\n        if (j < m - 1 && !visited.has(`${i},${j + 1}`))\
    \ {\n            queue.push([i, j + 1, sum + grid[i][j + 1], [...path, grid[i][j\
    \ + 1]]]);\n        }\n        visited.add(`${i},${j}`);\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = [];\n    for (let i = 0; i < n; i++) {\n        visited.push([]);\n      \
    \  for (let j = 0; j < m; j++) {\n            visited[i].push(false);\n      \
    \  }\n    }\n    let minPath = [];\n    for (let i = 0; i < k; i++) {\n      \
    \  minPath.push(Infinity);\n    }\n    let minPathSum = Infinity;\n    function\
    \ dfs(i: any, j: any, k: any, path: any, pathSum: any) {\n        if (i < 0 ||\
    \ i >= n || j < 0 || j >= m || visited[i][j] || pathSum > minPathSum) {\n    \
    \        return;\n        }\n        if (k === 0) {\n            if (pathSum <\
    \ minPathSum) {\n                minPathSum = pathSum;\n                minPath\
    \ = path.slice();\n            } else if (pathSum === minPathSum) {\n        \
    \        for (let i = 0; i < k; i++) {\n                    if (path[i] < minPath[i])\
    \ {\n                        minPath = path.slice();\n                       \
    \ break;\n                    } else if (path[i] > minPath[i]) {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \            return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        pathSum += grid[i][j];\n        dfs(i - 1, j, k - 1, path, pathSum);\n\
    \        dfs(i + 1, j, k - 1, path, pathSum);\n        dfs(i, j - 1, k - 1, path,\
    \ pathSum);\n        dfs(i, j + 1, k - 1, path, pathSum);\n        path.pop();\n\
    \        pathSum -= grid[i][j];\n        visited[i][j] = false;\n    }\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n         \
    \   dfs", "    let n = grid.length;\n    let m = grid[0].length;\n    let dp =\
    \ new Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = new Array(m);\n\
    \        for (let j = 0; j < m; j++) {\n            dp[i][j] = new Array(k + 1);\n\
    \            for (let l = 0; l <= k; l++) {\n                dp[i][j][l] = new\
    \ Array(2);\n                dp[i][j][l][0] = -1;\n                dp[i][j][l][1]\
    \ = -1;\n            }\n        }\n    }\n    let ans = new Array(k);\n    let\
    \ min = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i < n; i++) {\n        for\
    \ (let j = 0; j < m; j++) {\n            let cur = dfs(i, j, k, 0, grid, dp);\n\
    \            if (cur < min) {\n                min = cur;\n                for\
    \ (let l = 0; l < k; l++) {\n                    ans[l] = dp[i][j][k][1][l];\n\
    \                }\n            }\n        }\n    }\n    return ans;\n}\n", " \
    \   let n = grid.length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let minPathSum3\
    \ = Infinity;\n    let minPath3 = [];\n    let minPathSum4 = Infinity;\n    let\
    \ minPath4 = [];\n    let minPathSum5 = Infinity;\n    let minPath5 = [];\n  \
    \  let minPathSum6 = Infinity;\n    let minPath6 = [];\n    let minPathSum7 =\
    \ Infinity;\n    let minPath7 = [];\n    let minPathSum8 = Infinity;\n    let\
    \ minPath8 = [];\n    let minPathSum9 = Infinity;\n    let minPath9 = [];\n  \
    \  let minPathSum10 = Infinity;\n    let minPath10 = [];\n    let minPathSum11\
    \ = Infinity;\n    let minPath11 = [];\n    let minPathSum12 = Infinity;\n   \
    \ let minPath12 = [];\n    let minPathSum13 = Infinity;\n    let minPath13 = [];\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minPathSum15\
    \ = Infinity;\n    let minPath15 = [];\n    let minPathSum16 = Infinity;\n   \
    \ let minPath16 = [];\n    let minPathSum17 = Infinity;\n    let minPath17 = [];\n\
    \    let minPathSum18 = Infinity;\n    let minPath18 = [];\n    let minPathSum19\
    \ = Infinity;\n    let minPath19 = [];\n    let minPathSum20 = Infinity;\n   \
    \ let minPath20 = [];\n    let minPathSum21 = Infinity;\n    let minPath21 = [];\n\
    \    let minPathSum22 = Infinity;\n    let minPath22 = [];\n    let minPathSum23\
    \ = Infinity;\n    let minPath23 = [];\n    let minPathSum24 = Infinity;\n   \
    \ let minPath24 = [];\n    let minPathSum25 = Infinity;\n    let minPath25 = [];\n\
    \    let minPathSum26 = Infinity;\n    let minPath26 = [];\n    let minPathSum27\
    \ = Infinity;\n    let minPath27 = [];\n    let minPathSum28 = Infinity;\n   \
    \ let minPath28 = [];\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = new Array(k);\n    let\
    \ minSum = Number.MAX_SAFE_INTEGER;\n    let minPathSum = Number.MAX_SAFE_INTEGER;\n\
    \    let minPathIndex = 0;\n    let minPathSumIndex = 0;\n    let minPathIndexes\
    \ = [];\n    let minPathSumIndexes = [];\n    let minPaths = [];\n    let minPathSums\
    \ = [];\n    let minPathsIndexes = [];\n    let minPathSumsIndexes = [];\n   \
    \ let minPathsIndexesIndex = 0;\n    let minPathSumsIndexesIndex = 0;\n    let\
    \ minPathsIndex = 0;\n    let minPathSumsIndex = 0;\n    let minPathsIndexesIndexes\
    \ = [];\n    let minPathSumsIndexesIndexes = [];\n    let minPathsIndexesIndexesIndex\
    \ = 0;\n    let minPathSumsIndexesIndexesIndex = 0;\n    let minPathsIndexesIndexesIndexes\
    \ = [];\n    let minPathSumsIndexesIndexesIndexes = [];\n    let minPathsIndexesIndexesIndexesIndex\
    \ = 0;\n    let minPathsIndexesIndexesIndexesIndexes = [];\n    let minPathsIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n    let minPathsIndexesIndexesIndexesIndexesIndexes = [];\n    let minPathsIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n    let minPathsIndexesIndexesIndexesIndexesIndexesIndexes = [];\n   \
    \ let minPathsIndexesIndexesIndexesIndexesIndexesIndexesIndex = 0;\n    let minPathsIndexesIndexesIndexesIndexesIndexesIndexesIndexes\
    \ = [];\n    let minPathsIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n    let minPathsIndexesIndexesIndexesIndexesIndexesIndexesIndexes", " \
    \   let N = grid.length;\n    let M = grid[0].length;\n    let dp = new Array(N);\n\
    \    for (let i = 0; i < N; i++) {\n        dp[i] = new Array(M);\n        for\
    \ (let j = 0; j < M; j++) {\n            dp[i][j] = new Array(k + 1);\n      \
    \      for (let l = 0; l <= k; l++) {\n                dp[i][j][l] = new Array(2);\n\
    \                dp[i][j][l][0] = -1;\n                dp[i][j][l][1] = -1;\n\
    \            }\n        }\n    }\n    let ans = new Array(k);\n    for (let i\
    \ = 0; i < k; i++) {\n        ans[i] = -1;\n    }\n    let min = Number.MAX_SAFE_INTEGER;\n\
    \    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < M; j++) {\n  \
    \          let cur = dfs(i, j, k, grid, dp);\n            if (cur < min) {\n \
    \               min = cur;\n                for (let l = 0; l < k; l++) {\n  \
    \                  ans[l] = dp[i][j][k][1][l];\n                }\n          \
    \  }\n        }\n    }\n    return ans;\n}\n", "    let n = grid.length;\n   \
    \ let m = grid[0].length;\n    let visited = new Array(n);\n    for (let i = 0;\
    \ i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n    }\n    let\
    \ minPath = [];\n    let minPathValue = [];\n    let minPathValueSum = Infinity;\n\
    \    let minPathValueSumIndex = -1;\n    let minPathValueSumIndexI = -1;\n   \
    \ let minPathValueSumIndexJ = -1;\n    let minPathValueSumIndexK = -1;\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n         \
    \   for (let k = 0; k < n * m; k++) {\n                let path = [];\n      \
    \          let pathValue = [];\n                let pathValueSum = 0;\n      \
    \          let pathValueSumIndex = -1;\n                let pathValueSumIndexI\
    \ = -1;\n                let pathValueSumIndexJ = -1;\n                let pathValueSumIndexK\
    \ = -1;\n                if (grid[i][j] === k + 1) {\n                    path.push(i);\n\
    \                    path.push(j);\n                    pathValue.push(grid[i][j]);\n\
    \                    pathValueSum = grid[i][j];\n                    pathValueSumIndex\
    \ = 0;\n                    pathValueSumIndexI = i;\n                    pathValueSumIndexJ\
    \ = j;\n                    pathValueSumIndexK = k;\n                    visited[i][j]\
    \ = true;\n                    let result = minPathHelper(grid, visited, path,\
    \ pathValue, pathValueSum, pathValueSumIndex, pathValueSumIndexI, pathValueSumIndexJ,\
    \ pathValueSumIndexK, i, j, k, n, m, k - 1);\n                    if (result[0]\
    \ < minPathValueSum) {\n                        minPath = result[1];\n       \
    \                 minPathValue = result[2];\n                        minPathValueSum\
    \ = result[0];\n                        minPathValueSumIndex = result[3];\n  \
    \                      minPathValueSumIndexI = result[4];\n                  \
    \      minPathValueSumIndexJ = result[5];\n                        min", "   \
    \ let n = grid.length;\n    let m = grid[0].length;\n    let min = Infinity;\n\
    \    let minPath = [];\n    let visited = [];\n    for (let i = 0; i < n; i++)\
    \ {\n        visited[i] = [];\n        for (let j = 0; j < m; j++) {\n       \
    \     visited[i][j] = false;\n        }\n    }\n    for (let i = 0; i < n; i++)\
    \ {\n        for (let j = 0; j < m; j++) {\n            let path = [];\n     \
    \       let curr = grid[i][j];\n            path.push(curr);\n            visited[i][j]\
    \ = true;\n            dfs(i, j, 1, path);\n            visited[i][j] = false;\n\
    \        }\n    }\n    return minPath;\n\n    function dfs(i: any, j: any, len:\
    \ any, path: any) {\n        if (len === k) {\n            if (path < min) {\n\
    \                min = path;\n                minPath = path;\n            }\n\
    \            return;\n        }\n        if (i > 0 && !visited[i - 1][j]) {\n\
    \            visited[i - 1][j] = true;\n            path.push(grid[i - 1][j]);\n\
    \            dfs(i - 1, j, len + 1, path);\n            path.pop();\n        \
    \    visited[i - 1][j] = false;\n        }\n        if (i < n - 1 && !visited[i\
    \ + 1][j]) {\n            visited[i + 1][j] = true;\n            path.push(grid[i\
    \ + 1][j]);\n            dfs(i + 1, j, len + 1, path);\n            path.pop();\n\
    \            visited[i + 1][j] = false;\n        }\n        if (j > 0 && !visited[i][j\
    \ - 1]) {\n            visited[i][j - 1] = true;\n            path.push(grid[i][j\
    \ - 1]);\n            dfs(i, j - 1, len + 1, path);\n            path.pop();\n\
    \            visited[", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp = [];\n    for (let i = 0; i < n; i++) {\n        dp[i] = [];\n  \
    \      for (let j = 0; j < m; j++) {\n            dp[i][j] = [];\n        }\n\
    \    }\n    let min = Number.MAX_VALUE;\n    let minPath = [];\n    for (let i\
    \ = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            let cur\
    \ = grid[i][j];\n            if (i > 0) {\n                let prev = dp[i - 1][j];\n\
    \                if (prev.length > 0) {\n                    let newPath = prev.slice();\n\
    \                    newPath.push(cur);\n                    if (newPath.length\
    \ === k) {\n                        let sum = newPath.reduce((a, b) => a + b,\
    \ 0);\n                        if (sum < min) {\n                            min\
    \ = sum;\n                            minPath = newPath;\n                   \
    \     }\n                    } else {\n                        dp[i][j].push(...newPath);\n\
    \                    }\n                }\n            }\n            if (j >\
    \ 0) {\n                let prev = dp[i][j - 1];\n                if (prev.length\
    \ > 0) {\n                    let newPath = prev.slice();\n                  \
    \  newPath.push(cur);\n                    if (newPath.length === k) {\n     \
    \                   let sum = newPath.reduce((a, b) => a + b, 0);\n          \
    \              if (sum < min) {\n                            min = sum;\n    \
    \                        minPath = newPath;\n                        }\n     \
    \               } else {\n                        dp[i][j].push(...newPath);\n\
    \                    }\n                }\n            }\n            if (i ===\
    \ 0 && j === 0) {\n                dp[i][j].push(cur);\n            }\n      \
    \  }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let m =\
    \ grid[0].length;\n    let min = Infinity;\n    let minPath = [];\n    let path\
    \ = [];\n    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = [];\n        for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n\
    \        }\n    }\n    function dfs(i: any, j: any, k: any) {\n        if (i <\
    \ 0 || i >= n || j < 0 || j >= m || visited[i][j] || k < 0) {\n            return;\n\
    \        }\n        path.push(grid[i][j]);\n        visited[i][j] = true;\n  \
    \      if (k === 0) {\n            if (path.length < min) {\n                min\
    \ = path.length;\n                minPath = path.slice();\n            } else\
    \ if (path.length === min) {\n                if (path.join('') < minPath.join(''))\
    \ {\n                    minPath = path.slice();\n                }\n        \
    \    }\n        } else {\n            dfs(i - 1, j, k - 1);\n            dfs(i\
    \ + 1, j, k - 1);\n            dfs(i, j - 1, k - 1);\n            dfs(i, j + 1,\
    \ k - 1);\n        }\n        path.pop();\n        visited[i][j] = false;\n  \
    \  }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n\
    \            dfs(i, j, k);\n        }\n    }\n    return minPath;\n}\n", "   \
    \ // your code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let min = [];\n    let minSum = Infinity;\n    let minPath = [];\n    let\
    \ visited = [];\n    for (let i = 0; i < n; i++) {\n        visited[i] = [];\n\
    \        for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n \
    \       }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j\
    \ < m; j++) {\n            let path = [];\n            let sum = 0;\n        \
    \    let dfs = (i: any, j: any, k: any) => {\n                if (i < 0 || i >=\
    \ n || j < 0 || j >= m || visited[i][j] || k < 0) {\n                    return;\n\
    \                }\n                visited[i][j] = true;\n                path.push(grid[i][j]);\n\
    \                sum += grid[i][j];\n                if (k === 0) {\n        \
    \            if (sum < minSum) {\n                        minSum = sum;\n    \
    \                    minPath = path.slice();\n                    } else if (sum\
    \ === minSum) {\n                        let minPathStr = minPath.join('');\n\
    \                        let pathStr = path.join('');\n                      \
    \  if (pathStr < minPathStr) {\n                            minPath = path.slice();\n\
    \                        }\n                    }\n                } else {\n\
    \                    dfs(i - 1, j, k - 1);\n                    dfs(i + 1, j,\
    \ k - 1);\n                    dfs(i, j - 1, k - 1);\n                    dfs(i,\
    \ j + 1, k - 1);\n                }\n                visited[i][j] = false;\n\
    \                path.pop();\n                sum -= grid[i][j];\n           \
    \ }\n            dfs(i, j, k);\n        }\n    }\n    return minPath;\n}\n", " \
    \   // your code here\n}\n", "    // your code here\n    return [];\n}\n", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let dp = [];\n    for\
    \ (let i = 0; i < n; i++) {\n        dp[i] = [];\n        for (let j = 0; j <\
    \ m; j++) {\n            dp[i][j] = [];\n        }\n    }\n    for (let i = 0;\
    \ i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dp[i][j][0]\
    \ = [grid[i][j]];\n        }\n    }\n    for (let i = 0; i < n; i++) {\n     \
    \   for (let j = 0; j < m; j++) {\n            for (let l = 1; l < k; l++) {\n\
    \                let min = [];\n                if (i > 0) {\n               \
    \     min = dp[i - 1][j][l - 1];\n                }\n                if (j > 0\
    \ && (min.length == 0 || min.length > dp[i][j - 1][l - 1].length || (min.length\
    \ == dp[i][j - 1][l - 1].length && min > dp[i][j - 1][l - 1]))) {\n          \
    \          min = dp[i][j - 1][l - 1];\n                }\n                if (i\
    \ < n - 1 && (min.length == 0 || min.length > dp[i + 1][j][l - 1].length || (min.length\
    \ == dp[i + 1][j][l - 1].length && min > dp[i + 1][j][l - 1]))) {\n          \
    \          min = dp[i + 1][j][l - 1];\n                }\n                if (j\
    \ < m - 1 && (min.length == 0 || min.length > dp[i][j + 1][l - 1].length || (min.length\
    \ == dp[i][j + 1][l - 1].length && min > dp[i][j + 1][l - 1]))) {\n          \
    \          min = dp[i][j + 1][l - 1];\n                }\n                dp[i][j][",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n\
    \    let minPathSum = Number.MAX_SAFE_INTEGER;\n    let minPathSum2 = Number.MAX_SAFE_INTEGER;\n\
    \    let minPath2 = [];\n    let minPathSum3 = Number.MAX_SAFE_INTEGER;\n    let\
    \ minPath3 = [];\n    let minPathSum4 = Number.MAX_SAFE_INTEGER;\n    let minPath4\
    \ = [];\n    let minPathSum5 = Number.MAX_SAFE_INTEGER;\n    let minPath5 = [];\n\
    \    let minPathSum6 = Number.MAX_SAFE_INTEGER;\n    let minPath6 = [];\n    let\
    \ minPathSum7 = Number.MAX_SAFE_INTEGER;\n    let minPath7 = [];\n    let minPathSum8\
    \ = Number.MAX_SAFE_INTEGER;\n    let minPath8 = [];\n    let minPathSum9 = Number.MAX_SAFE_INTEGER;\n\
    \    let minPath9 = [];\n    let minPathSum10 = Number.MAX_SAFE_INTEGER;\n   \
    \ let minPath10 = [];\n    let minPathSum11 = Number.MAX_SAFE_INTEGER;\n    let\
    \ minPath11 = [];\n    let minPathSum12 = Number.MAX_SAFE_INTEGER;\n    let minPath12\
    \ = [];\n    let minPathSum13 = Number.MAX_SAFE_INTEGER;\n    let minPath13 =\
    \ [];\n    let minPathSum14 = Number.MAX_SAFE_INTEGER;\n    let minPath14 = [];\n\
    \    let minPathSum15 = Number.MAX_SAFE_INTEGER;\n    let minPath15 = [];\n  \
    \  let minPathSum16 = Number.MAX_SAFE_INTEGER;\n    let minPath16 = [];\n    let\
    \ minPathSum17 = Number.MAX_SAFE_INTEGER;\n    let minPath17 = [];\n    let minPathSum18\
    \ = Number.MAX_SAFE_INTEGER;\n    let minPath18 = [];\n    let minPathSum19 =",
  "    // Your code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp = new Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i]\
    \ = new Array(m);\n        for (let j = 0; j < m; j++) {\n            dp[i][j]\
    \ = new Array(k + 1);\n            for (let l = 0; l <= k; l++) {\n          \
    \      dp[i][j][l] = new Array(2);\n                dp[i][j][l][0] = -1;\n   \
    \             dp[i][j][l][1] = -1;\n            }\n        }\n    }\n    let ans\
    \ = new Array(k);\n    let res = dfs(0, 0, k, grid, dp);\n    for (let i = 0;\
    \ i < k; i++) {\n        ans[i] = res[i];\n    }\n    return ans;\n}\n", "   \
    \ let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n   \
    \ for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n     \
    \       let path = [];\n            let sum = 0;\n            dfs(i, j, k, path,\
    \ sum);\n        }\n    }\n    return minPath;\n\n    function dfs(i: number,\
    \ j: number, k: number, path: number[], sum: number) {\n        if (k === 0) {\n\
    \            if (sum < minSum) {\n                minSum = sum;\n            \
    \    minPath = path.slice();\n            }\n            return;\n        }\n\
    \        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n        \
    \    return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i + 1, j, k - 1, path, sum);\n      \
    \  dfs(i - 1, j, k - 1, path, sum);\n        dfs(i, j + 1, k - 1, path, sum);\n\
    \        dfs(i, j - 1, k - 1, path, sum);\n        path.pop();\n        visited[i][j]\
    \ = false;\n    }\n}\n", "    // your code here\n    let n = grid.length;\n  \
    \  let m = grid[0].length;\n    let min = Number.MAX_SAFE_INTEGER;\n    let minPath\
    \ = [];\n    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = [];\n        for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n\
    \        }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            let path = [];\n            let pathSum = 0;\n  \
    \          dfs(i, j, path, pathSum, k, grid, visited);\n            if (pathSum\
    \ < min) {\n                min = pathSum;\n                minPath = path;\n\
    \            }\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = [];\n    let min_sum = Infinity;\n\
    \    let min_path = [];\n    let min_path_sum = Infinity;\n    let visited = [];\n\
    \    let path = [];\n    let sum = 0;\n    let dfs = (i: any, j: any, k: any)\
    \ => {\n        if (k === 0) {\n            if (sum < min_sum) {\n           \
    \     min_sum = sum;\n                min = path.slice();\n            }\n   \
    \         if (sum < min_path_sum) {\n                min_path_sum = sum;\n   \
    \             min_path = path.slice();\n            }\n            return;\n \
    \       }\n        if (i < 0 || i >= n || j < 0 || j >= m) {\n            return;\n\
    \        }\n        if (visited[i][j]) {\n            return;\n        }\n   \
    \     visited[i][j] = true;\n        sum += grid[i][j];\n        path.push(grid[i][j]);\n\
    \        dfs(i - 1, j, k - 1);\n        dfs(i + 1, j, k - 1);\n        dfs(i,\
    \ j - 1, k - 1);\n        dfs(i, j + 1, k - 1);\n        visited[i][j] = false;\n\
    \        sum -= grid[i][j];\n        path.pop();\n    };\n    for (let i = 0;\
    \ i < n; i++) {\n        visited.push([]);\n        for (let j = 0; j < m; j++)\
    \ {\n            visited[i].push(false);\n        }\n    }\n    for (let i = 0;\
    \ i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dfs(i, j,\
    \ k);\n        }\n    }\n    return min_path;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let minPathSum3\
    \ = Infinity;\n    let minPath3 = [];\n    let minPathSum4 = Infinity;\n    let\
    \ minPath4 = [];\n    let minPathSum5 = Infinity;\n    let minPath5 = [];\n  \
    \  let minPathSum6 = Infinity;\n    let minPath6 = [];\n    let minPathSum7 =\
    \ Infinity;\n    let minPath7 = [];\n    let minPathSum8 = Infinity;\n    let\
    \ minPath8 = [];\n    let minPathSum9 = Infinity;\n    let minPath9 = [];\n  \
    \  let minPathSum10 = Infinity;\n    let minPath10 = [];\n    let minPathSum11\
    \ = Infinity;\n    let minPath11 = [];\n    let minPathSum12 = Infinity;\n   \
    \ let minPath12 = [];\n    let minPathSum13 = Infinity;\n    let minPath13 = [];\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minPathSum15\
    \ = Infinity;\n    let minPath15 = [];\n    let minPathSum16 = Infinity;\n   \
    \ let minPath16 = [];\n    let minPathSum17 = Infinity;\n    let minPath17 = [];\n\
    \    let minPathSum18 = Infinity;\n    let minPath18 = [];\n    let minPathSum19\
    \ = Infinity;\n    let minPath19 = [];\n    let minPathSum20 = Infinity;\n   \
    \ let minPath20 = [];\n    let minPathSum21 = Infinity;\n    let minPath21 = [];\n\
    \    let minPathSum22 = Infinity;\n    let minPath22 = [];\n    let minPathSum23\
    \ = Infinity;\n    let minPath23 = [];\n    let minPathSum24 = Infinity;\n   \
    \ let minPath24 = [];\n    let minPathSum25 = Infinity;\n    let minPath25 = [];\n\
    \    let minPathSum26 = Infinity;\n    let minPath26 = [];\n    let minPathSum27\
    \ = Infinity;\n    let minPath27 = [];\n    let minPathSum28 =", "    let n =\
    \ grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n    let minPathSum\
    \ = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let\
    \ minPathSum3 = Infinity;\n    let minPath3 = [];\n    let minPathSum4 = Infinity;\n\
    \    let minPath4 = [];\n    let minPathSum5 = Infinity;\n    let minPath5 = [];\n\
    \    let minPathSum6 = Infinity;\n    let minPath6 = [];\n    let minPathSum7\
    \ = Infinity;\n    let minPath7 = [];\n    let minPathSum8 = Infinity;\n    let\
    \ minPath8 = [];\n    let minPathSum9 = Infinity;\n    let minPath9 = [];\n  \
    \  let minPathSum10 = Infinity;\n    let minPath10 = [];\n    let minPathSum11\
    \ = Infinity;\n    let minPath11 = [];\n    let minPathSum12 = Infinity;\n   \
    \ let minPath12 = [];\n    let minPathSum13 = Infinity;\n    let minPath13 = [];\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minPathSum15\
    \ = Infinity;\n    let minPath15 = [];\n    let minPathSum16 = Infinity;\n   \
    \ let minPath16 = [];\n    let minPathSum17 = Infinity;\n    let minPath17 = [];\n\
    \    let minPathSum18 = Infinity;\n    let minPath18 = [];\n    let minPathSum19\
    \ = Infinity;\n    let minPath19 = [];\n    let minPathSum20 = Infinity;\n   \
    \ let minPath20 = [];\n    let minPathSum21 = Infinity;\n    let minPath21 = [];\n\
    \    let minPathSum22 = Infinity;\n    let minPath22 = [];\n    let minPathSum23\
    \ = Infinity;\n    let minPath23 = [];\n    let minPathSum24 = Infinity;\n   \
    \ let minPath24 = [];\n    let minPathSum25 = Infinity;\n    let minPath25 = [];\n\
    \    let minPathSum26 = Infinity;\n    let minPath26 = [];\n    let minPathSum27\
    \ = Infinity;\n    let minPath27 = [];\n    let minPathSum28 =", "    // your\
    \ code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n  \
    \  let visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = new Array(k);\n    let\
    \ minPathSum = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i < n; i++) {\n \
    \       for (let j = 0; j < m; j++) {\n            let path = new Array(k);\n\
    \            let pathSum = 0;\n            visited[i][j] = true;\n           \
    \ path[0] = grid[i][j];\n            pathSum += grid[i][j];\n            dfs(grid,\
    \ i, j, k, 1, path, pathSum, visited, minPath, minPathSum);\n            visited[i][j]\
    \ = false;\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPaths = [];\n    let visited = [];\n    for (let i = 0; i < n; i++)\
    \ {\n        visited[i] = [];\n        for (let j = 0; j < m; j++) {\n       \
    \     visited[i][j] = false;\n        }\n    }\n    function dfs(i: any, j: any,\
    \ sum: any, path: any) {\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j])\
    \ {\n            return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        if (path.length === k) {\n            if\
    \ (sum < minSum) {\n                minSum = sum;\n                minPath = path.slice();\n\
    \                minPaths = [];\n            } else if (sum === minSum) {\n  \
    \              minPaths.push(path.slice());\n            }\n        } else {\n\
    \            dfs(i - 1, j, sum, path);\n            dfs(i + 1, j, sum, path);\n\
    \            dfs(i, j - 1, sum, path);\n            dfs(i, j + 1, sum, path);\n\
    \        }\n        path.pop();\n        visited[i][j] = false;\n    }\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n         \
    \   dfs(i, j, 0, []);\n        }\n    }\n    if (minPaths.length === 0) {\n  \
    \      return minPath;\n    }\n    minPaths.sort((a: any, b: any) => {\n     \
    \   for (let i = 0; i < k; i++) {\n            if (a[i] < b[i]) {\n          \
    \      return -1;\n            } else if (a[i] > b[i]) {\n                return\
    \ 1;\n            }\n        }\n        return", "    let n = grid.length;\n \
    \   let m = grid[0].length;\n    let visited = new Array(n);\n    for (let i =\
    \ 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n    }\n  \
    \  let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPathSum3 = Infinity;\n    let minPathSum4\
    \ = Infinity;\n    let minPathSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPathSum7 = Infinity;\n    let minPathSum8 = Infinity;\n    let minPathSum9\
    \ = Infinity;\n    let minPathSum10 = Infinity;\n    let minPathSum11 = Infinity;\n\
    \    let minPathSum12 = Infinity;\n    let minPathSum13 = Infinity;\n    let minPathSum14\
    \ = Infinity;\n    let minPathSum15 = Infinity;\n    let minPathSum16 = Infinity;\n\
    \    let minPathSum17 = Infinity;\n    let minPathSum18 = Infinity;\n    let minPathSum19\
    \ = Infinity;\n    let minPathSum20 = Infinity;\n    let minPathSum21 = Infinity;\n\
    \    let minPathSum22 = Infinity;\n    let minPathSum23 = Infinity;\n    let minPathSum24\
    \ = Infinity;\n    let minPathSum25 = Infinity;\n    let minPathSum26 = Infinity;\n\
    \    let minPathSum27 = Infinity;\n    let minPathSum28 = Infinity;\n    let minPathSum29\
    \ = Infinity;\n    let minPathSum30 = Infinity;\n    let minPathSum31 = Infinity;\n\
    \    let minPathSum32 = Infinity;\n    let minPathSum33 = Infinity;\n    let minPathSum34\
    \ = Infinity;\n    let minPathSum35 = Infinity;\n    let minPathSum36 = Infinity;\n\
    \    let minPathSum37 = Infinity;\n    let minPathSum38 = Infinity;\n    let minPathSum39\
    \ = Infinity;\n    let minPathSum40 = Infinity;\n    let minPathSum41 = Infinity;\n\
    \    let minPathSum42 = Infinity;\n    let minPathSum43 = Infinity;\n    let"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
