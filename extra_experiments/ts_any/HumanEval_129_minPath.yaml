name: HumanEval_129_minPath
language: ts
prompt: "//Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n// each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have\
  \ to find the minimum path of length k in the grid. You can start\n// from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n// in other words,\
  \ you can go to cells which share an edge with you current\n// cell.\n// Please\
  \ note that a path of length k means visiting exactly k cells (not\n// necessarily\
  \ distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered\
  \ less than a path B (of length k) if\n// after making the ordered arrays of the\
  \ values on the cells that A and B go\n// through (let's call them lst_A and lst_B),\
  \ lst_A is lexicographically less\n// than lst_B, in other words, there exist an\
  \ integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j\
  \ (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer\
  \ is unique.\n// Return an ordered array of the values on the cells that the minimum\
  \ path go through.\n// Examples:    \n// >>> minPath([[1, 2, 3], [4, 5, 6], [7,\
  \ 8, 9]], 3)\n// [1, 2, 1]\n// >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n\
  // [1]\nfunction minPath(grid: any, k: any): any {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = minPath;\n  assert.deepEqual(candidate([[1, 2, 3],\
  \ [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1]);\n  assert.deepEqual(candidate([[5, 9, 3],\
  \ [4, 1, 6], [7, 8, 2]], 1),[1]);\n  assert.deepEqual(candidate([[1, 2, 3, 4], [5,\
  \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2]);\n  assert.deepEqual(candidate([[6,\
  \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10,\
  \ 1, 10, 1]);\n  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5,\
  \ 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1]);\n  assert.deepEqual(candidate([[11,\
  \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1,\
  \ 6, 1, 6, 1]);\n  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5,\
  \ 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n  assert.deepEqual(candidate([[2,\
  \ 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);\n  assert.deepEqual(candidate([[6,\
  \ 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);\n  assert.deepEqual(candidate([[1,\
  \ 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n  assert.deepEqual(candidate([[1,\
  \ 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n\ntest();"
completions: ["    let n = grid.length;\n    let m = grid[0].length;\n    let minPath\
    \ = [];\n    let minPathSum = Infinity;\n    let visited = [];\n    for (let i\
    \ = 0; i < n; i++) {\n        visited[i] = [];\n        for (let j = 0; j < m;\
    \ j++) {\n            visited[i][j] = false;\n        }\n    }\n    for (let i\
    \ = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            let path\
    \ = [];\n            let pathSum = 0;\n            let pathSumMin = Infinity;\n\
    \            let pathSumMinIndex = 0;\n            let pathSumMinIndexes = [];\n\
    \            let pathSumMinIndexesIndex = 0;\n            let pathSumMinIndexesIndexes\
    \ = [];\n            let pathSumMinIndexesIndexesIndex = 0;\n            let pathSumMinIndexesIndexesIndexes\
    \ = [];\n            let pathSumMinIndexesIndexesIndexesIndex = 0;\n         \
    \   let pathSumMinIndexesIndexesIndexesIndexes = [];\n            let pathSumMinIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n            let pathSumMinIndexesIndexesIndexesIndexesIndexes = [];\n\
    \            let pathSumMinIndexesIndexesIndexesIndexesIndexesIndex = 0;\n   \
    \         let pathSumMinIndexesIndexesIndexesIndexesIndexesIndexes = [];\n   \
    \         let pathSumMinIndexesIndexesIndexesIndexesIndexesIndexesIndex = 0;\n\
    \            let pathSumMinIndexesIndexesIndexesIndexesIndexesIndexesIndexes =\
    \ [];\n            let pathSumMinIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n            let pathSumMinIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexes\
    \ = [];\n            let pathSumMinIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n            let pathSumMinIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexes\
    \ = [];\n            let pathSumMinIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n            let pathSumMin", "    const n = grid.length;\n    const m\
    \ = grid[0].length;\n    const dp = new Array(n);\n    for (let i = 0; i < n;\
    \ i++) {\n        dp[i] = new Array(m);\n        for (let j = 0; j < m; j++) {\n\
    \            dp[i][j] = new Array(k + 1);\n            for (let l = 0; l <= k;\
    \ l++) {\n                dp[i][j][l] = new Array(2);\n                dp[i][j][l][0]\
    \ = [];\n                dp[i][j][l][1] = Infinity;\n            }\n        }\n\
    \    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            dp[i][j][1][0] = [grid[i][j]];\n            dp[i][j][1][1] =\
    \ grid[i][j];\n        }\n    }\n    for (let l = 2; l <= k; l++) {\n        for\
    \ (let i = 0; i < n; i++) {\n            for (let j = 0; j < m; j++) {\n     \
    \           for (let di = -1; di <= 1; di++) {\n                    for (let dj\
    \ = -1; dj <= 1; dj++) {\n                        if (Math.abs(di) + Math.abs(dj)\
    \ !== 1) continue;\n                        const ni = i + di;\n             \
    \           const nj = j + dj;\n                        if (ni < 0 || ni >= n\
    \ || nj < 0 || nj >= m) continue;\n                        const cur = dp[i][j][l\
    \ - 1][1] + grid[i][j];\n                        if (cur < dp[ni][nj][l][1]) {\n\
    \                            dp[ni][nj][l][1] = cur;\n                       \
    \     dp[ni][nj][l][0] = dp[i][j][l - 1][0].concat(grid[i][j]);\n            \
    \            }\n                    }\n                }\n            }\n    \
    \    }\n    }", "    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m;\
    \ j++) {\n            let path = [];\n            let sum = 0;\n            dfs(i,\
    \ j, k, path, sum);\n        }\n    }\n    return minPath;\n\n    function dfs(i:\
    \ number, j: number, k: number, path: any, sum: number) {\n        if (k === 0)\
    \ {\n            if (sum < minSum) {\n                minSum = sum;\n        \
    \        minPath = path.slice();\n            }\n            return;\n       \
    \ }\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n    \
    \        return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i + 1, j, k - 1, path, sum);\n      \
    \  dfs(i - 1, j, k - 1, path, sum);\n        dfs(i, j + 1, k - 1, path, sum);\n\
    \        dfs(i, j - 1, k - 1, path, sum);\n        path.pop();\n        visited[i][j]\
    \ = false;\n    }\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let min = Infinity;\n    let res = [];\n    let dp = [];\n    for (let i\
    \ = 0; i < n; i++) {\n        dp[i] = [];\n        for (let j = 0; j < m; j++)\
    \ {\n            dp[i][j] = [];\n        }\n    }\n    for (let i = 0; i < n;\
    \ i++) {\n        for (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n\
    \        }\n    }\n    return res;\n\n    function dfs(i: any, j: any, path: any,\
    \ cnt: any) {\n        if (cnt > k) {\n            return;\n        }\n      \
    \  if (cnt == k) {\n            if (path.length < min) {\n                min\
    \ = path.length;\n                res = path;\n            } else if (path.length\
    \ == min) {\n                for (let i = 0; i < path.length; i++) {\n       \
    \             if (path[i] < res[i]) {\n                        res = path;\n \
    \                       break;\n                    } else if (path[i] > res[i])\
    \ {\n                        break;\n                    }\n                }\n\
    \            }\n            return;\n        }\n        if (dp[i][j][cnt] != undefined)\
    \ {\n            return;\n        }\n        dp[i][j][cnt] = true;\n        path.push(grid[i][j]);\n\
    \        if (i > 0) {\n            dfs(i - 1, j, path.slice(), cnt + 1);\n   \
    \     }\n        if (i < n - 1) {\n            dfs(i + 1, j, path.slice(), cnt\
    \ + 1);\n        }\n        if (j > 0) {\n            dfs(i, j - 1, path.slice(),\
    \ cnt + 1);\n        }\n        if (j < m - 1) {\n            dfs(i, j + 1, path.slice(),\
    \ cnt + 1);\n        }\n    }\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = new Array(k);\n    let\
    \ minSum = Infinity;\n    let minPathSum = Infinity;\n    let minPathIndex = 0;\n\
    \    let minPathIndexSum = 0;\n    let dfs = (i: any, j: any, path: any, pathIndex:\
    \ any, pathSum: any) => {\n        if (pathIndex === k) {\n            if (pathSum\
    \ < minPathSum) {\n                minPathSum = pathSum;\n                minPathIndexSum\
    \ = pathIndex;\n                for (let i = 0; i < k; i++) {\n              \
    \      minPath[i] = path[i];\n                }\n            } else if (pathSum\
    \ === minPathSum) {\n                for (let i = 0; i < k; i++) {\n         \
    \           if (path[i] < minPath[i]) {\n                        minPathIndexSum\
    \ = pathIndex;\n                        for (let i = 0; i < k; i++) {\n      \
    \                      minPath[i] = path[i];\n                        }\n    \
    \                    break;\n                    } else if (path[i] > minPath[i])\
    \ {\n                        break;\n                    }\n                }\n\
    \            }\n            return;\n        }\n        if (i < 0 || i >= n ||\
    \ j < 0 || j >= m || visited[i][j]) {\n            return;\n        }\n      \
    \  visited[i][j] = true;\n        path[pathIndex] = grid[i][j];\n        pathSum\
    \ += grid[i][j];\n        dfs(i - 1, j, path, pathIndex + 1, pathSum);\n     \
    \   dfs(i + 1, j, path, pathIndex + 1, pathSum);\n        dfs(i, j - 1, path,\
    \ pathIndex + 1, pathSum);\n        dfs(i, j + 1, path, pathIndex + 1, pathSum);\n\
    \        visited[i][j] = false;\n    };\n", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let min = Infinity;\n    let minPath = [];\n    let\
    \ visited = [];\n    for (let i = 0; i < n; i++) {\n        visited[i] = [];\n\
    \        for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n \
    \       }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j\
    \ < m; j++) {\n            let path = [];\n            dfs(i, j, k, path, visited);\n\
    \            if (path.length < min) {\n                min = path.length;\n  \
    \              minPath = path;\n            }\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath:\
    \ any = [];\n    let minPathSum: any = Infinity;\n    let visited: any = [];\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = [];\n        for (let\
    \ j = 0; j < m; j++) {\n            visited[i][j] = false;\n        }\n    }\n\
    \    let dfs = (i: any, j: any, path: any, pathSum: any) => {\n        if (i <\
    \ 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n            return;\n  \
    \      }\n        path.push(grid[i][j]);\n        pathSum += grid[i][j];\n   \
    \     if (path.length === k) {\n            if (pathSum < minPathSum) {\n    \
    \            minPathSum = pathSum;\n                minPath = path.slice();\n\
    \            }\n            path.pop();\n            return;\n        }\n    \
    \    visited[i][j] = true;\n        dfs(i - 1, j, path, pathSum);\n        dfs(i\
    \ + 1, j, path, pathSum);\n        dfs(i, j - 1, path, pathSum);\n        dfs(i,\
    \ j + 1, path, pathSum);\n        visited[i][j] = false;\n        path.pop();\n\
    \    };\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n}\n",
  "    let N = grid.length;\n    let M = grid[0].length;\n    let minPath = [];\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2\
    \ = [];\n    let minPathSum3 = Infinity;\n    let minPath3 = [];\n    let minPathSum4\
    \ = Infinity;\n    let minPath4 = [];\n    let minPathSum5 = Infinity;\n    let\
    \ minPath5 = [];\n    let minPathSum6 = Infinity;\n    let minPath6 = [];\n  \
    \  let minPathSum7 = Infinity;\n    let minPath7 = [];\n    let minPathSum8 =\
    \ Infinity;\n    let minPath8 = [];\n    let minPathSum9 = Infinity;\n    let\
    \ minPath9 = [];\n    let minPathSum10 = Infinity;\n    let minPath10 = [];\n\
    \    let minPathSum11 = Infinity;\n    let minPath11 = [];\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minPathSum13 = Infinity;\n   \
    \ let minPath13 = [];\n    let minPathSum14 = Infinity;\n    let minPath14 = [];\n\
    \    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let minPathSum16\
    \ = Infinity;\n    let minPath16 = [];\n    let minPathSum17 = Infinity;\n   \
    \ let minPath17 = [];\n    let minPathSum18 = Infinity;\n    let minPath18 = [];\n\
    \    let minPathSum19 = Infinity;\n    let minPath19 = [];\n    let minPathSum20\
    \ = Infinity;\n    let minPath20 = [];\n    let minPathSum21 = Infinity;\n   \
    \ let minPath21 = [];\n    let minPathSum22 = Infinity;\n    let minPath22 = [];\n\
    \    let minPathSum23 = Infinity;\n    let minPath23 = [];\n    let minPathSum24\
    \ = Infinity;\n    let minPath24 = [];\n    let minPathSum25 = Infinity;\n   \
    \ let minPath25 = [];\n    let minPathSum26 = Infinity;\n    let minPath26 = [];\n\
    \    let minPathSum27 = Infinity;\n    let minPath27 = [];\n    let minPathSum28\
    \ =", "    let n = grid.length;\n    let m = grid[0].length;\n    let dp = new\
    \ Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = new Array(m);\n\
    \        for (let j = 0; j < m; j++) {\n            dp[i][j] = new Array(k + 1);\n\
    \            for (let l = 0; l <= k; l++) {\n                dp[i][j][l] = new\
    \ Array(2);\n                dp[i][j][l][0] = new Array(2);\n                dp[i][j][l][1]\
    \ = new Array(2);\n            }\n        }\n    }\n    for (let i = 0; i < n;\
    \ i++) {\n        for (let j = 0; j < m; j++) {\n            for (let l = 0; l\
    \ <= k; l++) {\n                for (let p = 0; p < 2; p++) {\n              \
    \      for (let q = 0; q < 2; q++) {\n                        dp[i][j][l][p][q]\
    \ = new Array(2);\n                    }\n                }\n            }\n \
    \       }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j\
    \ < m; j++) {\n            for (let l = 0; l <= k; l++) {\n                for\
    \ (let p = 0; p < 2; p++) {\n                    for (let q = 0; q < 2; q++) {\n\
    \                        for (let r = 0; r < 2; r++) {\n                     \
    \       dp[i][j][l][p][q][r] = new Array(2);\n                        }\n    \
    \                }\n                }\n            }\n        }\n    }\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n         \
    \   for (let l = 0; l <= k; l++) {\n                for (let p = 0; p < 2; p++)\
    \ {\n                    for (let q = 0; q < 2; q++) {\n                     \
    \   for (let", "    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ minPath = [];\n    let minSum = Infinity;\n    let visited = [];\n    for (let\
    \ i = 0; i < n; i++) {\n        visited[i] = [];\n        for (let j = 0; j <\
    \ m; j++) {\n            visited[i][j] = false;\n        }\n    }\n    function\
    \ dfs(i: any, j: any, sum: any, path: any) {\n        if (sum > minSum) {\n  \
    \          return;\n        }\n        if (path.length === k) {\n            if\
    \ (sum < minSum) {\n                minSum = sum;\n                minPath = path;\n\
    \            }\n            return;\n        }\n        if (i < 0 || i >= n ||\
    \ j < 0 || j >= m || visited[i][j]) {\n            return;\n        }\n      \
    \  visited[i][j] = true;\n        dfs(i - 1, j, sum + grid[i][j], path.concat(grid[i][j]));\n\
    \        dfs(i + 1, j, sum + grid[i][j], path.concat(grid[i][j]));\n        dfs(i,\
    \ j - 1, sum + grid[i][j], path.concat(grid[i][j]));\n        dfs(i, j + 1, sum\
    \ + grid[i][j], path.concat(grid[i][j]));\n        visited[i][j] = false;\n  \
    \  }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n\
    \            dfs(i, j, 0, []);\n        }\n    }\n    return minPath;\n}\n", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = new Array(k);\n    let minPathSum = Infinity;\n    let\
    \ minPathSumIndex = -1;\n    let minPathSumIndex2 = -1;\n    let minPathSumIndex3\
    \ = -1;\n    let minPathSumIndex4 = -1;\n    let minPathSumIndex5 = -1;\n    let\
    \ minPathSumIndex6 = -1;\n    let minPathSumIndex7 = -1;\n    let minPathSumIndex8\
    \ = -1;\n    let minPathSumIndex9 = -1;\n    let minPathSumIndex10 = -1;\n   \
    \ let minPathSumIndex11 = -1;\n    let minPathSumIndex12 = -1;\n    let minPathSumIndex13\
    \ = -1;\n    let minPathSumIndex14 = -1;\n    let minPathSumIndex15 = -1;\n  \
    \  let minPathSumIndex16 = -1;\n    let minPathSumIndex17 = -1;\n    let minPathSumIndex18\
    \ = -1;\n    let minPathSumIndex19 = -1;\n    let minPathSumIndex20 = -1;\n  \
    \  let minPathSumIndex21 = -1;\n    let minPathSumIndex22 = -1;\n    let minPathSumIndex23\
    \ = -1;\n    let minPathSumIndex24 = -1;\n    let minPathSumIndex25 = -1;\n  \
    \  let minPathSumIndex26 = -1;\n    let minPathSumIndex27 = -1;\n    let minPathSumIndex28\
    \ = -1;\n    let minPathSumIndex29 = -1;\n    let minPathSumIndex30 = -1;\n  \
    \  let minPathSumIndex31 = -1;\n    let minPathSumIndex32 = -1;\n    let minPathSumIndex33\
    \ = -1;\n    let minPathSumIndex34 = -1;\n    let minPathSumIndex35 = -1;\n  \
    \  let minPathSumIndex36", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp = new Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i]\
    \ = new Array(m);\n        for (let j = 0; j < m; j++) {\n            dp[i][j]\
    \ = new Array(k + 1);\n            for (let l = 0; l <= k; l++) {\n          \
    \      dp[i][j][l] = new Array(2);\n                dp[i][j][l][0] = -1;\n   \
    \             dp[i][j][l][1] = -1;\n            }\n        }\n    }\n    let ans\
    \ = new Array(k);\n    let min = Number.MAX_SAFE_INTEGER;\n    for (let i = 0;\
    \ i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            let cur =\
    \ dfs(i, j, k, grid, dp);\n            if (cur < min) {\n                min =\
    \ cur;\n                for (let l = 0; l < k; l++) {\n                    ans[l]\
    \ = dp[i][j][k][1];\n                }\n            }\n        }\n    }\n    return\
    \ ans;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = [];\n        for (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n\
    \        }\n    }\n    let dfs = (i: any, j: any, path: any, sum: any) => {\n\
    \        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || sum > minSum)\
    \ {\n            return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        if (path.length === k) {\n            if\
    \ (sum < minPathSum) {\n                minPathSum = sum;\n                minPath\
    \ = path.slice();\n            }\n        } else {\n            dfs(i - 1, j,\
    \ path, sum);\n            dfs(i + 1, j, path, sum);\n            dfs(i, j - 1,\
    \ path, sum);\n            dfs(i, j + 1, path, sum);\n        }\n        path.pop();\n\
    \        visited[i][j] = false;\n    };\n    for (let i = 0; i < n; i++) {\n \
    \       for (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n       \
    \     minSum = minPathSum;\n        }\n    }\n    return minPath;\n}\n", "   \
    \ let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(0));\n    let min = new Array(k).fill(Infinity);\n    let\
    \ minPath = new Array(k).fill(0);\n    let minPaths = [];\n    let minPathsCount\
    \ = 0;\n    let minPathsCountMax = 0;\n    let minPathsCountMaxIndex = 0;\n  \
    \  let minPathsCountMaxIndexes = [];\n    let minPathsCountMaxIndexesCount = 0;\n\
    \    let minPathsCountMaxIndexesCountMax = 0;\n    let minPathsCountMaxIndexesCountMaxIndex\
    \ = 0;\n    let minPathsCountMaxIndexesCountMaxIndexes = [];\n    let minPathsCountMaxIndexesCountMaxIndexesCount\
    \ = 0;\n    let minPathsCountMaxIndexesCountMaxIndexesCountMax = 0;\n    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndex\
    \ = 0;\n    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexes = [];\n\
    \    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCount = 0;\n   \
    \ let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMax = 0;\n   \
    \ let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndex = 0;\n\
    \    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndexes\
    \ = [];\n    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndexesCount\
    \ = 0;\n    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMax\
    \ = 0;\n    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndex\
    \ = 0;\n    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndexes\
    \ = [];\n    let minPathsCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndexesCountMaxIndexesCount\
    \ = 0;\n    let minPathsCountMaxIndexesCountMax", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for (let i\
    \ = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n    }\n\
    \    let res = [];\n    let min = Number.MAX_VALUE;\n    for (let i = 0; i < n;\
    \ i++) {\n        for (let j = 0; j < m; j++) {\n            let path = [];\n\
    \            dfs(i, j, k, grid, visited, path, res, min);\n        }\n    }\n\
    \    return res;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp = new Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i]\
    \ = new Array(m);\n        for (let j = 0; j < m; j++) {\n            dp[i][j]\
    \ = new Array(k + 1);\n            for (let l = 0; l <= k; l++) {\n          \
    \      dp[i][j][l] = new Array(2);\n                dp[i][j][l][0] = Infinity;\n\
    \                dp[i][j][l][1] = [];\n            }\n        }\n    }\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n         \
    \   dp[i][j][1][0] = grid[i][j];\n            dp[i][j][1][1] = [grid[i][j]];\n\
    \        }\n    }\n    for (let l = 2; l <= k; l++) {\n        for (let i = 0;\
    \ i < n; i++) {\n            for (let j = 0; j < m; j++) {\n                if\
    \ (i > 0) {\n                    if (dp[i - 1][j][l - 1][0] < dp[i][j][l][0])\
    \ {\n                        dp[i][j][l][0] = dp[i - 1][j][l - 1][0];\n      \
    \                  dp[i][j][l][1] = dp[i - 1][j][l - 1][1].slice();\n        \
    \            } else if (dp[i - 1][j][l - 1][0] == dp[i][j][l][0]) {\n        \
    \                let tmp = dp[i - 1][j][l - 1][1].slice();\n                 \
    \       tmp.push(grid[i][j]);\n                        if (tmp < dp[i][j][l][1])\
    \ {\n                            dp[i][j][l][1] = tmp;\n                     \
    \   }\n                    }\n                }\n                if (i < n", " \
    \   let N = grid.length;\n    let minPath: any = [];\n    let minSum: any = Infinity;\n\
    \    let minPaths: any = [];\n    let minSums: any = [];\n    let visited: any\
    \ = [];\n    for (let i = 0; i < N; i++) {\n        visited.push([]);\n      \
    \  for (let j = 0; j < N; j++) {\n            visited[i].push(false);\n      \
    \  }\n    }\n    function dfs(i: any, j: any, path: any, sum: any) {\n       \
    \ if (i < 0 || i >= N || j < 0 || j >= N || visited[i][j]) {\n            return;\n\
    \        }\n        if (path.length === k) {\n            if (sum < minSum) {\n\
    \                minSum = sum;\n                minPath = path;\n            }\
    \ else if (sum === minSum) {\n                minPaths.push(path);\n         \
    \       minSums.push(sum);\n            }\n            return;\n        }\n  \
    \      visited[i][j] = true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n\
    \        dfs(i - 1, j, path.slice(), sum);\n        dfs(i + 1, j, path.slice(),\
    \ sum);\n        dfs(i, j - 1, path.slice(), sum);\n        dfs(i, j + 1, path.slice(),\
    \ sum);\n        visited[i][j] = false;\n    }\n    for (let i = 0; i < N; i++)\
    \ {\n        for (let j = 0; j < N; j++) {\n            dfs(i, j, [], 0);\n  \
    \      }\n    }\n    for (let i = 0; i < minPaths.length; i++) {\n        if (minSums[i]\
    \ === minSum) {\n            if (minPaths[i] < minPath) {\n                minPath\
    \ = minPaths[i];\n            }\n        }\n    }\n    return minPath;\n}\n",
  "    // Your code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = [];\n    for (let i = 0; i < n; i++) {\n        visited.push([]);\n\
    \        for (let j = 0; j < m; j++) {\n            visited[i].push(false);\n\
    \        }\n    }\n    let minPath = [];\n    for (let i = 0; i < k; i++) {\n\
    \        minPath.push(Infinity);\n    }\n    let minPathSum = Infinity;\n    let\
    \ curPath = [];\n    let curPathSum = 0;\n    let dfs = (i: any, j: any) => {\n\
    \        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n        \
    \    return;\n        }\n        visited[i][j] = true;\n        curPath.push(grid[i][j]);\n\
    \        curPathSum += grid[i][j];\n        if (curPath.length === k) {\n    \
    \        if (curPathSum < minPathSum) {\n                minPathSum = curPathSum;\n\
    \                minPath = curPath.slice();\n            } else if (curPathSum\
    \ === minPathSum) {\n                for (let i = 0; i < k; i++) {\n         \
    \           if (curPath[i] < minPath[i]) {\n                        minPath =\
    \ curPath.slice();\n                        break;\n                    } else\
    \ if (curPath[i] > minPath[i]) {\n                        break;\n           \
    \         }\n                }\n            }\n        } else {\n            dfs(i\
    \ - 1, j);\n            dfs(i + 1, j);\n            dfs(i, j - 1);\n         \
    \   dfs(i, j + 1);\n        }\n        curPath.pop();\n        curPathSum -= grid[i][j];\n\
    \        visited[i][j] = false;\n    };\n    for (let i = 0; i < n; i++) {\n \
    \       for (let j = 0; j < m; j++) {\n            dfs(i, j);\n        }\n   \
    \ }\n    return minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp = [];\n    for (let i = 0; i < n; i++) {\n        dp[i] = [];\n  \
    \      for (let j = 0; j < m; j++) {\n            dp[i][j] = [];\n        }\n\
    \    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            if (i == 0 && j == 0) {\n                dp[i][j][0] = grid[i][j];\n\
    \            } else if (i == 0) {\n                dp[i][j][0] = dp[i][j - 1][0]\
    \ + grid[i][j];\n            } else if (j == 0) {\n                dp[i][j][0]\
    \ = dp[i - 1][j][0] + grid[i][j];\n            } else {\n                dp[i][j][0]\
    \ = Math.min(dp[i - 1][j][0], dp[i][j - 1][0]) + grid[i][j];\n            }\n\
    \        }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            for (let l = 1; l < k; l++) {\n                if\
    \ (i == 0 && j == 0) {\n                    dp[i][j][l] = grid[i][j];\n      \
    \          } else if (i == 0) {\n                    dp[i][j][l] = dp[i][j - 1][l]\
    \ + grid[i][j];\n                } else if (j == 0) {\n                    dp[i][j][l]\
    \ = dp[i - 1][j][l] + grid[i][j];\n                } else {\n                \
    \    dp[i][j][l] = Math.min(dp[i - 1][j][l], dp[i][j - 1][l]) + grid[i][j];\n\
    \                }\n            }\n        }\n    }\n   "]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
