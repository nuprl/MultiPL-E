language: sh
name: HumanEval_87_get_row
results:
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a rows=($(echo \"$lst\" | tr '\\n' ' '))\n    local -a cols\n    local -a row\n\
    \    local -a col\n    local -a row_col\n    local -a row_cols\n    local -a row_cols_sorted\n\
    \    local -a res_sorted\n    local -a row_col_sorted\n    local -a row_cols_sorted_sorted\n\
    \    local -a res_sorted_sorted\n    local -a row_col_sorted_sorted\n    local\
    \ -a row_cols_sorted_sorted_sorted\n    local -a res_sorted_sorted_sorted\n  \
    \  local -a row_col_sorted_sorted_sorted\n    local -a row_cols_sorted_sorted_sorted_sorted\n\
    \    local -a res_sorted_sorted_sorted_sorted\n    local -a row_col_sorted_sorted_sorted_sorted\n\
    \    local -a row_cols_sorted_sorted_sorted_sorted_sorted\n    local -a res_sorted_sorted_sorted_sorted_sorted\n\
    \    local -a row_col_sorted_sorted_sorted_sorted_sorted\n    local -a row_cols_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \    local -a res_sorted_sorted_sorted_sorted_sorted_sorted\n    local -a row_col_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \    local -a row_cols_sorted_sorted_sorted_sorted_sorted_sorted_sorted\n    local\
    \ -a res_sorted_sorted_sorted_sorted_sorted_sorted_sorted\n    local -a row_col_sorted_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \    local -a row_cols_sorted_sorted_sorted_sorted\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_reversed\n    local -a row_col_sorted_reversed_joined\n\
    \    local -a row_col_sorted_reversed_joined_quoted\n    local -a row_col_sorted_reversed_joined_quoted_joined\n\
    \    local -a row_col_sorted_reversed_joined_quoted_joined_quoted\n    local -a\
    \ row_col_sorted_reversed_joined_quoted_joined_quoted_joined\n    local -a row_col_sorted_reversed_joined_quoted_joined_quoted_joined_quoted\n\
    \    local -a row_col_sorted_reversed_joined_quoted_joined_quoted_joined_quoted_joined\n\
    \    local -a row_col_sorted_reversed_joined_quoted_joined_quoted_joined_quoted_joined_quoted\n\
    \    local -a row_col_sorted_reversed_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined\n\
    \    local -a row_col_sorted_reversed_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted\n\
    \    local -a row_col_sorted_reversed_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined\n\
    \    local -a row_col_sorted_reversed_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted\n\
    \    local -a row_col_sorted_reversed_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined\n\
    \    local -a row_col_sorted_reversed_joined_quoted_joined_quoted_joined_\n}\n\
    \ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row=0\n\
    \    local col=0\n    local result=()\n    while read -r line; do\n        col=0\n\
    \        for i in $line; do\n            if [[ \"$i\" == \"$x\" ]]; then\n   \
    \             result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n   \
    \         col=$((col+1))\n        done\n        row=$((row+1))\n    done <<< \"\
    $lst\"\n    echo \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3\
    \ 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1\
    \ 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local -a result\n\
    \    local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_rev\n\
    \    local -a row_col_rev_str\n    local -a row_col_rev_str_sorted\n    local\
    \ -a row_col_rev_str_sorted_str\n    local -a row_col_rev_str_sorted_str_sorted\n\
    \    local -a row_col_rev_str_sorted_str_sorted_str\n    local -a row_col_rev_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_rev_str_sorted_str_sorted_str_sorted_str\n    local -a row_col_rev_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_rev_str_sorted_str_sorted_str_sorted_str_sorted_str\n  \
    \  local -a row_col_rev_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_rev_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_rev_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_rev_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_rev_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_rev_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_rev_str_\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"\
    1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4\
    \ 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i -eq $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc6d6e8qp.sh: line 26: [[: 6\\n1: syntax error: invalid arithmetic
    operator (error token is "\\n1")\n/tmp/tmpc6d6e8qp.sh: line 26: [[: 6\\n1: syntax
    error: invalid arithmetic operator (error token is "\\n1")\n'''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            result+=([\"$row,$col\"]=\"$row,$col\"\
    )\n        fi\n        if [[ $i == $'\\n' ]]; then\n            ((row++))\n  \
    \          col=0\n        else\n            ((col++))\n        fi\n    done\n\
    \    echo \"${result[@]}\" | tr ' ' '\\n' | sort -t, -k1,1n -k2,2nr | tr '\\n'\
    \ ' '\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\\
    n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\\
    n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\
    \ = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\"\
    \ ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\"\
    ) = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local -a res\n  local -a\
    \ rows\n  local -a cols\n  local -a row\n  local -a col\n  local -a row_col\n\
    \  local -a row_col_sorted\n  local -a row_col_sorted_rev\n  local -a row_col_sorted_rev_str\n\
    \  local -a row_col_sorted_rev_str_str\n  local -a row_col_sorted_rev_str_str_str\n\
    \  local -a row_col_sorted_rev_str_str_str_str\n  local -a row_col_sorted_rev_str_str_str_str_str\n\
    \  local -a row_col_sorted_rev_str_str_str_str_str_str\n  local -a row_col_sorted_rev_str_str_str_str_str_str_str\n\
    \  local -a row_col_sorted_rev_str_str_str_str_str_str_str_str\n  local -a row_col_sorted_rev_str_str_str_str_str_str_str_str_str\n\
    \  local -a row_col_sorted_rev_str_str_str_str_str_str_str_str_str_str\n  local\
    \ -a row_col_sorted_rev_str_str_str_str_str_str_str_str_str_str_str\n  local -a\
    \ row_col_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str\n  local\
    \ -a row_col_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str_str\n\
    \  local -a row_col_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str_str_str\n\
    \  local -a row_col_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str\n\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local row_res=()\n    while read -r line; do\n\
    \        col=0\n        row_res=()\n        for i in $line; do\n            if\
    \ [ \"$i\" == \"$x\" ]; then\n                row_res+=(\"[\\\"$row\\\", \\\"\
    $col\\\"]\")\n            fi\n            col=$((col+1))\n        done\n     \
    \   if [ ${#row_res[@]} -gt 0 ]; then\n            res+=(\"[${row_res[@]}]\")\n\
    \        fi\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"[${res[@]}]\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local row_res=()\n    local line\n    local item\n\
    \    while read -r line; do\n        col=0\n        while read -r item; do\n \
    \           if [[ \"$item\" == \"$x\" ]]; then\n                row_res+=(\"$row\"\
    )\n                row_res+=(\"$col\")\n                res+=(\"$(printf \"[%s]\"\
    \ \"$(printf '\"%s\" ' \"${row_res[@]}\")\")\")\n                row_res=()\n\
    \            fi\n            col=$((col + 1))\n        done <<< \"$line\"\n  \
    \      row=$((row + 1))\n    done <<< \"$lst\"\n    if [[ \"${#res[@]}\" -eq 0\
    \ ]]; then\n        echo \"[]\"\n    else\n        echo \"$(printf \"[%s]\" \"\
    $(printf '%s ' \"${res[@]}\")\")\"\n    fi\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    for i in $lst; do\n        if [[ $i == $x\
    \ ]]; then\n            result+=([\"$row,$col\"]=\"$row,$col\")\n        fi\n\
    \        if [[ $i == \"\\n\" ]]; then\n            row=$((row+1))\n          \
    \  col=0\n        else\n            col=$((col+1))\n        fi\n    done\n   \
    \ echo ${result[@]} | tr ' ' '\\n' | sort -t, -k1,1n -k2,2nr | tr '\\n' ' '\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local row=0\n  local col=0\n\
    \  local res=()\n  for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n    if [[ $i\
    \ == $x ]]; then\n      res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n    fi\n    if\
    \ [[ $i == $'\\n' ]]; then\n      row=$((row + 1))\n      col=0\n    else\n  \
    \    col=$((col + 1))\n    fi\n  done\n  echo \"${res[@]}\" | tr ' ' ',' | sed\
    \ 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed -e 's/^/[/' -e 's/$/]/'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ i=0\n    local j=0\n    for row in $lst; do\n        j=0\n        for col in\
    \ $row; do\n            if [[ $col == $x ]]; then\n                res+=(\"[\\\
    \"$i\\\", \\\"$j\\\"]\")\n            fi\n            j=$((j+1))\n        done\n\
    \        i=$((i+1))\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n  \
    \  get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n   \
    \ [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    for i in $(echo $lst | tr \" \" \"\\n\"\
    ); do\n        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\",\
    \ \\\"$col\\\"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n       \
    \     row=$((row+1))\n            col=0\n        else\n            col=$((col+1))\n\
    \        fi\n    done\n    echo ${result[@]} | tr \" \" \",\" | sed -e 's/^/[/'\
    \ -e 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ i=0\n    local j=0\n    for row in $lst; do\n        j=0\n        for col in\
    \ $row; do\n            if [[ $col == $x ]]; then\n                res+=(\"[\\\
    \"$i\\\", \\\"$j\\\"]\")\n            fi\n            ((j++))\n        done\n\
    \        ((i++))\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row_num=0\n\
    \    local col_num=0\n    local result=()\n    while read -r line; do\n      \
    \  col_num=0\n        for i in $line; do\n            if [[ \"$i\" == \"$x\" ]];\
    \ then\n                result+=(\"[\\\"$row_num\\\", \\\"$col_num\\\"]\")\n \
    \           fi\n            col_num=$((col_num + 1))\n        done\n        row_num=$((row_num\
    \ + 1))\n    done <<< \"$lst\"\n    echo \"${result[@]}\"\n}\n\ncandidate() {\n\
    \    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5\
    \ 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a rows=($(echo \"$lst\" | tr '\\n' ' '))\n    local -a row\n    local\
    \ -a cols\n    local -a col\n    local -a tmp\n    local -a tmp2\n    local -a\
    \ tmp3\n    local -a tmp4\n    local -a tmp5\n    local -a tmp6\n    local -a\
    \ tmp7\n    local -a tmp8\n    local -a tmp9\n    local -a tmp10\n    local -a\
    \ tmp11\n    local -a tmp12\n    local -a tmp13\n    local -a tmp14\n    local\
    \ -a tmp15\n    local -a tmp16\n    local -a tmp17\n    local -a tmp18\n    local\
    \ -a tmp19\n    local -a tmp20\n    local -a tmp21\n    local -a tmp22\n    local\
    \ -a tmp23\n    local -a tmp24\n    local -a tmp25\n    local -a tmp26\n    local\
    \ -a tmp27\n    local -a tmp28\n    local -a tmp29\n    local -a tmp30\n    local\
    \ -a tmp31\n    local -a tmp32\n    local -a tmp33\n    local -a tmp34\n    local\
    \ -a tmp35\n    local -a tmp36\n    local -a tmp37\n    local -a tmp38\n    local\
    \ -a tmp39\n    local -a tmp40\n    local -a tmp41\n    local -a tmp42\n    local\
    \ -a tmp43\n    local -a tmp44\n    local -a tmp45\n    local -a tmp46\n    local\
    \ -a tmp47\n    local -a tmp48\n    local -a tmp49\n    local -a tmp50\n    local\
    \ -a tmp51\n    local -a tmp52\n    local -a tmp53\n    local -a tmp54\n    local\
    \ -a tmp55\n    local -a tmp56\n    local -a tmp57\n    local -a tmp58\n    local\
    \ -a tmp59\n    local -a tmp60\n    local -a tmp61\n    local -a tmp62\n    local\
    \ -a tmp63\n    local -a tmp64\n   \n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_rev\n    local -a row_col_sorted_rev_str\n    local\
    \ -a row_col_sorted_rev_str_json\n    local -a row_col_sorted_rev_str_json_str\n\
    \    local -a row_col_sorted_rev_str_json_str_json\n    local -a row_col_sorted_rev_str_json_str_json_str\n\
    \    local -a row_col_sorted_rev_str_json_str_json_str_json\n    local -a row_col_sorted_rev_str_json_str_json_str_json_str\n\
    \    local -a row_col_sorted_rev_str_json_str_json_str_json_str_json\n    local\
    \ -a row_col_sorted_rev_str_json_str_json_str_json_str_json_str\n    local -a\
    \ row_col_sorted_rev_str_json_str_json_str_json_str_json_str_json\n    local -a\
    \ row_col_sorted_rev_str_json_str_json_str_json_str_json_str_json_str\n    local\
    \ -a row_col_sorted_rev_str_json_str_json_str_json_str_json_str_json_str_json\n\
    \    local -a row_col_sorted_rev_str_json_str_json_str_json_str_json_str_json_str_json_str\n\
    \    local -a row_col_sorted_rev_str_json_str_json_str_json_str_json_str_json_str_json_str_json\n\
    \    local -a row_col_sorted_rev_str_json_str_json_str_json_str_json_str_json_str_json_str_json_str\n\
    \    local -a row_col_sorted_rev_\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3\
    \ 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1\
    \ 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo $lst | tr ' ' '\\n'); do\n    \
    \    if [[ $i == $x ]]; then\n            res+=([$row,$col])\n        fi\n   \
    \     if [[ $i == \"\\n\" ]]; then\n            row=$((row+1))\n            col=0\n\
    \        else\n            col=$((col+1))\n        fi\n    done\n    echo ${res[@]}\
    \ | tr ' ' '\\n' | sort -k1 -n -k2 -r | tr '\\n' ' '\n}\n\ncandidate() {\n   \
    \ get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n   \
    \ [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local ret=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                ret+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${ret[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local y=0\n\
    \    local z=0\n    local res=()\n    while read -r line; do\n        z=0\n  \
    \      for i in $line; do\n            if [[ $i == $x ]]; then\n             \
    \   res+=(\"[\\\"$y\\\", \\\"$z\\\"]\")\n            fi\n            z=$((z+1))\n\
    \        done\n        y=$((y+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            res+=(\"[\\\"$row\\\", \\\
    \"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n       \
    \     row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/'\
    \ | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row=0\n\
    \    local col=0\n    local result=()\n    while read -r line; do\n        col=0\n\
    \        for i in $line; do\n            if [[ \"$i\" == \"$x\" ]]; then\n   \
    \             result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n   \
    \         col=$((col+1))\n        done\n        row=$((row+1))\n    done <<< \"\
    $lst\"\n    echo \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3\
    \ 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1\
    \ 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local i=0\n    local\
    \ j=0\n    local res=()\n    for row in $(echo \"$lst\" | tr '\\n' ' '); do\n\
    \        j=0\n        for col in $(echo \"$row\" | tr ' ' '\\n'); do\n       \
    \     if [[ \"$col\" == \"$x\" ]]; then\n                res+=(\"[\\\"$i\\\",\
    \ \\\"$j\\\"]\")\n            fi\n            j=$((j+1))\n        done\n     \
    \   i=$((i+1))\n    done\n    echo \"${res[@]}\" | tr ' ' '\\n' | sort -t '\"\
    ' -k 1,1n -k 3,3nr | tr '\\n' ' '\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3\
    \ 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1\
    \ 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i -eq $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb87oipxb.sh: line 26: [[: 6\\n1: syntax error: invalid arithmetic
    operator (error token is "\\n1")\n/tmp/tmpb87oipxb.sh: line 26: [[: 6\\n1: syntax
    error: invalid arithmetic operator (error token is "\\n1")\n'''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ row=0\n    local col=0\n    while read -r line; do\n        col=0\n        for\
    \ i in $line; do\n            if [ \"$i\" == \"$x\" ]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a rows=($(echo \"$lst\" | tr '\\n' ' '))\n    local -a cols=()\n  \
    \  local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local -a\
    \ col_row=()\n    local -a row_col_row=()\n    local -a col_row_col=()\n    local\
    \ -a row_col_row_col=()\n    local -a row_col_row_col_row=()\n    local -a col_row_col_row_col=()\n\
    \    local -a row_col_row_col_row_col=()\n    local -a col_row_col_row_col_row=()\n\
    \    local -a row_col_row_col_row_col_row=()\n    local -a col_row_col_row_col_row_col=()\n\
    \    local -a row_col_row_col_row_col_row_col=()\n    local -a col_row_col_row_col_row_col_row=()\n\
    \    local -a row_col_row_col_row_col_row_col_row=()\n    local -a col_row_col_row_col_row_col_row_col=()\n\
    \    local -a row_col_row_col_row_col_row_col_row_col=()\n    local -a col_row_col_row_col_row_col_row_col_row=()\n\
    \    local -a row_col_row_col_row_col_row_col_row_col_row=()\n    local -a col_row_col_row_col_row_col_row_col_row_col=()\n\
    \    local -a row_col_row_col_row_col_row_col_row_col_row_col=()\n    local -a\
    \ col_row_col_row_col_row_col_row_col_row_col_row=()\n    local -a row_col_row_col_row_col_\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local row_res=()\n    local row_res_sorted=()\n\
    \    local res_sorted=()\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"); do\n\
    \        if [ \"$i\" == \"$x\" ]; then\n            row_res+=($row $col)\n   \
    \     fi\n        if [ \"$i\" == \"\\n\" ]; then\n            row=$((row+1))\n\
    \            col=0\n            row_res_sorted=$(echo \"${row_res[@]}\" | tr \"\
    \ \" \"\\n\" | sort -r -n | tr \"\\n\" \" \")\n            res+=($row_res_sorted)\n\
    \            row_res=()\n        else\n            col=$((col+1))\n        fi\n\
    \    done\n    res_sorted=$(echo \"${res[@]}\" | tr \" \" \"\\n\" | sort -n |\
    \ tr \"\\n\" \" \")\n    echo \"$res_sorted\" | tr \" \" \"\\n\" | awk '{print\
    \ \"[\\\"\"$1\"\\\", \\\"\"$2\"\\\"]\"}' | tr \"\\n\" \",\" | sed 's/,$//'\n}\n\
    \ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a arr=()\n \
    \   local -a res=()\n    local -a tmp=()\n    local -a tmp2=()\n    local -a tmp3=()\n\
    \    local -a tmp4=()\n    local -a tmp5=()\n    local -a tmp6=()\n    local -a\
    \ tmp7=()\n    local -a tmp8=()\n    local -a tmp9=()\n    local -a tmp10=()\n\
    \    local -a tmp11=()\n    local -a tmp12=()\n    local -a tmp13=()\n    local\
    \ -a tmp14=()\n    local -a tmp15=()\n    local -a tmp16=()\n    local -a tmp17=()\n\
    \    local -a tmp18=()\n    local -a tmp19=()\n    local -a tmp20=()\n    local\
    \ -a tmp21=()\n    local -a tmp22=()\n    local -a tmp23=()\n    local -a tmp24=()\n\
    \    local -a tmp25=()\n    local -a tmp26=()\n    local -a tmp27=()\n    local\
    \ -a tmp28=()\n    local -a tmp29=()\n    local -a tmp30=()\n    local -a tmp31=()\n\
    \    local -a tmp32=()\n    local -a tmp33=()\n    local -a tmp34=()\n    local\
    \ -a tmp35=()\n    local -a tmp36=()\n    local -a tmp37=()\n    local -a tmp38=()\n\
    \    local -a tmp39=()\n    local -a tmp40=()\n    local -a tmp41=()\n    local\
    \ -a tmp42=()\n    local -a tmp43=()\n    local -a tmp44=()\n    local -a tmp45=()\n\
    \    local -a tmp46=()\n    local -a tmp47=()\n    local -a tmp48=()\n    local\
    \ -a tmp49=()\n    local -a tmp50=()\n    local -a tmp51=()\n    local -a tmp52=()\n\
    \    local -a tmp53=()\n    local -a tmp54\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            res+=(\"[\\\"$row\\\", \\\
    \"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n       \
    \     row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${res[@]}\" | tr \" \" \"\\n\" | sort\
    \ -t \"\\\"\" -k 2 -n -r | sort -t \"\\\"\" -k 1 -n\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -i row=0\n    local -i col=0\n    while read -r line; do\n        col=0\n\
    \        for i in $line; do\n            if [[ $i == $x ]]; then\n           \
    \     result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n           \
    \ ((col++))\n        done\n        ((row++))\n    done <<< \"$lst\"\n    echo\
    \ \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a result_sorted\n    local -a row_col_sorted_rev\n    local -a result_sorted_rev\n\
    \    local -a result_sorted_rev_str\n    local -a result_sorted_rev_str_str\n\
    \    local -a result_sorted_rev_str_str_str\n    local -a result_sorted_rev_str_str_str_str\n\
    \    local -a result_sorted_rev_str_str_str_str_str\n    local -a result_sorted_rev_str_str_str_str_str_str\n\
    \    local -a result_sorted_rev_str_str_str_str_str_str_str\n    local -a result_sorted_rev_str_str_str_str_str_str_str_str\n\
    \    local -a result_sorted_rev_str_str_str_str_str_str_str_str_str\n    local\
    \ -a result_sorted_rev_str_str_str_str_str_str_str_str_str_str\n    local -a result_sorted_rev_str_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a result_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a result_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a result_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a result_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str\n\
    \    local -a result_sorted_rev_str_str_str_str_str_str_\n}\n\ncandidate() {\n\
    \    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5\
    \ 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a col=()\n    local -a arr=()\n    local -a arr2=()\n\
    \    local -a arr3=()\n    local -a arr4=()\n    local -a arr5=()\n    local -a\
    \ arr6=()\n    local -a arr7=()\n    local -a arr8=()\n    local -a arr9=()\n\
    \    local -a arr10=()\n    local -a arr11=()\n    local -a arr12=()\n    local\
    \ -a arr13=()\n    local -a arr14=()\n    local -a arr15=()\n    local -a arr16=()\n\
    \    local -a arr17=()\n    local -a arr18=()\n    local -a arr19=()\n    local\
    \ -a arr20=()\n    local -a arr21=()\n    local -a arr22=()\n    local -a arr23=()\n\
    \    local -a arr24=()\n    local -a arr25=()\n    local -a arr26=()\n    local\
    \ -a arr27=()\n    local -a arr28=()\n    local -a arr29=()\n    local -a arr30=()\n\
    \    local -a arr31=()\n    local -a arr32=()\n    local -a arr33=()\n    local\
    \ -a arr34=()\n    local -a arr35=()\n    local -a arr36=()\n    local -a arr37=()\n\
    \    local -a arr38=()\n    local -a arr39=()\n    local -a arr40=()\n    local\
    \ -a arr41=()\n    local -a arr42=()\n    local -a arr43=()\n    local -a arr44=()\n\
    \    local -a arr45=()\n    local -a arr46=()\n    local -a arr47=()\n    local\
    \ -a arr48=()\n    local -a arr49=()\n    local -a arr50=()\n    local -a arr51=()\n\
    \    local -a arr52=()\n    local -a arr53=\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local -a result=()\n\
    \    local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local\
    \ -a row_col_sorted=()\n    local -a row_col_sorted_rev=()\n    local -a row_col_sorted_rev_str=()\n\
    \    local -a row_col_sorted_rev_str_quoted=()\n    local -a row_col_sorted_rev_str_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_quoted=()\n    local -a row_col_sorted_rev_str_quoted_joined_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_quoted_joined_quoted=()\n \
    \   local -a row_col_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3\
    \ 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1\
    \ 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a arr=()\n \
    \   while read -r line; do\n        local -a line_arr=($line)\n        for ((i=0;\
    \ i<${#line_arr[@]}; i++)); do\n            if [[ ${line_arr[$i]} == $x ]]; then\n\
    \                arr+=(\"[\\\"$((${#arr[@]} / 2))\\\", \\\"$i\\\"]\")\n      \
    \      fi\n        done\n    done <<< \"$lst\"\n    echo \"${arr[@]}\"\n}\n\n\
    candidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a rows\n    local -a row\n    local -a cols\n    local -a col\n    local -a\
    \ row_col\n    local -a row_cols\n    local -a row_cols_sorted\n    local -a res_sorted\n\
    \    local -a res_sorted_unique\n    local -a res_sorted_unique_sorted\n    local\
    \ -a res_sorted_unique_sorted_sorted\n    local row_col_sorted\n    local row_cols_sorted_sorted\n\
    \    local res_sorted_unique_sorted_sorted_sorted\n    local i\n    local j\n\
    \    local k\n    local l\n    local m\n    local n\n    local o\n    local p\n\
    \    local q\n    local r\n    local s\n    local t\n    local u\n    local v\n\
    \    local w\n    local x\n    local y\n    local z\n    local aa\n    local bb\n\
    \    local cc\n    local dd\n    local ee\n    local ff\n    local gg\n    local\
    \ hh\n    local ii\n    local jj\n    local kk\n    local ll\n    local mm\n \
    \   local nn\n    local oo\n    local pp\n    local qq\n    local rr\n    local\
    \ ss\n    local tt\n    local uu\n    local vv\n    local ww\n    local xx\n \
    \   local yy\n    local zz\n    local aaa\n    local bbb\n    local ccc\n    local\
    \ ddd\n    local eee\n    local fff\n    local ggg\n    local hhh\n    local iii\n\
    \    local jjj\n    local kkk\n    local lll\n    local mmm\n    local nnn\n \
    \   local ooo\n    local ppp\n    local qqq\n    local rrr\n    local sss\n  \
    \  local ttt\n    local uuu\n    local vvv\n    local www\n    local xxx\n   \
    \ local yyy\n    local zzz\n    local aaaa\n    local bbbb\n    local cccc\n \
    \   local dddd\n    local e\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5\
    \ 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\"\
    \ \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a rows\n    local -a cols\n    local -a row\n    local -a col\n    local -a\
    \ row_col\n    local -a row_col_sorted\n    local -a row_col_sorted_rev\n    local\
    \ -a row_col_sorted_rev_str\n    local -a row_col_sorted_rev_str_sorted\n    local\
    \ -a row_col_sorted_rev_str_sorted_rev\n    local -a row_col_sorted_rev_str_sorted_rev_str\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted\n    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str\n    local\
    \ -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted\n    local -a\
    \ row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev\n    local -a\
    \ row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str\n    local\
    \ -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted\n\
    \    local -a row_col_\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"\
    1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\")\
    \ = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\\
    n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate\
    \ \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            result+=(\"[\\\"$row\\\"\
    , \\\"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\" ]]; then\n      \
    \      row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/'\
    \ | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result=()\n\
    \    local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_rev\n    local -a row_col_sorted_rev_str\n    local\
    \ -a row_col_sorted_rev_str_sorted\n    local -a row_col_sorted_rev_str_sorted_rev\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str\n    local -a row_col_sorted_rev_str_sorted_rev_str_sorted\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev\n    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted\n  \
    \  local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted\n\
    \    local -a row_col_sorted_rev_str_sorted_rev\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a rows\n   \
    \ local -a columns\n    local -a result\n    local -a row\n    local -a column\n\
    \    local -a row_column\n    local -a row_columns\n    local -a row_columns_sorted\n\
    \    local -i i\n    local -i j\n    local -i k\n    local -i l\n    local -i\
    \ m\n    local -i n\n    local -i o\n    local -i p\n    local -i q\n    local\
    \ -i r\n    local -i s\n    local -i t\n    local -i u\n    local -i v\n    local\
    \ -i w\n    local -i x\n    local -i y\n    local -i z\n    local -i aa\n    local\
    \ -i bb\n    local -i cc\n    local -i dd\n    local -i ee\n    local -i ff\n\
    \    local -i gg\n    local -i hh\n    local -i ii\n    local -i jj\n    local\
    \ -i kk\n    local -i ll\n    local -i mm\n    local -i nn\n    local -i oo\n\
    \    local -i pp\n    local -i qq\n    local -i rr\n    local -i ss\n    local\
    \ -i tt\n    local -i uu\n    local -i vv\n    local -i ww\n    local -i xx\n\
    \    local -i yy\n    local -i zz\n    local -i aaa\n    local -i bbb\n    local\
    \ -i ccc\n    local -i ddd\n    local -i eee\n    local -i fff\n    local -i ggg\n\
    \    local -i hhh\n    local -i iii\n    local -i jjj\n    local -i kkk\n    local\
    \ -i lll\n    local -i mmm\n    local -i nnn\n    local -i ooo\n    local -i ppp\n\
    \    local -i qqq\n    local -i rrr\n    local -i sss\n    local -i ttt\n    local\
    \ -i uuu\n    local -i vvv\n    local -i www\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=\"\"\n\
    \    local row=0\n    local col=0\n    local max_col=0\n    local max_row=0\n\
    \    local max_col_row=0\n    local max_col_col=0\n    local max_row_row=0\n \
    \   local max_row_col=0\n    local max_row_val=0\n    local max_col_val=0\n  \
    \  local max_row_val_row=0\n    local max_row_val_col=0\n    local max_col_val_row=0\n\
    \    local max_col_val_col=0\n    local max_row_val_row_col=0\n    local max_row_val_row_val=0\n\
    \    local max_col_val_row_col=0\n    local max_col_val_row_val=0\n    local max_row_val_row_col_val=0\n\
    \    local max_col_val_row_col_val=0\n    local max_row_val_row_col_val_row=0\n\
    \    local max_row_val_row_col_val_col=0\n    local max_col_val_row_col_val_row=0\n\
    \    local max_col_val_row_col_val_col=0\n    local max_row_val_row_col_val_row_col=0\n\
    \    local max_row_val_row_col_val_row_val=0\n    local max_col_val_row_col_val_row_col=0\n\
    \    local max_col_val_row_col_val_row_val=0\n    local max_row_val_row_col_val_row_col_val=0\n\
    \    local max_col_val_row_col_val_row_col_val=0\n    local max_row_val_row_col_val_row_col_val_row=0\n\
    \    local max_row_val_row_col_val_row_col_val_col=0\n    local max_col_val_row_col_val_row_col_val_row=0\n\
    \   \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\\
    n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\\
    n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3\
    \ 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n \
    \   [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\
    \" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed\
    \ 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\\
    n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\\
    n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\
    \ = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\"\
    \ ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\"\
    ) = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local -a\
    \ row_col_sorted=()\n    local -a row_col_sorted_rev=()\n    local -a row_col_sorted_rev_str=()\n\
    \    local -a row_col_sorted_rev_str_joined=()\n    local -a row_col_sorted_rev_str_joined_str=()\n\
    \    local -a res_str=()\n    local -a res_str_joined=()\n    local -a res_str_joined_str=()\n\
    \    local -a res_str_joined_str_joined=()\n    local -a res_str_joined_str_joined_str=()\n\
    \    local -a res_str_joined_str_joined_str_joined=()\n    local -a res_str_joined_str_joined_str_joined_str=()\n\
    \    local -a res_str_joined_str_joined_str_joined_str_joined=()\n    local -a\
    \ res_str_joined_str_joined_str_joined_str_joined_str=()\n    local -a res_str_joined_str_joined_str_joined_str_joined_str_joined=()\n\
    \    local -a res_str_joined_str_joined_str_joined_str_joined_str_joined_str=()\n\
    \    local -a res_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined=()\n\
    \    local -a res_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined_str=()\n\
    \    local -a res_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined=()\n\
    \    local -a res_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined_str=()\n\
    \    local -a res_str_joined_str_joined_str_joined_str\n}\n\ncandidate() {\n \
    \   get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5\
    \ 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row=0\n\
    \    local col=0\n    local result=()\n    while read -r line; do\n        col=0\n\
    \        for i in $line; do\n            if [[ \"$i\" == \"$x\" ]]; then\n   \
    \             result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n   \
    \         col=$((col+1))\n        done\n        row=$((row+1))\n    done <<< \"\
    $lst\"\n    echo \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3\
    \ 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1\
    \ 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_desc\n    local -a row_col_sorted_desc_str\n    local\
    \ -a row_col_sorted_desc_str_sorted\n    local -a row_col_sorted_desc_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted\n    local -a row_col_sorted_desc_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted\n    local\
    \ -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str\n    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=\"\"\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"\
    )\n    do\n        if [ \"$i\" == \"$x\" ]; then\n            result=\"$result\
    \ [\\\"$row\\\", \\\"$col\\\"]\"\n        fi\n        if [ \"$i\" == \"\\n\" ];\
    \ then\n            row=$((row+1))\n            col=0\n        else\n        \
    \    col=$((col+1))\n        fi\n    done\n    echo \"$result\" | sort -t '\"\
    ' -k2 -n -r -t '\"' -k1 -n\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"\
    1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\")\
    \ = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\\
    n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate\
    \ \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a arr=()\n \
    \   local -a res=()\n    local -a row=()\n    local -a col=()\n    local -a tmp=()\n\
    \    local -a tmp2=()\n    local -a tmp3=()\n    local -a tmp4=()\n    local -a\
    \ tmp5=()\n    local -a tmp6=()\n    local -a tmp7=()\n    local -a tmp8=()\n\
    \    local -a tmp9=()\n    local -a tmp10=()\n    local -a tmp11=()\n    local\
    \ -a tmp12=()\n    local -a tmp13=()\n    local -a tmp14=()\n    local -a tmp15=()\n\
    \    local -a tmp16=()\n    local -a tmp17=()\n    local -a tmp18=()\n    local\
    \ -a tmp19=()\n    local -a tmp20=()\n    local -a tmp21=()\n    local -a tmp22=()\n\
    \    local -a tmp23=()\n    local -a tmp24=()\n    local -a tmp25=()\n    local\
    \ -a tmp26=()\n    local -a tmp27=()\n    local -a tmp28=()\n    local -a tmp29=()\n\
    \    local -a tmp30=()\n    local -a tmp31=()\n    local -a tmp32=()\n    local\
    \ -a tmp33=()\n    local -a tmp34=()\n    local -a tmp35=()\n    local -a tmp36=()\n\
    \    local -a tmp37=()\n    local -a tmp38=()\n    local -a tmp39=()\n    local\
    \ -a tmp40=()\n    local -a tmp41=()\n    local -a tmp42=()\n    local -a tmp43=()\n\
    \    local -a tmp44=()\n    local -a tmp45=()\n    local -a tmp46=()\n    local\
    \ -a tmp47=()\n    local -a tmp48=()\n    local -a tmp49=()\n    local -a tmp50=()\n\
    \    local -a tmp51=()\n    local -a tmp52=()\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local row=0\n  local col=0\n\
    \  local res=()\n  while read -r line; do\n    col=0\n    for i in $line; do\n\
    \      if [[ $i == $x ]]; then\n        res+=([\"$row,$col\"]=\"$row,$col\")\n\
    \      fi\n      col=$((col+1))\n    done\n    row=$((row+1))\n  done <<< \"$lst\"\
    \n  if [[ ${#res[@]} -eq 0 ]]; then\n    echo \"[]\"\n  else\n    local sorted_res=()\n\
    \    for i in \"${!res[@]}\"; do\n      sorted_res+=($i)\n    done\n    IFS=$'\\\
    n' sorted_res=($(sort <<<\"${sorted_res[*]}\"))\n    unset IFS\n    local res_str=\"\
    \"\n    for i in \"${sorted_res[@]}\"; do\n      res_str+=\"[\\\"${res[$i]}\\\"\
    ]\"\n    done\n    echo \"[$res_str]\"\n  fi\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local row_res=()\n    local row_res_sorted=()\n\
    \    local res_sorted=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n \
    \       if [[ \"$i\" = \"$x\" ]]; then\n            row_res+=(\"$row\" \"$col\"\
    )\n        fi\n        if [[ \"$i\" =~ ^[0-9]+$ ]]; then\n            col=$((col+1))\n\
    \        else\n            col=0\n            row=$((row+1))\n        fi\n   \
    \ done\n    if [[ ${#row_res[@]} -gt 0 ]]; then\n        for i in $(seq 0 2 $((${#row_res[@]}-1)));\
    \ do\n            row_res_sorted+=(\"${row_res[$i]}\" \"${row_res[$((i+1))]}\"\
    )\n        done\n        IFS=$'\\n' row_res_sorted=($(sort -t ' ' -k 1,1n -k 2,2nr\
    \ <<<\"${row_res_sorted[*]}\"))\n        for i in $(seq 0 2 $((${#row_res_sorted[@]}-1)));\
    \ do\n            res+=(\"\\\"${row_res_sorted[$i]}\\\"\" \"\\\"${row_res_sorted[$((i+1))]}\\\
    \"\")\n        done\n    fi\n    echo \"[${res[*]}]\"\n}\n\ncandidate() {\n  \
    \  get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n   \
    \ [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\" | tr \" \" \"\\n\" | sort -t \"\\\"\"\
    \ -k 2 -n -r | sort -t \"\\\"\" -k 1 -n\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local row_res=()\n    while read -r line; do\n\
    \        col=0\n        row_res=()\n        for i in $line; do\n            if\
    \ [[ $i == $x ]]; then\n                row_res+=([\"$row\"]=\"$col\")\n     \
    \       fi\n            col=$((col+1))\n        done\n        if [[ ${#row_res[@]}\
    \ -gt 0 ]]; then\n            res+=([\"$row\"]=\"${row_res[@]}\")\n        fi\n\
    \        row=$((row+1))\n    done <<< \"$lst\"\n    local res_str=()\n    for\
    \ i in \"${!res[@]}\"; do\n        for j in ${res[$i]}; do\n            res_str+=(\"\
    [\\\"$i\\\", \\\"$j\\\"]\")\n        done\n    done\n    echo \"[${res_str[@]}]\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a arr=()\n    local -a tmp=()\n    local -a tmp2=()\n    local -a tmp3=()\n\
    \    local -a tmp4=()\n    local -a tmp5=()\n    local -a tmp6=()\n    local -a\
    \ tmp7=()\n    local -a tmp8=()\n    local -a tmp9=()\n    local -a tmp10=()\n\
    \    local -a tmp11=()\n    local -a tmp12=()\n    local -a tmp13=()\n    local\
    \ -a tmp14=()\n    local -a tmp15=()\n    local -a tmp16=()\n    local -a tmp17=()\n\
    \    local -a tmp18=()\n    local -a tmp19=()\n    local -a tmp20=()\n    local\
    \ -a tmp21=()\n    local -a tmp22=()\n    local -a tmp23=()\n    local -a tmp24=()\n\
    \    local -a tmp25=()\n    local -a tmp26=()\n    local -a tmp27=()\n    local\
    \ -a tmp28=()\n    local -a tmp29=()\n    local -a tmp30=()\n    local -a tmp31=()\n\
    \    local -a tmp32=()\n    local -a tmp33=()\n    local -a tmp34=()\n    local\
    \ -a tmp35=()\n    local -a tmp36=()\n    local -a tmp37=()\n    local -a tmp38=()\n\
    \    local -a tmp39=()\n    local -a tmp40=()\n    local -a tmp41=()\n    local\
    \ -a tmp42=()\n    local -a tmp43=()\n    local -a tmp44=()\n    local -a tmp45=()\n\
    \    local -a tmp46=()\n    local -a tmp47=()\n    local -a tmp48=()\n    local\
    \ -a tmp49=()\n    local -a tmp50=()\n    local -a tmp51=()\n    local -a tmp52=()\n\
    \    local -a tmp53=()\n    local -a tmp54\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local row=0\n  local col=0\n\
    \  local res=()\n  local row_res=()\n  while read -r line; do\n    col=0\n   \
    \ row_res=()\n    for i in $line; do\n      if [ \"$i\" == \"$x\" ]; then\n  \
    \      row_res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n      fi\n      col=$((col+1))\n\
    \    done\n    if [ ${#row_res[@]} -gt 0 ]; then\n      res+=(\"$(echo \"${row_res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/')\")\n    fi\n    row=$((row+1))\n\
    \  done <<< \"$lst\"\n  echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a rows=($(echo \"$lst\" | tr -s ' ' '\\n'))\n    for ((i=0; i<${#rows[@]};\
    \ i++)); do\n        local -a row=($(echo \"${rows[$i]}\" | tr -s ' ' '\\n'))\n\
    \        for ((j=0; j<${#row[@]}; j++)); do\n            if [[ \"${row[$j]}\"\
    \ == \"$x\" ]]; then\n                res+=(\"[\\\"$i\\\", \\\"$j\\\"]\")\n  \
    \          fi\n        done\n    done\n    echo \"${res[@]}\" | tr ' ' '\\n' |\
    \ sort -t '\"' -k 2 -n -r | sort -t '\"' -k 1 -n\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a rows=($(echo \"$lst\" | tr '\\n' ' '))\n    local -a cols=()\n  \
    \  local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local -a\
    \ col_col=()\n    local -a row_col_col=()\n    local -a col_col_col=()\n    local\
    \ -a row_col_col_col=()\n    local -a col_col_col_col=()\n    local -a row_col_col_col_col=()\n\
    \    local -a col_col_col_col_col=()\n    local -a row_col_col_col_col_col=()\n\
    \    local -a col_col_col_col_col_col=()\n    local -a row_col_col_col_col_col_col=()\n\
    \    local -a col_col_col_col_col_col_col=()\n    local -a row_col_col_col_col_col_col_col=()\n\
    \    local -a col_col_col_col_col_col_col_col=()\n    local -a row_col_col_col_col_col_col_col_col=()\n\
    \    local -a col_col_col_col_col_col_col_col_col=()\n    local -a row_col_col_col_col_col_col_col_col_col=()\n\
    \    local -a col_col_col_col_col_col_col_col_col_col=()\n    local -a row_col_col_col_col_col_col_col_col_col_col=()\n\
    \    local -a col_col_col_col_col_col_col_col_col_col_col=()\n    local -a row_col_col_col_col_col_col_col_col_col_col_col=()\n\
    \    local -a col_col_col_col_col_col_col_col_col_col_col_col=()\n    local\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a rows=()\n    local -a cols=()\n    local -a\
    \ col=()\n    local -a tmp=()\n    local -a tmp2=()\n    local -a tmp3=()\n  \
    \  local -a tmp4=()\n    local -a tmp5=()\n    local -a tmp6=()\n    local -a\
    \ tmp7=()\n    local -a tmp8=()\n    local -a tmp9=()\n    local -a tmp10=()\n\
    \    local -a tmp11=()\n    local -a tmp12=()\n    local -a tmp13=()\n    local\
    \ -a tmp14=()\n    local -a tmp15=()\n    local -a tmp16=()\n    local -a tmp17=()\n\
    \    local -a tmp18=()\n    local -a tmp19=()\n    local -a tmp20=()\n    local\
    \ -a tmp21=()\n    local -a tmp22=()\n    local -a tmp23=()\n    local -a tmp24=()\n\
    \    local -a tmp25=()\n    local -a tmp26=()\n    local -a tmp27=()\n    local\
    \ -a tmp28=()\n    local -a tmp29=()\n    local -a tmp30=()\n    local -a tmp31=()\n\
    \    local -a tmp32=()\n    local -a tmp33=()\n    local -a tmp34=()\n    local\
    \ -a tmp35=()\n    local -a tmp36=()\n    local -a tmp37=()\n    local -a tmp38=()\n\
    \    local -a tmp39=()\n    local -a tmp40=()\n    local -a tmp41=()\n    local\
    \ -a tmp42=()\n    local -a tmp43=()\n    local -a tmp44=()\n    local -a tmp45=()\n\
    \    local -a tmp46=()\n    local -a tmp47=()\n    local -a tmp48=()\n    local\
    \ -a tmp49=()\n    local -a tmp50=()\n    local -a tmp51=()\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a tmp\n    local -a tmp2\n    local -a tmp3\n    local -a tmp4\n    local -a\
    \ tmp5\n    local -a tmp6\n    local -a tmp7\n    local -a tmp8\n    local -a\
    \ tmp9\n    local -a tmp10\n    local -a tmp11\n    local -a tmp12\n    local\
    \ -a tmp13\n    local -a tmp14\n    local -a tmp15\n    local -a tmp16\n    local\
    \ -a tmp17\n    local -a tmp18\n    local -a tmp19\n    local -a tmp20\n    local\
    \ -a tmp21\n    local -a tmp22\n    local -a tmp23\n    local -a tmp24\n    local\
    \ -a tmp25\n    local -a tmp26\n    local -a tmp27\n    local -a tmp28\n    local\
    \ -a tmp29\n    local -a tmp30\n    local -a tmp31\n    local -a tmp32\n    local\
    \ -a tmp33\n    local -a tmp34\n    local -a tmp35\n    local -a tmp36\n    local\
    \ -a tmp37\n    local -a tmp38\n    local -a tmp39\n    local -a tmp40\n    local\
    \ -a tmp41\n    local -a tmp42\n    local -a tmp43\n    local -a tmp44\n    local\
    \ -a tmp45\n    local -a tmp46\n    local -a tmp47\n    local -a tmp48\n    local\
    \ -a tmp49\n    local -a tmp50\n    local -a tmp51\n    local -a tmp52\n    local\
    \ -a tmp53\n    local -a tmp54\n    local -a tmp55\n    local -a tmp56\n    local\
    \ -a tmp57\n    local -a tmp58\n    local -a tmp59\n    local -a tmp60\n    local\
    \ -a tmp61\n    local -a tmp62\n    local -a tmp63\n    local -a tmp64\n    local\
    \ -a tmp65\n    local -a tmp66\n    local -a tmp67\n    local -a tmp68\n    local\
    \ -a tmp69\n    local -a tmp70\n    local -\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            res+=(\"[\\\"$row\\\", \\\
    \"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n       \
    \     row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/'\
    \ | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a col=()\n    local -a rows=()\n    local -a cols=()\n\
    \    local -a tmp=()\n    local -a tmp2=()\n    local -a tmp3=()\n    local -a\
    \ tmp4=()\n    local -a tmp5=()\n    local -a tmp6=()\n    local -a tmp7=()\n\
    \    local -a tmp8=()\n    local -a tmp9=()\n    local -a tmp10=()\n    local\
    \ -a tmp11=()\n    local -a tmp12=()\n    local -a tmp13=()\n    local -a tmp14=()\n\
    \    local -a tmp15=()\n    local -a tmp16=()\n    local -a tmp17=()\n    local\
    \ -a tmp18=()\n    local -a tmp19=()\n    local -a tmp20=()\n    local -a tmp21=()\n\
    \    local -a tmp22=()\n    local -a tmp23=()\n    local -a tmp24=()\n    local\
    \ -a tmp25=()\n    local -a tmp26=()\n    local -a tmp27=()\n    local -a tmp28=()\n\
    \    local -a tmp29=()\n    local -a tmp30=()\n    local -a tmp31=()\n    local\
    \ -a tmp32=()\n    local -a tmp33=()\n    local -a tmp34=()\n    local -a tmp35=()\n\
    \    local -a tmp36=()\n    local -a tmp37=()\n    local -a tmp38=()\n    local\
    \ -a tmp39=()\n    local -a tmp40=()\n    local -a tmp41=()\n    local -a tmp42=()\n\
    \    local -a tmp43=()\n    local -a tmp44=()\n    local -a tmp45=()\n    local\
    \ -a tmp46=()\n    local -a tmp47=()\n    local -a tmp48=()\n    local -a tmp49=()\n\
    \    local -a tmp50=()\n    local -a tmp51=()\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_desc\n    local -a row_col_sorted_desc_str\n    local\
    \ -a row_col_sorted_desc_str_json\n    local -a row_col_sorted_desc_str_json_str\n\
    \    local -a row_col_sorted_desc_str_json_str_json\n    local -a row_col_sorted_desc_str_json_str_json_str\n\
    \    local -a row_col_sorted_desc_str_json_str_json_str_json\n    local -a row_col_sorted_desc_str_json_str_json_str_json_str\n\
    \    local -a row_col_sorted_desc_str_json_str_json_str_json_str_json\n    local\
    \ -a row_col_sorted_desc_str_json_str_json_str_json_str_json_str\n    local -a\
    \ row_col_sorted_desc_str_json_str_json_str_json_str_json_str_json\n    local\
    \ -a row_col_sorted_desc_str_json_str_json_str_json_str_json_str_json_str\n  \
    \  local -a row_col_sorted_desc_str_json_str_json_str_json_str_json_str_json_str_json\n\
    \    local -a row_col_sorted_desc_str_json_str_json_str_json_str_json_str_json_str_json_str\n\
    \    local -a row_col_sorted_desc_str_json_str_json_str_json_str_json_str_json_str_json_str_json\n\
    \    local -a row_col_sorted_desc_str_json_str_json_str_json_str_json_str_json_str_json_str_json_str\n\
    \    local -a row_col_sorted_desc_\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3\
    \ 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1\
    \ 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    for i in $lst; do\n        local col=0\n        for j in\
    \ $i; do\n            if [[ $j == $x ]]; then\n                result+=(\"[\\\"\
    $row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n     \
    \   done\n        row=$((row+1))\n    done\n    echo ${result[@]}\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row=0\n\
    \    local col=0\n    local res=()\n    while read -r line; do\n        col=0\n\
    \        for i in $line; do\n            if [[ \"$i\" == \"$x\" ]]; then\n   \
    \             res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n      \
    \      col=$((col+1))\n        done\n        row=$((row+1))\n    done <<< \"$lst\"\
    \n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [ \"$i\" == \"$x\" ]; then\n            \
    \    res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a rows=($(echo \"$lst\" | tr '\\n' ' '))\n    local -a cols=()\n  \
    \  local -a row_cols=()\n    local -a row_cols_sorted=()\n    local -a row_cols_sorted_rev=()\n\
    \    local -a row_cols_sorted_rev_str=()\n    local -a row_cols_sorted_rev_str_res=()\n\
    \    local -a row_cols_sorted_rev_str_res_str=()\n    local -a row_cols_sorted_rev_str_res_str_res=()\n\
    \    local -a row_cols_sorted_rev_str_res_str_res_str=()\n    local -a row_cols_sorted_rev_str_res_str_res_str_res=()\n\
    \    local -a row_cols_sorted_rev_str_res_str_res_str_res_str=()\n    local -a\
    \ row_cols_sorted_rev_str_res_str_res_str_res_str_res=()\n    local -a row_cols_sorted_rev_str_res_str_res_str_res_str_res_str=()\n\
    \    local -a row_cols_sorted_rev_str_res_str_res_str_res_str_res_str_res=()\n\
    \    local -a row_cols_sorted_rev_str_res_str_res_str_res_str_res_str_res_str=()\n\
    \    local -a row_cols_sorted_rev_str_res_str_res_str_res_str_res_str_res_str_res=()\n\
    \    local -a row_cols_sorted_rev_str_res_str_res_str_res_str_res_str_res_str_res_str=()\n\
    \    local -a row_cols_sorted_rev_str_res_str_res_str_res_str\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    for i in $(echo \"$lst\" | tr ' ' '\\n');\
    \ do\n        if [[ \"$i\" == \"$x\" ]]; then\n            result+=(\"[\\\"$row\\\
    \", \\\"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n \
    \           row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/'\
    \ | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result=()\n\
    \    local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local\
    \ -a row_col_sorted=()\n    local -a result_sorted=()\n    local -a row_col_sorted_final=()\n\
    \    local -a result_sorted_final=()\n    local -a row_col_sorted_final_final=()\n\
    \    local -a result_sorted_final_final=()\n    local -a row_col_sorted_final_final_final=()\n\
    \    local -a result_sorted_final_final_final=()\n    local -a row_col_sorted_final_final_final_final=()\n\
    \    local -a result_sorted_final_final_final_final=()\n    local -a row_col_sorted_final_final_final_final_final=()\n\
    \    local -a result_sorted_final_final_final_final_final=()\n    local -a row_col_sorted_final_final_final_final_final_final=()\n\
    \    local -a result_sorted_final_final_final_final_final_final=()\n    local\
    \ -a row_col_sorted_final_final_final_final_final_final_final=()\n    local -a\
    \ result_sorted_final_final_final_final_final_final_final=()\n    local -a row_col_sorted_final_final_final_final_final_final_final_final=()\n\
    \    local -a result_sorted_final_final_final_final_final_final_final_final=()\n\
    \    local -a row_col_sorted_final_final_final_final_final_final_final_final_final=()\n\
    \    local -a result_sorted_final_final_final_final_final_final_final_final_final=()\n\
    \    local -a row_col_sorted_final_final_final_final_final_final_final_final_final_final=()\n\
    \    local -a result_sorted_final_\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3\
    \ 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1\
    \ 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo $lst | tr ' ' '\\n'); do\n    \
    \    if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\"\
    ]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row+1))\n\
    \            col=0\n        else\n            col=$((col+1))\n        fi\n   \
    \ done\n    echo ${res[@]} | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"\
    ); do\n        if [[ \"$i\" == \"$x\" ]]; then\n            result+=(\"[\\\"$row\\\
    \", \\\"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n \
    \           row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr \" \" \"\\n\" |\
    \ sort -t \",\" -k 1,1 -k 2,2 -r | tr \"\\n\" \" \"\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=([\"$row,$col\"])\n       \
    \ fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row + 1))\n    \
    \        col=0\n        else\n            col=$((col + 1))\n        fi\n    done\n\
    \    echo \"${res[@]}\" | tr ' ' '\\n' | sort -t, -k1,1n -k2,2nr | tr '\\n' '\
    \ '\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\\
    n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\\
    n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3\
    \ 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n \
    \   [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\
    \" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local -a res=()\n\
    \    local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local\
    \ -a row_col_res=()\n    local -a row_col_res_sorted=()\n    local -a row_col_res_sorted_res=()\n\
    \    local -a row_col_res_sorted_res_res=()\n    local -a row_col_res_sorted_res_res_res=()\n\
    \    local -a row_col_res_sorted_res_res_res_res=()\n    local -a row_col_res_sorted_res_res_res_res_res=()\n\
    \    local -a row_col_res_sorted_res_res_res_res_res_res=()\n    local -a row_col_res_sorted_res_res_res_res_res_res_res=()\n\
    \    local -a row_col_res_sorted_res_res_res_res_res_res_res_res=()\n    local\
    \ -a row_col_res_sorted_res_res_res_res_res_res_res_res_res=()\n    local -a row_col_res_sorted_res_res_res_res_res_res_res_res_res_res=()\n\
    \    local -a row_col_res_sorted_res_res_res_res_res_res_res_res_res_res_res=()\n\
    \    local -a row_col_res_sorted_res_res_res_res_res_res_res_res_res_res_res_res=()\n\
    \    local -a row_col_res_sorted_res_res_res_res_res_res_res_res_res_res_res_res_res=()\n\
    \    local -a row_col_res_sorted_res_res_res_res_res_res_res_res_res_res_res_res_res_res=()\n\
    \    local -a row_col_res_sorted_\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3\
    \ 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1\
    \ 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    while read -r line; do\n        col=0\n    \
    \    while read -r num; do\n            if [[ $num == $x ]]; then\n          \
    \      result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n          \
    \  col=$((col+1))\n        done <<< \"$line\"\n        row=$((row+1))\n    done\
    \ <<< \"$lst\"\n    echo \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=$1\n  local x=$2\n  local row=0\n  local col=0\n\
    \  local result=()\n  for i in $(echo \"$lst\" | tr \" \" \"\\n\"); do\n    if\
    \ [[ $i == $x ]]; then\n      result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n   \
    \ fi\n    if [[ $i == \"\\n\" ]]; then\n      row=$((row + 1))\n      col=0\n\
    \    else\n      col=$((col + 1))\n    fi\n  done\n  echo \"${result[@]}\" | tr\
    \ \" \" \",\" | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row=0\n\
    \    local col=0\n    local res=()\n    while read -r line; do\n        col=0\n\
    \        for i in $line; do\n            if [[ \"$i\" == \"$x\" ]]; then\n   \
    \             res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n      \
    \      col=$((col+1))\n        done\n        row=$((row+1))\n    done <<< \"$lst\"\
    \n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row_index=0\n    local col_index=0\n    local row_len=0\n    local col_len=0\n\
    \    local row=()\n    local col=()\n    local i=0\n    local j=0\n    local k=0\n\
    \    local l=0\n    local m=0\n    local n=0\n    local o=0\n    local p=0\n \
    \   local q=0\n    local r=0\n    local s=0\n    local t=0\n    local u=0\n  \
    \  local v=0\n    local w=0\n    local x=0\n    local y=0\n    local z=0\n   \
    \ local aa=0\n    local bb=0\n    local cc=0\n    local dd=0\n    local ee=0\n\
    \    local ff=0\n    local gg=0\n    local hh=0\n    local ii=0\n    local jj=0\n\
    \    local kk=0\n    local ll=0\n    local mm=0\n    local nn=0\n    local oo=0\n\
    \    local pp=0\n    local qq=0\n    local rr=0\n    local ss=0\n    local tt=0\n\
    \    local uu=0\n    local vv=0\n    local ww=0\n    local xx=0\n    local yy=0\n\
    \    local zz=0\n    local aaa=0\n    local bbb=0\n    local ccc=0\n    local\
    \ ddd=0\n    local eee=0\n    local fff=0\n    local ggg=0\n    local hhh=0\n\
    \    local iii=0\n    local jjj=0\n    local kkk=0\n    local lll=0\n    local\
    \ mmm=0\n    local nnn=0\n    local ooo=0\n    local ppp=0\n    local qqq=0\n\
    \    local rrr=0\n    local sss=0\n    local ttt=0\n    local uuu=0\n    local\
    \ vvv=0\n    local www=0\n    local xxx=0\n   \n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a arr=()\n \
    \   local -a res=()\n    local -a tmp=()\n    local -a tmp2=()\n    local -a tmp3=()\n\
    \    local -a tmp4=()\n    local -a tmp5=()\n    local -a tmp6=()\n    local -a\
    \ tmp7=()\n    local -a tmp8=()\n    local -a tmp9=()\n    local -a tmp10=()\n\
    \    local -a tmp11=()\n    local -a tmp12=()\n    local -a tmp13=()\n    local\
    \ -a tmp14=()\n    local -a tmp15=()\n    local -a tmp16=()\n    local -a tmp17=()\n\
    \    local -a tmp18=()\n    local -a tmp19=()\n    local -a tmp20=()\n    local\
    \ -a tmp21=()\n    local -a tmp22=()\n    local -a tmp23=()\n    local -a tmp24=()\n\
    \    local -a tmp25=()\n    local -a tmp26=()\n    local -a tmp27=()\n    local\
    \ -a tmp28=()\n    local -a tmp29=()\n    local -a tmp30=()\n    local -a tmp31=()\n\
    \    local -a tmp32=()\n    local -a tmp33=()\n    local -a tmp34=()\n    local\
    \ -a tmp35=()\n    local -a tmp36=()\n    local -a tmp37=()\n    local -a tmp38=()\n\
    \    local -a tmp39=()\n    local -a tmp40=()\n    local -a tmp41=()\n    local\
    \ -a tmp42=()\n    local -a tmp43=()\n    local -a tmp44=()\n    local -a tmp45=()\n\
    \    local -a tmp46=()\n    local -a tmp47=()\n    local -a tmp48=()\n    local\
    \ -a tmp49=()\n    local -a tmp50=()\n    local -a tmp51=()\n    local -a tmp52=()\n\
    \    local -a tmp53=()\n    local -a tmp54\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    while read -r line; do\n        col=0\n\
    \        for num in $line; do\n            if [[ $num == $x ]]; then\n       \
    \         result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n       \
    \     ((col++))\n        done\n        ((row++))\n    done <<< \"$lst\"\n    echo\
    \ \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local line\n    while read -r line; do\n      \
    \  col=0\n        for num in $line; do\n            if [ \"$num\" == \"$x\" ];\
    \ then\n                res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n\
    \            col=$((col + 1))\n        done\n        row=$((row + 1))\n    done\
    \ <<< \"$lst\"\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result=()\n\
    \    local -a rows=($(echo \"$lst\" | tr '\\n' ' '))\n    local -a row\n    local\
    \ -a columns\n    local -a column\n    local -a row_column\n    local -a row_columns\n\
    \    local -a row_columns_sorted\n    local -a row_columns_sorted_desc\n    local\
    \ -a row_columns_sorted_desc_string\n    local -a row_columns_sorted_desc_string_sorted\n\
    \    local -a row_columns_sorted_desc_string_sorted_string\n    local -a row_columns_sorted_desc_string_sorted_string_string\n\
    \    local -a row_columns_sorted_desc_string_sorted_string_string_string\n   \
    \ local -a row_columns_sorted_desc_string_sorted_string_string_string_string\n\
    \    local -a row_columns_sorted_desc_string_sorted_string_string_string_string_string\n\
    \    local -a row_columns_sorted_desc_string_sorted_string_string_string_string_string_string\n\
    \    local -a row_columns_sorted_desc_string_sorted_string_string_string_string_string_string_string\n\
    \    local -a row_columns_sorted_desc_string_sorted_string_string_string_string_string_string_string_string\n\
    \    local -a row_columns_sorted_desc_string_sorted_string_string_string_string_string_string_string_string_string\n\
    \    local -a row_columns_sorted_desc_string_sorted_string_string_string_string_string_string_string_string_string_string\n\
    \    local -a row_columns_sorted_desc_string_sorted_string_string_string_string_string_string_string_string_string_string_string\n\
    \    local -a row_columns_sorted_desc_string_sorted_string_string_string_string_string_string\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row=0\n\
    \    local col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\\
    n'); do\n        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\
    \"$col\\\"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            ((row++))\n\
    \            col=0\n        else\n            ((col++))\n        fi\n    done\n\
    \    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n\
    \    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5\
    \ 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local res=()\n\
    \    local row=0\n    local col=0\n    local row_len=0\n    local col_len=0\n\
    \    local row_arr=()\n    local col_arr=()\n    local row_arr_len=0\n    local\
    \ col_arr_len=0\n    local i=0\n    local j=0\n    local k=0\n    local l=0\n\
    \    local m=0\n    local n=0\n    local o=0\n    local p=0\n    local q=0\n \
    \   local r=0\n    local s=0\n    local t=0\n    local u=0\n    local v=0\n  \
    \  local w=0\n    local x=0\n    local y=0\n    local z=0\n    local aa=0\n  \
    \  local bb=0\n    local cc=0\n    local dd=0\n    local ee=0\n    local ff=0\n\
    \    local gg=0\n    local hh=0\n    local ii=0\n    local jj=0\n    local kk=0\n\
    \    local ll=0\n    local mm=0\n    local nn=0\n    local oo=0\n    local pp=0\n\
    \    local qq=0\n    local rr=0\n    local ss=0\n    local tt=0\n    local uu=0\n\
    \    local vv=0\n    local ww=0\n    local xx=0\n    local yy=0\n    local zz=0\n\
    \    local aaa=0\n    local bbb=0\n    local ccc=0\n    local ddd=0\n    local\
    \ eee=0\n    local fff=0\n    local ggg=0\n    local hhh=0\n    local iii=0\n\
    \    local jjj=0\n    local kkk=0\n    local lll=0\n    local mmm=0\n    local\
    \ nnn=0\n    local ooo=0\n    local ppp=0\n    local qqq=0\n    local rrr=0\n\
    \    local sss=0\n    local ttt=0\n    local uuu\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sort\n\
    \    local -a row_col_sort_rev\n    local -a row_col_sort_rev_join\n    local\
    \ -a row_col_sort_rev_join_sort\n    local -a row_col_sort_rev_join_sort_rev\n\
    \    local -a row_col_sort_rev_join_sort_rev_join\n    local -a row_col_sort_rev_join_sort_rev_join_sort\n\
    \    local -a row_col_sort_rev_join_sort_rev_join_sort_rev\n    local -a row_col_sort_rev_join_sort_rev_join_sort_rev_join\n\
    \    local -a row_col_sort_rev_join_sort_rev_join_sort_rev_join_sort\n    local\
    \ -a row_col_sort_rev_join_sort_rev_join_sort_rev_join_sort_rev\n    local -a\
    \ row_col_sort_rev_join_sort_rev_join_sort_rev_join_sort_rev_join\n    local -a\
    \ row_col_sort_rev_join_sort_rev_join_sort_rev_join_sort_rev_join_sort\n    local\
    \ -a row_col_sort_rev_join_sort_rev_join_sort_rev_join_sort_rev_join_sort_rev\n\
    \    local -a row_col_sort_rev_join_sort_rev_join_sort_rev_join_sort_rev_join_sort_rev_join\n\
    \    local -a row_col_sort_rev_join_sort_rev_join_sort_rev_join_sort_rev_join_sort_rev_join_sort\n\
    \    local -a row_col_sort_rev_join_sort_rev_join_sort_rev_join_sort_rev_join_sort_rev_join_sort_rev\n\
    \    local -a row_col_sort_rev_join_sort_rev_join_sort_rev_join_sort_rev_\n}\n\
    \ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            result+=(\"[\\\"$row\\\"\
    , \\\"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n   \
    \         row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/'\
    \ | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local -a res=()\n\
    \    local -a rows=($(echo \"$lst\" | tr '\\n' ' '))\n    for ((i=0; i<${#rows[@]};\
    \ i++)); do\n        local -a row=($(echo \"${rows[$i]}\" | tr ' ' ' '))\n   \
    \     for ((j=0; j<${#row[@]}; j++)); do\n            if [[ \"${row[$j]}\" ==\
    \ \"$x\" ]]; then\n                res+=(\"[\\\"$i\\\", \\\"$j\\\"]\")\n     \
    \       fi\n        done\n    done\n    echo \"${res[@]}\" | tr ' ' ',' | sed\
    \ 's/^/[/; s/,$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a row_cols=()\n\
    \    local -a rows=()\n    local -a cols=()\n    local -a row_cols_sorted=()\n\
    \    local -a rows_sorted=()\n    local -a cols_sorted=()\n    local -a result=()\n\
    \    local -a result_sorted=()\n    local -a row_cols_sorted_desc=()\n    local\
    \ -a rows_sorted_desc=()\n    local -a cols_sorted_desc=()\n    local -a result_sorted_desc=()\n\
    \    local -a result_sorted_desc_str=()\n    local -a result_sorted_desc_str_sorted=()\n\
    \    local -a result_sorted_desc_str_sorted_str=()\n    local -a result_sorted_desc_str_sorted_str_sorted=()\n\
    \    local -a result_sorted_desc_str_sorted_str_sorted_str=()\n    local -a result_sorted_desc_str_sorted_str_sorted_str_sorted=()\n\
    \    local -a result_sorted_desc_str_sorted_str_sorted_str_sorted_str=()\n   \
    \ local -a result_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted=()\n\
    \    local -a result_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str=()\n\
    \    local -a result_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted=()\n\
    \    local -a result_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str=()\n\
    \    local -a result_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted=()\n\
    \    local -a result_sorted_desc\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"\
    1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4\
    \ 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a rows=($(echo \"$lst\" | tr \"\\n\" \" \"))\n    local -a row\n  \
    \  local -a row_res\n    local -a row_res_sorted\n    local -a row_res_sorted_rev\n\
    \    local -a row_res_sorted_rev_str\n    local -a row_res_sorted_rev_str_res\n\
    \    local i j\n    for ((i=0; i<${#rows[@]}; i++)); do\n        row=($(echo \"\
    ${rows[$i]}\" | tr \" \" \"\\n\"))\n        row_res=()\n        for ((j=0; j<${#row[@]};\
    \ j++)); do\n            if [[ \"${row[$j]}\" == \"$x\" ]]; then\n           \
    \     row_res+=(\"$i\" \"$j\")\n            fi\n        done\n        if [[ ${#row_res[@]}\
    \ -gt 0 ]]; then\n            row_res_sorted=($(echo \"${row_res[@]}\" | tr \"\
    \ \" \"\\n\" | sort -n))\n            row_res_sorted_rev=($(echo \"${row_res_sorted[@]}\"\
    \ | tr \" \" \"\\n\" | sort -nr))\n            row_res_sorted_rev_str=($(echo\
    \ \"${row_res_sorted_rev[@]}\" | tr \" \" \"\\n\" | sed -e 's/^/\\\"/' -e 's/$/\\\
    \"/'))\n            row_res_sorted_rev_str_res=($(echo \"${row_res_sorted_rev_str[@]}\"\
    \ | tr \" \" \"\\n\" | sed -e 's/^/\\[/' -e 's/$/\\]/'))\n            res+=(${row_res_sorted_rev_str_res[@]})\n\
    \        fi\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [ \"$i\" == \"$x\" ]; then\n            \
    \    res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    local row_result=()\n    while read -r line;\
    \ do\n        col=0\n        row_result=()\n        for i in $line; do\n     \
    \       if [[ $i == $x ]]; then\n                row_result+=(\"[\\\"$row\\\"\
    , \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n        done\n\
    \        if [[ ${#row_result[@]} -gt 0 ]]; then\n            result+=(\"[${row_result[@]}]\"\
    )\n        fi\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"[${result[@]}]\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local -a res\n\
    \    local -a tmp\n    local -a tmp2\n    local -a tmp3\n    local -a tmp4\n \
    \   local -a tmp5\n    local -a tmp6\n    local -a tmp7\n    local -a tmp8\n \
    \   local -a tmp9\n    local -a tmp10\n    local -a tmp11\n    local -a tmp12\n\
    \    local -a tmp13\n    local -a tmp14\n    local -a tmp15\n    local -a tmp16\n\
    \    local -a tmp17\n    local -a tmp18\n    local -a tmp19\n    local -a tmp20\n\
    \    local -a tmp21\n    local -a tmp22\n    local -a tmp23\n    local -a tmp24\n\
    \    local -a tmp25\n    local -a tmp26\n    local -a tmp27\n    local -a tmp28\n\
    \    local -a tmp29\n    local -a tmp30\n    local -a tmp31\n    local -a tmp32\n\
    \    local -a tmp33\n    local -a tmp34\n    local -a tmp35\n    local -a tmp36\n\
    \    local -a tmp37\n    local -a tmp38\n    local -a tmp39\n    local -a tmp40\n\
    \    local -a tmp41\n    local -a tmp42\n    local -a tmp43\n    local -a tmp44\n\
    \    local -a tmp45\n    local -a tmp46\n    local -a tmp47\n    local -a tmp48\n\
    \    local -a tmp49\n    local -a tmp50\n    local -a tmp51\n    local -a tmp52\n\
    \    local -a tmp53\n    local -a tmp54\n    local -a tmp55\n    local -a tmp56\n\
    \    local -a tmp57\n    local -a tmp58\n    local -a tmp59\n    local -a tmp60\n\
    \    local -a tmp61\n    local -a tmp62\n    local -a tmp63\n    local -a tmp64\n\
    \    local -a tmp65\n    local -a tmp66\n    local -a tmp67\n    local -a tmp68\n\
    \    local -a tmp69\n    local -a tmp70\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_rev\n    local -a row_col_sorted_rev_sorted\n   \
    \ local -a row_col_sorted_rev_sorted_rev\n    local -a row_col_sorted_rev_sorted_rev_sorted\n\
    \    local -a row_col_sorted_rev_sorted_rev_sorted_rev\n    local -a row_col_sorted_rev_sorted_rev_sorted_rev_sorted\n\
    \    local -a row_col_sorted_rev_sorted_rev_sorted_rev_sorted_rev\n    local -a\
    \ row_col_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted\n    local -a row_col_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted_rev\n\
    \    local -a row_col_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted\n\
    \    local -a row_col_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted_rev\n\
    \    local -a row_col_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted\n\
    \    local -a row_col_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted_rev\n\
    \    local -a row_col_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted\n\
    \    local -a row_col_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted_rev_sorted_rev\n\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    while read -r line; do\n        col=0\n    \
    \    for i in $line; do\n            if [[ $i == $x ]]; then\n               \
    \ result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${result[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ i=0\n    local j=0\n    for row in $lst; do\n        j=0\n        for col in\
    \ $row; do\n            if [[ $col == $x ]]; then\n                res+=(\"[\\\
    \"$i\\\", \\\"$j\\\"]\")\n            fi\n            j=$((j+1))\n        done\n\
    \        i=$((i+1))\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n  \
    \  get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n   \
    \ [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result=()\n\
    \    local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local\
    \ -a row_col_sorted=()\n    local -a row_col_sorted_final=()\n    local -a row_col_sorted_final_str=()\n\
    \    local -a row_col_sorted_final_str_final=()\n    local -a row_col_sorted_final_str_final_str=()\n\
    \    local -a row_col_sorted_final_str_final_str_final=()\n    local -a row_col_sorted_final_str_final_str_final_str=()\n\
    \    local -a row_col_sorted_final_str_final_str_final_str_final=()\n    local\
    \ -a row_col_sorted_final_str_final_str_final_str_final_str=()\n    local -a row_col_sorted_final_str_final_str_final_str_final_str_final=()\n\
    \    local -a row_col_sorted_final_str_final_str_final_str_final_str_final_str=()\n\
    \    local -a row_col_sorted_final_str_final_str_final_str_final_str_final_str_final=()\n\
    \    local -a row_col_sorted_final_str_final_str_final_str_final_str_final_str_final_str=()\n\
    \    local -a row_col_sorted_final_str_final_str_final_str_final_str_final_str_final_str_final=()\n\
    \    local -a row_col_sorted_final_str_final_str_final_str_final_str_final_str_final_str_final_str=()\n\
    \    local -a row_col_sorted_final_str_final_str_final_str_final_str_final_str_final_str_final_str_final=()\n\
    \    local -a row_col_sorted_final_str_final\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ row=0\n    local col=0\n    while read -r line; do\n        col=0\n        for\
    \ i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            res+=(\"[\\\"$row\\\", \\\
    \"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\" ]]; then\n          \
    \  row=$((row + 1))\n            col=0\n        else\n            col=$((col +\
    \ 1))\n        fi\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    local res_row=()\n    local res_col=()\n    for\
    \ i in $(echo \"$lst\" | tr ' ' '\\n'); do\n        if [[ $i -eq $x ]]; then\n\
    \            res_row+=($row)\n            res_col+=($col)\n        fi\n      \
    \  if [[ $i == $'\\n' ]]; then\n            ((row++))\n            col=0\n   \
    \     else\n            ((col++))\n        fi\n    done\n    for i in ${!res_row[@]};\
    \ do\n        res+=($(echo \"[\\\"${res_row[$i]}\\\"\" \"\\\"${res_col[$i]}\\\"\
    ]\"))\n    done\n    echo ${res[@]} | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\n\
    candidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8u83r8oq.sh: line 26: [[: 6\\n1: syntax error: invalid arithmetic
    operator (error token is "\\n1")\n/tmp/tmp8u83r8oq.sh: line 26: [[: 6\\n1: syntax
    error: invalid arithmetic operator (error token is "\\n1")\n'''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    for i in $(echo \"$lst\" | tr ' ' '\\n');\
    \ do\n        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\", \\\
    \"$col\\\"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed\
    \ 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\\
    n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\\
    n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\
    \ = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\"\
    \ ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\"\
    ) = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a rows\n    local -a cols\n    local -a row\n    local -a col\n    local -a\
    \ row_col\n    local -a row_col_sorted\n    local -a row_col_sorted_rev\n    local\
    \ -a row_col_sorted_rev_str\n    local -a row_col_sorted_rev_str_sorted\n    local\
    \ -a row_col_sorted_rev_str_sorted_rev\n    local -a row_col_sorted_rev_str_sorted_rev_str\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted\n    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str\n    local\
    \ -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted\n    local -a\
    \ row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev\n    local -a\
    \ row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str\n    local\
    \ -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted\n\
    \    local -a row_col_\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"\
    1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\")\
    \ = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\\
    n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate\
    \ \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [ \"$i\" == \"$x\" ]; then\n            \
    \    res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    while read -r line; do\n        col=0\n\
    \        for i in $line; do\n            if [[ $i == $x ]]; then\n           \
    \     result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n           \
    \ ((col++))\n        done\n        ((row++))\n    done <<< \"$lst\"\n    echo\
    \ \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_rev\n    local -a row_col_sorted_rev_str\n    local\
    \ -a res_str\n    local i=0\n    local j=0\n    local k=0\n    local l=0\n   \
    \ local m=0\n    local n=0\n    local o=0\n    local p=0\n    local q=0\n    local\
    \ r=0\n    local s=0\n    local t=0\n    local u=0\n    local v=0\n    local w=0\n\
    \    local x=0\n    local y=0\n    local z=0\n    local aa=0\n    local bb=0\n\
    \    local cc=0\n    local dd=0\n    local ee=0\n    local ff=0\n    local gg=0\n\
    \    local hh=0\n    local ii=0\n    local jj=0\n    local kk=0\n    local ll=0\n\
    \    local mm=0\n    local nn=0\n    local oo=0\n    local pp=0\n    local qq=0\n\
    \    local rr=0\n    local ss=0\n    local tt=0\n    local uu=0\n    local vv=0\n\
    \    local ww=0\n    local xx=0\n    local yy=0\n    local zz=0\n    local aaa=0\n\
    \    local bbb=0\n    local ccc=0\n    local ddd=0\n    local eee=0\n    local\
    \ fff=0\n    local ggg=0\n    local hhh=0\n    local iii=0\n    local jjj=0\n\
    \    local kkk=0\n    local lll=0\n    local mmm=0\n    local nnn=0\n    local\
    \ ooo=0\n    local ppp=0\n    local qqq=0\n    local rrr=0\n    local sss=0\n\
    \    local ttt=0\n    local uuu=\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"\
    1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4\
    \ 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    while read -r line; do\n        col=0\n\
    \        for i in $line; do\n            if [[ $i -eq $x ]]; then\n          \
    \      result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n          \
    \  col=$((col + 1))\n        done\n        row=$((row + 1))\n    done <<< \"$lst\"\
    \n    echo \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5\
    \ 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\"\
    \ \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz5yq_zwa.sh: line 26: [[: 6\\n1: syntax error: invalid arithmetic
    operator (error token is "\\n1")\n/tmp/tmpz5yq_zwa.sh: line 26: [[: 6\\n1: syntax
    error: invalid arithmetic operator (error token is "\\n1")\n'''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row_num=0\n\
    \    local col_num=0\n    local row_col_arr=()\n    local row_col_str=\"\"\n \
    \   local row_col_str_arr=()\n    local row_col_str_arr_sorted=()\n    local row_col_str_arr_sorted_rev=()\n\
    \    local row_col_str_arr_sorted_rev_str=\"\"\n    local row_col_str_arr_sorted_rev_str_arr=()\n\
    \    local row_col_str_arr_sorted_rev_str_arr_sorted=()\n    local row_col_str_arr_sorted_rev_str_arr_sorted_rev=()\n\
    \    local row_col_str_arr_sorted_rev_str_arr_sorted_rev_str=\"\"\n    local row_col_str_arr_sorted_rev_str_arr_sorted_rev_str_arr=()\n\
    \    local row_col_str_arr_sorted_rev_str_arr_sorted_rev_str_arr_sorted=()\n \
    \   local row_col_str_arr_sorted_rev_str_arr_sorted_rev_str_arr_sorted_rev=()\n\
    \    local row_col_str_arr_sorted_rev_str_arr_sorted_rev_str_arr_sorted_rev_str=\"\
    \"\n    local row_col_str_arr_sorted_rev_str_arr_sorted_rev_str_arr_sorted_rev_str_arr=()\n\
    \    local row_col_str_arr_sorted_rev_str_arr_sorted_rev_str_arr_sorted_rev_str_arr_sorted=()\n\
    \    local row_col_str_arr_sorted_rev_str_arr_sorted_rev_str_arr_sorted_rev_str_arr_sorted_rev=()\n\
    \    local row_col_str_arr_sorted_rev_str_arr_sorted_rev_str_arr_sorted_rev_str_arr_sorted_\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ row=0\n    local col=0\n    local row_len=0\n    local col_len=0\n    local\
    \ row_arr=()\n    local row_arr_len=0\n    local row_arr_idx=0\n    local row_arr_val=0\n\
    \    local row_arr_val_len=0\n    local row_arr_val_idx=0\n    local row_arr_val_char=0\n\
    \    local row_arr_val_char_code=0\n    local row_arr_val_char_code_str=0\n  \
    \  local row_arr_val_char_code_str_len=0\n    local row_arr_val_char_code_str_idx=0\n\
    \    local row_arr_val_char_code_str_char=0\n    local row_arr_val_char_code_str_char_code=0\n\
    \    local row_arr_val_char_code_str_char_code_str=0\n    local row_arr_val_char_code_str_char_code_str_len=0\n\
    \    local row_arr_val_char_code_str_char_code_str_idx=0\n    local row_arr_val_char_code_str_char_code_str_char=0\n\
    \    local row_arr_val_char_code_str_char_code_str_char_code=0\n    local row_arr_val_char_code_str_char_code_str_char_code_str=0\n\
    \    local row_arr_val_char_code_str_char_code_str_char_code_str_len=0\n    local\
    \ row_arr_val_char_code_str_char_code_str_char_code_str_idx=0\n    local row_arr_val_char_code_str_char_code_str_char_code_str_char=0\n\
    \    local row_arr_val_char_code_str_char_code_str_char_code_str_char_code=0\n\
    \    local row_arr_val_char_code\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"\
    1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4\
    \ 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ row=0\n    local col=0\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            res+=(\"[\\\"$row\\\", \\\
    \"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n       \
    \     row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${res[@]}\" | tr \" \" \"\\n\" | sort\
    \ -t \"\\\"\" -k 1,1 -k 3,3 -r | tr \"\\n\" \" \"\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result=()\n\
    \    local -a rows=()\n    local -a row=()\n    local -a columns=()\n    local\
    \ -a column=()\n    local -a row_columns=()\n    local -a row_column=()\n    local\
    \ -a row_column_index=()\n    local -a row_column_index_sorted=()\n    local -a\
    \ row_column_index_sorted_desc=()\n    local -a row_column_index_sorted_desc_str=()\n\
    \    local -a row_column_index_sorted_desc_str_sorted=()\n    local -a row_column_index_sorted_desc_str_sorted_str=()\n\
    \    local -a row_column_index_sorted_desc_str_sorted_str_sorted=()\n    local\
    \ -a row_column_index_sorted_desc_str_sorted_str_sorted_str=()\n    local -a row_column_index_sorted_desc_str_sorted_str_sorted_str_sorted=()\n\
    \    local -a row_column_index_sorted_desc_str_sorted_str_sorted_str_sorted_str=()\n\
    \    local -a row_column_index_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted=()\n\
    \    local -a row_column_index_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str=()\n\
    \    local -a row_column_index_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted=()\n\
    \    local -a row_column_index_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str=()\n\
    \    local -a row_column_index_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a arr\n    local\
    \ -a res\n    local -a tmp\n    local -a tmp2\n    local -a tmp3\n    local -a\
    \ tmp4\n    local -a tmp5\n    local -a tmp6\n    local -a tmp7\n    local -a\
    \ tmp8\n    local -a tmp9\n    local -a tmp10\n    local -a tmp11\n    local -a\
    \ tmp12\n    local -a tmp13\n    local -a tmp14\n    local -a tmp15\n    local\
    \ -a tmp16\n    local -a tmp17\n    local -a tmp18\n    local -a tmp19\n    local\
    \ -a tmp20\n    local -a tmp21\n    local -a tmp22\n    local -a tmp23\n    local\
    \ -a tmp24\n    local -a tmp25\n    local -a tmp26\n    local -a tmp27\n    local\
    \ -a tmp28\n    local -a tmp29\n    local -a tmp30\n    local -a tmp31\n    local\
    \ -a tmp32\n    local -a tmp33\n    local -a tmp34\n    local -a tmp35\n    local\
    \ -a tmp36\n    local -a tmp37\n    local -a tmp38\n    local -a tmp39\n    local\
    \ -a tmp40\n    local -a tmp41\n    local -a tmp42\n    local -a tmp43\n    local\
    \ -a tmp44\n    local -a tmp45\n    local -a tmp46\n    local -a tmp47\n    local\
    \ -a tmp48\n    local -a tmp49\n    local -a tmp50\n    local -a tmp51\n    local\
    \ -a tmp52\n    local -a tmp53\n    local -a tmp54\n    local -a tmp55\n    local\
    \ -a tmp56\n    local -a tmp57\n    local -a tmp58\n    local -a tmp59\n    local\
    \ -a tmp60\n    local -a tmp61\n    local -a tmp62\n    local -a tmp63\n    local\
    \ -a tmp64\n    local -a tmp65\n    local -a tmp66\n    local -a tmp67\n    local\
    \ -a tmp68\n    local -a tmp69\n    local -a\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a arr\n    local\
    \ -a arr_x\n    local -a arr_y\n    local -a arr_res\n    local -i i\n    local\
    \ -i j\n    local -i k\n    local -i len\n    local -i len_x\n    local -i len_y\n\
    \    local -i len_res\n    local -i x_count\n    local -i y_count\n    local -i\
    \ x_count_old\n    local -i y_count_old\n    local -i x_count_new\n    local -i\
    \ y_count_new\n    local -i x_count_new_old\n    local -i y_count_new_old\n  \
    \  local -i x_count_new_new\n    local -i y_count_new_new\n    local -i x_count_new_new_old\n\
    \    local -i y_count_new_new_old\n    local -i x_count_new_new_new\n    local\
    \ -i y_count_new_new_new\n    local -i x_count_new_new_new_old\n    local -i y_count_new_new_new_old\n\
    \    local -i x_count_new_new_new_new\n    local -i y_count_new_new_new_new\n\
    \    local -i x_count_new_new_new_new_old\n    local -i y_count_new_new_new_new_old\n\
    \    local -i x_count_new_new_new_new_new\n    local -i y_count_new_new_new_new_new\n\
    \    local -i x_count_new_new_new_new_new_old\n    local -i y_count_new_new_new_new_new_old\n\
    \    local -i x_count_new_new_new_new_new_new\n    local -i y_count_new_new_new_new_new_new\n\
    \    local -i x_count_new_new_new_new_new_new_old\n    local -i y_count_new_new_new_new_new_new_old\n\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result=()\n\
    \    local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local\
    \ -a row_col_sorted=()\n    local -a row_col_sorted_rev=()\n    local -a row_col_sorted_rev_str=()\n\
    \    local -a row_col_sorted_rev_str_quoted=()\n    local -a row_col_sorted_rev_str_quoted_json=()\n\
    \    local -a row_col_sorted_rev_str_quoted_json_str=()\n    local -a row_col_sorted_rev_str_quoted_json_str_quoted=()\n\
    \    local -a row_col_sorted_rev_str_quoted_json_str_quoted_json=()\n    local\
    \ -a row_col_sorted_rev_str_quoted_json_str_quoted_json_str=()\n    local -a row_col_sorted_rev_str_quoted_json_str_quoted_json_str_quoted=()\n\
    \    local -a row_col_sorted_rev_str_quoted_json_str_quoted_json_str_quoted_json=()\n\
    \    local -a row_col_sorted_rev_str_quoted_json_str_quoted_json_str_quoted_json_str=()\n\
    \    local -a row_col_sorted_rev_str_quoted_json_str_quoted_json_str_quoted_json_str_quoted=()\n\
    \    local -a row_col_sorted_rev_str_quoted_json_str_quoted_json_str_quoted_json_str_quoted_json=()\n\
    \    local -a row_col_sorted_rev_str_quoted_json_str_quoted_json_str_quoted_json_str_quoted_json_str=()\n\
    \    local -a row_col_sorted_rev_str_quoted_json_str_quoted_json_str_\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            ((row++))\n\
    \            col=0\n        else\n            ((col++))\n        fi\n    done\n\
    \    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=([\"\
    $row,$col\"])\n            fi\n            col=$((col+1))\n        done\n    \
    \    row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\" | tr ' ' '\\\
    n' | sort -t ',' -k 1,1n -k 2,2nr | tr '\\n' ' '\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=\"\"\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"\
    ); do\n        if [[ $i == $x ]]; then\n            result=\"$result [\\\"$row\\\
    \", \\\"$col\\\"]\"\n        fi\n        if [[ $i == \"\\n\" ]]; then\n      \
    \      row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"$result\" | sort -t '\"' -k1n -k3nr\
    \ | tr -d \" \"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ i=0\n    local j=0\n    for row in $lst; do\n        for col in $row; do\n \
    \           if [[ $col == $x ]]; then\n                res+=(\"[\\\"$i\\\", \\\
    \"$j\\\"]\")\n            fi\n            j=$((j+1))\n        done\n        j=0\n\
    \        i=$((i+1))\n    done\n    echo ${res[@]} | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local i=0\n    local j=0\n    for row in $lst; do\n        j=0\n        for\
    \ col in $row; do\n            if [[ $col == $x ]]; then\n                result+=(\"\
    [\\\"$i\\\", \\\"$j\\\"]\")\n            fi\n            j=$((j+1))\n        done\n\
    \        i=$((i+1))\n    done\n    echo ${result[@]}\n}\n\ncandidate() {\n   \
    \ get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n   \
    \ [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local -a res=()\n\
    \    local -a rows=()\n    local -a cols=()\n    local -a row=()\n    local -a\
    \ col=()\n    local -a row_col=()\n    local -a row_col_sorted=()\n    local -a\
    \ res_sorted=()\n    local -a row_col_sorted_cols=()\n    local -a row_col_sorted_cols_sorted=()\n\
    \    local -a res_sorted_cols=()\n    local -a res_sorted_cols_sorted=()\n   \
    \ local -a res_sorted_cols_sorted_str=()\n    local -a res_sorted_cols_sorted_str_sorted=()\n\
    \    local -a res_sorted_cols_sorted_str_sorted_str=()\n    local -a res_sorted_cols_sorted_str_sorted_str_sorted=()\n\
    \    local -a res_sorted_cols_sorted_str_sorted_str_sorted_str=()\n    local -a\
    \ res_sorted_cols_sorted_str_sorted_str_sorted_str_sorted=()\n    local -a res_sorted_cols_sorted_str_sorted_str_sorted_str_sorted_str=()\n\
    \    local -a res_sorted_cols_sorted_str_sorted_str_sorted_str_sorted_str_sorted=()\n\
    \    local -a res_sorted_cols_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str=()\n\
    \    local -a res_sorted_cols_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted=()\n\
    \    local -a res_sorted_cols_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str=()\n\
    \    local -a\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a col=()\n    local -a tmp=()\n    local -a tmp2=()\n\
    \    local -a tmp3=()\n    local -a tmp4=()\n    local -a tmp5=()\n    local -a\
    \ tmp6=()\n    local -a tmp7=()\n    local -a tmp8=()\n    local -a tmp9=()\n\
    \    local -a tmp10=()\n    local -a tmp11=()\n    local -a tmp12=()\n    local\
    \ -a tmp13=()\n    local -a tmp14=()\n    local -a tmp15=()\n    local -a tmp16=()\n\
    \    local -a tmp17=()\n    local -a tmp18=()\n    local -a tmp19=()\n    local\
    \ -a tmp20=()\n    local -a tmp21=()\n    local -a tmp22=()\n    local -a tmp23=()\n\
    \    local -a tmp24=()\n    local -a tmp25=()\n    local -a tmp26=()\n    local\
    \ -a tmp27=()\n    local -a tmp28=()\n    local -a tmp29=()\n    local -a tmp30=()\n\
    \    local -a tmp31=()\n    local -a tmp32=()\n    local -a tmp33=()\n    local\
    \ -a tmp34=()\n    local -a tmp35=()\n    local -a tmp36=()\n    local -a tmp37=()\n\
    \    local -a tmp38=()\n    local -a tmp39=()\n    local -a tmp40=()\n    local\
    \ -a tmp41=()\n    local -a tmp42=()\n    local -a tmp43=()\n    local -a tmp44=()\n\
    \    local -a tmp45=()\n    local -a tmp46=()\n    local -a tmp47=()\n    local\
    \ -a tmp48=()\n    local -a tmp49=()\n    local -a tmp50=()\n    local -a tmp51=()\n\
    \    local -a tmp52=()\n    local -a tmp53=\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $lst; do\n        if [[ \"$i\" == \"$x\"\
    \ ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n        fi\n\
    \        if [[ \"$i\" == \"\\n\" ]]; then\n            row=$((row + 1))\n    \
    \        col=0\n        else\n            col=$((col + 1))\n        fi\n    done\n\
    \    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a rows\n    local -a cols\n    local -a row\n    local -a col\n    local -a\
    \ row_col\n    local -a row_col_sorted\n    local -a res_sorted\n    local -a\
    \ row_col_sorted_rev\n    local -a res_sorted_rev\n    local i=0\n    local j=0\n\
    \    local k=0\n    local l=0\n    local m=0\n    local n=0\n    local o=0\n \
    \   local p=0\n    local q=0\n    local r=0\n    local s=0\n    local t=0\n  \
    \  local u=0\n    local v=0\n    local w=0\n    local x=0\n    local y=0\n   \
    \ local z=0\n    local aa=0\n    local bb=0\n    local cc=0\n    local dd=0\n\
    \    local ee=0\n    local ff=0\n    local gg=0\n    local hh=0\n    local ii=0\n\
    \    local jj=0\n    local kk=0\n    local ll=0\n    local mm=0\n    local nn=0\n\
    \    local oo=0\n    local pp=0\n    local qq=0\n    local rr=0\n    local ss=0\n\
    \    local tt=0\n    local uu=0\n    local vv=0\n    local ww=0\n    local xx=0\n\
    \    local yy=0\n    local zz=0\n    local aaa=0\n    local bbb=0\n    local ccc=0\n\
    \    local ddd=0\n    local eee=0\n    local fff=0\n    local ggg=0\n    local\
    \ hhh=0\n    local iii=0\n    local jjj=0\n    local kkk=0\n    local lll=0\n\
    \    local mmm=0\n    local nnn=0\n    local ooo=0\n    local ppp=0\n    local\
    \ qqq=0\n    local rrr=0\n    local sss=0\n    local\n}\n\ncandidate() {\n   \
    \ get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n   \
    \ [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\\
    n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\\
    n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"\
    1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row=0\n\
    \    local col=0\n    local res=()\n    while read -r line; do\n        col=0\n\
    \        for i in $line; do\n            if [[ \"$i\" == \"$x\" ]]; then\n   \
    \             res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n      \
    \      col=$((col+1))\n        done\n        row=$((row+1))\n    done <<< \"$lst\"\
    \n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\" | tr \" \" \"\\n\" | sort -t \"\\\"\"\
    \ -k 1 -n -r -k 2 -n\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for num in $line; do\n            if [[ $num == $x ]]; then\n              \
    \  res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col\
    \ + 1))\n        done\n        row=$((row + 1))\n    done <<< \"$lst\"\n    echo\
    \ \"${res[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result\n \
    \   local -i i=0\n    local -i j=0\n    local -i k=0\n    local -i len=0\n   \
    \ local -i len2=0\n    local -i len3=0\n    local -a arr\n    local -a arr2\n\
    \    local -a arr3\n    local -a arr4\n    local -a arr5\n    local -a arr6\n\
    \    local -a arr7\n    local -a arr8\n    local -a arr9\n    local -a arr10\n\
    \    local -a arr11\n    local -a arr12\n    local -a arr13\n    local -a arr14\n\
    \    local -a arr15\n    local -a arr16\n    local -a arr17\n    local -a arr18\n\
    \    local -a arr19\n    local -a arr20\n    local -a arr21\n    local -a arr22\n\
    \    local -a arr23\n    local -a arr24\n    local -a arr25\n    local -a arr26\n\
    \    local -a arr27\n    local -a arr28\n    local -a arr29\n    local -a arr30\n\
    \    local -a arr31\n    local -a arr32\n    local -a arr33\n    local -a arr34\n\
    \    local -a arr35\n    local -a arr36\n    local -a arr37\n    local -a arr38\n\
    \    local -a arr39\n    local -a arr40\n    local -a arr41\n    local -a arr42\n\
    \    local -a arr43\n    local -a arr44\n    local -a arr45\n    local -a arr46\n\
    \    local -a arr47\n    local -a arr48\n    local -a arr49\n    local -a arr50\n\
    \    local -a arr51\n    local -a arr52\n    local -a arr53\n    local -a arr54\n\
    \    local -a arr55\n    local -a arr56\n    local -a arr57\n    local -a arr58\n\
    \    local -a arr59\n    local -a arr60\n    local -a arr61\n    local -a arr62\n\
    \    local -a arr63\n    local\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"\
    1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4\
    \ 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a res_sorted\n    local -a row_sorted\n    local -a col_sorted\n \
    \   local -a row_col_sorted_sorted\n    local -a res_sorted_sorted\n    local\
    \ -a row_sorted_sorted\n    local -a col_sorted_sorted\n    local -a row_col_sorted_sorted_sorted\n\
    \    local -a res_sorted_sorted_sorted\n    local -a row_sorted_sorted_sorted\n\
    \    local -a col_sorted_sorted_sorted\n    local -a row_col_sorted_sorted_sorted_sorted\n\
    \    local -a res_sorted_sorted_sorted_sorted\n    local -a row_sorted_sorted_sorted_sorted\n\
    \    local -a col_sorted_sorted_sorted_sorted\n    local -a row_col_sorted_sorted_sorted_sorted_sorted\n\
    \    local -a res_sorted_sorted_sorted_sorted_sorted\n    local -a row_sorted_sorted_sorted_sorted_sorted\n\
    \    local -a col_sorted_sorted_sorted_sorted_sorted\n    local -a row_col_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \    local -a res_sorted_sorted_sorted_sorted_sorted_sorted\n    local -a row_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \    local -a col_sorted_sorted_sorted_sorted_sorted_sorted\n    local -a row_col_sorted_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \    local -a res_sorted_sorted_sorted_sorted_sorted_sorted_sorted\n    local\
    \ -a row_sorted\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=([\"\
    $row,$col\"])\n            fi\n            col=$((col+1))\n        done\n    \
    \    row=$((row+1))\n    done <<< \"$lst\"\n    if [[ ${#res[@]} -eq 0 ]]; then\n\
    \        echo \"[]\"\n    else\n        echo \"$(IFS=$'\\n'; echo \"${res[*]}\"\
    \ | sort -t ',' -k1n -k2nr | sed -e 's/^/\"/' -e 's/$/\"/' | tr '\\n' ',' | sed\
    \ -e 's/,$//' -e 's/,/],[/g')\"\n    fi\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row=0\n\
    \    local col=0\n    local result=()\n    while read -r line; do\n        col=0\n\
    \        for num in $line; do\n            if [[ \"$num\" == \"$x\" ]]; then\n\
    \                result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n\
    \            col=$((col + 1))\n        done\n        row=$((row + 1))\n    done\
    \ <<< \"$lst\"\n    echo \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local i=0\n    local j=0\n    for row in $lst; do\n        for col in $row;\
    \ do\n            if [[ $col == $x ]]; then\n                result+=(\"[\\\"\
    $i\\\", \\\"$j\\\"]\")\n            fi\n            j=$((j+1))\n        done\n\
    \        j=0\n        i=$((i+1))\n    done\n    echo ${result[@]} | tr ' ' ','\
    \ | sed 's/\\[\\(.*\\)\\]/\\[\\1\\]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 2
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result=()\n\
    \    local -a rows=($(echo \"$lst\" | tr '\\n' ' '))\n    local -a row\n    local\
    \ -a row_result\n    local -i i\n    local -i j\n    local -i k\n    local -i\
    \ row_len\n    local -i row_result_len\n    for ((i=0; i<${#rows[@]}; i++)); do\n\
    \        row=($(echo \"${rows[$i]}\" | tr ' ' '\\n'))\n        row_len=${#row[@]}\n\
    \        for ((j=0; j<row_len; j++)); do\n            if [[ \"${row[$j]}\" ==\
    \ \"$x\" ]]; then\n                row_result+=($i $j)\n            fi\n     \
    \   done\n    done\n    row_result_len=${#row_result[@]}\n    for ((i=0; i<row_result_len;\
    \ i+=2)); do\n        for ((j=i+2; j<row_result_len; j+=2)); do\n            if\
    \ [[ \"${row_result[$i]}\" -gt \"${row_result[$j]}\" ]]; then\n              \
    \  k=${row_result[$i]}\n                row_result[$i]=${row_result[$j]}\n   \
    \             row_result[$j]=$k\n                k=${row_result[$i+1]}\n     \
    \           row_result[$i+1]=${row_result[$j+1]}\n                row_result[$j+1]=$k\n\
    \            elif [[ \"${row_result[$i]}\" -eq \"${row_result[$j]}\" ]]; then\n\
    \                if [[ \"${row_result[$i+1]}\" -lt \"${row_result[$j+1]}\" ]];\
    \ then\n                    k=${row_result[$i]}\n                    row_result[$i]=${row_result[$j]}\n\
    \                    row_result[$j]=$k\n                    k=${row_result[$i+1]}\n\
    \                    row_result[$i+\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b"/tmp/tmpuroe0gk8.sh: line 54: unexpected EOF while looking for matching
    `]''\n/tmp/tmpuroe0gk8.sh: line 72: syntax error: unexpected end of file\n"'
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            result+=(\"[\\\"$row\\\"\
    , \\\"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n   \
    \         row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/'\
    \ | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n  local lst=\"$1\"\n  local x=\"$2\"\n  local row=0\n  local\
    \ col=0\n  local result=()\n  local row_result=()\n  local row_result_sorted=()\n\
    \  local row_result_sorted_str=()\n  local result_str=()\n  for i in $(echo \"\
    $lst\" | tr ' ' '\\n'); do\n    if [ \"$i\" = \"$x\" ]; then\n      row_result+=(\"\
    $row\")\n      row_result+=(\"$col\")\n    fi\n    if [ \"$i\" = \"$'\\n'\" ];\
    \ then\n      row_result_sorted=($(printf '%s\\n' \"${row_result[@]}\" | sort\
    \ -nr))\n      row_result_sorted_str=($(printf '%s\\n' \"${row_result_sorted[@]}\"\
    \ | tr '\\n' ' '))\n      result+=(\"${row_result_sorted_str[@]}\")\n      row_result=()\n\
    \      row_result_sorted=()\n      row_result_sorted_str=()\n      row=$((row\
    \ + 1))\n      col=0\n    else\n      col=$((col + 1))\n    fi\n  done\n  if [\
    \ \"${#row_result[@]}\" -gt 0 ]; then\n    row_result_sorted=($(printf '%s\\n'\
    \ \"${row_result[@]}\" | sort -nr))\n    row_result_sorted_str=($(printf '%s\\\
    n' \"${row_result_sorted[@]}\" | tr '\\n' ' '))\n    result+=(\"${row_result_sorted_str[@]}\"\
    )\n  fi\n  result_str=($(printf '%s\\n' \"${result[@]}\" | tr ' ' '\\n'))\n  echo\
    \ \"[${result_str[@]}]\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"\
    1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\")\
    \ = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\\
    n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate\
    \ \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a row_cols=()\n\
    \    local -a rows=()\n    local -a cols=()\n    local -a result=()\n    local\
    \ -a row=()\n    local -a col=()\n    local -a temp=()\n    local -a temp2=()\n\
    \    local -a temp3=()\n    local -a temp4=()\n    local -a temp5=()\n    local\
    \ -a temp6=()\n    local -a temp7=()\n    local -a temp8=()\n    local -a temp9=()\n\
    \    local -a temp10=()\n    local -a temp11=()\n    local -a temp12=()\n    local\
    \ -a temp13=()\n    local -a temp14=()\n    local -a temp15=()\n    local -a temp16=()\n\
    \    local -a temp17=()\n    local -a temp18=()\n    local -a temp19=()\n    local\
    \ -a temp20=()\n    local -a temp21=()\n    local -a temp22=()\n    local -a temp23=()\n\
    \    local -a temp24=()\n    local -a temp25=()\n    local -a temp26=()\n    local\
    \ -a temp27=()\n    local -a temp28=()\n    local -a temp29=()\n    local -a temp30=()\n\
    \    local -a temp31=()\n    local -a temp32=()\n    local -a temp33=()\n    local\
    \ -a temp34=()\n    local -a temp35=()\n    local -a temp36=()\n    local -a temp37=()\n\
    \    local -a temp38=()\n    local -a temp39=()\n    local -a temp40=()\n    local\
    \ -a temp41=()\n    local -a temp42=()\n    local -a temp43=()\n    local -a temp44=()\n\
    \    local -a temp45=()\n    local -a temp46=()\n    local -a temp47=()\n    local\
    \ -a temp48=()\n    local -a temp49=()\n    local -a temp50\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a arr=()\n \
    \   local -a tmp=()\n    local -a res=()\n    local -a tmp2=()\n    local -a tmp3=()\n\
    \    local -a tmp4=()\n    local -a tmp5=()\n    local -a tmp6=()\n    local -a\
    \ tmp7=()\n    local -a tmp8=()\n    local -a tmp9=()\n    local -a tmp10=()\n\
    \    local -a tmp11=()\n    local -a tmp12=()\n    local -a tmp13=()\n    local\
    \ -a tmp14=()\n    local -a tmp15=()\n    local -a tmp16=()\n    local -a tmp17=()\n\
    \    local -a tmp18=()\n    local -a tmp19=()\n    local -a tmp20=()\n    local\
    \ -a tmp21=()\n    local -a tmp22=()\n    local -a tmp23=()\n    local -a tmp24=()\n\
    \    local -a tmp25=()\n    local -a tmp26=()\n    local -a tmp27=()\n    local\
    \ -a tmp28=()\n    local -a tmp29=()\n    local -a tmp30=()\n    local -a tmp31=()\n\
    \    local -a tmp32=()\n    local -a tmp33=()\n    local -a tmp34=()\n    local\
    \ -a tmp35=()\n    local -a tmp36=()\n    local -a tmp37=()\n    local -a tmp38=()\n\
    \    local -a tmp39=()\n    local -a tmp40=()\n    local -a tmp41=()\n    local\
    \ -a tmp42=()\n    local -a tmp43=()\n    local -a tmp44=()\n    local -a tmp45=()\n\
    \    local -a tmp46=()\n    local -a tmp47=()\n    local -a tmp48=()\n    local\
    \ -a tmp49=()\n    local -a tmp50=()\n    local -a tmp51=()\n    local -a tmp52=()\n\
    \    local -a tmp53=()\n    local -a tmp54\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ i=0\n    local j=0\n    for row in $lst; do\n        for col in $row; do\n \
    \           if [[ $col == $x ]]; then\n                res+=([$i,$j])\n      \
    \      fi\n            ((j++))\n        done\n        ((i++))\n        j=0\n \
    \   done\n    echo ${res[@]}\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5\
    \ 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\"\
    \ \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local row=0\n\
    \    local col=0\n    local res=()\n    local row_res=()\n    local row_res_sorted=()\n\
    \    local row_res_sorted_rev=()\n    local res_sorted=()\n    local res_sorted_rev=()\n\
    \    local res_sorted_rev_str=()\n    local res_sorted_rev_str_str=()\n    local\
    \ res_sorted_rev_str_str_str=()\n    local res_sorted_rev_str_str_str_str=()\n\
    \    local res_sorted_rev_str_str_str_str_str=()\n    local res_sorted_rev_str_str_str_str_str_str=()\n\
    \    local res_sorted_rev_str_str_str_str_str_str_str=()\n    local res_sorted_rev_str_str_str_str_str_str_str_str=()\n\
    \    local res_sorted_rev_str_str_str_str_str_str_str_str_str=()\n    local res_sorted_rev_str_str_str_str_str_str_str_str_str_str=()\n\
    \    local res_sorted_rev_str_str_str_str_str_str_str_str_str_str_str=()\n   \
    \ local res_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str=()\n  \
    \  local res_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str_str=()\n\
    \    local res_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str_str_str=()\n\
    \    local res_sorted_rev_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str=()\n\
    \    local res_sorted_rev_str_str_str_str_str_\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read line; do\n        col=0\n        for\
    \ i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"[${res[@]}]\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo $lst | tr \" \" \"\\n\"); do\n\
    \        if [[ $i == $x ]]; then\n            res+=([$row,$col])\n        fi\n\
    \        if [[ $i == \"\\n\" ]]; then\n            row=$((row+1))\n          \
    \  col=0\n        else\n            col=$((col+1))\n        fi\n    done\n   \
    \ echo ${res[@]} | tr \" \" \"\\n\" | sort -t \",\" -k 1 -n -k 2 -r | tr \"\\\
    n\" \" \"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\\
    n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\\
    n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\
    \ = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\"\
    \ ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\"\
    ) = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local -a res=()\n\
    \    local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local\
    \ -a row_col_res=()\n    local -a row_col_res_res=()\n    local -a row_col_res_res_res=()\n\
    \    local -a row_col_res_res_res_res=()\n    local -a row_col_res_res_res_res_res=()\n\
    \    local -a row_col_res_res_res_res_res_res=()\n    local -a row_col_res_res_res_res_res_res_res=()\n\
    \    local -a row_col_res_res_res_res_res_res_res_res=()\n    local -a row_col_res_res_res_res_res_res_res_res_res=()\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res=()\n    local -a\
    \ row_col_res_res_res_res_res_res_res_res_res_res_res=()\n    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_res=()\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_res_res=()\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_res_res_res=()\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_res_res_res_res=()\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_res_res_res_res_res_res=()\n\
    \    local -a row_col_res_res_res_res_res_res_res_res_res_res_\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local -a res=()\n\
    \    local -a rows=()\n    local -a cols=()\n    local -a row=()\n    local -a\
    \ col=()\n    local -a tmp=()\n    local -a tmp2=()\n    local -a tmp3=()\n  \
    \  local -a tmp4=()\n    local -a tmp5=()\n    local -a tmp6=()\n    local -a\
    \ tmp7=()\n    local -a tmp8=()\n    local -a tmp9=()\n    local -a tmp10=()\n\
    \    local -a tmp11=()\n    local -a tmp12=()\n    local -a tmp13=()\n    local\
    \ -a tmp14=()\n    local -a tmp15=()\n    local -a tmp16=()\n    local -a tmp17=()\n\
    \    local -a tmp18=()\n    local -a tmp19=()\n    local -a tmp20=()\n    local\
    \ -a tmp21=()\n    local -a tmp22=()\n    local -a tmp23=()\n    local -a tmp24=()\n\
    \    local -a tmp25=()\n    local -a tmp26=()\n    local -a tmp27=()\n    local\
    \ -a tmp28=()\n    local -a tmp29=()\n    local -a tmp30=()\n    local -a tmp31=()\n\
    \    local -a tmp32=()\n    local -a tmp33=()\n    local -a tmp34=()\n    local\
    \ -a tmp35=()\n    local -a tmp36=()\n    local -a tmp37=()\n    local -a tmp38=()\n\
    \    local -a tmp39=()\n    local -a tmp40=()\n    local -a tmp41=()\n    local\
    \ -a tmp42=()\n    local -a tmp43=()\n    local -a tmp44=()\n    local -a tmp45=()\n\
    \    local -a tmp46=()\n    local -a tmp47=()\n    local -a tmp48=()\n    local\
    \ -a tmp49=()\n    local -a tmp50=()\n    local -a\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    while read -r line; do\n        col=0\n    \
    \    for i in $line; do\n            if [[ $i == $x ]]; then\n               \
    \ result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${result[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a rows\n    local -a cols\n    local -a row\n    local -a col\n    local -a\
    \ row_col\n    local -a row_col_sorted\n    local -a row_col_sorted_rev\n    local\
    \ -a row_col_sorted_rev_str\n    local -a res_str\n    local -a res_str_sorted\n\
    \    local -a res_str_sorted_rev\n    local -a res_str_sorted_rev_str\n    local\
    \ -a res_str_sorted_rev_str_sorted\n    local -a res_str_sorted_rev_str_sorted_rev\n\
    \    local -a res_str_sorted_rev_str_sorted_rev_str\n    local -a res_str_sorted_rev_str_sorted_rev_str_sorted\n\
    \    local -a res_str_sorted_rev_str_sorted_rev_str_sorted_rev\n    local -a res_str_sorted_rev_str_sorted_rev_str_sorted_rev_str\n\
    \    local -a res_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted\n  \
    \  local -a res_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev\n\
    \    local -a res_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str\n\
    \    local -a res_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted\n\
    \    local -a res_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev\n\
    \    local -a res_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str\n\
    \    local -a res_str\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    while read -r line; do\n        col=0\n    \
    \    for i in $line; do\n            if [[ $i == $x ]]; then\n               \
    \ result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${result[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local i=0\n    local j=0\n    local row\n    for row in $lst; do\n       \
    \ j=0\n        for col in $row; do\n            if [[ $col == $x ]]; then\n  \
    \              result+=(\"[\\\"$i\\\", \\\"$j\\\"]\")\n            fi\n      \
    \      j=$((j+1))\n        done\n        i=$((i+1))\n    done\n    echo \"${result[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        col=$((col + 1))\n        if [[ $i == $'\\n' ]]; then\n\
    \            row=$((row + 1))\n            col=0\n        fi\n    done\n    echo\
    \ \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 2
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    local row_result=()\n    local row_result_sorted=()\n\
    \    local row_result_sorted_desc=()\n    local row_result_sorted_desc_str=()\n\
    \    local result_str=()\n    local result_str_sorted=()\n    local result_str_sorted_desc=()\n\
    \    local result_str_sorted_desc_str=()\n    for i in $(echo \"$lst\" | tr '\
    \ ' '\\n'); do\n        if [[ \"$i\" == \"$x\" ]]; then\n            row_result+=($col)\n\
    \        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n            row_result_sorted=($(printf\
    \ '%s\\n' \"${row_result[@]}\" | sort -n))\n            for j in \"${row_result_sorted[@]}\"\
    ; do\n                row_result_sorted_desc+=($j)\n            done\n       \
    \     row_result_sorted_desc_str=($(printf '\"%s\" ' \"${row_result_sorted_desc[@]}\"\
    ))\n            for j in \"${row_result_sorted_desc_str[@]}\"; do\n          \
    \      result+=($row $j)\n            done\n            row_result=()\n      \
    \      row_result_sorted=()\n            row_result_sorted_desc=()\n         \
    \   row_result_sorted_desc_str=()\n            row=$((row+1))\n            col=-1\n\
    \        fi\n        col=$((col+1))\n    done\n    row_result_sorted=($(printf\
    \ '%s\\n' \"${row_result[@]}\" | sort -n))\n    for j in \"${row_result_sorted[@]}\"\
    ; do\n        row_result_sorted_desc+=($j)\n    done\n    row_result_sorted_desc_str=($(printf\
    \ '\"%s\" ' \"${row_result_sorted_desc[@]}\"))\n    for j in \"${row_\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfjojcfpj.sh: line 72: unexpected EOF while looking for matching
    `"\''\n/tmp/tmpfjojcfpj.sh: line 76: syntax error: unexpected end of file\n'''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    for i in $(echo \"$lst\" | tr \" \" \"\\\
    n\"); do\n        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\"\
    , \\\"$col\\\"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n       \
    \     row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr \" \" \",\" | sed\
    \ 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a arr\n    local\
    \ -a arr2\n    local -a arr3\n    local -a arr4\n    local -a arr5\n    local\
    \ -a arr6\n    local -a arr7\n    local -a arr8\n    local -a arr9\n    local\
    \ -a arr10\n    local -a arr11\n    local -a arr12\n    local -a arr13\n    local\
    \ -a arr14\n    local -a arr15\n    local -a arr16\n    local -a arr17\n    local\
    \ -a arr18\n    local -a arr19\n    local -a arr20\n    local -a arr21\n    local\
    \ -a arr22\n    local -a arr23\n    local -a arr24\n    local -a arr25\n    local\
    \ -a arr26\n    local -a arr27\n    local -a arr28\n    local -a arr29\n    local\
    \ -a arr30\n    local -a arr31\n    local -a arr32\n    local -a arr33\n    local\
    \ -a arr34\n    local -a arr35\n    local -a arr36\n    local -a arr37\n    local\
    \ -a arr38\n    local -a arr39\n    local -a arr40\n    local -a arr41\n    local\
    \ -a arr42\n    local -a arr43\n    local -a arr44\n    local -a arr45\n    local\
    \ -a arr46\n    local -a arr47\n    local -a arr48\n    local -a arr49\n    local\
    \ -a arr50\n    local -a arr51\n    local -a arr52\n    local -a arr53\n    local\
    \ -a arr54\n    local -a arr55\n    local -a arr56\n    local -a arr57\n    local\
    \ -a arr58\n    local -a arr59\n    local -a arr60\n    local -a arr61\n    local\
    \ -a arr62\n    local -a arr63\n    local -a arr64\n    local -a arr65\n    local\
    \ -a arr66\n    local -a arr67\n    local -a arr68\n    local -a arr69\n    local\
    \ -a arr70\n    local -a arr71\n    local\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a rows=($(echo \"$lst\" | tr '\\n' ' '))\n    local -a cols=()\n  \
    \  local -a tmp=()\n    local -a tmp2=()\n    local i=0\n    local j=0\n    for\
    \ row in \"${rows[@]}\"; do\n        cols=($(echo \"$row\" | tr ' ' '\\n'))\n\
    \        for col in \"${cols[@]}\"; do\n            if [[ \"$col\" == \"$x\" ]];\
    \ then\n                tmp+=(\"$i\")\n                tmp+=(\"$j\")\n       \
    \         res+=(\"[\\\"$i\\\", \\\"$j\\\"]\")\n            fi\n            ((j++))\n\
    \        done\n        ((i++))\n        j=0\n    done\n    if [[ ${#res[@]} -eq\
    \ 0 ]]; then\n        echo \"[]\"\n    else\n        echo \"${res[@]}\" | tr '\
    \ ' '\\n' | sort -t '\"' -k 2 -n -r | sort -t '\"' -k 1 -n\n    fi\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ \"$i\" == \"$x\" ]]; then\n            res+=(\"[\\\"$row\\\", \\\
    \"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n       \
    \     row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/'\
    \ | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ row=0\n    local col=0\n    while read -r line; do\n        col=0\n        for\
    \ num in $line; do\n            if [[ $num == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a rows=()\n\
    \    local -a cols=()\n    local -a res=()\n    local -a row=()\n    local -a\
    \ col=()\n    local -a row_col=()\n    local -a row_col_sorted=()\n    local -a\
    \ row_col_sorted_rev=()\n    local -a row_col_sorted_rev_str=()\n    local -a\
    \ row_col_sorted_rev_str_sorted=()\n    local -a row_col_sorted_rev_str_sorted_rev=()\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str=()\n    local -a row_col_sorted_rev_str_sorted_rev_str_sorted=()\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev=()\n    local -a\
    \ row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str=()\n    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted=()\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev=()\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str=()\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted=()\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev=()\n\
    \    local -a row_col_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str=()\n\
    \    local -a row_col_sorted_rev\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"\
    1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4\
    \ 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=([\"\
    $row,$col\"])\n            fi\n            col=$((col+1))\n        done\n    \
    \    row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\" | tr ' ' '\\\
    n' | sort -t ',' -k 1n -k 2nr | tr '\\n' ' '\n}\n\ncandidate() {\n    get_row\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3\
    \ 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    for i in $(echo \"$lst\" | tr ' ' '\\n');\
    \ do\n        if [[ \"$i\" == \"$x\" ]]; then\n            result+=(\"[\\\"$row\\\
    \", \\\"$col\\\"]\")\n        fi\n        if [[ \"$i\" == \"\\n\" ]]; then\n \
    \           row=$((row + 1))\n            col=0\n        else\n            col=$((col\
    \ + 1))\n        fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/'\
    \ | sed 's/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for num in $line; do\n            if [[ $num -eq $x ]]; then\n             \
    \   res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col\
    \ + 1))\n        done\n        row=$((row + 1))\n    done <<< \"$lst\"\n    echo\
    \ \"${res[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmmx6fddo.sh: line 26: [[: 6\\n1: syntax error: invalid arithmetic
    operator (error token is "\\n1")\n/tmp/tmpmmx6fddo.sh: line 26: [[: 6\\n1: syntax
    error: invalid arithmetic operator (error token is "\\n1")\n'''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    local row_result=()\n    while read -r line;\
    \ do\n        col=0\n        row_result=()\n        for i in $line; do\n     \
    \       if [[ $i == $x ]]; then\n                row_result+=(\"[\\\"$row\\\"\
    , \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n        done\n\
    \        if [[ ${#row_result[@]} -gt 0 ]]; then\n            result+=(\"${row_result[@]}\"\
    )\n        fi\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${result[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ row=0\n    local col=0\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n \
    \       if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\" | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\" | tr \" \" \"\\n\" | sort -t \"\\\"\"\
    \ -k 1 -n -k 2 -r | tr \"\\n\" \" \"\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local -a\
    \ row_col_sorted=()\n    local -a res_sorted=()\n    local -a row_col_sorted_rev=()\n\
    \    local -a res_sorted_rev=()\n    local -a res_sorted_rev_str=()\n    local\
    \ -a res_sorted_rev_str_sorted=()\n    local -a res_sorted_rev_str_sorted_rev=()\n\
    \    local -a res_sorted_rev_str_sorted_rev_str=()\n    local -a res_sorted_rev_str_sorted_rev_str_sorted=()\n\
    \    local -a res_sorted_rev_str_sorted_rev_str_sorted_rev=()\n    local -a res_sorted_rev_str_sorted_rev_str_sorted_rev_str=()\n\
    \    local -a res_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted=()\n   \
    \ local -a res_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev=()\n  \
    \  local -a res_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str=()\n\
    \    local -a res_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted=()\n\
    \    local -a res_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev=()\n\
    \    local -a res_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev_str=()\n\
    \    local -a res_sorted_rev_str_sorted_rev_str_sorted_rev_str_sorted_rev\n}\n\
    \ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a row_cols=()\n\
    \    local -a rows=()\n    local -a cols=()\n    local -a result=()\n    local\
    \ -a row=()\n    local -a col=()\n    local -a row_col=()\n    local -a row_col_str=()\n\
    \    local -a row_col_str_sorted=()\n    local -a row_col_sorted=()\n    local\
    \ -a row_col_sorted_str=()\n    local -a row_col_sorted_str_sorted=()\n    local\
    \ -a row_col_sorted_str_sorted_str=()\n    local -a row_col_sorted_str_sorted_str_sorted=()\n\
    \    local -a row_col_sorted_str_sorted_str_sorted_str=()\n    local -a row_col_sorted_str_sorted_str_sorted_str_sorted=()\n\
    \    local -a row_col_sorted_str_sorted_str_sorted_str_sorted_str=()\n    local\
    \ -a row_col_sorted_str_sorted_str_sorted_str_sorted_str_sorted=()\n    local\
    \ -a row_col_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str=()\n    local\
    \ -a row_col_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted=()\n\
    \    local -a row_col_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str=()\n\
    \    local -a row_col_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted=()\n\
    \    local -a row_col_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str=()\n\
    \    local -\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ i=0\n    local j=0\n    for row in $(echo \"$lst\" | tr '\\n' ' '); do\n   \
    \     j=0\n        for col in $(echo \"$row\" | tr ' ' '\\n'); do\n          \
    \  if [[ \"$col\" == \"$x\" ]]; then\n                res+=(\"[\\\"$i\\\", \\\"\
    $j\\\"]\")\n            fi\n            j=$((j+1))\n        done\n        i=$((i+1))\n\
    \    done\n    echo \"${res[@]}\" | tr ' ' '\\n' | sort -t '\"' -k1n -k3nr | tr\
    \ '\\n' ' '\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\\
    n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\\
    n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\
    \ = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\"\
    \ ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\"\
    ) = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=\"$1\"\n    local x=\"$2\"\n    local -a result\n\
    \    local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_rev\n    local -a row_col_sorted_rev_str\n    local\
    \ -a row_col_sorted_rev_str_sorted\n    local -a row_col_sorted_rev_str_sorted_str\n\
    \    local -a row_col_sorted_rev_str_sorted_str_sorted\n    local -a row_col_sorted_rev_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_rev_str_sorted_str_sorted_str_sorted\n    local -a\
    \ row_col_sorted_rev_str_sorted_str_sorted_str_sorted_str\n    local -a row_col_sorted_rev_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_rev_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_rev_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_rev_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_rev_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_rev_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_rev_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    while read -r line; do\n        col=0\n\
    \        for i in $line; do\n            if [[ $i == $x ]]; then\n           \
    \     result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n           \
    \ col=$((col+1))\n        done\n        row=$((row+1))\n    done <<< \"$lst\"\n\
    \    echo \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"\
    1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\")\
    \ = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4\
    \ 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\\
    n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate\
    \ \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local row=0\n    local col=0\n    while read -r line; do\n        col=0\n\
    \        for num in $line; do\n            if [[ $num == $x ]]; then\n       \
    \         result+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n       \
    \     col=$((col+1))\n        done\n        row=$((row+1))\n    done <<< \"$lst\"\
    \n    echo \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5\
    \ 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\"\
    \ \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            ((row++))\n\
    \            col=0\n        else\n            ((col++))\n        fi\n    done\n\
    \    echo \"${result[@]}\" | tr ' ' ',' | sed 's/^/[/;s/$/]/'\n}\n\ncandidate()\
    \ {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\"\
    \ ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5\
    \ 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2\
    \ 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\
    \" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr ' ' '\\n'); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo \"${res[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
    n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo $lst | tr \" \" \"\\n\"); do\n\
    \        if [[ $i == $x ]]; then\n            res+=([\"$row,$col\"])\n       \
    \ fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row+1))\n     \
    \       col=0\n        else\n            col=$((col+1))\n        fi\n    done\n\
    \    echo ${res[@]} | tr \" \" \"\\n\" | sort -t \",\" -k 1n -k 2nr | tr \"\\\
    n\" \" \"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\\
    n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\\
    n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\\
    n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\
    \ = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\"\
    \ ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\"\
    ) = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a result=()\n\
    \    local -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_desc\n    local -a row_col_sorted_desc_str\n    local\
    \ -a row_col_sorted_desc_str_joined\n    local -a row_col_sorted_desc_str_joined_str\n\
    \    local -a row_col_sorted_desc_str_joined_str_joined\n    local -a row_col_sorted_desc_str_joined_str_joined_str\n\
    \    local -a row_col_sorted_desc_str_joined_str_joined_str_joined\n    local\
    \ -a row_col_sorted_desc_str_joined_str_joined_str_joined_str\n    local -a row_col_sorted_desc_str_joined_str_joined_str_joined_str_joined\n\
    \    local -a row_col_sorted_desc_str_joined_str_joined_str_joined_str_joined_str\n\
    \    local -a row_col_sorted_desc_str_joined_str_joined_str_joined_str_joined_str_joined\n\
    \    local -a row_col_sorted_desc_str_joined_str_joined_str_joined_str_joined_str_joined_str\n\
    \    local -a row_col_sorted_desc_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined\n\
    \    local -a row_col_sorted_desc_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined_str\n\
    \    local -a row_col_sorted_desc_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined\n\
    \    local -a row_col_sorted_desc_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined_str_joined_str\n\
    \    local -a row_col_sorted_\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5\
    \ 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3\
    \ 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\"\
    \ \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\\
    n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[\
    \ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\"\
    ) = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a row_cols=()\n\
    \    local -a rows=()\n    local -a cols=()\n    local -a result=()\n    local\
    \ -a row=()\n    local -a col=()\n    local -a row_col=()\n    local -a row_col_sorted=()\n\
    \    local -a row_col_sorted_rev=()\n    local -a row_col_sorted_rev_str=()\n\
    \    local -a row_col_sorted_rev_str_quoted=()\n    local -a row_col_sorted_rev_str_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_quoted=()\n    local -a row_col_sorted_rev_str_quoted_joined_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_quoted_joined_quoted=()\n \
    \   local -a row_col_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted_joined_quoted=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_quoted_joined_quoted_joined_quoted_joined_qu\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a rows\n   \
    \ local -a cols\n    local -a result\n    local -a row\n    local -a col\n   \
    \ local -a row_col\n    local -i i=0\n    local -i j=0\n    local -i k=0\n   \
    \ local -i l=0\n    local -i m=0\n    local -i n=0\n    local -i o=0\n    local\
    \ -i p=0\n    local -i q=0\n    local -i r=0\n    local -i s=0\n    local -i t=0\n\
    \    local -i u=0\n    local -i v=0\n    local -i w=0\n    local -i x=0\n    local\
    \ -i y=0\n    local -i z=0\n    local -i aa=0\n    local -i bb=0\n    local -i\
    \ cc=0\n    local -i dd=0\n    local -i ee=0\n    local -i ff=0\n    local -i\
    \ gg=0\n    local -i hh=0\n    local -i ii=0\n    local -i jj=0\n    local -i\
    \ kk=0\n    local -i ll=0\n    local -i mm=0\n    local -i nn=0\n    local -i\
    \ oo=0\n    local -i pp=0\n    local -i qq=0\n    local -i rr=0\n    local -i\
    \ ss=0\n    local -i tt=0\n    local -i uu=0\n    local -i vv=0\n    local -i\
    \ ww=0\n    local -i xx=0\n    local -i yy=0\n    local -i zz=0\n    local -i\
    \ aaa=0\n    local -i bbb=0\n    local -i ccc=0\n    local -i ddd=0\n    local\
    \ -i eee=0\n    local -i fff=0\n    local -i ggg=0\n    local -i hhh=0\n    local\
    \ -i iii=0\n    local -i jjj=0\n   \n}\n\ncandidate() {\n    get_row \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1\
    \ 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ row=0\n    local col=0\n    while read -r line; do\n        col=0\n        for\
    \ i in $line; do\n            if [ \"$i\" == \"$x\" ]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local result=()\n \
    \   local i=0\n    local j=0\n    local row\n    local col\n    for row in $lst;\
    \ do\n        j=0\n        for col in $row; do\n            if [[ $col == $x ]];\
    \ then\n                result+=(\"[\\\"$i\\\", \\\"$j\\\"]\")\n            fi\n\
    \            j=$((j+1))\n        done\n        i=$((i+1))\n    done\n    echo\
    \ \"${result[@]}\"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a rows\n   \
    \ local -a cols\n    local -a result\n    local i=0\n    local j=0\n    local\
    \ -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_desc\n    local -a row_col_sorted_desc_str\n    local\
    \ -a row_col_sorted_desc_str_sorted\n    local -a row_col_sorted_desc_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted\n    local -a row_col_sorted_desc_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted\n    local\
    \ -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str\n    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str_sorted_str\n\
    \    local -a row_col_sorted_desc_str_sorted_str_sorted_str_sorted_str_\n}\n\n\
    candidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a row\n    local -a col\n    local -a row_col\n    local -a row_col_sorted\n\
    \    local -a row_col_sorted_rev\n    local -a row_col_sorted_rev_str\n    local\
    \ -a row_col_sorted_rev_str_quoted\n    local -a row_col_sorted_rev_str_quoted_str\n\
    \    local -a row_col_sorted_rev_str_quoted_str_quoted\n    local -a row_col_sorted_rev_str_quoted_str_quoted_str\n\
    \    local -a row_col_sorted_rev_str_quoted_str_quoted_str_quoted\n    local -a\
    \ row_col_sorted_rev_str_quoted_str_quoted_str_quoted_str\n    local -a row_col_sorted_rev_str_quoted_str_quoted_str_quoted_str_quoted\n\
    \    local -a row_col_sorted_rev_str_quoted_str_quoted_str_quoted_str_quoted_str\n\
    \    local -a row_col_sorted_rev_str_quoted_str_quoted_str_quoted_str_quoted_str_quoted\n\
    \    local -a row_col_sorted_rev_str_quoted_str_quoted_str_quoted_str_quoted_str_quoted_str\n\
    \    local -a row_col_sorted_rev_str_quoted_str_quoted_str_quoted_str_quoted_str_quoted_str_quoted\n\
    \    local -a row_col_sorted_rev_str_quoted_str_quoted_str_quoted_str_quoted_str_quoted_str_quoted_str\n\
    \    local -a row_col_sorted_rev_str_quoted_str_quoted_str_quoted_str_quoted_str_quoted_str_quoted_str_quoted\n\
    \    local -a row_col\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    for i in $(echo \"$lst\" | tr \" \" \"\\n\"); do\n\
    \        if [[ $i == $x ]]; then\n            res+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == $'\\n' ]]; then\n            ((row++))\n\
    \            col=0\n        else\n            ((col++))\n        fi\n    done\n\
    \    echo \"${res[@]}\" | tr \" \" \"\\n\" | sort -t '\"' -k1,1n -k3,3nr | tr\
    \ \"\\n\" \" \"\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"\
    0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5\
    \ 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\\
    n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\"\
    \ \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\\
    n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\"\
    \ \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [ \"$i\" == \"$x\" ]; then\n            \
    \    res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res=()\n \
    \   local -a row=()\n    local -a col=()\n    local -a row_col=()\n    local -a\
    \ row_col_sorted=()\n    local -a row_col_sorted_rev=()\n    local -a row_col_sorted_rev_str=()\n\
    \    local -a row_col_sorted_rev_str_quoted=()\n    local -a row_col_sorted_rev_str_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_str=()\n    local -a row_col_sorted_rev_str_quoted_joined_str_quoted=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined=()\n    local\
    \ -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined_str=()\n    local\
    \ -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted=()\n  \
    \  local -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted_joined_str=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted_joined_str_quoted=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted_joined_str_quoted_joined=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined_str_quoted_joined_str_quoted_joined_str=()\n\
    \    local -a row_col_sorted_rev_str_quoted_joined_str_quoted_joined_str_\n}\n\
    \ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local -a res\n    local\
    \ -a arr\n    local -a arr2\n    local -a arr3\n    local -a arr4\n    local -a\
    \ arr5\n    local -a arr6\n    local -a arr7\n    local -a arr8\n    local -a\
    \ arr9\n    local -a arr10\n    local -a arr11\n    local -a arr12\n    local\
    \ -a arr13\n    local -a arr14\n    local -a arr15\n    local -a arr16\n    local\
    \ -a arr17\n    local -a arr18\n    local -a arr19\n    local -a arr20\n    local\
    \ -a arr21\n    local -a arr22\n    local -a arr23\n    local -a arr24\n    local\
    \ -a arr25\n    local -a arr26\n    local -a arr27\n    local -a arr28\n    local\
    \ -a arr29\n    local -a arr30\n    local -a arr31\n    local -a arr32\n    local\
    \ -a arr33\n    local -a arr34\n    local -a arr35\n    local -a arr36\n    local\
    \ -a arr37\n    local -a arr38\n    local -a arr39\n    local -a arr40\n    local\
    \ -a arr41\n    local -a arr42\n    local -a arr43\n    local -a arr44\n    local\
    \ -a arr45\n    local -a arr46\n    local -a arr47\n    local -a arr48\n    local\
    \ -a arr49\n    local -a arr50\n    local -a arr51\n    local -a arr52\n    local\
    \ -a arr53\n    local -a arr54\n    local -a arr55\n    local -a arr56\n    local\
    \ -a arr57\n    local -a arr58\n    local -a arr59\n    local -a arr60\n    local\
    \ -a arr61\n    local -a arr62\n    local -a arr63\n    local -a arr64\n    local\
    \ -a arr65\n    local -a arr66\n    local -a arr67\n    local -a arr68\n    local\
    \ -a arr69\n    local -a arr70\n    local -\n}\n\ncandidate() {\n    get_row \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1\
    \ 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for i in $line; do\n            if [[ $i == $x ]]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \ | jq -s 'sort_by(. | tonumber)'\n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3\
    \ 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1\
    \ 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4\
    \ 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2\
    \ 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\\
    n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate \"\" \"1\") = \"\" ]]\n\
    \    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate \"\\n1\\n1 2 3\"\
    \ \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpho9b5mmk.sh: line 33: jq: command not found\n'''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local result=()\n    for i in $(echo $lst | tr ' ' '\\n'); do\n \
    \       if [[ $i == $x ]]; then\n            result+=(\"[\\\"$row\\\", \\\"$col\\\
    \"]\")\n        fi\n        if [[ $i == \"\\n\" ]]; then\n            row=$((row\
    \ + 1))\n            col=0\n        else\n            col=$((col + 1))\n     \
    \   fi\n    done\n    echo ${result[@]} | tr ' ' ',' | sed 's/^/[/' | sed 's/$/]/'\n\
    }\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local res=()\n    local\
    \ row=0\n    local col=0\n    while read -r line; do\n        col=0\n        for\
    \ i in $line; do\n            if [ \"$i\" == \"$x\" ]; then\n                res+=(\"\
    [\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
- exit_code: 1
  program: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n\
    # which is similar to matrix, however, unlike matrices,\n# each row may contain\
    \ a different number of columns.\n# Given lst, and integer x, find integers x\
    \ in the list,\n# and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    # each tuple is a coordinate - (row, columns), starting with 0.\n# Sort coordinates\
    \ initially by rows in ascending order.\n# Also, sort coordinates of the row by\
    \ columns in descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1\
    \ 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'],\
    \ ['\"1\"', '\"0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row\
    \ \"\" \"1\")\n# []\n# >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"\
    2\"']]\nget_row() {\n    local lst=$1\n    local x=$2\n    local row=0\n    local\
    \ col=0\n    local res=()\n    while read -r line; do\n        col=0\n       \
    \ for num in $line; do\n            if [[ $num == $x ]]; then\n              \
    \  res+=(\"[\\\"$row\\\", \\\"$col\\\"]\")\n            fi\n            col=$((col+1))\n\
    \        done\n        row=$((row+1))\n    done <<< \"$lst\"\n    echo \"${res[@]}\"\
    \n}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\n1 0\\n2 5\\\
    n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2\
    \ 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3 1\\n4 1\\\
    n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5 6\\n1 2\
    \ 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 0\\n2\
    \ 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
    \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
    \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660340335
