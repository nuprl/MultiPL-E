language: sh
name: HumanEval_2_truncate_number
results:
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo $number | cut -d. -f1)\n    local decimal_part=$(echo\
    \ $number | cut -d. -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n \
    \   truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{ print $1 - int($1) }'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo $number | cut -d'.' -f1)\n    local decimal_part=$(echo\
    \ $number | cut -d'.' -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n  local number=\"\
    $1\"\n  local integer_part=$(echo \"$number\" | cut -d'.' -f1)\n  local decimal_part=$(echo\
    \ \"$number\" | cut -d'.' -f2)\n  echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo $1\
    \ | awk '{printf \"%f\", $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d. -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d. -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d. -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d. -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d'.' -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d'.' -f2)\n    if [ -z \"$decimal_part\" ]; then\n      \
    \  echo \"0\"\n    else\n        echo \"0.$decimal_part\"\n    fi\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo $number | cut -d'.' -f1)\n    local decimal_part=$(echo\
    \ $number | cut -d'.' -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=${number%.*}\n    local decimal_part=${number#*.}\n  \
    \  echo \"0.${decimal_part}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{printf \"%.2f\", $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"${decimal_part}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d'.' -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d'.' -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"${decimal_part:0:1}.${decimal_part:1}\"\n}\n\ncandidate() {\n   \
    \ truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n  local number=\"\
    $1\"\n  local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n  local decimal_part=$(echo\
    \ \"$number\" | cut -d '.' -f 2)\n  echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=${number%%.*}\n    local decimal_part=${number#*.}\n \
    \   echo \"0.${decimal_part}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo \"$number\" | cut -d'.' -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d'.' -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{ print $1 - int($1) }'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n  local number=\"\
    $1\"\n  local integer_part=\"${number%.*}\"\n  local decimal_part=\"${number#*.}\"\
    \n  echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo $number | cut -d '.' -f 1)\n    local decimal_part=$(echo\
    \ $number | cut -d '.' -f 2)\n    echo \"0.${decimal_part}\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=${number%.*}\n    local decimal_part=${number#*.}\n  \
    \  echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    echo \"${number#*.*}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n  local number=\"\
    $1\"\n  echo \"$number\" | awk -F. '{print $2}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d'.' -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d'.' -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d. -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d. -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    if [ \"$decimal_part\"\
    \ == \"\" ]; then\n        echo \"0\"\n    else\n        echo \"0.$decimal_part\"\
    \n    fi\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n  local number=\"\
    $1\"\n  local integer_part=$(echo \"$number\" | cut -d. -f1)\n  local decimal_part=$(echo\
    \ \"$number\" | cut -d. -f2)\n  echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    echo \"${number}\" | awk '{printf(\"%s\", $1 - int($1))}'\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d. -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d. -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | awk '{print int($1)}')\n   \
    \ local decimal_part=$(echo \"$number - $integer_part\" | bc)\n    echo \"$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    echo \"${number}\" | awk '{printf(\"%s\", $1 - int($1))}'\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    echo \"$number\" | awk -F\".\" '{print $2}'\n}\n\ncandidate() {\n  \
    \  truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n  echo \"$1\"\
    \ | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    echo \"${number#*.*}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    echo \"$number\" | awk -F '.' '{print $2}'\n}\n\ncandidate() {\n   \
    \ truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | awk '{print int($1)}')\n   \
    \ local decimal_part=$(echo \"$number - $integer_part\" | bc)\n    echo \"$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local int_part=\"${number%.*}\"\n    local dec_part=\"${number#*.}\"\
    \n    echo \"0.$dec_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{printf(\"%f\", $1 - int($1))}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    if [ -z \"$decimal_part\"\
    \ ]; then\n        decimal_part=\"0\"\n    fi\n    echo \"$decimal_part\"\n}\n\
    \ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n\
    \    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    echo \"${number#*.*}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n  local number=$1\n\
    \  local integer_part=$(echo $number | cut -d. -f1)\n  local decimal_part=$(echo\
    \ $number | cut -d. -f2)\n  echo \"0.$decimal_part\"\n}\n\ncandidate() {\n   \
    \ truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    if [ -z \"$decimal_part\"\
    \ ]; then\n        echo \"0\"\n    else\n        echo \"0.$decimal_part\"\n  \
    \  fi\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d'.' -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d'.' -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo $number | cut -d '.' -f 1)\n    local decimal_part=$(echo\
    \ $number | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo $number | cut -d. -f1)\n    local decimal_part=$(echo\
    \ $number | cut -d. -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n \
    \   truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local int_part=$(echo \"$number\" | cut -d. -f1)\n    local dec_part=$(echo\
    \ \"$number\" | cut -d. -f2)\n    echo \"0.$dec_part\"\n}\n\ncandidate() {\n \
    \   truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    echo \"${number#*.*}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo $1\
    \ | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{printf \"%.2f\", $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{printf \"%.2f\", $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d. -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d. -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{ print $1 - int($1) }'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d. -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d. -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    echo \"$number\" | awk -F. '{print $2}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    echo \"$number\" | awk -F \".\" '{print $2}'\n}\n\ncandidate() {\n \
    \   truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    echo \"${number}\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo $number | cut -d \".\" -f 1)\n    local decimal_part=$(echo\
    \ $number | cut -d \".\" -f 2)\n    echo \"0.${decimal_part}\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo $number | cut -d. -f1)\n    local decimal_part=$(echo\
    \ $number | cut -d. -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n \
    \   truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n  echo $1 |\
    \ awk '{printf \"%.2f\", $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d'.' -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d'.' -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d'.' -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d'.' -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | awk '{print int($1)}')\n   \
    \ local decimal_part=$(echo \"$number - $integer_part\" | bc)\n    echo \"$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo \"$number\" | cut -d'.' -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d'.' -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d'.' -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d'.' -f2)\n    local decimal_part_length=$(echo \"$decimal_part\"\
    \ | wc -c)\n    local decimal_part_length=$((decimal_part_length - 1))\n    local\
    \ decimal_part_length=$((decimal_part_length - integer_part))\n    local decimal_part=$(echo\
    \ \"$decimal_part\" | cut -c1-$decimal_part_length)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b"cut: invalid byte or character range\nTry ''cut --help'' for more information.\n"'
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d. -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d. -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d. -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d. -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo $1\
    \ | awk '{printf \"%.2f\", $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d'.' -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d'.' -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    echo \"${number}\" | awk '{printf(\"%s\", $1 - int($1))}'\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d \".\" -f 2)\n    if [ -z \"$decimal_part\" ]; then\n  \
    \      echo \"0\"\n    else\n        echo \"0.$decimal_part\"\n    fi\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"${decimal_part:0:1}.${decimal_part:1}\"\n}\n\ncandidate() {\n   \
    \ truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo $number | cut -d '.' -f 1)\n    local decimal_part=$(echo\
    \ $number | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo $1\
    \ | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo $number | cut -d. -f1)\n    local decimal_part=$(echo\
    \ $number | cut -d. -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n \
    \   truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo $1\
    \ | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    echo \"${number}\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local int_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"${decimal_part}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{printf \"%.2f\", $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo \"$number\" | cut -d. -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d. -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer=$(echo \"$number\" | cut -d. -f1)\n    local decimals=$(echo\
    \ \"$number\" | cut -d. -f2)\n    if [ -z \"$decimals\" ]; then\n        decimals=\"\
    0\"\n    fi\n    echo \"0.$decimals\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{printf \"%f\", $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{printf(\"%s\", $1 - int($1))}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{printf \"%.2f\", $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(printf \"%.0f\" \"$number\")\n    local decimal_part=$(echo\
    \ \"$number - $integer_part\" | bc)\n    echo \"$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local int_part=\"${number%.*}\"\n    local dec_part=\"${number#*.}\"\
    \n    echo \"0.$dec_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo $number | cut -d. -f1)\n    local decimal_part=$(echo\
    \ $number | cut -d. -f2)\n    echo \"0.${decimal_part}\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n  local number=\"\
    $1\"\n  local integer_part=$(echo \"$number\" | cut -d'.' -f1)\n  local decimal_part=$(echo\
    \ \"$number\" | cut -d'.' -f2)\n  echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo $number | cut -d '.' -f 1)\n    local decimal_part=$(echo\
    \ $number | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d. -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d. -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo \"$number\" | cut -d'.' -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d'.' -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d. -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d. -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    echo \"$number\" | awk -F. '{print $2}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d. -f1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d. -f2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    echo \"\
    $1\" | awk '{printf(\"%s\", $1 - int($1))}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n  local number=\"\
    $1\"\n  local integer_part=\"${number%.*}\"\n  local decimal_part=\"${number#*.}\"\
    \n  echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo $number | cut -d '.' -f 1)\n    local decimal_part=$(echo\
    \ $number | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo $number | cut -d. -f1)\n    local decimal_part=$(echo\
    \ $number | cut -d. -f2)\n    local truncated_number=\"0.$decimal_part\"\n   \
    \ echo $truncated_number\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n  local number=\"\
    $1\"\n  local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n  local decimal_part=$(echo\
    \ \"$number\" | cut -d '.' -f 2)\n  echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n  local number=$1\n\
    \  local integer_part=$(echo $number | cut -d. -f1)\n  local decimal_part=$(echo\
    \ $number | cut -d. -f2)\n  echo \"0.$decimal_part\"\n}\n\ncandidate() {\n   \
    \ truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    if [ $#\
    \ -ne 1 ]; then\n        echo \"Usage: $0 <number>\"\n        exit 1\n    fi\n\
    \    echo \"$1\" | cut -d. -f2\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(printf \"%.0f\" \"$number\")\n    local decimal_part=$(echo\
    \ \"$number - $integer_part\" | bc)\n    echo \"$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n  echo \"$1\"\
    \ | awk '{print $1 - int($1)}'\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | cut -d '.' -f 1)\n    local\
    \ decimal_part=$(echo \"$number\" | cut -d '.' -f 2)\n    echo \"0.$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number#*.}\"\
    \n    echo \"0.$decimal_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=\"\
    $1\"\n    local integer_part=$(echo \"$number\" | awk '{print int($1)}')\n   \
    \ local decimal_part=$(echo \"$number - $integer_part\" | bc)\n    echo \"$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660341774
- exit_code: 0
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\ntruncate_number() {\n    local number=$1\n\
    \    local integer_part=$(echo \"$number\" | cut -d \".\" -f 1)\n    local decimal_part=$(echo\
    \ \"$number\" | cut -d \".\" -f 2)\n    echo \"0.$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: b''
  stdout: b''
  timestamp: 1660341774
