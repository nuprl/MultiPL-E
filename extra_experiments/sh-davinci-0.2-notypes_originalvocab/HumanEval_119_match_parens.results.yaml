language: sh
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local count=0\n    local i=0\n    local len=${#str3}\n\
    \    while [ $i -lt $len ]; do\n        if [ \"${str3:$i:1}\" == \"(\" ]; then\n\
    \            count=$((count+1))\n        elif [ \"${str3:$i:1}\" == \")\" ]; then\n\
    \            count=$((count-1))\n        fi\n        if [ $count -lt 0 ]; then\n\
    \            break\n        fi\n        i=$((i+1))\n    done\n    if [ $count\
    \ -eq 0 ]; then\n        echo \"Yes\"\n    else\n        count=0\n        i=0\n\
    \        while [ $i -lt $len ]; do\n            if [ \"${str4:$i:1}\" == \"(\"\
    \ ]; then\n                count=$((count+1))\n            elif [ \"${str4:$i:1}\"\
    \ == \")\" ]; then\n                count=$((count-1))\n            fi\n     \
    \       if [ $count -lt 0 ]; then\n                break\n            fi\n   \
    \         i=$((i+1))\n        done\n        if [ $count -eq 0 ]; then\n      \
    \      echo \"Yes\"\n        else\n            echo \"No\"\n        fi\n    fi\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    if [[ $(is_good_parens $str3) == \"Yes\" ]]; then\n   \
    \     echo \"Yes\"\n    elif [[ $(is_good_parens $str4) == \"Yes\" ]]; then\n\
    \        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpzjzikx4o.sh: line 20: is_good_parens: command not found\n/tmp/tmpzjzikx4o.sh:
    line 22: is_good_parens: command not found\n'''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | tr -d '()' | wc -c)\n  local str6=$(echo $str4 |\
    \ tr -d '()' | wc -c)\n  if [ $str5 -eq 0 ] || [ $str6 -eq 0 ]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str=\"$str1$str2\"\n    local\
    \ count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ ${str:$i:1} ==\
    \ \"(\" ]]; then\n            (( count++ ))\n        elif [[ ${str:$i:1} == \"\
    )\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count -lt\
    \ 0 ]]; then\n            echo \"No\"\n            return\n        fi\n    done\n\
    \    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n        echo\
    \ \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [ -z \"$str5\" ];\
    \ then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" == \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n  if [[ \"$str5\" == \"\"\
    \ ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo \"\
    Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ \"$count\" -lt 0 ]]; then\n      echo\
    \ \"No\"\n      return\n    fi\n  done\n  if [[ \"$count\" -eq 0 ]]; then\n  \
    \  echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [ -z $str5 ]; then\n        echo \"Yes\"\n  \
    \  elif [ -z $str6 ]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\
    \n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmptc13my7j.sh: line 22: [: (: binary operator expected\n/tmp/tmptc13my7j.sh:
    line 24: [: (: binary operator expected\n'''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      count=$(( count + 1 ))\n    elif [[ \"${str:$i:1}\" == \"\
    )\" ]]; then\n      count=$(( count - 1 ))\n    fi\n    if [[ $count -lt 0 ]];\
    \ then\n      echo \"No\"\n      return\n    fi\n  done\n  if [[ $count -eq 0\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\n  local str4=\"\
    $str2$str1\"\n  local str5=\"$(echo $str3 | sed 's/()//g')\"\n  local str6=\"\
    $(echo $str4 | sed 's/()//g')\"\n  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\
    \n  elif [[ $str6 == \"\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n\
    \  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" == \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [[ -z $str5 ]]; then\n        echo \"Yes\"\n\
    \    elif [[ -z $str6 ]]; then\n        echo \"Yes\"\n    else\n        echo \"\
    No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local count=0\n  for (( i=0; i<${#str3}; i++ )); do\n    if [[ ${str3:$i:1}\
    \ == \"(\" ]]; then\n      (( count++ ))\n    else\n      (( count-- ))\n    fi\n\
    \    if [[ $count -lt 0 ]]; then\n      break\n    fi\n  done\n  if [[ $count\
    \ -eq 0 ]]; then\n    echo \"Yes\"\n  else\n    count=0\n    for (( i=0; i<${#str4};\
    \ i++ )); do\n      if [[ ${str4:$i:1} == \"(\" ]]; then\n        (( count++ ))\n\
    \      else\n        (( count-- ))\n      fi\n      if [[ $count -lt 0 ]]; then\n\
    \        break\n      fi\n    done\n    if [[ $count -eq 0 ]]; then\n      echo\
    \ \"Yes\"\n    else\n      echo \"No\"\n    fi\n  fi\n}\n\ncandidate() {\n   \
    \ match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"\
    (()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"()\
    \ ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[\
    \ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\") =\
    \ \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [ -z \"$str5\" ] || [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n \
    \   echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str3}; i++ )); do\n        if [[ ${str3:$i:1}\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ ${str3:$i:1} ==\
    \ \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str3}; i++ )); do\n        if [[ ${str3:$i:1}\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ ${str3:$i:1} ==\
    \ \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return 0\n        fi\n\
    \    done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n \
    \       echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=\"$str1$str2\"\n   \
    \ local str4=\"$str2$str1\"\n    local str5=\"$(echo $str3 | sed 's/()//g')\"\n\
    \    local str6=\"$(echo $str4 | sed 's/()//g')\"\n    if [ \"$str5\" == \"\"\
    \ ]; then\n        echo \"Yes\"\n    elif [ \"$str6\" == \"\" ]; then\n      \
    \  echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n \
    \   match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"\
    (()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"()\
    \ ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[\
    \ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\") =\
    \ \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str1_len=${#str1}\n  local str2_len=${#str2}\n\
    \  local str1_open=0\n  local str1_close=0\n  local str2_open=0\n  local str2_close=0\n\
    \  local i=0\n  local j=0\n  local k=0\n  local l=0\n  local str1_open_arr=()\n\
    \  local str1_close_arr=()\n  local str2_open_arr=()\n  local str2_close_arr=()\n\
    \  local str1_open_arr_len=0\n  local str1_close_arr_len=0\n  local str2_open_arr_len=0\n\
    \  local str2_close_arr_len=0\n  local str1_open_arr_last=0\n  local str1_close_arr_last=0\n\
    \  local str2_open_arr_last=0\n  local str2_close_arr_last=0\n  local str1_open_arr_last_index=0\n\
    \  local str1_close_arr_last_index=0\n  local str2_open_arr_last_index=0\n  local\
    \ str2_close_arr_last_index=0\n  local str1_open_arr_last_index_plus_one=0\n \
    \ local str1_close_arr_last_index_plus_one=0\n  local str2_open_arr_last_index_plus_one=0\n\
    \  local str2_close_arr_last_index_plus_one=0\n  local str1_open_arr_last_index_plus_one_char=''\n\
    \  local str1_close_arr_last_index_plus_one_char=''\n  local str2_open_arr_last_index_plus_one_char=''\n\
    \  local str2_close_arr_last_index_plus_one_char=''\n  local str1_open_arr_last_index_plus_one_char_is_open=0\n\
    \  local str1_close_arr_last_index_plus_one_char\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6 ]]; then\n  \
    \  echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" = \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" = \"\" ]]; then\n    echo \"\
    Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [ -z \"$str5\" ];\
    \ then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n  local str4=$4\n  local\
    \ str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n  local str9=$9\n\
    \  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n  local str13=${13}\n\
    \  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n  local str17=${17}\n\
    \  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n  local str21=${21}\n\
    \  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n  local str25=${25}\n\
    \  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n  local str29=${29}\n\
    \  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n  local str33=${33}\n\
    \  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n  local str37=${37}\n\
    \  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n  local str41=${41}\n\
    \  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n  local str45=${45}\n\
    \  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n  local str49=${49}\n\
    \  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n  local str53=${53}\n\
    \  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n  local str57=${57}\n\
    \  local str58=${58}\n  local str59=${59\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk0c_kns7.sh: line 98: syntax error: unexpected end of file\n'''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  if [[ $(check_parens $str3) == \"Yes\" ]]; then\n    echo \"Yes\"\n  elif [[\
    \ $(check_parens $str4) == \"Yes\" ]]; then\n    echo \"Yes\"\n  else\n    echo\
    \ \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpdf00grdj.sh: line 20: check_parens: command not found\n/tmp/tmpdf00grdj.sh:
    line 22: check_parens: command not found\n'''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [ -z \"$str5\" ];\
    \ then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local s1=\"$1\"\n    local s2=\"$2\"\n    local s3=\"$s1$s2\"\n    local\
    \ s4=\"$s2$s1\"\n    local s5=\"$(echo \"$s3\" | sed 's/[()]//g')\"\n    local\
    \ s6=\"$(echo \"$s4\" | sed 's/[()]//g')\"\n    if [[ -z \"$s5\" ]]; then\n  \
    \      echo \"Yes\"\n    elif [[ -z \"$s6\" ]]; then\n        echo \"Yes\"\n \
    \   else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str=\"$1\"\n  local str_len=${#str}\n  local i=0\n  local open_parens=0\n\
    \  local close_parens=0\n  while [ $i -lt $str_len ]; do\n    local char=${str:$i:1}\n\
    \    if [ \"$char\" == \"(\" ]; then\n      open_parens=$((open_parens + 1))\n\
    \    elif [ \"$char\" == \")\" ]; then\n      close_parens=$((close_parens + 1))\n\
    \    fi\n    i=$((i + 1))\n  done\n  if [ $open_parens -eq $close_parens ]; then\n\
    \    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\n  local str4=\"\
    $str2$str1\"\n  if [[ $(is_good \"$str3\") == \"Yes\" ]]; then\n    echo \"Yes\"\
    \n  elif [[ $(is_good \"$str4\") == \"Yes\" ]]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpomksiags.sh: line 20: is_good: command not found\n/tmp/tmpomksiags.sh:
    line 22: is_good: command not found\n'''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [[ $str5 == \"\" ]]; then\n        echo \"Yes\"\
    \n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\n    else\n       \
    \ echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n  if [ \"$str5\" == \"\"\
    \ ] || [ \"$str6\" == \"\" ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n\
    \  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  if [[ $str3 =~ ^\\(+\\)+$ ]] || [[ $str4 =~ ^\\(+\\)+$ ]]; then\n    echo \"\
    Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  if [[ $(echo $str3 | grep -P '^\\(\\)\\(\\)$') ]]; then\n    echo \"Yes\"\n\
    \  elif [[ $(echo $str4 | grep -P '^\\(\\)\\(\\)$') ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" == \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  if [[ $str3 =~ ^\\(+\\)+$ ]] || [[ $str4 =~ ^\\(+\\)+$ ]]; then\n    echo \"\
    Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=\"$str1$str2\"\n   \
    \ local str4=\"$str2$str1\"\n    local str5=$(echo \"$str3\" | sed 's/[^()]//g')\n\
    \    local str6=$(echo \"$str4\" | sed 's/[^()]//g')\n    local str7=$(echo \"\
    $str5\" | sed 's/()//g')\n    local str8=$(echo \"$str6\" | sed 's/()//g')\n \
    \   if [ -z \"$str7\" ]; then\n        echo \"Yes\"\n    elif [ -z \"$str8\" ];\
    \ then\n        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\n  local str4=\"\
    $str2$str1\"\n  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo\
    \ $str4 | sed 's/[()]//g')\n  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif\
    \ [[ -z $str6 ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\n\
    candidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  if [[ $(is_good_parens $str3) == \"Yes\" ]]; then\n    echo \"Yes\"\n  elif\
    \ [[ $(is_good_parens $str4) == \"Yes\" ]]; then\n    echo \"Yes\"\n  else\n \
    \   echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpu61qje_y.sh: line 20: is_good_parens: command not found\n/tmp/tmpu61qje_y.sh:
    line 22: is_good_parens: command not found\n'''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [ -z \"$str5\" ]; then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n\
    \    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/\\(.*\\)/\\(\\1\\)/')\n\
    \    local str6=$(echo $str4 | sed 's/\\(.*\\)/\\(\\1\\)/')\n    if [[ $str5 =~\
    \ ^\\(\\)\\)$ ]] || [[ $str6 =~ ^\\(\\)\\)$ ]]; then\n        echo \"No\"\n  \
    \  else\n        echo \"Yes\"\n    fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" == \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [ \"$str5\" == \"\
    \" ] || [ \"$str6\" == \"\" ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\
    \n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local count=0\n  for (( i=0; i<${#str3}; i++ )); do\n    if [[ ${str3:$i:1}\
    \ == \"(\" ]]; then\n      (( count++ ))\n    elif [[ ${str3:$i:1} == \")\" ]];\
    \ then\n      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo\
    \ \"No\"\n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [ -z \"$str5\" ] || [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n \
    \   echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local parens=$1\n  local stack=()\n  local top\n  local i\n  local c\n\
    \  for ((i=0; i<${#parens}; i++)); do\n    c=${parens:$i:1}\n    if [[ $c == '('\
    \ ]]; then\n      stack+=($c)\n    else\n      top=${stack[${#stack[@]}-1]}\n\
    \      if [[ $top == '(' ]]; then\n        stack=(\"${stack[@]:0:${#stack[@]}-1}\"\
    )\n      else\n        stack+=($c)\n      fi\n    fi\n  done\n  if [[ ${#stack[@]}\
    \ -eq 0 ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpyqi2dh38.sh: line 26: stack: bad array subscript\n'''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n    local str6=$(echo\
    \ $str4 | sed 's/[()]//g')\n    if [[ -z $str5 ]]; then\n        echo \"Yes\"\n\
    \    elif [[ -z $str6 ]]; then\n        echo \"Yes\"\n    else\n        echo \"\
    No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str=\"$str1$str2\"\n  local count=0\n\
    \  for (( i=0; i<${#str}; i++ )); do\n    if [[ ${str:$i:1} == \"(\" ]]; then\n\
    \      (( count++ ))\n    elif [[ ${str:$i:1} == \")\" ]]; then\n      (( count--\
    \ ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\n      return\n\
    \    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\n  else\n   \
    \ echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6\
    \ == \"\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6\
    \ == \"\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local open=0\n    local close=0\n    for ((i=0; i<${#str3}; i++)); do\n\
    \        if [[ \"${str3:$i:1}\" == \"(\" ]]; then\n            ((open++))\n  \
    \      elif [[ \"${str3:$i:1}\" == \")\" ]]; then\n            ((close++))\n \
    \       fi\n    done\n    if [[ \"$open\" -eq \"$close\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [ -z \"$str5\" ];\
    \ then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str=\"$str1$str2\"\n  local len=${#str}\n\
    \  local i=0\n  local count=0\n  for ((i=0; i<len; i++)); do\n    if [[ \"${str:i:1}\"\
    \ == \"(\" ]]; then\n      count=$((count + 1))\n    else\n      count=$((count\
    \ - 1))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\n      return\n\
    \    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\n  else\n   \
    \ echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [ -z \"$str5\" ];\
    \ then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6\
    \ == \"\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    if [[ $(check_parens $str3) == \"Yes\" ]]; then\n     \
    \   echo \"Yes\"\n    elif [[ $(check_parens $str4) == \"Yes\" ]]; then\n    \
    \    echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpwzokmbua.sh: line 20: check_parens: command not found\n/tmp/tmpwzokmbua.sh:
    line 22: check_parens: command not found\n'''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local len=${#str}\n    local i=0\n    local count=0\n    while [ $i -lt\
    \ $len ]; do\n        local char=${str:$i:1}\n        if [ \"$char\" == \"(\"\
    \ ]; then\n            count=$((count + 1))\n        elif [ \"$char\" == \")\"\
    \ ]; then\n            count=$((count - 1))\n        fi\n        if [ $count -lt\
    \ 0 ]; then\n            echo \"No\"\n            return\n        fi\n       \
    \ i=$((i + 1))\n    done\n    if [ $count -eq 0 ]; then\n        echo \"Yes\"\n\
    \    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str=\"$str1$str2\"\n  local count=0\n\
    \  for (( i=0; i<${#str}; i++ )); do\n    if [[ ${str:$i:1} == \"(\" ]]; then\n\
    \      (( count++ ))\n    elif [[ ${str:$i:1} == \")\" ]]; then\n      (( count--\
    \ ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\n      return\n\
    \    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\n  else\n   \
    \ echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6 ]]; then\n  \
    \  echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\n  local str4=\"\
    $str2$str1\"\n  if [[ $(parens_balanced \"$str3\") == \"Yes\" ]]; then\n    echo\
    \ \"Yes\"\n  elif [[ $(parens_balanced \"$str4\") == \"Yes\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmp5sk786_w.sh: line 20: parens_balanced: command not found\n/tmp/tmp5sk786_w.sh:
    line 22: parens_balanced: command not found\n'''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    if [[ $(is_good_parens $str3) == \"Yes\" ]]; then\n   \
    \     echo \"Yes\"\n    elif [[ $(is_good_parens $str4) == \"Yes\" ]]; then\n\
    \        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpzjzikx4o.sh: line 20: is_good_parens: command not found\n/tmp/tmpzjzikx4o.sh:
    line 22: is_good_parens: command not found\n'''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\n  local str4=\"\
    $str2$str1\"\n  local str5=\"$(echo $str3 | sed 's/[()]//g')\"\n  local str6=\"\
    $(echo $str4 | sed 's/[()]//g')\"\n  if [ -z \"$str5\" ]; then\n    echo \"Yes\"\
    \n  elif [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n \
    \ fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ len=${#str}\n  local count=0\n  for (( i=0; i<$len; i++ )); do\n    if [[ \"\
    ${str:$i:1}\" == \"(\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n\
    \      echo \"No\"\n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n\
    \    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local stack=()\n    local i=0\n    local len=${#str}\n    local c\n    while\
    \ [ $i -lt $len ]; do\n        c=${str:$i:1}\n        if [ \"$c\" == \"(\" ];\
    \ then\n            stack+=($c)\n        elif [ \"$c\" == \")\" ]; then\n    \
    \        if [ ${#stack[@]} -eq 0 ]; then\n                echo \"No\"\n      \
    \          return\n            fi\n            stack=(\"${stack[@]:0:$((${#stack[@]}\
    \ - 1))}\")\n        fi\n        i=$(($i + 1))\n    done\n    if [ ${#stack[@]}\
    \ -eq 0 ]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" == \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" == \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\n  local str4=\"\
    $str2$str1\"\n  local str5=$(echo \"$str3\" | sed 's/[()]//g')\n  local str6=$(echo\
    \ \"$str4\" | sed 's/[()]//g')\n  if [[ -z \"$str5\" ]]; then\n    echo \"Yes\"\
    \n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n\
    \  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [ -z \"$str5\" ];\
    \ then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n    if [[ \"$str5\" ==\
    \ \"\" ]]; then\n        echo \"Yes\"\n    elif [[ \"$str6\" == \"\" ]]; then\n\
    \        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str=\"$str1$str2\"\n  local count=0\n\
    \  for (( i=0; i<${#str}; i++ )); do\n    if [[ ${str:$i:1} == \"(\" ]]; then\n\
    \      (( count++ ))\n    elif [[ ${str:$i:1} == \")\" ]]; then\n      (( count--\
    \ ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\n      return\n\
    \    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\n  else\n   \
    \ echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [ -z \"$str5\" ]; then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n\
    \    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [ \"$str5\" == \"\
    \" ] || [ \"$str6\" == \"\" ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\
    \n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6 ]]; then\n  \
    \  echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6 == \"\" ]];\
    \ then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local count=0\n  for (( i=0; i<${#str3}; i++ )); do\n    if [[ ${str3:$i:1}\
    \ == \"(\" ]]; then\n      (( count++ ))\n    elif [[ ${str3:$i:1} == \")\" ]];\
    \ then\n      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo\
    \ \"No\"\n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n  if [[ \"$str5\" == \"\"\
    \ ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo \"\
    Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6 ]]; then\n  \
    \  echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=\"$str1$str2\"\n   \
    \ local str4=\"$str2$str1\"\n    local str5\n    local str6\n    local str7\n\
    \    local str8\n    local str9\n    local str10\n    local str11\n    local str12\n\
    \    local str13\n    local str14\n    local str15\n    local str16\n    local\
    \ str17\n    local str18\n    local str19\n    local str20\n    local str21\n\
    \    local str22\n    local str23\n    local str24\n    local str25\n    local\
    \ str26\n    local str27\n    local str28\n    local str29\n    local str30\n\
    \    local str31\n    local str32\n    local str33\n    local str34\n    local\
    \ str35\n    local str36\n    local str37\n    local str38\n    local str39\n\
    \    local str40\n    local str41\n    local str42\n    local str43\n    local\
    \ str44\n    local str45\n    local str46\n    local str47\n    local str48\n\
    \    local str49\n    local str50\n    local str51\n    local str52\n    local\
    \ str53\n    local str54\n    local str55\n    local str56\n    local str57\n\
    \    local str58\n    local str59\n    local str60\n    local str61\n    local\
    \ str62\n    local str63\n    local str64\n    local str65\n    local str66\n\
    \    local str67\n    local str68\n    local str69\n    local str70\n    local\
    \ str71\n    local str72\n    local str73\n    local str74\n    local str75\n\
    \    local str76\n    local str77\n    local str78\n    local str79\n    local\
    \ str80\n    local str81\n    local str82\n    local str83\n    local str84\n\
    \    local str85\n    local str86\n    local str87\n    local str88\n    local\
    \ str89\n    local str90\n    local str91\n    local str92\n    local str93\n\
    \    local str94\n    local str95\n    local str96\n    local str97\n    local\
    \ str98\n   \n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [[ -z $str5 ]]; then\n        echo \"Yes\"\n\
    \    elif [[ -z $str6 ]]; then\n        echo \"Yes\"\n    else\n        echo \"\
    No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [ \"$str5\" == \"\
    \" ] || [ \"$str6\" == \"\" ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\
    \n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ stack=()\n  local stack_size=0\n  local i\n  for ((i=0; i<${#str}; i++)); do\n\
    \    if [[ \"${str:$i:1}\" == \"(\" ]]; then\n      stack[$stack_size]=\"$i\"\n\
    \      stack_size=$((stack_size + 1))\n    elif [[ \"${str:$i:1}\" == \")\" ]];\
    \ then\n      if [[ $stack_size -eq 0 ]]; then\n        echo \"No\"\n        return\n\
    \      fi\n      stack_size=$((stack_size - 1))\n    fi\n  done\n  if [[ $stack_size\
    \ -eq 0 ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [ -z \"$str5\" ];\
    \ then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [[ -z $str5 ]]; then\n        echo \"Yes\"\n\
    \    elif [[ -z $str6 ]]; then\n        echo \"Yes\"\n    else\n        echo \"\
    No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6 ]]; then\n  \
    \  echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\n  local str4=\"\
    $str2$str1\"\n  if [[ $(is_good_parens \"$str3\") == \"Yes\" ]]; then\n    echo\
    \ \"Yes\"\n  elif [[ $(is_good_parens \"$str4\") == \"Yes\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpuk1w_ymt.sh: line 20: is_good_parens: command not found\n/tmp/tmpuk1w_ymt.sh:
    line 22: is_good_parens: command not found\n'''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [ -z \"$str5\" ];\
    \ then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=$(echo \"$str3\" | sed 's/[()]//g')\n\
    \  local str6=$(echo \"$str4\" | sed 's/[()]//g')\n  if [[ -z \"$str5\" ]]; then\n\
    \    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ \"$count\" -lt 0 ]]; then\n      echo\
    \ \"No\"\n      return\n    fi\n  done\n  if [[ \"$count\" -eq 0 ]]; then\n  \
    \  echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6 ]]; then\n  \
    \  echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local len=$((${#str1} + ${#str2}))\n  local count=0\n\
    \  for ((i=0; i<len; i++)); do\n    if [[ ${str3:i:1} == \"(\" ]]; then\n    \
    \  ((count++))\n    elif [[ ${str3:i:1} == \")\" ]]; then\n      ((count--))\n\
    \    fi\n    if [[ $count -lt 0 ]]; then\n      break\n    fi\n  done\n  if [[\
    \ $count -eq 0 ]]; then\n    echo \"Yes\"\n  else\n    count=0\n    for ((i=0;\
    \ i<len; i++)); do\n      if [[ ${str4:i:1} == \"(\" ]]; then\n        ((count++))\n\
    \      elif [[ ${str4:i:1} == \")\" ]]; then\n        ((count--))\n      fi\n\
    \      if [[ $count -lt 0 ]]; then\n        break\n      fi\n    done\n    if\
    \ [[ $count -eq 0 ]]; then\n      echo \"Yes\"\n    else\n      echo \"No\"\n\
    \    fi\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str1_len=${#str1}\n  local\
    \ str2_len=${#str2}\n  local str1_open=0\n  local str1_close=0\n  local str2_open=0\n\
    \  local str2_close=0\n  local i=0\n  local j=0\n  local k=0\n  local l=0\n  local\
    \ str1_open_arr=()\n  local str1_close_arr=()\n  local str2_open_arr=()\n  local\
    \ str2_close_arr=()\n  local str1_open_arr_len=0\n  local str1_close_arr_len=0\n\
    \  local str2_open_arr_len=0\n  local str2_close_arr_len=0\n  local str1_open_arr_idx=0\n\
    \  local str1_close_arr_idx=0\n  local str2_open_arr_idx=0\n  local str2_close_arr_idx=0\n\
    \  local str1_open_arr_idx_last=0\n  local str1_close_arr_idx_last=0\n  local\
    \ str2_open_arr_idx_last=0\n  local str2_close_arr_idx_last=0\n  local str1_open_arr_idx_last_val=0\n\
    \  local str1_close_arr_idx_last_val=0\n  local str2_open_arr_idx_last_val=0\n\
    \  local str2_close_arr_idx_last_val=0\n  local str1_open_arr_idx_last_val_next=0\n\
    \  local str1_close_arr_idx_last_val_next=0\n  local str2_open_arr_idx_last_val_next=0\n\
    \  local str2_close_arr_idx_last_val_next=0\n  local str1_open_arr_idx_last_val_next_next=0\n\
    \  local str1_close_arr_idx_last_val_next\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n    if [[ \"$str5\" ==\
    \ \"\" ]]; then\n        echo \"Yes\"\n    elif [[ \"$str6\" == \"\" ]]; then\n\
    \        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local -r str1=\"$1\"\n  local -r str2=\"$2\"\n  local -r str1_len=\"${#str1}\"\
    \n  local -r str2_len=\"${#str2}\"\n  local -r str1_parens=\"$(grep -o '(' <<<\
    \ \"$str1\" | wc -l)\"\n  local -r str2_parens=\"$(grep -o '(' <<< \"$str2\" |\
    \ wc -l)\"\n  local -r str1_parens_len=\"$(grep -o '(' <<< \"$str1\" | wc -m)\"\
    \n  local -r str2_parens_len=\"$(grep -o '(' <<< \"$str2\" | wc -m)\"\n  local\
    \ -r str1_parens_len_diff=\"$((str1_parens_len - str1_len))\"\n  local -r str2_parens_len_diff=\"\
    $((str2_parens_len - str2_len))\"\n  local -r str1_parens_diff=\"$((str1_parens\
    \ - str2_parens))\"\n  local -r str2_parens_diff=\"$((str2_parens - str1_parens))\"\
    \n  local -r str1_parens_diff_abs=\"$((str1_parens_diff < 0 ? -str1_parens_diff\
    \ : str1_parens_diff))\"\n  local -r str2_parens_diff_abs=\"$((str2_parens_diff\
    \ < 0 ? -str2_parens_diff : str2_parens_diff))\"\n  local -r str1_parens_diff_abs_odd=\"\
    $((str1_parens_diff_abs % 2))\"\n  local -r str2_parens_diff_abs_odd=\"$((str2_parens_diff_abs\
    \ % 2))\"\n  local -r str1_parens_diff_abs_even=\"$((str1_parens_diff_abs % 2))\"\
    \n  local -r str2_parens_diff_abs_even=\"$((str2_parens_diff_abs\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b"/tmp/tmpukq1mezu.sh: line 33: unexpected EOF while looking for matching
    `)''\n/tmp/tmpukq1mezu.sh: line 57: syntax error: unexpected end of file\n"'
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    if [[ $(echo $str3 | grep -P \"^\\(\\)\\( \\)\\*$\") ]];\
    \ then\n        echo \"Yes\"\n    elif [[ $(echo $str4 | grep -P \"^\\(\\)\\(\
    \ \\)\\*$\") ]]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\n \
    \   fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str=\"$str1$str2\"\n  local len=${#str}\n\
    \  local i=0\n  local count=0\n  while [ $i -lt $len ]; do\n    if [ \"${str:$i:1}\"\
    \ == \"(\" ]; then\n      count=$((count + 1))\n    else\n      count=$((count\
    \ - 1))\n    fi\n    if [ $count -lt 0 ]; then\n      echo \"No\"\n      return\n\
    \    fi\n    i=$((i + 1))\n  done\n  if [ $count -eq 0 ]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local count=0\n  local i=0\n  while [ $i -lt ${#str3} ]; do\n    if [ \"${str3:$i:1}\"\
    \ == \"(\" ]; then\n      ((count++))\n    elif [ \"${str3:$i:1}\" == \")\" ];\
    \ then\n      ((count--))\n    fi\n    if [ $count -lt 0 ]; then\n      echo \"\
    No\"\n      return\n    fi\n    ((i++))\n  done\n  if [ $count -eq 0 ]; then\n\
    \    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"\"\n    local\
    \ str4=\"\"\n    local str5=\"\"\n    local str6=\"\"\n    local str7=\"\"\n \
    \   local str8=\"\"\n    local str9=\"\"\n    local str10=\"\"\n    local str11=\"\
    \"\n    local str12=\"\"\n    local str13=\"\"\n    local str14=\"\"\n    local\
    \ str15=\"\"\n    local str16=\"\"\n    local str17=\"\"\n    local str18=\"\"\
    \n    local str19=\"\"\n    local str20=\"\"\n    local str21=\"\"\n    local\
    \ str22=\"\"\n    local str23=\"\"\n    local str24=\"\"\n    local str25=\"\"\
    \n    local str26=\"\"\n    local str27=\"\"\n    local str28=\"\"\n    local\
    \ str29=\"\"\n    local str30=\"\"\n    local str31=\"\"\n    local str32=\"\"\
    \n    local str33=\"\"\n    local str34=\"\"\n    local str35=\"\"\n    local\
    \ str36=\"\"\n    local str37=\"\"\n    local str38=\"\"\n    local str39=\"\"\
    \n    local str40=\"\"\n    local str41=\"\"\n    local str42=\"\"\n    local\
    \ str43=\"\"\n    local str44=\"\"\n    local str45=\"\"\n    local str46=\"\"\
    \n    local str47=\"\"\n    local str48=\"\"\n    local str49=\"\"\n    local\
    \ str50=\"\"\n    local str51=\"\"\n    local str52=\"\"\n    local str53=\"\"\
    \n    local str54=\"\"\n    local str55=\"\"\n    local str56=\"\"\n    local\
    \ str57=\"\"\n    local str58=\"\"\n    local str59=\"\"\n    local str60=\"\"\
    \n    local str61=\"\"\n    local str62=\"\"\n    local str63=\"\"\n    local\
    \ str64=\"\"\n    local str65=\"\"\n    local str66=\"\"\n    local str67=\"\"\
    \n    local str68=\"\"\n    local str69=\"\"\n    local str70=\"\"\n    local\
    \ str71=\"\"\n    local str72=\"\"\n    local str73=\"\"\n    local str74=\"\"\
    \n    local str75=\"\"\n    local str76=\"\"\n    local str77=\"\"\n    local\
    \ str78=\"\"\n    local str79=\"\"\n    local str80=\"\"\n    local str81=\"\"\
    \n    local str82=\"\"\n    local str83=\"\"\n    local str84=\"\"\n   \n}\n\n\
    candidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str=\"$str1$str2\"\n  local count=0\n\
    \  for (( i=0; i<${#str}; i++ )); do\n    if [[ ${str:$i:1} == \"(\" ]]; then\n\
    \      (( count++ ))\n    elif [[ ${str:$i:1} == \")\" ]]; then\n      (( count--\
    \ ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\n      return\n\
    \    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\n  else\n   \
    \ echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  if [[ $str3 =~ ^\\(+\\)+$ ]] || [[ $str4 =~ ^\\(+\\)+$ ]]; then\n    echo \"\
    Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local i=0\n    local count=0\n    while [ $i -lt ${#str} ]; do\n       \
    \ if [ \"${str:$i:1}\" == \"(\" ]; then\n            count=$((count + 1))\n  \
    \      elif [ \"${str:$i:1}\" == \")\" ]; then\n            count=$((count - 1))\n\
    \        fi\n        if [ $count -lt 0 ]; then\n            echo \"No\"\n    \
    \        return\n        fi\n        i=$((i + 1))\n    done\n    if [ $count -eq\
    \ 0 ]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\n\
    candidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6 == \"\" ]];\
    \ then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n    local str6=$(echo\
    \ $str4 | sed 's/[()]//g')\n    if [[ -z $str5 ]]; then\n        echo \"Yes\"\n\
    \    elif [[ -z $str6 ]]; then\n        echo \"Yes\"\n    else\n        echo \"\
    No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [[ $str5 == \"\" ]]; then\n        echo \"Yes\"\
    \n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\n    else\n       \
    \ echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=\"$str1$str2\"\n   \
    \ local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/\\(.\\)/\\1 /g')\n   \
    \ local str6=$(echo $str4 | sed 's/\\(.\\)/\\1 /g')\n    local str7=$(echo $str5\
    \ | sed 's/\\( \\)/\\1/g')\n    local str8=$(echo $str6 | sed 's/\\( \\)/\\1/g')\n\
    \    local str9=$(echo $str7 | sed 's/\\( \\)/\\1/g')\n    local str10=$(echo\
    \ $str8 | sed 's/\\( \\)/\\1/g')\n    local str11=$(echo $str9 | sed 's/\\( \\\
    )/\\1/g')\n    local str12=$(echo $str10 | sed 's/\\( \\)/\\1/g')\n    local str13=$(echo\
    \ $str11 | sed 's/\\( \\)/\\1/g')\n    local str14=$(echo $str12 | sed 's/\\(\
    \ \\)/\\1/g')\n    local str15=$(echo $str13 | sed 's/\\( \\)/\\1/g')\n    local\
    \ str16=$(echo $str14 | sed 's/\\( \\)/\\1/g')\n    local str17=$(echo $str15\
    \ | sed 's/\\( \\)/\\1/g')\n    local str18=$(echo $str16 | sed 's/\\( \\)/\\\
    1/g')\n    local str19=$(echo $str17 | sed 's/\\( \\)/\\1/g')\n    local str20=$(echo\
    \ $str18 | sed 's/\\( \\)/\\1/g')\n    local str21=$(echo $str19 | sed 's/\\(\
    \ \\)/\\1/g')\n    local str22=$(echo $str20 | sed 's/\\( \\)/\\1/g')\n    local\
    \ str23=$(echo $str21 | sed 's/\\( \\)/\\1/g\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'b"/tmp/tmpwt0o_si5.sh: line 38: unexpected EOF while looking for matching
    `''''\n/tmp/tmpwt0o_si5.sh: line 62: syntax error: unexpected end of file\n"'
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str=\"$str1$str2\"\n  local count=0\n\
    \  for (( i=0; i<${#str}; i++ )); do\n    local c=${str:$i:1}\n    if [[ $c ==\
    \ \"(\" ]]; then\n      count=$(( count + 1 ))\n    elif [[ $c == \")\" ]]; then\n\
    \      count=$(( count - 1 ))\n    fi\n    if [[ $count -lt 0 ]]; then\n     \
    \ echo \"No\"\n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n \
    \   echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6 == \"\" ]];\
    \ then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6\
    \ == \"\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local result1=$(check_parens \"$str3\")\n  local\
    \ result2=$(check_parens \"$str4\")\n  if [[ \"$result1\" == \"Yes\" ]] || [[\
    \ \"$result2\" == \"Yes\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n\
    \  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpbja_zayx.sh: line 20: check_parens: command not found\n/tmp/tmpbja_zayx.sh:
    line 21: check_parens: command not found\n'''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n  if [[ \"$str5\" == \"\"\
    \ ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo \"\
    Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n  if [ \"$str5\" = \"\"\
    \ ]; then\n    echo \"Yes\"\n  elif [ \"$str6\" = \"\" ]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [ -z \"$str5\" ];\
    \ then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local count=0\n  for (( i=0; i<${#str3}; i++ )); do\n    if [[ ${str3:$i:1}\
    \ == \"(\" ]]; then\n      (( count++ ))\n    elif [[ ${str3:$i:1} == \")\" ]];\
    \ then\n      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo\
    \ \"No\"\n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo\
    \ \"Yes\"\n    return\n  fi\n  count=0\n  for (( i=0; i<${#str4}; i++ )); do\n\
    \    if [[ ${str4:$i:1} == \"(\" ]]; then\n      (( count++ ))\n    elif [[ ${str4:$i:1}\
    \ == \")\" ]]; then\n      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n\
    \      echo \"No\"\n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n\
    \    echo \"Yes\"\n    return\n  fi\n  echo \"No\"\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    if [[ $(echo \"$str1\"\
    \ | grep -c \"^[()]*$\") -eq 0 ]]; then\n        echo \"Invalid input\"\n    \
    \    return 1\n    fi\n    if [[ $(echo \"$str2\" | grep -c \"^[()]*$\") -eq 0\
    \ ]]; then\n        echo \"Invalid input\"\n        return 1\n    fi\n    local\
    \ str1_count=$(echo \"$str1\" | grep -o \"(\" | wc -l)\n    local str2_count=$(echo\
    \ \"$str2\" | grep -o \"(\" | wc -l)\n    local str1_rev=$(echo \"$str1\" | rev)\n\
    \    local str2_rev=$(echo \"$str2\" | rev)\n    local str1_rev_count=$(echo \"\
    $str1_rev\" | grep -o \")\" | wc -l)\n    local str2_rev_count=$(echo \"$str2_rev\"\
    \ | grep -o \")\" | wc -l)\n    if [[ $str1_count -eq $str1_rev_count ]] && [[\
    \ $str2_count -eq $str2_rev_count ]]; then\n        echo \"Yes\"\n    else\n \
    \       echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" == \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6 ]]; then\n  \
    \  echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6 ]]; then\n  \
    \  echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local input=$1\n  local open_parens=$(echo $input | grep -o \"(\" | wc\
    \ -l)\n  local close_parens=$(echo $input | grep -o \")\" | wc -l)\n  if [[ $open_parens\
    \ -eq $close_parens ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return 0\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6 ]]; then\n  \
    \  echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [ -z \"$str5\" ]; then\n    echo \"Yes\"\n  elif [ -z \"\
    $str6\" ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6 == \"\" ]];\
    \ then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" == \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\n  local str4=\"\
    $str2$str1\"\n  if [[ $(is_good_parens \"$str3\") == \"Yes\" ]]; then\n    echo\
    \ \"Yes\"\n  elif [[ $(is_good_parens \"$str4\") == \"Yes\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpuk1w_ymt.sh: line 20: is_good_parens: command not found\n/tmp/tmpuk1w_ymt.sh:
    line 22: is_good_parens: command not found\n'''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [[ -z $str5 ]]; then\n        echo \"Yes\"\n\
    \    elif [[ -z $str6 ]]; then\n        echo \"Yes\"\n    else\n        echo \"\
    No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str1_count=$(echo $str1 | grep\
    \ -o '(' | wc -l)\n  local str2_count=$(echo $str2 | grep -o '(' | wc -l)\n  local\
    \ str1_count_close=$(echo $str1 | grep -o ')' | wc -l)\n  local str2_count_close=$(echo\
    \ $str2 | grep -o ')' | wc -l)\n  local str1_count_diff=$((str1_count - str1_count_close))\n\
    \  local str2_count_diff=$((str2_count - str2_count_close))\n  if [ $str1_count_diff\
    \ -eq $str2_count_diff ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str1_len=\"${#str1}\"\n\
    \  local str2_len=\"${#str2}\"\n  local str1_parens=0\n  local str2_parens=0\n\
    \  local i=0\n  local j=0\n  local k=0\n  local l=0\n  local m=0\n  local n=0\n\
    \  local o=0\n  local p=0\n  local q=0\n  local r=0\n  local s=0\n  local t=0\n\
    \  local u=0\n  local v=0\n  local w=0\n  local x=0\n  local y=0\n  local z=0\n\
    \  local aa=0\n  local bb=0\n  local cc=0\n  local dd=0\n  local ee=0\n  local\
    \ ff=0\n  local gg=0\n  local hh=0\n  local ii=0\n  local jj=0\n  local kk=0\n\
    \  local ll=0\n  local mm=0\n  local nn=0\n  local oo=0\n  local pp=0\n  local\
    \ qq=0\n  local rr=0\n  local ss=0\n  local tt=0\n  local uu=0\n  local vv=0\n\
    \  local ww=0\n  local xx=0\n  local yy=0\n  local zz=0\n  local aaa=0\n  local\
    \ bbb=0\n  local ccc=0\n  local ddd=0\n  local eee=0\n  local fff=0\n  local ggg=0\n\
    \  local hhh=0\n  local iii=0\n  local jjj=0\n  local kkk=0\n  local lll=0\n \
    \ local mmm=0\n  local nnn=0\n  local ooo=0\n  local ppp=0\n  local qqq=0\n  local\
    \ rrr=0\n  local sss=0\n  local ttt=0\n  local uuu=0\n  local vvv=0\n  local www=0\n\
    \  local xxx=0\n\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n    local str6=$(echo\
    \ $str4 | sed 's/()//g')\n    if [ -z $str5 ]; then\n        echo \"Yes\"\n  \
    \  elif [ -z $str6 ]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\
    \n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmptc13my7j.sh: line 22: [: (: binary operator expected\n/tmp/tmptc13my7j.sh:
    line 24: [: (: binary operator expected\n'''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local s1=\"$1\"\n    local s2=\"$2\"\n    local s=\"$s1$s2\"\n    local\
    \ count=0\n    for ((i=0; i<${#s}; i++)); do\n        if [[ \"${s:$i:1}\" == \"\
    (\" ]]; then\n            ((count++))\n        elif [[ \"${s:$i:1}\" == \")\"\
    \ ]]; then\n            ((count--))\n        fi\n        if [[ $count -lt 0 ]];\
    \ then\n            echo \"No\"\n            return\n        fi\n    done\n  \
    \  if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n        echo \"\
    No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str=\"$str1$str2\"\n  local count=0\n\
    \  for (( i=0; i<${#str}; i++ )); do\n    if [[ ${str:$i:1} == \"(\" ]]; then\n\
    \      (( count++ ))\n    elif [[ ${str:$i:1} == \")\" ]]; then\n      (( count--\
    \ ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\n      return\n\
    \    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\n  else\n   \
    \ echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local parens=$1\n  local left=0\n  local right=0\n  for (( i=0; i<${#parens};\
    \ i++ )); do\n    if [[ ${parens:$i:1} == \"(\" ]]; then\n      left=$(( left\
    \ + 1 ))\n    else\n      right=$(( right + 1 ))\n    fi\n    if [[ $right -gt\
    \ $left ]]; then\n      echo \"No\"\n      return\n    fi\n  done\n  if [[ $left\
    \ -eq $right ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\n\
    candidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local string1=\"$1\"\n  local string2=\"$2\"\n  local string3=\"$string1$string2\"\
    \n  local string4=\"$string2$string1\"\n  local string5=\"$(echo \"$string3\"\
    \ | sed 's/()//g')\"\n  local string6=\"$(echo \"$string4\" | sed 's/()//g')\"\
    \n  if [ \"$string5\" == \"\" ] || [ \"$string6\" == \"\" ]; then\n    echo \"\
    Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ -z \"$str5\" ]];\
    \ then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n    echo \"Yes\"\n\
    \  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\n  local str4=\"\
    $str2$str1\"\n  local str5=\"$(echo $str3 | sed 's/\\(.*\\)/\\(\\1\\)/')\"\n \
    \ local str6=\"$(echo $str4 | sed 's/\\(.*\\)/\\(\\1\\)/')\"\n  if [[ $str5 =~\
    \ ^\\(\\(.*\\)\\)$ ]] && [[ $str6 =~ ^\\(\\(.*\\)\\)$ ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n    if [[ -z \"$str5\"\
    \ ]]; then\n        echo \"Yes\"\n    elif [[ -z \"$str6\" ]]; then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      (( count++ ))\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n      echo \"No\"\
    \n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/()//g')\n  local str6=$(echo $str4 | sed 's/()//g')\n\
    \  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6 == \"\" ]];\
    \ then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [ -z \"$str5\" ];\
    \ then\n    echo \"Yes\"\n  elif [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  # TODO: Implement this function\n  return\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local count1=$(echo $str3 | grep -o \"(\" | wc -l)\n  local count2=$(echo $str3\
    \ | grep -o \")\" | wc -l)\n  local count3=$(echo $str4 | grep -o \"(\" | wc -l)\n\
    \  local count4=$(echo $str4 | grep -o \")\" | wc -l)\n  if [[ $count1 -eq $count2\
    \ ]] && [[ $count3 -eq $count4 ]]; then\n    echo \"Yes\"\n  else\n    echo \"\
    No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local count1=$(echo $str3 | grep -o \"(\" | wc -l)\n  local count2=$(echo $str3\
    \ | grep -o \")\" | wc -l)\n  local count3=$(echo $str4 | grep -o \"(\" | wc -l)\n\
    \  local count4=$(echo $str4 | grep -o \")\" | wc -l)\n  if [ $count1 -eq $count2\
    \ ] && [ $count3 -eq $count4 ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\
    \n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\n  local str4=\"\
    $str2$str1\"\n  local count1=$(echo \"$str1\" | grep -o \"(\" | wc -l)\n  local\
    \ count2=$(echo \"$str1\" | grep -o \")\" | wc -l)\n  local count3=$(echo \"$str2\"\
    \ | grep -o \"(\" | wc -l)\n  local count4=$(echo \"$str2\" | grep -o \")\" |\
    \ wc -l)\n  if [[ $count1 -eq $count2 && $count3 -eq $count4 ]]; then\n    if\
    \ [[ $(is_good \"$str3\") -eq 1 || $(is_good \"$str4\") -eq 1 ]]; then\n     \
    \ echo \"Yes\"\n    else\n      echo \"No\"\n    fi\n  else\n    echo \"No\"\n\
    \  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''/tmp/tmpe5pl_5kj.sh: line 25: is_good: command not found\n/tmp/tmpe5pl_5kj.sh:
    line 25: is_good: command not found\n'''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str1_len=${#str1}\n  local str2_len=${#str2}\n\
    \  local str1_open_parens=$(echo $str1 | grep -o \"(\" | wc -l)\n  local str1_close_parens=$(echo\
    \ $str1 | grep -o \")\" | wc -l)\n  local str2_open_parens=$(echo $str2 | grep\
    \ -o \"(\" | wc -l)\n  local str2_close_parens=$(echo $str2 | grep -o \")\" |\
    \ wc -l)\n  local str1_open_parens_remainder=$((str1_open_parens - str1_close_parens))\n\
    \  local str2_open_parens_remainder=$((str2_open_parens - str2_close_parens))\n\
    \  local str1_close_parens_remainder=$((str1_close_parens - str1_open_parens))\n\
    \  local str2_close_parens_remainder=$((str2_close_parens - str2_open_parens))\n\
    \  local str1_open_parens_remainder_len=$(echo $str1_open_parens_remainder | wc\
    \ -c)\n  local str2_open_parens_remainder_len=$(echo $str2_open_parens_remainder\
    \ | wc -c)\n  local str1_close_parens_remainder_len=$(echo $str1_close_parens_remainder\
    \ | wc -c)\n  local str2_close_parens_remainder_len=$(echo $str2_close_parens_remainder\
    \ | wc -c)\n  local str1_open_parens_remainder_len_minus_one=$((str1_open_parens_remainder_len\
    \ - 1))\n  local str2_open_parens_remainder_len_minus_one=$((str2_open_parens_remainder_len\
    \ - 1))\n  local str1_close_\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/[()]//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[ \"$str5\" == \"\
    \" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ -z $str5 ]]; then\n    echo \"Yes\"\n  elif [[ -z $str6\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"$str1$str2\"\n \
    \ local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed 's/()//g')\"\
    \n  local str6=\"$(echo \"$str4\" | sed 's/()//g')\"\n  if [ \"$str5\" == \"\"\
    \ ] || [ \"$str6\" == \"\" ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n\
    \  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  local str5=$(echo $str3 | sed 's/[()]//g')\n  local str6=$(echo $str4 | sed\
    \ 's/[()]//g')\n  if [[ $str5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $str6\
    \ == \"\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n  local str4=$str2$str1\n\
    \  if [[ $str3 =~ ^\\(+\\)+$ ]] || [[ $str4 =~ ^\\(+\\)+$ ]]; then\n    echo \"\
    Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n    local str6=$(echo\
    \ $str4 | sed 's/[()]//g')\n    if [[ -z $str5 ]]; then\n        echo \"Yes\"\n\
    \    elif [[ -z $str6 ]]; then\n        echo \"Yes\"\n    else\n        echo \"\
    No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str3=\"$str1$str2\"\
    \n    local str4=\"$str2$str1\"\n    local str5=\"$(echo \"$str3\" | sed 's/\\\
    (//g')\"\n    local str6=\"$(echo \"$str4\" | sed 's/\\(//g')\"\n    local str7=\"\
    $(echo \"$str3\" | sed 's/\\)//g')\"\n    local str8=\"$(echo \"$str4\" | sed\
    \ 's/\\)//g')\"\n    if [[ \"$str5\" == \"$str7\" ]] || [[ \"$str6\" == \"$str8\"\
    \ ]]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\n\
    candidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'b''sed: -e expression #1, char 7: Unmatched ( or \\(\nsed: -e expression
    #1, char 7: Unmatched ( or \\(\nsed: -e expression #1, char 7: Unmatched ) or
    \\)\nsed: -e expression #1, char 7: Unmatched ) or \\)\nsed: -e expression #1,
    char 7: Unmatched ( or \\(\nsed: -e expression #1, char 7: Unmatched ( or \\(\nsed:
    -e expression #1, char 7: Unmatched ) or \\)\nsed: -e expression #1, char 7: Unmatched
    ) or \\)\n'''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=$1\n  local str2=$2\n  local str1_len=${#str1}\n  local str2_len=${#str2}\n\
    \  local str1_open=0\n  local str1_close=0\n  local str2_open=0\n  local str2_close=0\n\
    \  local i=0\n  local j=0\n  local k=0\n  local l=0\n  local result=\"\"\n  for\
    \ ((i=0; i<str1_len; i++)); do\n    if [[ ${str1:i:1} == \"(\" ]]; then\n    \
    \  ((str1_open++))\n    else\n      ((str1_close++))\n    fi\n  done\n  for ((j=0;\
    \ j<str2_len; j++)); do\n    if [[ ${str2:j:1} == \"(\" ]]; then\n      ((str2_open++))\n\
    \    else\n      ((str2_close++))\n    fi\n  done\n  if [[ $str1_open -eq $str2_open\
    \ ]]; then\n    result=\"Yes\"\n  elif [[ $str1_close -eq $str2_close ]]; then\n\
    \    result=\"Yes\"\n  elif [[ $str1_open -eq $str2_close ]]; then\n    result=\"\
    Yes\"\n  elif [[ $str1_close -eq $str2_open ]]; then\n    result=\"Yes\"\n  else\n\
    \    result=\"No\"\n  fi\n  echo $result\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            count=$(( count + 1 ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            count=$(( count - 1 ))\n        fi\n        if\
    \ [[ $count -lt 0 ]]; then\n            echo \"No\"\n            return\n    \
    \    fi\n    done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n   \
    \ else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"$str1$str2\"\n  local\
    \ stack=()\n  local c\n  for ((i=0; i<${#str}; i++)); do\n    c=${str:$i:1}\n\
    \    if [[ $c == \"(\" ]]; then\n      stack+=(\"$c\")\n    elif [[ $c == \")\"\
    \ ]]; then\n      if [[ ${#stack[@]} -eq 0 ]]; then\n        echo \"No\"\n   \
    \     return\n      fi\n      unset stack[${#stack[@]}-1]\n    fi\n  done\n  if\
    \ [[ ${#stack[@]} -eq 0 ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n\
    \  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local str=\"$str1$str2\"\
    \n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            (( count++ ))\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            (( count-- ))\n        fi\n        if [[ $count\
    \ -lt 0 ]]; then\n            echo \"No\"\n            return\n        fi\n  \
    \  done\n    if [[ $count -eq 0 ]]; then\n        echo \"Yes\"\n    else\n   \
    \     echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# >>> $(match_parens\
    \ \"()( )\")\n# \"Yes\"\n# >>> $(match_parens \") )\")\n# \"No\"\nmatch_parens()\
    \ {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n    local\
    \ str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n    local str6=$(echo\
    \ $str4 | sed 's/[()]//g')\n    if [[ $str5 == \"\" ]]; then\n        echo \"\
    Yes\"\n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\n    else\n  \
    \      echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: b''
  stdout: b''
  timestamp: 1660339609
